This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed, line numbers have been added.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: data/
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Line numbers have been added to the beginning of each line
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
.repomix/
  bundles.json
configs/
  noisy_surrogate_eval.yml
  sbm_fit_block_size_experiments.yml
  surrogate_eval.yml
notebooks/
  block_assigner_comparison_01-07-2025.ipynb
  convergence_figures_25-06-2025.ipynb
  likelihood_test.ipynb
  move_type_comparisons_30-06-2025.ipynb
  noisy_network_sampling_07-07-2025.ipynb
  sbm_block_sizes_26-06-2025.ipynb
  sbm_visualize.ipynb
  surrogate_accuracy_26-06-2025.ipynb
  visualize_generated_networks_08-07-2025.ipynb
planted_partitions/
  undirected_planted_partitions.py
slurm_scripts/
  fit_sbm.sh
src/
  data_processing/
    process_all.py
    process_caltech.py
    process_congress_twitter.py
    process_email_eu.py
    process_enron_email.py
    process_lastfm_asia.py
    process_wiki_vote.py
  metrics/
    __init__.py
    assortativity.py
    clustering.py
    community.py
    degree.py
    embedding.py
    shortest_path.py
    spectral.py
  pipelines/
    evaluate_noisy_surrogates.py
    evaluate_surrogates.py
    fit_sbm.py
    run_all.py
  sbm/
    utils/
      logger.py
      pipeline_utils.py
      util.py
    block_assigner.py
    block_change_proposers.py
    block_data.py
    edge_delta.py
    graph_data.py
    initial_partition.py
    io.py
    likelihood.py
    mcmc.py
    model.py
    node_mover.py
    noisy_fit.py
    post_process.py
    sampling.py
    stopping_criteria.py
  tests/
    likelihood_test.py
    planted_partition_tests.py
    test_block_assigner.py
    test_change_proposer_and_mover.py
    test_edge_delta.py
    test_global_ll.py
    test_greedy_assign_helpers.py
    test_io.py
    test_metrics.py
    test_noise.py
    test_post_processing.py
    test_sampling.py
    test_swaps.py
.gitignore
env_backup.yml
pyproject.toml
README.md
requirements.txt
setup.cfg
tmp_test.py

================================================================
Files
================================================================

================
File: configs/noisy_surrogate_eval.yml
================
 1: # ---------------------------------------------------------------
 2: n_surrogates: 20 # graphs to sample per dataset
 3: overwrite: true # set true to ignore cached results
 4: # privacy levels
 5: eps: [1, 3, 5]
 6: delta: [1e-6, 1e-4, 1e-2]
 7: metrics:
 8:   - shortest_path
 9:   - avg_path_length
10:   - degree
11:   - clustering
12:   - avg_clustering
13:   - spectral
14:   - infomap
15:   - leiden
16:   - assortativity
17:   - embedding_node2vec
18:   - embedding_prone

================
File: notebooks/noisy_network_sampling_07-07-2025.ipynb
================
  1: {
  2:  "cells": [
  3:   {
  4:    "cell_type": "markdown",
  5:    "id": "d44396b3",
  6:    "metadata": {},
  7:    "source": [
  8:     "# Test that sampling noisy SBMFit and graph from noisy SBMFit works"
  9:    ]
 10:   },
 11:   {
 12:    "cell_type": "code",
 13:    "execution_count": null,
 14:    "id": "80082d4e",
 15:    "metadata": {},
 16:    "outputs": [],
 17:    "source": [
 18:     "from pathlib import Path\n",
 19:     "import numpy as np\n",
 20:     "import scipy.sparse as sp\n",
 21:     "from sbm.sampling import sample_sbm_graph_from_fit\n",
 22:     "\n",
 23:     "from sbm.io import SBMFit, SBMWriter\n",
 24:     "from sbm.noisy_fit import create_sbm_noise\n",
 25:     "\n",
 26:     "EPS, DELTA, ALPHA = 10, 1e-3, 1-1e-4\n",
 27:     "RNG = np.random.default_rng(0)"
 28:    ]
 29:   },
 30:   {
 31:    "cell_type": "markdown",
 32:    "id": "b7b0346b",
 33:    "metadata": {},
 34:    "source": [
 35:     "# Test for empirical fit"
 36:    ]
 37:   },
 38:   {
 39:    "cell_type": "code",
 40:    "execution_count": 17,
 41:    "id": "52d2519e",
 42:    "metadata": {},
 43:    "outputs": [
 44:     {
 45:      "name": "stdout",
 46:      "output_type": "stream",
 47:      "text": [
 48:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_lastfm_asia_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_25\n"
 49:      ]
 50:     }
 51:    ],
 52:    "source": [
 53:     "sbm = SBMWriter.load(\n",
 54:     "    Path(\"/Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_lastfm_asia_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_25\")\n",
 55:     ")"
 56:    ]
 57:   },
 58:   {
 59:    "cell_type": "code",
 60:    "execution_count": 18,
 61:    "id": "6142e5d8",
 62:    "metadata": {},
 63:    "outputs": [
 64:     {
 65:      "name": "stdout",
 66:      "output_type": "stream",
 67:      "text": [
 68:       "Block-conn array before noise:\n",
 69:       "[[30  3  0 ...  0  0  0]\n",
 70:       " [ 3 17  0 ...  0  0  0]\n",
 71:       " [ 0  0 38 ...  0  0  0]\n",
 72:       " ...\n",
 73:       " [ 0  0  0 ...  7  0  0]\n",
 74:       " [ 0  0  0 ...  0  1  0]\n",
 75:       " [ 0  0  0 ...  0  0 11]]\n",
 76:       "[LASSO]   Î» for activation: 1.645 (rho=0.10000)\n",
 77:       "[LASSO]   added 117574 edges to previously-zero pairs\n",
 78:       "Block-conn array after noise+post-processing:\n",
 79:       "[[0 0 0 ... 0 0 0]\n",
 80:       " [0 0 0 ... 0 0 0]\n",
 81:       " [0 0 0 ... 0 0 0]\n",
 82:       " ...\n",
 83:       " [0 0 0 ... 0 0 0]\n",
 84:       " [0 0 0 ... 0 0 0]\n",
 85:       " [0 0 0 ... 0 0 0]]\n",
 86:       "Added 2227082 edges to zero pairs.\n",
 87:       "Block-conn array after noise+post-processing:\n",
 88:       "[[300   0   0 ... 119 195   0]\n",
 89:       " [  0 300  18 ... 268   0   0]\n",
 90:       " [  0  18   0 ...   0   0   0]\n",
 91:       " ...\n",
 92:       " [119 268   0 ...   0 116  43]\n",
 93:       " [195   0   0 ... 116   0   0]\n",
 94:       " [  0   0   0 ...  43   0   0]]\n"
 95:      ]
 96:     }
 97:    ],
 98:    "source": [
 99:     "print(f'Block-conn array before noise:\\n{sbm.block_conn.toarray()}')\n",
100:     "noise = create_sbm_noise(sbm, EPS, DELTA, ALPHA, noise_type=\"heterogeneous_gaussian\")\n",
101:     "\n",
102:     "lasso_noisy_fit = noise.sample_sbm_fit(RNG, post='lasso')\n",
103:     "print(f'Block-conn array after noise+post-processing:\\n{lasso_noisy_fit.block_conn.toarray()}')\n",
104:     "naive_noisy_fit = noise.sample_sbm_fit(RNG, post='naive')\n",
105:     "print(f'Block-conn array after noise+post-processing:\\n{naive_noisy_fit.block_conn.toarray()}')"
106:    ]
107:   },
108:   {
109:    "cell_type": "code",
110:    "execution_count": 20,
111:    "id": "0cac595b",
112:    "metadata": {},
113:    "outputs": [],
114:    "source": [
115:     "#graph_data = sample_sbm_graph_from_fit(noisy_fit, rng=RNG)\n",
116:     "#print(f'Sampled adjacency:\\n{graph_data.adjacency.toarray()}')"
117:    ]
118:   },
119:   {
120:    "cell_type": "code",
121:    "execution_count": 21,
122:    "id": "145a2f32",
123:    "metadata": {},
124:    "outputs": [],
125:    "source": [
126:     "value, counts = np.unique(sbm.block_conn.toarray().ravel(), return_counts=True)\n",
127:     "lasso_value, lasso_counts = np.unique(lasso_noisy_fit.block_conn.toarray().ravel(), return_counts=True)\n",
128:     "naive_value, naive_counts = np.unique(naive_noisy_fit.block_conn.toarray().ravel(), return_counts=True)"
129:    ]
130:   },
131:   {
132:    "cell_type": "code",
133:    "execution_count": 23,
134:    "id": "dcebf810",
135:    "metadata": {},
136:    "outputs": [
137:     {
138:      "data": {
139:       "image/png": "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",
140:       "text/plain": [
141:        "<Figure size 1000x300 with 3 Axes>"
142:       ]
143:      },
144:      "metadata": {},
145:      "output_type": "display_data"
146:     }
147:    ],
148:    "source": [
149:     "import matplotlib.pyplot as plt\n",
150:     "\n",
151:     "fig, ax = plt.subplots(ncols=3, sharex=True, figsize=(10,3), sharey=True)\n",
152:     "ax[0].plot(value, counts, marker='.', linewidth=0, color='teal')\n",
153:     "ax[1].plot(naive_value, naive_counts, marker='.', linewidth=0, color='salmon')\n",
154:     "ax[2].plot(lasso_value, lasso_counts, marker='.', linewidth=0, color='black')\n",
155:     "\n",
156:     "ax[0].set_title('Original block-conn values')\n",
157:     "ax[1].set_title('Naive')\n",
158:     "ax[2].set_title('Lasso')\n",
159:     "\n",
160:     "for axis in ax:\n",
161:     "    axis.set_xlabel('Block-conn value')\n",
162:     "    axis.set_ylabel('Count')\n",
163:     "    #axis.set_yscale('log')\n",
164:     "    # remove the right and top spines\n",
165:     "    axis.spines[['right', 'top']].set_visible(False)\n",
166:     "\n",
167:     "plt.show(fig)"
168:    ]
169:   },
170:   {
171:    "cell_type": "code",
172:    "execution_count": 24,
173:    "id": "df15335a",
174:    "metadata": {},
175:    "outputs": [
176:     {
177:      "data": {
178:       "image/png": "iVBORw0KGgoAAAANSUhEUgAAA1EAAAE8CAYAAAAhcDsHAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjMsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvZiW1igAAAAlwSFlzAAAPYQAAD2EBqD+naQAAYvhJREFUeJzt3Ql4E9XaB/A3LZR9a0HWlqJFFJR9K8p1AUW0VVCR6/VqRQRUVNzFexVcUFwRdxZBFDeQT7aKKCCy772AyK5llbUVEVQKzXzP/8DESZqk2ZPJ/H/PE0Imk5nJtHmbd84577FpmqYJERERERER+STBt9WIiIiIiIgImEQRERERERH5gUkUERERERGRH5hEERERERER+YFJFBERERERkR+YRBEREREREfmBSRQREREREZEfmEQRERERERH5gUkUERERERGRH5hERcjTTz8tNpstoNdOmDBBvXbHjh0SLtg29oF9+XIsq1evLnWbl156qbqFC47j3nvvDdv2rSDcPyMiM+HngYiIfMUkqhQ//vij/Pvf/5b69etLuXLlpF69enLLLbeo5UREFHn6xZzy5cvL3r17SzyPROiCCy6IyrERkTn4c1GYyB0mUV58+eWX0rp1a5k3b5706dNH3n33Xenbt6/Mnz9fLZ86darP23ryySflzz//DOg4br31VvXahg0bBvR6IqJ4dOLECXnxxRdDtr1vv/1W3YiIiEpTptQ1LOqnn35SycvZZ58tCxculFq1ajmeGzRokHTu3Fk9v379erWOJ8ePH5dKlSpJmTJl1C0QiYmJ6kZERH9r2bKljB07Vp544gnVSyBYSUlJITkuIiKKf2yJ8uCVV16RP/74Q8aMGeOUQEHNmjVl9OjRKkF6+eWXS4x72rhxo/zrX/+SGjVqyMUXX+z0nBFal+6//361vSpVqsi1116ruqZgPazvbUxUenq6ZGVlyeLFi6V9+/aqWwuSuY8++shpH4WFhfLII4/IhRdeKJUrV5aqVatK9+7dZd26dUGdH5ybAQMGSEpKitrmbbfdJr/++muprzt48KBqzatdu7Y65hYtWsiHH35YYj273S5vvPGGOm6sh5/BVVddVWqz+7BhwyQhIUHeeuutUo/lyJEj8uCDD6pzia6aDRo0UO/j8OHDfh2vPp7s1VdfVb8v55xzjtpeu3btZNWqVU7r3n777ern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W7ducvDgQfX89OnT5dxzz1U3X5w4cULNDG68ERH5ijGEiILFOEJkflFPotAFb9iwYdKzZ0+3z48YMUL69esnffr0kaZNm8qoUaOkYsWKMn78ePX88uXL5fPPP1ctVWiRGjt2rDz77LMe94cWq2rVqjluqampYXtvRBR/GEOIKFiMI0TmZ9M0TZMYge58U6dOlR49eqjHRUVFKmGaMmWKYxnk5OTIkSNHVCuU0YQJE2TDhg3y6quver36g5sOV38QvH777TepWrVqWN4XEcUPxhAiChbjCJH5lZEYdvjwYSkuLpbatWs7LcdjFJIIRLly5dQN3Qdxw/aJiHzFGEJEwWIcITK/mG6J+uWXX6R+/fqydOlSyczMdKz32GOPyYIFC2TFihVB7xNXf9CUzqs/RBQIxhAiChbjCJH5RH1MlDc1a9aUxMREOXDggNNyPK5Tp05Q28aVH4yxateuXZBHSURWxBhCRMFiHCEyr5huiQKUNG/fvr289dZb6rHdbpe0tDS59957ZfDgwUHvk1d/iCgYjCFEFCzGESLzifqYqGPHjsn27dsdj/Pz82Xt2rWSnJyskiWUN0chibZt26pkauTIkaosOqr1ERERERERWS6JWr16tVx22WWOx0iaAIkTqu317t1bDh06JEOGDJH9+/dLy5YtZfbs2SWKTfiLgzmJKBiMIUQULMYRIvOKqe580cAmdCIKBmMIEQWLcYTIfGK6sAQREREREVGssWwSxYo4RBQMxhAiChbjCJF5sTsfm9CJKAiMIUQULMYRIvOxbEsUERERERFRICybRPnbhL7n6FGZn5+v7omI2A2HiILFOEJkXuzO50MT+ri8POmfmyt2TZMEm03GZGVJ39atI36sRBR72A2HiILFOEJkPpZtifIVWp70BApwPyA3ly1SREREREQWxSSqFNsKChwJlK5Y02R7YWHUjomIiIiIiKLHskmUr/2QG6ekqC58Rok2m2QkJ4f5CIkolnEsAxEFi3GEyLw4JsrHMVHowocWKCRQozkmiojO4FgGIgoW4wiR+ZSJ9gGYARKmbhkZqgsfWqAaMMAREREREVkWkygfIXFi8kRERERERJYdE0VERERERBQIJlFERERERER+sGwSxYo4RBQMxhAiChbjCJF5sTofK+IQURAYQ4goWIwjROZj2ZYoIiIiIiKiQDCJIiIiIiIi8gOT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RERE5AcmUURERERERH5gEkVEREREROQHJlFERERERER+YBJFRERERETkByZRREREREREfmASRURERERE5AcmUSQ7duwQm80ma9eujcntmd3333+vzseRI0eifShEYcM4El6MIxTvGEPCizEk9JhExbnbb79dfWj0W0pKilx11VWyfv36aB8aEZkE4wgRBYMxhOIRkygLQKDat2+fus2bN0/KlCkjWVlZ0T4sIjIRxhEiCgZjCMUbJlEWUK5cOalTp466tWzZUgYPHiy7d++WQ4cOeXzNggULpH379uq1devWVa85deqU43m73S4vv/yyZGRkqHXS0tLk+eefd7ut4uJiueOOO+S8886TXbt2edznnj175Oabb5bk5GSpVKmStG3bVlasWOF4/r333pNzzjlHkpKSpEmTJjJx4kSn1+Pq1vvvvy89e/aUihUrSuPGjWXGjBklmrIRvLFtrNOpUyfZsmWLx2PC848//rjTMpy3smXLysKFC9VjHAe2V6VKFXWO//Wvf8nBgwc9bvPpp59WPwejkSNHSnp6utMyvJfzzz9fypcvr87du+++63GbROHGOHIa4whRYBhDTmMMiR9Moizm2LFj8vHHH6uAg+Z0d/bu3StXX321tGvXTtatW6cCxrhx42TYsGGOdZ544gl58cUX5amnnpKNGzfKp59+KrVr1y6xrRMnTkivXr1Un+RFixapAOfpuC655BK1bwQb7Pexxx5TARKmTp0qgwYNkocfflg2bNggAwYMkD59+sj8+fOdtvPMM8/ITTfdpLoI4D3ccsstUlhY6LTOf//7X3nttddk9erV6koYgqoneP3nn38umqY5lk2aNEnq1asnnTt3Vo9Pnjwpzz33nDrmadOmqX7Y6LoQjE8++USGDBmi/hhs2rRJXnjhBXWuP/zww6C2SxQKjCOMI0TBYAxhDIkLGsW1nJwcLTExUatUqZK64Udet25dbc2aNY518vPz1fL//e9/6vF//vMfrUmTJprdbnes884772iVK1fWiouLtaNHj2rlypXTxo4d63af+vYWLVqkdenSRbv44ou1I0eOeD3O0aNHa1WqVNEKCgrcPt+pUyetX79+Tst69eqlXX311Y7H2OeTTz7peHzs2DG17Ouvv1aP58+frx7PnTvXsc5XX32llv35559u93vw4EGtTJky2sKFCx3LMjMztccff9zje1m1apXa5u+//+60319//VU9Hjp0qNaiRQun17z++utaw4YNHY/POecc7dNPP3Va57nnnlP7Joo0xhHGEaJgMIYwhsQjtkRZwGWXXaauvuC2cuVK6datm3Tv3l127tzpdn1cbcjMzFTNzbqLLrpIXaFBMzeex1WdLl26eN0vmsOPHz8u3377rVSrVs2x/K677pLKlSs7boBja9WqlWo+93RMOAYjPMZyo+bNmzv+j2b4qlWrlmjONq6D7gHgqcm7Vq1acuWVV6qrMZCfny/Lli1TV4V0a9askezsbHVlC83ouIoF3roLeINz9tNPP0nfvn2dzhOuvmE5UTQwjjCOEAWDMYQxJN4wibIAfIDRZI4bmsXRvxUfjrFjxwa0vQoVKvi0Hpqw0ZSND7rRs88+6wikeulRX7dZGvQPNkLw1Zvh3a2jB2fXdYwQpKZMmaKaytFV4MILL1Q3wHnEHwIESAS3VatWqeZ+KCoqcru9hIQEpyZ5wLZ1+AMB+PkYzxO6Dixfvtznc0EUSowjjCNEwWAMYQyJN0yiLAgfVnx4/vzzT7fPYwAhgo3xw7VkyRJ1ZaNBgwZqkCQCDQZFenP33XervsrXXnutGhyqO+ussxyBFDf9igw+nK59ho3HhGMwwuOmTZtKuF133XXy119/yezZs1XgMl752bx5sxQUFKj3iX7JGHTpbSCnfkVp//79TufXOI8F+nOjn/PPP//sdJ5wa9SoUZjeJZF/GEf8wzhC5IwxxD+MITEo2v0JKfz9kK+66ipt37596rZx40btnnvu0Ww2m+of664f8p49e7SKFStqAwcO1DZt2qRNmzZNq1mzpuo/q3v66ae1GjVqaB9++KG2fft2bdmyZdr777/vdnvoY4s+zOiX7MmJEye0c889V+vcubO2ePFi7aefftKmTJmiLV26VD0/depUrWzZstq7776rbd26VXvttddU/2r9PQD2ifWMqlWrpn3wwQdu+wMDjhHLcMze3HLLLarvMM7bzp07nfopJyUlaY8++qg65unTp6v3YXz/rvvFzwDbefHFF9W5e/vtt9W5NPZDRh/vChUqaG+88Ya2ZcsWbf369dr48ePV+yaKNMYRxhGiYDCGMIbEIyZRFghc+NDoNwyYbNeunQoKOtdAA99//71aDx/KOnXqqMGLJ0+edDyPQZ3Dhg1THzYElLS0NO2FF17wuD184LDvJUuWeDzWHTt2aDfccINWtWpVFTjbtm2rrVixwvE8gtbZZ5+t9ofg8NFHHzm9PpyBa9asWWq9f/zjHyWew6DL9PR0NcAVgy1nzJjhNXDBe++9p6WmpqoBtrfddpv2/PPPOwUu+OSTT7SWLVuqnwECG/b95Zdfej1OonBgHGEcIQoGYwhjSDyy4Z9ot4YRERERERGZBcdEERERERER+YFJFBERERERkR+YRBEREREREfmBSRQREREREZEfmEQRERERERH5gUkUERERERGRH5hEERERERER+YFJFBERERERkR+YRBEREREREfmBSRQREREREZEfmEQRERERERGJ7/4fRqdmsPDiOyIAAAAASUVORK5CYII=",
179:       "text/plain": [
180:        "<Figure size 1000x300 with 3 Axes>"
181:       ]
182:      },
183:      "metadata": {},
184:      "output_type": "display_data"
185:     }
186:    ],
187:    "source": [
188:     "import matplotlib.pyplot as plt\n",
189:     "\n",
190:     "fig, ax = plt.subplots(ncols=3, sharex=True, figsize=(10,3), sharey=True)\n",
191:     "ax[0].plot(value, counts, marker='.', linewidth=0, color='teal')\n",
192:     "ax[1].plot(naive_value, naive_counts, marker='.', linewidth=0, color='salmon')\n",
193:     "ax[2].plot(lasso_value, lasso_counts, marker='.', linewidth=0, color='black')\n",
194:     "\n",
195:     "ax[0].set_title('Original block-conn values')\n",
196:     "ax[1].set_title('Naive')\n",
197:     "ax[2].set_title('Lasso')\n",
198:     "\n",
199:     "for axis in ax:\n",
200:     "    axis.set_xlabel('Block-conn value')\n",
201:     "    axis.set_ylabel('Count')\n",
202:     "    axis.set_yscale('log')\n",
203:     "    # remove the right and top spines\n",
204:     "    axis.spines[['right', 'top']].set_visible(False)\n",
205:     "\n",
206:     "plt.show(fig)"
207:    ]
208:   },
209:   {
210:    "cell_type": "code",
211:    "execution_count": 25,
212:    "id": "091a93af",
213:    "metadata": {},
214:    "outputs": [
215:     {
216:      "data": {
217:       "image/png": "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",
218:       "text/plain": [
219:        "<Figure size 640x480 with 1 Axes>"
220:       ]
221:      },
222:      "metadata": {},
223:      "output_type": "display_data"
224:     }
225:    ],
226:    "source": [
227:     "fig, ax = plt.subplots()\n",
228:     "hist, bins = np.histogram(noise.sigma_e.data, bins=50, density=True)\n",
229:     "\n",
230:     "ax.plot(bins[:-1], hist, marker='.', linewidth=1, color='#dddddd', label=f'Ï_e (avg {np.average(noise.sigma_e.data):.2f})')\n",
231:     "\n",
232:     "sigma_zero = noise.sigma_zero_fun(naive_noisy_fit.block_sizes[0] * naive_noisy_fit.block_sizes[1])\n",
233:     "\n",
234:     "ax.axvline(sigma_zero, color='teal', linestyle='--', label=f'Ï_zero = {sigma_zero:.2f}')\n",
235:     "plt.legend()\n",
236:     "ax.spines[['right', 'top']].set_visible(False)\n",
237:     "\n",
238:     "plt.show(fig)"
239:    ]
240:   },
241:   {
242:    "cell_type": "code",
243:    "execution_count": null,
244:    "id": "2722073f",
245:    "metadata": {},
246:    "outputs": [],
247:    "source": []
248:   }
249:  ],
250:  "metadata": {
251:   "kernelspec": {
252:    "display_name": "Python 3",
253:    "language": "python",
254:    "name": "python3"
255:   },
256:   "language_info": {
257:    "codemirror_mode": {
258:     "name": "ipython",
259:     "version": 3
260:    },
261:    "file_extension": ".py",
262:    "mimetype": "text/x-python",
263:    "name": "python",
264:    "nbconvert_exporter": "python",
265:    "pygments_lexer": "ipython3",
266:    "version": "3.12.11"
267:   }
268:  },
269:  "nbformat": 4,
270:  "nbformat_minor": 5
271: }

================
File: notebooks/visualize_generated_networks_08-07-2025.ipynb
================
  1: {
  2:  "cells": [
  3:   {
  4:    "cell_type": "markdown",
  5:    "id": "a39b7981",
  6:    "metadata": {},
  7:    "source": [
  8:     "# Visualizing a series of observed and surrogate networks"
  9:    ]
 10:   },
 11:   {
 12:    "cell_type": "code",
 13:    "execution_count": 1,
 14:    "id": "9ec1e6ca",
 15:    "metadata": {},
 16:    "outputs": [],
 17:    "source": [
 18:     "from pathlib import Path\n",
 19:     "import numpy as np\n",
 20:     "import scipy.sparse as sp\n",
 21:     "import matplotlib.pyplot as plt\n",
 22:     "import networkx as nx\n",
 23:     "\n",
 24:     "from sbm.sampling import sample_sbm_graph_from_fit\n",
 25:     "from sbm.io import SBMFit, SBMWriter, GraphLoader\n",
 26:     "from sbm.noisy_fit import create_sbm_noise\n",
 27:     "\n",
 28:     "RNG = np.random.default_rng(0)"
 29:    ]
 30:   },
 31:   {
 32:    "cell_type": "code",
 33:    "execution_count": 2,
 34:    "id": "ab4db642",
 35:    "metadata": {},
 36:    "outputs": [
 37:     {
 38:      "name": "stdout",
 39:      "output_type": "stream",
 40:      "text": [
 41:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_caltech_fb_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n"
 42:      ]
 43:     }
 44:    ],
 45:    "source": [
 46:     "name = \"caltech_fb\"\n",
 47:     "sbm = SBMWriter.load(\n",
 48:     "    Path(f\"/Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_{name}_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\")\n",
 49:     ")\n",
 50:     "g = GraphLoader.load(\n",
 51:     "    Path(f'/Users/lmmi/anon_sbm/data/processed/{name}.edgelist'),\n",
 52:     "    force_undirected=True, # type: ignore\n",
 53:     "    )"
 54:    ]
 55:   },
 56:   {
 57:    "cell_type": "code",
 58:    "execution_count": 3,
 59:    "id": "ce7dc0d4",
 60:    "metadata": {},
 61:    "outputs": [],
 62:    "source": [
 63:     "import numpy as np\n",
 64:     "import igraph as ig\n",
 65:     "import matplotlib.pyplot as plt\n",
 66:     "from matplotlib import cm\n",
 67:     "from scipy.sparse import isspmatrix_csr\n",
 68:     "\n",
 69:     "\n",
 70:     "def plot_csr_network_igraph(\n",
 71:     "    ax,\n",
 72:     "    csr_adj,\n",
 73:     "    title=\"\",\n",
 74:     "    *,\n",
 75:     "    layout=\"kamada_kawai\",      # \"fr\" (Fruchterman-Reingold) or any igraph layout name\n",
 76:     "    base_node_size=5,          # pixel diameter of the least-connected node\n",
 77:     "    max_node_size=10,\n",
 78:     "    node_cmap=cm.magma,\n",
 79:     "    with_labels=False,\n",
 80:     "    restrict_to_lcc=True,\n",
 81:     "):\n",
 82:     "    \"\"\"\n",
 83:     "    Draw an undirected graph stored as a CSR array on the supplied Matplotlib Axes.\n",
 84:     "\n",
 85:     "    Parameters\n",
 86:     "    ----------\n",
 87:     "    ax : matplotlib.axes.Axes\n",
 88:     "        Host axes created by plt.subplots.\n",
 89:     "    csr_adj : scipy.sparse.csr_array / csr_matrix\n",
 90:     "        Symmetric adjacency matrix.  Non-zeros are treated as edge weights.\n",
 91:     "    title : str\n",
 92:     "        Subplot title.\n",
 93:     "    layout : str | (n,2) array\n",
 94:     "        igraph layout name or explicit coordinates.\n",
 95:     "    *size / *width : float\n",
 96:     "        Ranges for vertex bubble diameters and edge strokes (pixels).\n",
 97:     "    node_cmap : matplotlib colormap\n",
 98:     "        Vertex colour map keyed on degree.\n",
 99:     "    with_labels : bool\n",
100:     "        Draw integer node labels.\n",
101:     "    \"\"\"\n",
102:     "\n",
103:     "    # 1 ââââââââââ build igraph graph from sparse input\n",
104:     "\n",
105:     "    n = csr_adj.shape[0]\n",
106:     "    coo = csr_adj.tocoo()\n",
107:     "    mask = coo.row < coo.col                      # keep each undirected edge once\n",
108:     "    edges = list(zip(coo.row[mask], coo.col[mask]))\n",
109:     "    weights = coo.data[mask].astype(float).tolist()\n",
110:     "\n",
111:     "    g = ig.Graph(n=n, edges=edges, directed=False)\n",
112:     "    if restrict_to_lcc:\n",
113:     "        g = g.connected_components().giant()\n",
114:     "\n",
115:     "    if weights:\n",
116:     "        g.es[\"weight\"] = weights  # optional\n",
117:     "\n",
118:     "    # 2 ââââââââââ vertex/edge aesthetics\n",
119:     "    deg = np.array(g.degree())\n",
120:     "    deg_norm = (deg - deg.min()) / (deg.ptp() + 1e-9)\n",
121:     "    g.vs[\"size\"] = (base_node_size + deg_norm * (max_node_size - base_node_size)).tolist()\n",
122:     "\n",
123:     "    rgba = node_cmap(deg_norm)\n",
124:     "    g.vs[\"color\"] = [cm.colors.to_hex(c) for c in rgba]\n",
125:     "    g.vs[\"frame_color\"] = [\"white\"] * n\n",
126:     "    g.vs[\"frame_width\"] = 0.1\n",
127:     "\n",
128:     "    if \"weight\" in g.es.attributes():\n",
129:     "        w = np.array(weights)\n",
130:     "        w_norm = (w - w.min()) / (w.ptp() + 1e-9)\n",
131:     "    else:\n",
132:     "        w_norm = np.zeros(len(g.es))\n",
133:     "    g.es[\"width\"] = 0.1 #(base_edge_width + w_norm * (max_edge_width - base_edge_width)).tolist()\n",
134:     "    g.es[\"color\"] = [\"#bbbbbb\"] * len(g.es)\n",
135:     "\n",
136:     "    # 3 ââââââââââ layout\n",
137:     "    if isinstance(layout, str):\n",
138:     "        try:\n",
139:     "            coord = g.layout(layout)\n",
140:     "            coord = np.array(coord)\n",
141:     "        except ValueError:\n",
142:     "            # if the layout name is not recognized, use a default layout\n",
143:     "            raise ValueError(f\"Unknown layout: {layout}. Please use a valid igraph layout name.\")\n",
144:     "    else:                       # numpy array supplied\n",
145:     "        coord = layout\n",
146:     "    \n",
147:     "    # 4 ââââââââââ draw\n",
148:     "    ax.set_title(title, fontsize=12)\n",
149:     "    ax.axis(\"off\")\n",
150:     "    ig.plot(\n",
151:     "        g,\n",
152:     "        target=ax,\n",
153:     "        layout=coord,\n",
154:     "        vertex_size=g.vs[\"size\"],\n",
155:     "        vertex_color=g.vs[\"color\"],\n",
156:     "        vertex_frame_width=g.vs[\"frame_width\"],\n",
157:     "        vertex_frame_color=g.vs[\"frame_color\"],\n",
158:     "        edge_width=g.es[\"width\"],\n",
159:     "        edge_color=g.es[\"color\"],\n",
160:     "        vertex_label=g.vs.indices if with_labels else None,\n",
161:     "        vertex_label_size=8,\n",
162:     "    )\n",
163:     "\n",
164:     "    # scale limits to fit the graph\n",
165:     "    x_min, x_max = min(coord[:, 0]), max(coord[:, 0])\n",
166:     "    y_min, y_max = min(coord[:, 1]), max(coord[:, 1])\n",
167:     "\n",
168:     "    scale = 1.05\n",
169:     "    ax.set_xlim(x_min * scale, x_max * scale)\n",
170:     "    ax.set_ylim(y_min * scale, y_max * scale)\n"
171:    ]
172:   },
173:   {
174:    "cell_type": "code",
175:    "execution_count": 4,
176:    "id": "3c5b959a",
177:    "metadata": {},
178:    "outputs": [
179:     {
180:      "name": "stdout",
181:      "output_type": "stream",
182:      "text": [
183:       "[LASSO]    Added 7321 edges to previously-zero pairs\n",
184:       "[NAIVE]    Added 83741 edges to zero pairs.\n"
185:      ]
186:     }
187:    ],
188:    "source": [
189:     "EPS, DELTA, ALPHA = 3, 1e-2, 1-1e-4\n",
190:     "\n",
191:     "sbm_g = sample_sbm_graph_from_fit(sbm, RNG)\n",
192:     "\n",
193:     "noise = create_sbm_noise(sbm, EPS, DELTA, ALPHA, noise_type=\"heterogeneous_gaussian\")\n",
194:     "\n",
195:     "lasso_noisy_fit = noise.sample_sbm_fit(RNG, post='lasso')\n",
196:     "lasso_g = sample_sbm_graph_from_fit(lasso_noisy_fit, RNG)\n",
197:     "\n",
198:     "naive_noisy_fit = noise.sample_sbm_fit(RNG, post='naive')\n",
199:     "naive_g = sample_sbm_graph_from_fit(naive_noisy_fit, RNG)"
200:    ]
201:   },
202:   {
203:    "cell_type": "code",
204:    "execution_count": 5,
205:    "id": "69e8d221",
206:    "metadata": {},
207:    "outputs": [],
208:    "source": [
209:     "# check that graph is undirected\n",
210:     "assert (sbm_g.adjacency != sbm_g.adjacency.T).sum() == 0,\\\n",
211:     "    \"The sampled SBM graph is not undirected.\"\n",
212:     "assert (lasso_g.adjacency != lasso_g.adjacency.T).sum() == 0,\\\n",
213:     "    \"The lasso noisy graph is not undirected.\"\n",
214:     "assert (naive_g.adjacency != naive_g.adjacency.T).sum() == 0,\\\n",
215:     "    \"The naive noisy graph is not undirected.\""
216:    ]
217:   },
218:   {
219:    "cell_type": "code",
220:    "execution_count": 6,
221:    "id": "45e318fa",
222:    "metadata": {},
223:    "outputs": [
224:     {
225:      "data": {
226:       "image/png": "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",
227:       "text/plain": [
228:        "<Figure size 1600x400 with 4 Axes>"
229:       ]
230:      },
231:      "metadata": {},
232:      "output_type": "display_data"
233:     }
234:    ],
235:    "source": [
236:     "fig, ax = plt.subplots(ncols=4, figsize=(16, 4))\n",
237:     "\n",
238:     "for idx, (name, adjacency) in enumerate(\n",
239:     "    [\n",
240:     "        (\"Empirical\", g.adjacency),\n",
241:     "        ('SBM', sbm_g.adjacency),\n",
242:     "        (\"Lasso Noisy Fit\", lasso_g.adjacency),\n",
243:     "        (\"Naive Noisy Fit\", naive_g.adjacency),\n",
244:     "    ]\n",
245:     "):\n",
246:     "    plot_csr_network_igraph(\n",
247:     "        ax[idx],\n",
248:     "        adjacency,\n",
249:     "        title=name,\n",
250:     "        layout=\"kamada_kawai\", \n",
251:     "        base_node_size=1,\n",
252:     "        max_node_size=10,\n",
253:     "        restrict_to_lcc=False,\n",
254:     "        )\n",
255:     "\n",
256:     "plt.show()"
257:    ]
258:   },
259:   {
260:    "cell_type": "code",
261:    "execution_count": null,
262:    "id": "1ff4b1df",
263:    "metadata": {},
264:    "outputs": [],
265:    "source": []
266:   },
267:   {
268:    "cell_type": "markdown",
269:    "id": "ada47c4b",
270:    "metadata": {},
271:    "source": [
272:     "# Visualize for all networks:\n"
273:    ]
274:   },
275:   {
276:    "cell_type": "code",
277:    "execution_count": 7,
278:    "id": "c24dbce9",
279:    "metadata": {},
280:    "outputs": [],
281:    "source": [
282:     "import sys\n",
283:     "from pathlib import Path\n",
284:     "from itertools import product\n",
285:     "from tqdm import tqdm\n",
286:     "\n",
287:     "### Load all surrogate statistics\n",
288:     "folder_path = Path('/Users/lmmi/anon_sbm/data/processed/')\n",
289:     "\n",
290:     "# find all log files in the logs directory\n",
291:     "edgelist_files = list(folder_path.glob(\"*.edgelist\"))\n",
292:     "size = (3,6,12,25)"
293:    ]
294:   },
295:   {
296:    "cell_type": "code",
297:    "execution_count": 8,
298:    "id": "9654c7d7",
299:    "metadata": {},
300:    "outputs": [],
301:    "source": [
302:     "def extract_network_name(file_path: Path) -> str:\n",
303:     "    \"\"\"\n",
304:     "    Extract the network name from the file path.\n",
305:     "    \"\"\"\n",
306:     "    return file_path.stem.split('.')[0]  # Assuming the name is the first part of the filename"
307:    ]
308:   },
309:   {
310:    "cell_type": "code",
311:    "execution_count": 9,
312:    "id": "c41de916",
313:    "metadata": {},
314:    "outputs": [],
315:    "source": [
316:     "EPS, DELTA, ALPHA = 3, 1e-4, 1-1e-4"
317:    ]
318:   },
319:   {
320:    "cell_type": "code",
321:    "execution_count": null,
322:    "id": "0dc7e752",
323:    "metadata": {},
324:    "outputs": [
325:     {
326:      "name": "stderr",
327:      "output_type": "stream",
328:      "text": [
329:       "0it [00:00, ?it/s]"
330:      ]
331:     },
332:     {
333:      "name": "stdout",
334:      "output_type": "stream",
335:      "text": [
336:       "Processing /Users/lmmi/anon_sbm/data/processed/eu_email.edgelist with block size 3...\n",
337:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_eu_email_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
338:       "[LASSO]    Added 16869 edges to previously-zero pairs\n",
339:       "[NAIVE]    Added 184453 edges to zero pairs.\n"
340:      ]
341:     },
342:     {
343:      "name": "stderr",
344:      "output_type": "stream",
345:      "text": [
346:       "1it [01:09, 69.46s/it]"
347:      ]
348:     },
349:     {
350:      "name": "stdout",
351:      "output_type": "stream",
352:      "text": [
353:       "Processing /Users/lmmi/anon_sbm/data/processed/eu_email.edgelist with block size 6...\n",
354:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_eu_email_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
355:       "[LASSO]    Added 17130 edges to previously-zero pairs\n",
356:       "[NAIVE]    Added 181981 edges to zero pairs.\n"
357:      ]
358:     },
359:     {
360:      "name": "stderr",
361:      "output_type": "stream",
362:      "text": [
363:       "2it [02:20, 70.34s/it]"
364:      ]
365:     },
366:     {
367:      "name": "stdout",
368:      "output_type": "stream",
369:      "text": [
370:       "Processing /Users/lmmi/anon_sbm/data/processed/eu_email.edgelist with block size 12...\n",
371:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_eu_email_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
372:       "[LASSO]    Added 17122 edges to previously-zero pairs\n",
373:       "[NAIVE]    Added 180181 edges to zero pairs.\n"
374:      ]
375:     },
376:     {
377:      "name": "stderr",
378:      "output_type": "stream",
379:      "text": [
380:       "3it [03:31, 70.54s/it]"
381:      ]
382:     },
383:     {
384:      "name": "stdout",
385:      "output_type": "stream",
386:      "text": [
387:       "Processing /Users/lmmi/anon_sbm/data/processed/eu_email.edgelist with block size 25...\n",
388:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_eu_email_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
389:       "[LASSO]    Added 17167 edges to previously-zero pairs\n",
390:       "[NAIVE]    Added 183048 edges to zero pairs.\n"
391:      ]
392:     },
393:     {
394:      "name": "stderr",
395:      "output_type": "stream",
396:      "text": [
397:       "4it [04:42, 70.94s/it]"
398:      ]
399:     },
400:     {
401:      "name": "stdout",
402:      "output_type": "stream",
403:      "text": [
404:       "Processing /Users/lmmi/anon_sbm/data/processed/caltech_fb.edgelist with block size 3...\n",
405:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_caltech_fb_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
406:       "[LASSO]    Added 7322 edges to previously-zero pairs\n",
407:       "[NAIVE]    Added 88259 edges to zero pairs.\n"
408:      ]
409:     },
410:     {
411:      "name": "stderr",
412:      "output_type": "stream",
413:      "text": [
414:       "5it [05:30, 62.74s/it]"
415:      ]
416:     },
417:     {
418:      "name": "stdout",
419:      "output_type": "stream",
420:      "text": [
421:       "Processing /Users/lmmi/anon_sbm/data/processed/caltech_fb.edgelist with block size 6...\n",
422:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_caltech_fb_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
423:       "[LASSO]    Added 7477 edges to previously-zero pairs\n",
424:       "[NAIVE]    Added 84503 edges to zero pairs.\n"
425:      ]
426:     },
427:     {
428:      "name": "stderr",
429:      "output_type": "stream",
430:      "text": [
431:       "6it [06:18, 57.64s/it]"
432:      ]
433:     },
434:     {
435:      "name": "stdout",
436:      "output_type": "stream",
437:      "text": [
438:       "Processing /Users/lmmi/anon_sbm/data/processed/caltech_fb.edgelist with block size 12...\n",
439:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_caltech_fb_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
440:       "[LASSO]    Added 7364 edges to previously-zero pairs\n",
441:       "[NAIVE]    Added 85151 edges to zero pairs.\n"
442:      ]
443:     },
444:     {
445:      "name": "stderr",
446:      "output_type": "stream",
447:      "text": [
448:       "7it [07:08, 55.23s/it]"
449:      ]
450:     },
451:     {
452:      "name": "stdout",
453:      "output_type": "stream",
454:      "text": [
455:       "Processing /Users/lmmi/anon_sbm/data/processed/caltech_fb.edgelist with block size 25...\n",
456:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_caltech_fb_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
457:       "[LASSO]    Added 7296 edges to previously-zero pairs\n",
458:       "[NAIVE]    Added 82972 edges to zero pairs.\n"
459:      ]
460:     },
461:     {
462:      "name": "stderr",
463:      "output_type": "stream",
464:      "text": [
465:       "8it [07:57, 53.19s/it]"
466:      ]
467:     },
468:     {
469:      "name": "stdout",
470:      "output_type": "stream",
471:      "text": [
472:       "Processing /Users/lmmi/anon_sbm/data/processed/congress_twitter.edgelist with block size 3...\n",
473:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_congress_twitter_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
474:       "[LASSO]    Added 1663 edges to previously-zero pairs\n",
475:       "[NAIVE]    Added 20444 edges to zero pairs.\n"
476:      ]
477:     },
478:     {
479:      "name": "stderr",
480:      "output_type": "stream",
481:      "text": [
482:       "9it [08:20, 43.61s/it]"
483:      ]
484:     },
485:     {
486:      "name": "stdout",
487:      "output_type": "stream",
488:      "text": [
489:       "Processing /Users/lmmi/anon_sbm/data/processed/congress_twitter.edgelist with block size 6...\n",
490:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_congress_twitter_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
491:       "[LASSO]    Added 1978 edges to previously-zero pairs\n",
492:       "[NAIVE]    Added 19975 edges to zero pairs.\n"
493:      ]
494:     },
495:     {
496:      "name": "stderr",
497:      "output_type": "stream",
498:      "text": [
499:       "10it [08:44, 37.60s/it]"
500:      ]
501:     },
502:     {
503:      "name": "stdout",
504:      "output_type": "stream",
505:      "text": [
506:       "Processing /Users/lmmi/anon_sbm/data/processed/congress_twitter.edgelist with block size 12...\n",
507:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_congress_twitter_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
508:       "[LASSO]    Added 1556 edges to previously-zero pairs\n",
509:       "[NAIVE]    Added 19468 edges to zero pairs.\n"
510:      ]
511:     },
512:     {
513:      "name": "stderr",
514:      "output_type": "stream",
515:      "text": [
516:       "11it [09:08, 33.44s/it]"
517:      ]
518:     },
519:     {
520:      "name": "stdout",
521:      "output_type": "stream",
522:      "text": [
523:       "Processing /Users/lmmi/anon_sbm/data/processed/congress_twitter.edgelist with block size 25...\n",
524:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_congress_twitter_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
525:       "[LASSO]    Added 1845 edges to previously-zero pairs\n",
526:       "[NAIVE]    Added 19494 edges to zero pairs.\n"
527:      ]
528:     },
529:     {
530:      "name": "stderr",
531:      "output_type": "stream",
532:      "text": [
533:       "12it [09:32, 30.72s/it]"
534:      ]
535:     },
536:     {
537:      "name": "stdout",
538:      "output_type": "stream",
539:      "text": [
540:       "Processing /Users/lmmi/anon_sbm/data/processed/enron_email.edgelist with block size 3...\n",
541:       "Processing /Users/lmmi/anon_sbm/data/processed/enron_email.edgelist with block size 6...\n",
542:       "Processing /Users/lmmi/anon_sbm/data/processed/enron_email.edgelist with block size 12...\n",
543:       "Processing /Users/lmmi/anon_sbm/data/processed/enron_email.edgelist with block size 25...\n",
544:       "Processing /Users/lmmi/anon_sbm/data/processed/lastfm_asia.edgelist with block size 3...\n",
545:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_lastfm_asia_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
546:       "[LASSO]    Added 1400325 edges to previously-zero pairs\n",
547:       "[NAIVE]    Added 14194133 edges to zero pairs.\n"
548:      ]
549:     }
550:    ],
551:    "source": [
552:     "for index, (edgelist_path, block_size) in tqdm(enumerate(product(edgelist_files[::-1], size))):\n",
553:     "    print(f\"Processing {edgelist_path} with block size {block_size}...\")\n",
554:     "\n",
555:     "    name = extract_network_name(edgelist_path)\n",
556:     "\n",
557:     "    # too big\n",
558:     "    if name in {'enron_email', 'wiki_vote'}:\n",
559:     "        continue\n",
560:     "\n",
561:     "    sbm = SBMWriter.load(\n",
562:     "        Path(f\"/Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_{name}_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\")\n",
563:     "    )\n",
564:     "    g = GraphLoader.load(\n",
565:     "        Path(edgelist_path), force_undirected=True)\n",
566:     "\n",
567:     "    sbm_g = sample_sbm_graph_from_fit(sbm, RNG)\n",
568:     "\n",
569:     "    noise = create_sbm_noise(sbm, EPS, DELTA, ALPHA, noise_type=\"heterogeneous_gaussian\")\n",
570:     "\n",
571:     "    lasso_noisy_fit = noise.sample_sbm_fit(RNG, post='lasso')\n",
572:     "    lasso_g = sample_sbm_graph_from_fit(lasso_noisy_fit, RNG)\n",
573:     "\n",
574:     "    naive_noisy_fit = noise.sample_sbm_fit(RNG, post='naive')\n",
575:     "    naive_g = sample_sbm_graph_from_fit(naive_noisy_fit, RNG)\n",
576:     "\n",
577:     "    fig, ax = plt.subplots(ncols=4, figsize=(16, 4))\n",
578:     "\n",
579:     "    if g.adjacency.shape[0] > 1000:\n",
580:     "        layout = 'large'\n",
581:     "        restrict_to_lcc = True\n",
582:     "    else:\n",
583:     "        layout = 'kamada_kawai'\n",
584:     "        restrict_to_lcc = False\n",
585:     "\n",
586:     "    for idx, (method_name, adjacency) in enumerate(\n",
587:     "        [\n",
588:     "            (\"Empirical\", g.adjacency),\n",
589:     "            ('SBM', sbm_g.adjacency),\n",
590:     "            (\"Lasso Noisy Fit\", lasso_g.adjacency),\n",
591:     "            (\"Naive Noisy Fit\", naive_g.adjacency),\n",
592:     "        ]\n",
593:     "    ):\n",
594:     "        plot_csr_network_igraph(\n",
595:     "            ax[idx],\n",
596:     "            adjacency,\n",
597:     "            title=method_name,\n",
598:     "            layout=layout, \n",
599:     "            base_node_size=1,\n",
600:     "            max_node_size=10,\n",
601:     "            restrict_to_lcc=restrict_to_lcc,\n",
602:     "            )\n",
603:     "\n",
604:     "    save_path = Path(f\"/Users/lmmi/anon_sbm/results/figures/sbm_fit_{name}_block_size_{block_size}.png\")\n",
605:     "    save_path.parent.mkdir(parents=True, exist_ok=True)\n",
606:     "    fig.savefig(save_path, dpi=300, bbox_inches='tight')\n",
607:     "    plt.close(fig)"
608:    ]
609:   },
610:   {
611:    "cell_type": "code",
612:    "execution_count": null,
613:    "id": "d95132b0",
614:    "metadata": {},
615:    "outputs": [],
616:    "source": []
617:   }
618:  ],
619:  "metadata": {
620:   "kernelspec": {
621:    "display_name": "Python 3",
622:    "language": "python",
623:    "name": "python3"
624:   },
625:   "language_info": {
626:    "codemirror_mode": {
627:     "name": "ipython",
628:     "version": 3
629:    },
630:    "file_extension": ".py",
631:    "mimetype": "text/x-python",
632:    "name": "python",
633:    "nbconvert_exporter": "python",
634:    "pygments_lexer": "ipython3",
635:    "version": "3.12.11"
636:   }
637:  },
638:  "nbformat": 4,
639:  "nbformat_minor": 5
640: }

================
File: src/metrics/assortativity.py
================
 1: """ 
 2: Metrics for comparing assortativity of two graph.
 3: """
 4: import numpy as np
 5: from scipy.sparse import csr_array
 6: import networkx as nx
 7: ###############################################################################
 8: #Assortativity coefficient difference ------------------------------------
 9: ###############################################################################
10: def assortativity_difference(
11:     emp_adj: csr_array,
12:     sur_adj: csr_array,
13:     *,
14:     rng: np.random.Generator = np.random.default_rng(1),
15: ) -> float:
16:     """Absolute difference in degreeâassortativity (Pearson) coefficient."""
17:     def _assort(adj: csr_array) -> float:
18:         G = nx.from_scipy_sparse_matrix(adj)
19:         # NetworkX warns for disconnected graphs â ignore
20:         try:
21:             return float(nx.degree_pearson_correlation_coefficient(G))
22:         except Exception:
23:             return 0.0  # fallback (e.g., for trivial graphs)
24:     return abs(_assort(emp_adj) - _assort(sur_adj))

================
File: src/metrics/community.py
================
 1: """
 2: Metric functions to compare the community structure of two graphs.
 3: """
 4: import numpy as np
 5: from scipy.sparse import csr_array
 6: # external heavyâduty packages (all listed in requirements.txt)
 7: from infomap import Infomap  # type: ignore
 8: import igraph as ig  # type: ignore
 9: import leidenalg  # type: ignore
10: ###############################################################################
11: # Infomap codelength difference -------------------------------------------
12: ###############################################################################
13: def infomap_codelength_difference(
14:     emp_adj: csr_array,
15:     sur_adj: csr_array,
16:     *,
17:     directed: bool = False,
18:     rng: np.random.Generator = np.random.default_rng(1),
19: ) -> float:
20:     """Absolute difference in Infomap codelength (compression) between graphs."""
21:     def _codelength(adj: csr_array) -> float:
22:         im = Infomap("--directed" if directed else "--undirected")
23:         rows, cols = adj.nonzero()
24:         for u, v in zip(rows, cols, strict=False):
25:             if u < v or directed:
26:                 im.add_link(int(u), int(v))
27:         im.run()
28:         return im.codelength
29:     return abs(_codelength(emp_adj) - _codelength(sur_adj))
30: ###############################################################################
31: # Modularity distance via Leiden ------------------------------------------
32: ###############################################################################
33: def leiden_modularity_difference(
34:     emp_adj: csr_array,
35:     sur_adj: csr_array,
36:     *,
37:     rng: np.random.Generator = np.random.default_rng(1),
38: ) -> float:
39:     """Absolute difference in maximum modularity found by Leiden."""
40:     def _modularity(adj: csr_array) -> float:
41:         g = ig.Graph.FromAdjacency(adj.toarray(), mode="UNDIRECTED")  # small graphs â dense ok
42:         part = leidenalg.find_partition(g, leidenalg.ModularityVertexPartition, weights=None)
43:         return g.modularity(part)
44:     return abs(_modularity(emp_adj) - _modularity(sur_adj))

================
File: src/metrics/embedding.py
================
 1: """
 2: Metrics for comparing two adjacency matrices based on node embeddings
 3: """
 4: from typing import Literal
 5: import numpy as np
 6: import networkx as nx
 7: from scipy.sparse import csr_array
 8: from scipy.stats import wasserstein_distance  # 1âD Earth mover distance
 9: from sbm.utils.util import restrict_to_lcc
10: from nodevectors import Node2Vec, ProNE  # type: ignore
11: ### Aliases --------------------------------------------------------
12: EmbeddingMethods = Literal["node2vec", "prone"]
13: ### Helper functions -----------------------------------------------
14: def _embedding_ip_emd(
15:     emp_adj: csr_array,
16:     sur_adj: csr_array,
17:     *,
18:     dim: int = 128,
19:     n_pairs: int = 10_000,
20:     embedding_method: EmbeddingMethods = "node2vec",  # "node2vec" or "prone"
21:     rng: np.random.Generator = np.random.default_rng(1),
22: ) -> float:
23:     """Compare Node2Vec *and* ProNE embeddings via innerâproduct distributions.
24:     The returned distance is the mean of the two 1âD Wasserstein distances.
25:     """
26:     def _embed_and_sample(adj: csr_array, method: str) -> np.ndarray:
27:         G = nx.from_scipy_sparse_matrix(adj)
28:         if method == "node2vec":
29:             model = Node2Vec(n_components=dim, walklen=80, return_weight=1.0, 
30:                              neighbor_weight=1.0, epochs=20, verbose=False)
31:         elif method == "prone":
32:             model = ProNE(n_components=dim)
33:         else:
34:             raise ValueError("Unknown method")
35:         emb = model.fit_transform(G)
36:         nodes = np.arange(emb.shape[0])  # node indices
37:         vecs = np.vstack([emb[n] for n in nodes])
38:         # sample pairs uniformly without replacement (if possible)
39:         m = nodes.size
40:         total_pairs = m * (m - 1) // 2
41:         n_samp = min(n_pairs, total_pairs)
42:         idx1 = rng.choice(m, size=n_samp, replace=True)
43:         idx2 = rng.choice(m - 1, size=n_samp, replace=True)
44:         idx2[idx2 >= idx1] += 1  # ensure idx2 â  idx1
45:         ips = np.sum(vecs[idx1] * vecs[idx2], axis=1)
46:         return ips.astype(np.float32)
47:     if embedding_method == "node2vec":
48:         ip_emp_n2v = _embed_and_sample(emp_adj, "node2vec")
49:         ip_sur_n2v = _embed_and_sample(sur_adj, "node2vec")
50:         d = wasserstein_distance(ip_emp_n2v, ip_sur_n2v)
51:     elif embedding_method == "prone":
52:         ip_emp_prn = _embed_and_sample(emp_adj, "prone")
53:         ip_sur_prn = _embed_and_sample(sur_adj, "prone")
54:         d = wasserstein_distance(ip_emp_prn, ip_sur_prn)
55:     else:
56:         raise ValueError(f"Unknown embedding method: {embedding_method}")
57:     return float(d)
58: ###############################################################################
59: # Embedding innerâproduct EMD ---------------------------------------------
60: ###############################################################################
61: def embedding_node2vec_ip_emd(
62:     emp_adj: csr_array,
63:     sur_adj: csr_array,
64:     *,
65:     dim: int = 128,
66:     n_pairs: int = 10_000,
67:     rng: np.random.Generator = np.random.default_rng(1),
68: ) -> float:
69:     """Compare Node2Vec embeddings via innerâproduct distributions."""
70:     return _embedding_ip_emd(emp_adj, sur_adj, dim=dim, n_pairs=n_pairs, 
71:                              embedding_method="node2vec", rng=rng)
72: def embedding_prone_ip_emd(
73:     emp_adj: csr_array,
74:     sur_adj: csr_array,
75:     *,
76:     dim: int = 128,
77:     n_pairs: int = 10_000,
78:     rng: np.random.Generator = np.random.default_rng(1),
79: ) -> float:
80:     """Compare ProNE embeddings via innerâproduct distributions."""
81:     return _embedding_ip_emd(emp_adj, sur_adj, dim=dim, n_pairs=n_pairs, 
82:                              embedding_method="prone", rng=rng)

================
File: src/metrics/spectral.py
================
 1: """ 
 2: Metrics functions to compare the spectral properties of two graphs.
 3: """
 4: from typing import Tuple
 5: import numpy as np
 6: import scipy.sparse as sp
 7: from scipy.sparse import csr_array
 8: from scipy.sparse.csgraph import shortest_path
 9: from scipy.sparse.linalg import eigsh
10: from scipy.spatial.distance import cosine
11: ### Utility functions --------------------------------------------------------
12: def _eig_pairs(A: csr_array, k: int, which:str="LA") -> Tuple[np.ndarray, np.ndarray]:
13:     """Return the *k* leading eigenpairs of the symmetric matrix *A*.
14:     """ 
15:     if A.shape[0] <= 2 * k:
16:         w, v = np.linalg.eigh(A.toarray())
17:         idx = np.argsort(w)[::-1][:k]
18:         return w[idx], v[:, idx]
19:     w, v = eigsh(A, k=k, which=which)
20:     idx = np.argsort(w)[::-1]
21:     return w[idx], v[:, idx]
22: ###############################################################################
23: # Leading eigenâsubspace similarity ----------------------------------------
24: ###############################################################################
25: def eigen_subspace_distance(
26:     emp_adj: csr_array,
27:     sur_adj: csr_array,
28:     *,
29:     k: int = 1,
30:     which: str = "LA",  # largest algebraic
31:     rng: np.random.Generator = np.random.default_rng(1),  # included for API consistency
32: ) -> float:
33:     """Distance between the *k* leading eigenpairs of the adjacency matrices.
34:     The score is
35:         ÎÎ»  +  (1 â cosÌ)
36:     where
37:         ÎÎ»  = mean |Î»áµ¢Â¹ â Î»áµ¢Â²| / (|Î»áµ¢Â¹| + |Î»áµ¢Â²| + 1eâ9)
38:         cosÌ = mean absolute cosine between matching eigenvectors.
39:     """
40:     # ensure symmetric (undirected) matrix (avoid double counting diagonal)
41:     A_emp = emp_adj + emp_adj.T - sp.diags(emp_adj.diagonal())
42:     A_sur = sur_adj + sur_adj.T - sp.diags(sur_adj.diagonal())
43:     n1 = min(k, A_emp.shape[0] - 2)
44:     n2 = min(k, A_sur.shape[0] - 2)
45:     k_ = min(n1, n2, k)
46:     if k_ <= 0:
47:         return 0.0
48:     Î»_emp, V_emp = _eig_pairs(A_emp, k_, which=which)
49:     Î»_sur, V_sur = _eig_pairs(A_sur, k_, which=which)
50:     # --- eigenvalue part ------------------------------------------------------
51:     ÎÎ» = np.mean(np.abs(Î»_emp - Î»_sur) / (np.abs(Î»_emp) + np.abs(Î»_sur) + 1e-9))
52:     # --- eigenvector part -----------------------------------------------------
53:     cos_sim = [1 - cosine(np.abs(V_emp[:, i]), np.abs(V_sur[:, i])) for i in range(k_)]
54:     cosÌ = np.mean(cos_sim)
55:     return float(ÎÎ» + (1 - cosÌ))

================
File: src/pipelines/evaluate_noisy_surrogates.py
================
 1: """
 2:     Generate surrogate differentially private SBM graphs and evaluate them against empirical data.
 3: """
 4: from typing import TypedDict, List, Union
 5: import argparse
 6: import yaml
 7: import csv
 8: from pathlib import Path
 9: import numpy as np
10: from metrics import REGISTRY
11: from sbm.io import SBMWriter
12: from sbm.sampling import sample_sbm_graph_from_fit
13: from sbm.io import GraphLoader
14: from sbm.utils.pipeline_utils import (
15:     sbmfit_folderpath,
16:     surrogate_statistics_filename,
17:     FitConfig,
18:     EvalConfig,
19: )
20: def main(fit_config: str, eval_config: str): # type: ignore
21:     fit_config: FitConfig = yaml.safe_load(Path(fit_config).read_text())
22:     rng = np.random.default_rng(fit_config["seed"])
23:     data_config = fit_config["datasets"] # type: ignore
24:     eval_config: EvalConfig = yaml.safe_load(Path(eval_config).read_text())
25:     for sbm_config in fit_config["sbm"]:
26:         for ds in data_config:
27:             # Load empirical graph
28:             g = GraphLoader.load(
29:                     Path(ds["path"]),
30:                     force_undirected=sbm_config["force_undirected"], # type: ignore
31:                 )
32:             emp = g.adjacency
33:             # load fitted model
34:             fit_folder_path = sbmfit_folderpath(
35:                 base_dir=Path("results/sbm_fits"),
36:                 sbm_config=sbm_config,# type: ignore
37:                 data_spec=ds,
38:             )
39:             # load the sbm fit
40:             sbm_fit = SBMWriter.load(fit_folder_path)
41:             # check if metrics have been cached earlier
42:             out = surrogate_statistics_filename(
43:                 base_dir=Path("results/surrogate_statistics"),
44:                 eval_configs=eval_config,
45:                 sbm_config=sbm_config,# type: ignore
46:                 data_spec=ds,
47:             )
48:             out.parent.mkdir(exist_ok=True)
49:             if out.exists() and not eval_config["overwrite"]:
50:                 continue
51:             # Generate surrogates and campare metrics
52:             results = []
53:             for i in range(eval_config["n_surrogates"]):
54:                 surr = sample_sbm_graph_from_fit(
55:                     sbm_fit=sbm_fit,
56:                     rng=rng,
57:                 )
58:                 surr = surr.adjacency
59:                 row = {"dataset": ds["name"], "surrogate": f'surr_{i}'}
60:                 for m in eval_config["metrics"]:
61:                     row[m] = REGISTRY[m](emp, surr)
62:                 results.append(row)
63:             with out.open("w", newline="") as f:
64:                 w = csv.DictWriter(f, fieldnames=results[0].keys())
65:                 w.writeheader(); w.writerows(results)
66: if __name__ == "__main__":
67:     p = argparse.ArgumentParser()
68:     p.add_argument("--fit_config", type=str, help="Path to the configuration file.")
69:     p.add_argument("--eval_config", type=str, help="Path to the configuration file.")
70:     args = p.parse_args()
71:     main(
72:         fit_config=args.fit_config,
73:         eval_config=args.eval_config
74:     )

================
File: src/sbm/noisy_fit.py
================
  1: ###############################################################################
  2: #  noisy_fit_refactored.py
  3: #  âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
  4: #  Differential-privacy noise generation for Stochastic-Block-Model (SBM) fits
  5: #
  6: #  This module implements three Gaussianâmechanism variants:
  7: #
  8: #    â¢ **heterogeneous_gaussian**  â optimal per-coordinate Ïq   (Sec.-4, eq. 12)
  9: #    â¢ **naive_degree_gaussian**   â one common  Ï  calibrated to global
 10: #                                     Îmax-degree  (classic node-DP baseline)
 11: #    â¢ **naive_edge_count_gaussian** â one common  Ï  calibrated to
 12: #                                       Înlk  (Î±-quantile âsingleâblock changeâ)
 13: #
 14: #  All noise is added to the *SBM sufficient statistics*
 15: #           n_r   â¦ block sizes            (1 Ã B   coordinates)
 16: #           m_rs  â¦ upper-tri edge counts  (B(B+1)/2 coordinates)
 17: #
 18: #  Memory footprint is O(B + nnz(m)), never BÂ².
 19: #
 20: #ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
 21: #  SYMBOL TABLE  (matches notation in the derivation)
 22: #ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
 23: #
 24: #  B           : number of blocks.
 25: #  k_vec       : integer array [kâ,â¦,k_{B-1}]  â true block sizes (âk or k+1).
 26: #
 27: #  m_rs        : true edge count between blocks r and s (upper triangle incl. diag).
 28: #  N_rs        : number of *possible* edges, =
 29: #                  k_rÂ·(k_r-1)/2    if r=s
 30: #                  k_rÂ·k_s          if râ s
 31: #
 32: #  p_rs        : edge probability  m_rs / N_rs.  For p=0 or 1 we clip to
 33: #                clip_p   (default 1e-12) to keep weights finite.
 34: #
 35: #  Î_nlk       : âsingle-block changeâ sensitivity â Î±-quantile of the
 36: #                maximum number of neighbours a *single* node can have in the
 37: #                *same* block (max Binomial), eq. (2).
 38: #  delta_tail  : 1-Î± â contributes to Î´ in (Îµ,Î´+Î´_tail)-DP.
 39: #
 40: #  c_n         : sensitivityÂ² for n_r.  Here Î=1 â  c_n = 1.
 41: #  c_e_val     : sensitivityÂ² for *all* edge counts m_rs = Î_nlkÂ².
 42: #
 43: #  w_n[r]      : utility weight for n_r      â eq. (5), last two lines.
 44: #  w_rs        : utility weight for m_rs     â eq. (5), first line.
 45: #  w_e         : list of w_rs for every stored upper-tri cell.
 46: #
 47: #  S_sum       : Î£_q â(c_q w_q)   (needed in eq. (10)â(12)).
 48: #
 49: #  R           : ÎµÂ² / (2 ln(1.25/(Î´+Î´_tail)))   â Gaussian mech. constant.
 50: #
 51: #  Ï_n[r]      : standard deviation for noise on n_r  (heterogeneous case).
 52: #  Ï_e[r,s]    : standard deviation for noise on m_rs (upper-tri CSR).
 53: #  Ï_common    : single Ï used by the two naÃ¯ve variants.
 54: #
 55: #  noise_type  : one of {"heterogeneous_gaussian", "naive_degree_gaussian",
 56: #                        "naive_edge_count_gaussian"}.
 57: #
 58: #  clip_p      : lower/upper bound substituted for p_rs = 0 or 1.
 59: #  weight_clip : optional upper bound on w to avoid extreme Ïâ0.
 60: ###############################################################################
 61: # sbm/noisy_fit.py
 62: from dataclasses import dataclass
 63: from typing import List, Optional, Callable, Literal, Tuple
 64: import math
 65: import numpy as np
 66: import scipy.sparse as sp
 67: from scipy.sparse import csr_array
 68: from scipy.special import binom
 69: import line_profiler
 70: from sbm.io import SBMFit
 71: from sbm.post_process import (
 72:     naive_clamping,
 73:     constrained_lasso,
 74:     PostProcessFnName,
 75: )
 76: # --------------------------------------------------------------
 77: ### aliasses
 78: # --------------------------------------------------------------
 79: NoiseType = Literal[
 80:     "heterogeneous_gaussian",
 81:     "naive_degree_gaussian",
 82:     "naive_edge_count_gaussian"
 83: ]
 84: # --------------------------------------------------------------
 85: ### Helper functions
 86: # --------------------------------------------------------------
 87: def _upper_tri_csr(rows, cols, data, B):
 88:     """Return symmetric CSR from upper-tri lists."""
 89:     coo = sp.coo_array((data, (rows, cols)), shape=(B, B))
 90:     csr = csr_array(coo)
 91:     return csr + csr.T - sp.diags(csr.diagonal())
 92: def max_binom_quantile(k: int, ps: np.ndarray, alpha: float) -> int:
 93:     """
 94:     Small k (â¤50) â brute-force exact cdf of max{Bin(k,p_s)}.
 95:     Returns the smallest c s.t.   P(max â¤ c) â¥ Î±.
 96:     """
 97:     if not (0 < alpha < 1):
 98:         raise ValueError("alpha must be in (0,1)")
 99:     # pre-compute per-block Binomial pmf for 0..k
100:     pmf = np.array([binom(k, j) * ps**j * (1 - ps)**(k - j)
101:                     for j in range(k + 1)])        # shape (k+1,B)
102:     cdf = pmf.cumsum(axis=0)                       # shape (k+1,B)
103:     # P(max â¤ c) = â_s F_s(c)
104:     prod = np.prod(cdf, axis=1)                    # length k+1
105:     for c in range(k + 1):
106:         if prod[c] >= alpha:
107:             return c
108:     return k  # should never happen if alpha<1
109: def n_possible(k_r: int, k_s: int, same_block: bool) -> int:
110:     if same_block:
111:         return k_r * (k_r - 1) // 2
112:     return k_r * k_s
113: def add_edge_noise(
114:         block_conn: sp.csr_array,
115:         sigma_e: sp.csr_array,
116:         rng: np.random.Generator
117:     ) -> sp.csr_array:
118:     noisy_conn = sp.triu(
119:         block_conn.copy(),
120:         k=0, # include diagonal
121:         format="csr"
122:     )
123:     # add noise to edge-counts (m_rs) upper traingle
124:     rr, cc = noisy_conn.nonzero() # coordinates of the stored upper-tri values
125:     sigma = np.asarray(sigma_e[rr, cc]).ravel() # shape the sigma_e vector
126:     data = np.array(noisy_conn.data, dtype=float)
127:     data += rng.normal(0.0, sigma, size=len(sigma))
128:     return sp.csr_array(
129:         (data, (rr, cc)),
130:         shape=noisy_conn.shape,
131:         dtype=float
132:     )
133: # ---------------------------------------------------------
134: #### Main class
135: # ---------------------------------------------------------
136: @dataclass
137: class Noise:
138:     """Base class for noise added to an SBM fit."""
139:     fit: SBMFit
140:     sigma_n: np.ndarray              # shape (B,)
141:     sigma_e: sp.csr_array            # upper triangle incl. diag
142:     eps: float
143:     delta: float
144:     delta_tail: float                # = 1 - alpha
145:     delta_nlk: int                   # sensitivity used for m_rs
146:     metadata: dict
147:     def sample_sbm_fit(self,
148:                        rng: np.random.Generator,
149:                        post: Optional[Callable[[sp.csr_array], sp.csr_array]] = None,
150:                        ) -> SBMFit:
151:         """
152:         Draw *one* noisy SBM draw.
153:         Returns a **new** `SBMFit` instance ready for `sample_sbm_graph`.
154:         """
155:         raise NotImplementedError("Must be implemented in subclass")
156: @dataclass
157: class HeterogeneousGaussNoise(Noise):
158:     """An `SBMFit` with optimal Gaussian noise already added."""
159:     fit: SBMFit
160:     sigma_n: np.ndarray              # shape (B,)
161:     sigma_e: sp.csr_array            # upper triangle incl. diag
162:     sigma_zero_fun: Callable[[int], float]  # function to compute Ï for zero pairs
163:     eps: float
164:     delta: float
165:     delta_tail: float                # = 1 - alpha
166:     delta_nlk: int                   # sensitivity used for m_rs
167:     S_sum: float                     # Î£_q â(c_q w_q) used in Ï formula
168:     R: float
169:     metadata: dict
170:     # ---------- sampling ---------------------------------------------
171:     def sample_sbm_fit(self, # type: ignore
172:                      rng: np.random.Generator,
173:                      post: Optional[PostProcessFnName] = 'naive',
174:                      ) -> SBMFit:
175:         """
176:         Draw *one* noisy SBM draw, then (optionally) post-process the
177:         noisy counts.
178:         Returns a **new** `SBMFit` instance ready for `sample_sbm_graph`.
179:         """
180:         k_vec = np.array(self.fit.block_sizes, int)
181:         # find the most frequent block size (this will be k)
182:         k_val = int(np.bincount(k_vec).argmax())  # most frequent block size
183:         # 1) add Gaussian noise to non-zero elements --------------------
184:         n_noisy = k_vec + rng.normal(0, self.sigma_n)
185:         noisy_conn = add_edge_noise(
186:             block_conn=self.fit.block_conn,
187:             sigma_e=self.sigma_e,
188:             rng=rng
189:         )
190:         ### post-process the noisy counts ------------------------
191:         if str(post).lower() == 'lasso':
192:             conn, n_noisy = constrained_lasso(
193:                 n_noisy=n_noisy,
194:                 noisy_conn=noisy_conn,  # type: ignore
195:                 sigma_rs=self.sigma_e,
196:                 k_val=k_val,
197:                 sigma_zero_fun=self.sigma_zero_fun,
198:                 rng=rng,
199:                 round_thresh=0.5,  # threshold for rounding
200:                 lam=None,  # Î» in soft-threshold (impute from noisy fit)
201:                 n_possible_fn=n_possible,
202:             )
203:         else:
204:             ### perform simple post-processing:
205:             conn, n_noisy = naive_clamping(
206:                 n_noisy=n_noisy,
207:                 noisy_conn=noisy_conn, # type: ignore
208:                 sigma_e=self.sigma_e,
209:                 k_val=k_val,
210:                 sigma_zero_fun=self.sigma_zero_fun,
211:                 rng=rng,
212:                 round_thresh=0.5,  # threshold for rounding
213:                 n_possible_fn=n_possible,
214:                 )
215:         # 2) re-symmetrise & cast to int -----------------------------
216:         block_sizes = n_noisy.astype(int).tolist()
217:         return SBMFit(
218:             block_sizes=block_sizes,
219:             block_conn=conn,
220:             directed_graph=self.fit.directed_graph,
221:             neg_loglike=float("nan"),          # unknown after noise
222:             metadata={
223:                 **self.fit.metadata,
224:                 "dp_eps": self.eps,
225:                 "dp_delta": self.delta,
226:                 "dp_delta_tail": self.delta_tail,
227:             },
228:         )
229: @dataclass
230: class _HomogGaussNoiseBase(Noise):
231:     """
232:     Base for 'naÃ¯ve' variants with *single* Ï for n_r, single Ï for m_rs.
233:     Stores only two scalars:  sigma_n_scalar, sigma_e_scalar
234:     """
235:     sigma_n_scalar: float      # same Ï for every n_r
236:     sigma_e_scalar: float      # same Ï for every m_rs (non-zero counts)
237:     # ---- helper ----------------------------------------------------
238:     def _draw_noisy_counts(self,
239:                            rng: np.random.Generator,
240:     ) -> tuple[np.ndarray, sp.csr_array]:
241:         k_vec = np.array(self.fit.block_sizes, int)
242:         n_noisy = np.maximum( 1, k_vec + rng.normal(0, self.sigma_n_scalar, size=len(k_vec)))
243:         conn = self.fit.block_conn.copy().astype(float).tocsr()
244:         mask_nz = conn.data != 0          # we only stored non-zeros
245:         conn.data[mask_nz] += rng.normal(
246:             0, self.sigma_e_scalar, size=mask_nz.sum()
247:         )
248:         conn = sp.triu(conn, k=0, format="csr")
249:         conn = conn + conn.T - sp.diags(conn.diagonal())
250:         conn = conn.astype(int).tocsr()
251:         return n_noisy, conn
252:     # ---- public ----------------------------------------------------
253:     def sample_sbm_fit(self,
254:                        rng: np.random.Generator,
255:                        post: Optional[Callable[[sp.csr_array], sp.csr_array]] = None
256:                        ) -> SBMFit:
257:         n_noisy, conn = self._draw_noisy_counts(rng)
258:         if post is not None:
259:             conn = post(conn)
260:         else:
261:             ### perform simple post-processing:
262:             #   round conn and block_sizes to int and ensure
263:             #   no conn-count is larger than the max possible
264:             rr, cc = conn.nonzero()
265:             for r, c in zip(rr, cc):
266:                 n_noisy[r] = np.round(n_noisy[r])
267:                 n_noisy[c] = np.round(n_noisy[c])
268:                 N = n_possible(n_noisy[r], n_noisy[c], same_block=(r == c)) # type: ignore
269:                 conn[r, c] = np.round(conn[r, c]) # type: ignore
270:                 if conn[r, c] > N: # type: ignore
271:                     conn[r, c] = N # type: ignore
272:         return SBMFit(
273:             block_sizes=n_noisy.tolist(),
274:             block_conn=conn,
275:             directed_graph=self.fit.directed_graph,
276:             neg_loglike=float("nan"),
277:             metadata={**self.fit.metadata, **self.metadata},
278:         )
279: @dataclass
280: class NaiveDegreeGaussNoise(_HomogGaussNoiseBase):
281:     """Homogeneous Ï using global Î_deg (Î±-quantile max-degree)."""
282:     pass
283: @dataclass
284: class NaiveEdgeCountGaussNoise(_HomogGaussNoiseBase):
285:     """Homogeneous Ï using global Î_nlk (Î±-quantile single block-change)."""
286:     pass
287: # --------------------------------------------------------------------
288: # 1.  p-matrix and Î_{nlk}
289: # --------------------------------------------------------------------
290: def _prob_matrix_and_sens(
291:     conn: sp.csr_array,
292:     k_vec: np.ndarray,
293:     alpha: float,
294:     clip_p: float
295: ) -> Tuple[sp.csr_array, int]:
296:     """
297:     Convert edge counts â probabilities **p_{rs}** and compute
298:     Î_{nlk} = Î±âquantile of max neighbours in any single block.
299:     """
300:     B = len(k_vec)
301:     p = conn.copy().astype(float).tocoo()
302:     for i, (r, s) in enumerate(zip(p.row, p.col)):
303:         N = n_possible(k_vec[r], k_vec[s], r == s) # type: ignore
304:         p.data[i] = conn[r, s] / N
305:     p = p.tocsr()
306:     delta_nlk = 0
307:     for r in range(B):
308:         ps_row = np.zeros(B)
309:         start, end = p.indptr[r], p.indptr[r + 1]
310:         ps_row[p.indices[start:end]] = p.data[start:end]
311:         delta_nlk = max(delta_nlk,
312:                         max_binom_quantile(k_vec[r], ps_row, alpha))
313:     # Avoid p=0 or 1 in later calculations
314:     p.data[p.data == 0.0] = clip_p
315:     p.data[p.data == 1.0] = 1.0 - clip_p
316:     return p, delta_nlk
317: # --------------------------------------------------------------------
318: # 2.  Weight computation
319: # --------------------------------------------------------------------
320: def _weights_and_S(
321:     p_mat: sp.csr_array,
322:     k_vec: np.ndarray,
323:     delta_nlk: int,
324:     weight_clip: float,
325:     c_n_val: float,
326: ) -> Tuple[np.ndarray, np.ndarray, List[int], List[int], float]:
327:     """
328:     Compute weights w_q for n_r and m_rs, and the sum S = Î£ â(c_q w_q).
329:     Weights are used to compute the noise levels Ï_q so as to minimize
330:     expected likelihood loss
331:     Compute:
332:       * w_n   : vector length B
333:       * w_e   : list for every stored upper-tri cell (row parity)
334:       * idx_e : corresponding *column* indices (for CSR builder)
335:       * S_sum = Î£ sqrt(c_q w_q) used in Ï formula (12)
336:     """
337:     B = len(k_vec)
338:     c_e_val = delta_nlk ** 2
339:     w_n = np.zeros(B)
340:     w_e = []
341:     col_e= []
342:     row_e = []
343:     S_sum = 0.0
344:     for r in range(B):
345:         # ---- diagonal r,r (zero and non-zero alike) ---------------
346:         N_rr = n_possible(k_vec[r], k_vec[r], True)
347:         p_rr = p_mat[r, r]
348:         w_rr = 1.0 / N_rr# (2 * N_rr * p_rr * (1 - p_rr))
349:         w_rr = min(w_rr, weight_clip)
350:         # store sparse diagonal weight
351:         w_e.append(w_rr)
352:         row_e.append(r)
353:         col_e.append(r)
354:         S_sum += math.sqrt(c_e_val * w_rr)
355:         # ---- off-diagonal non-zero pairs r,s (s>r) -------------------------------
356:         for s_ptr in range(p_mat.indptr[r], p_mat.indptr[r + 1]):
357:             s = p_mat.indices[s_ptr]
358:             if s <= r:
359:                 continue
360:             N_rs = n_possible(k_vec[r], k_vec[s], False) # type: ignore
361:             w_rs = 1.0 / N_rs# (2 * N_rs * p_rs * (1 - p_rs))
362:             w_rs = min(w_rs, weight_clip)
363:             # store sparse upper-tri weights
364:             w_e.append(w_rs)
365:             row_e.append(r)
366:             col_e.append(s)
367:             # add to normalization S
368:             S_sum += math.sqrt(c_e_val * w_rs)
369:         # ---- off-diagonal zero-pairs r>s ----------------------------
370:         # off diag
371:         present = set(p_mat.indices[p_mat.indptr[r] : p_mat.indptr[r+1]])
372:         for s in range(r+1, B):
373:             # only add terms from zero pairs upper diagonal pairs
374:             if (s in present) or s<=r:
375:                 continue
376:             N_rs = n_possible(k_vec[r], k_vec[s], False)
377:             S_sum += math.sqrt(c_e_val * (1/N_rs))
378:         # ---- block-size weight w_n[r] -----------------------------
379:         inter = p_mat[[r]].toarray().ravel()
380:         inter[r] = 0.0
381:         ### Old likelihood version
382:         #w_n[r] = (inter / (1 - inter + clip_p)).sum() / k_vec[r] \
383:         #       + ((2 * k_vec[r] - 4)**2)/(2*k_vec[r]*(k_vec[r]-1)) \
384:         #         * (p_rr / (1 - p_rr + clip_p))
385:         # ---- block-size weight w_n[r]  (MSE version)
386:         p_row = p_mat[[r]].toarray().ravel()
387:         p_off = np.delete(p_row, r)
388:         w_n[r]  = k_vec[r] * (p_off ** 2 @ np.delete(k_vec, r))
389:         p_rr    = p_row[r]
390:         if k_vec[r] > 1:
391:             w_n[r] += ((2 * k_vec[r] - 1) ** 2) / (2 * k_vec[r] * (k_vec[r] - 1)) \
392:               * (p_rr ** 2)
393:         if w_n[r] > weight_clip:
394:             w_n[r] = weight_clip
395:         S_sum += math.sqrt(c_n_val * w_n[r])
396:     # backup in case all probs were clipped to zero 
397:     if S_sum <= 0:
398:         print("Warning: S_sum is zero, using small value to avoid division by zero.")
399:         S_sum = 1e-12
400:     return w_n, np.asarray(w_e), row_e, col_e, S_sum
401: # --------------------------------------------------------------------
402: # 3.  Ï computation
403: # --------------------------------------------------------------------
404: def _compute_sigmas(
405:     w_n: np.ndarray,
406:     w_e: np.ndarray,
407:     S_sum: float,
408:     eps: float,
409:     delta: float,
410:     delta_tail: float,
411:     B: int,
412:     c_e_val: float,
413:     col_e: List[int],
414:     row_e: List[int],
415: ) -> Tuple[np.ndarray, sp.csr_array, float]:
416:     """
417:     Return vector Ï_n and sparse CSR Ï_e (upper-tri inc. diag).
418:     Computes the noise levels for the heterogeneous Gaussian mechanism
419:     """
420:     R = eps**2 / (2*math.log(1.25/(delta+delta_tail)))
421:     sigma_n = np.sqrt(1/np.sqrt(w_n*R) * S_sum)
422:     #sigma_e_vals = np.sqrt(c_e_val * w_e) * S_sum / R
423:     sigma_e_vals = np.sqrt(np.sqrt(c_e_val / (w_e*R)) * S_sum)
424:     sigma_e = _upper_tri_csr(row_e, col_e, sigma_e_vals, B)
425:     return sigma_n, sigma_e, R
426: # --------------------------------------------------------------------
427: # 4.  Factory
428: # --------------------------------------------------------------------
429: def create_sbm_noise(
430:     sbm: SBMFit,
431:     eps: float,
432:     delta: float,
433:     alpha: float,
434:     *,
435:     clip_p: float = 1e-12,
436:     weight_clip: float = 1e12,
437:     noise_type: NoiseType = "heterogeneous_gaussian",
438: ) -> "Noise":
439:     """
440:     Construct one of the three Noise objects.
441:     Steps:
442:       (1) convert countsâprobabilities and compute Î_{nlk}
443:       (2) weights  w_q  and  S = Î£â(c_q w_q)
444:       (3) Ï_q  via eq. (12)
445:       (4) package into chosen Noise subclass
446:     """
447:     if sbm.directed_graph:
448:         raise NotImplementedError("undirected only")
449:     k_vec = np.asarray(sbm.block_sizes, int)
450:     B = len(k_vec)
451:     # 1) probabilities & sensitivity Î_nlk --------------------------
452:     p_mat, delta_nlk = _prob_matrix_and_sens(
453:         sbm.block_conn, k_vec, alpha, clip_p
454:     )
455:     delta_tail = 1.0 - alpha
456:     c_e_val = delta_nlk ** 2
457:     # 2) weights & S -------------------------------------------------
458:     w_n, w_e, row_e, col_e, S_sum = _weights_and_S(
459:         p_mat, k_vec, delta_nlk, weight_clip, c_n_val=1.0
460:     )
461:     # 3) Ïâs  --------------------------------------------------------
462:     sigma_n, sigma_e, R = _compute_sigmas(
463:         w_n=w_n, w_e=w_e, S_sum=S_sum,
464:         eps=eps, delta=delta, delta_tail=delta_tail,
465:         B=B, c_e_val=c_e_val, col_e=col_e, row_e=row_e
466:     )
467:     # -- select variant ---------------------------------------------
468:     if noise_type == "heterogeneous_gaussian":
469:         return HeterogeneousGaussNoise(
470:             fit=sbm,
471:             sigma_n=sigma_n,
472:             sigma_e=sigma_e,
473:             sigma_zero_fun=lambda N_rs: np.sqrt(np.sqrt(c_e_val / (N_rs*R)) * S_sum),
474:             eps=eps,
475:             delta=delta,
476:             delta_tail=delta_tail,
477:             delta_nlk=delta_nlk,
478:             S_sum=S_sum,
479:             R=R,
480:             metadata={"noise": "heterogeneous_gaussian",
481:                       "alpha": alpha,
482:                       "Delta_nlk": delta_nlk,
483:                       "delta_tail": delta_tail,
484:                       "eps": eps,
485:                       **sbm.metadata,
486:                       },
487:         )
488:     # ----- homogeneous variants share one Ï ------------------------
489:     total_c = B*1.0 + (B*(B+1)//2) * c_e_val   # all cells!
490:     sigma_common = math.sqrt(total_c /
491:                              (eps**2 / (2*math.log(1.25/(delta+delta_tail)))))
492:     if noise_type == "naive_edge_count_gaussian":
493:         return NaiveEdgeCountGaussNoise(
494:             fit=sbm,
495:             sigma_n_scalar=sigma_common,
496:             sigma_e_scalar=sigma_common,
497:             sigma_n=np.full(B, sigma_common),
498:             sigma_e=sp.csr_array((B, B), dtype=float),
499:             eps=eps,
500:             delta=delta,
501:             delta_tail=delta_tail,
502:             delta_nlk=delta_nlk,
503:             metadata={"noise": "naive_edge_count_gaussian",
504:                       "sigma_common": sigma_common, **sbm.metadata},
505:         )
506:     # compute 
507:     if noise_type == "naive_degree_gaussian":
508:         return NaiveDegreeGaussNoise(
509:             fit=sbm,
510:             sigma_n_scalar=sigma_common,
511:             sigma_e_scalar=sigma_common,
512:             sigma_n=np.full(B, sigma_common),
513:             sigma_e=sp.csr_array((B, B), dtype=float),
514:             eps=eps,
515:             delta=delta,
516:             delta_tail=0.,
517:             delta_nlk=0,
518:             metadata={"noise": "naive_degree_gaussian",
519:                       "sigma_common": sigma_common,
520:                       **sbm.metadata},
521:         )
522:     raise ValueError(f"unknown noise_type {noise_type!r}")

================
File: src/sbm/post_process.py
================
  1: """
  2: Functions and classes for post-processing SBM fits to create noisy SBM fits
  3: """
  4: # --------------------------------------------------------------
  5: from typing import Callable, Tuple, Literal, Optional
  6: import numpy as np
  7: import scipy.sparse as sp
  8: from scipy.stats import norm
  9: from scipy.sparse import csr_array
 10: from typing import Callable
 11: # ------------------------------------------------------------------
 12: # Aliases
 13: PostProcessFnName = Literal['naive', 'lasso']
 14: # ------------------------------------------------------------------
 15: def naive_clamping(
 16:     n_noisy: np.ndarray,
 17:     noisy_conn: sp.csr_array,
 18:     sigma_e: sp.csr_array,
 19:     k_val: int,
 20:     sigma_zero_fun: Callable[[int], float],
 21:     rng: np.random.Generator,
 22:     *,
 23:     round_thresh: float = 0.5,
 24:     n_possible_fn: Callable[[int, int, bool], int],
 25: )-> Tuple[csr_array, np.ndarray]: 
 26:     rr, cc = noisy_conn.nonzero()
 27:     noise = rng.normal(loc=0, scale=sigma_e[rr, cc]) # type: ignore
 28:     noisy_conn.data = np.maximum(0., noisy_conn.data + noise).astype(int)
 29:     ### perform simple post-processing:
 30:     #   We have to release k anyway, so we set all block sizes to k_val.
 31:     #   This allows us to put strict bounds on the connectivity matrix.
 32:     for r, c in zip(rr, cc):
 33:         n_noisy[r] = k_val # type: ignore
 34:         n_noisy[c] = k_val # type: ignore
 35:         # ensure no negative counts
 36:         if noisy_conn[r, c] < 0: # type: ignore
 37:             noisy_conn[r, c] = 0 # type: ignore
 38:             continue
 39:         # ensure no noisy_conn-count is larger than the max possible
 40:         N = n_possible_fn(n_noisy[r], n_noisy[c], same_block=(r == c)) # type: ignore
 41:         if noisy_conn[r, c] > N: # type: ignore
 42:             noisy_conn[r, c] = N # type: ignore
 43:             continue
 44:         # round conn to int
 45:         noisy_conn[r, c] = np.round(noisy_conn[r, c]) # type: ignore
 46:     ### add noise to zero pairs
 47:     noisy_conn_lil = noisy_conn.tolil()
 48:     B = len(n_noisy)
 49:     total_zero_pair_edges = 0
 50:     for r in range(B):
 51:         present = set(noisy_conn_lil.rows[r])
 52:         for s in range(r, B):
 53:             # only add noise to zero pairs
 54:             if s in present:
 55:                 continue
 56:             N_rs = n_possible_fn(k_val, k_val, r == s)  # type: ignore
 57:             z = rng.normal(0, sigma_zero_fun(N_rs))  # noise for zero pair (r,s)
 58:             if z < round_thresh:  # round_thresh
 59:                 continue  # remain zero
 60:             m_rs = int(round(z))  # symmetric, non-negative
 61:             m_rs = min(m_rs, N_rs)
 62:             if m_rs > 0:
 63:                 total_zero_pair_edges += m_rs
 64:                 noisy_conn_lil[r, s] = m_rs # type: ignore
 65:                 if r != s:
 66:                     noisy_conn_lil[s, r] = m_rs # type: ignore
 67:     print(f"[NAIVE]    Added {total_zero_pair_edges} edges to zero pairs.") 
 68:     # ---------- finish   ------------------------------------------
 69:     conn_csr = csr_array(noisy_conn_lil, dtype=int)
 70:     conn_sym = sp.triu(conn_csr, k=0, format='csr')
 71:     conn_sym = conn_sym + conn_sym.T - sp.diags(conn_sym.diagonal())
 72:     conn_sym.data = conn_sym.data.astype(int)
 73:     noisy_conn = csr_array(conn_sym, dtype=int)
 74:     return noisy_conn, n_noisy
 75: # ------------------------------------------------------------------
 76: # utility functions for Lasso post-processing
 77: def lambda_for_activation(rho: float) -> float:
 78:     """Î» so that exactly rho of zero cells survive the threshold."""
 79:     lam = norm.isf(rho / 2.0) # two-sided tail
 80:     return float(lam)
 81: # ------------------------------------------------------------------
 82: def constrained_lasso(
 83:     n_noisy: np.ndarray,
 84:     noisy_conn: sp.csr_array,
 85:     sigma_rs: sp.csr_array,
 86:     k_val: int,
 87:     sigma_zero_fun: Callable[[int], float],
 88:     rng: np.random.Generator,
 89:     *,
 90:     round_thresh: float = 0.5,
 91:     lam: Optional[float] = None,
 92:     n_possible_fn: Callable[[int, int, bool], int],
 93: ) -> Tuple[sp.csr_array, np.ndarray]:
 94:     """
 95:     L1-constrained projection row-by-row.
 96:     Parameters
 97:     ----------
 98:     conn_ut        : noisy counts, CSR, **upper triangle only**.
 99:     sigma_rs       : matching Ï_rs for the same nnz pattern.
100:     k_val          : released block size k (all blocks are k or k+1).
101:     sigma_zero_fun : N_rs â¦ Ï for a zero entry (uses new weight scheme).
102:     rng            : np.random.Generator.
103:     round_thresh   : magnitude that rounds to 1 (default .5).
104:     lam            : Î» in soft-threshold  x â sign(x)Â·max(|x|âÎ»ÏÂ²,0).
105:     n_possible_fn  : callable (k_r,k_s,r==s) â N_rs.
106:     """
107:     B = noisy_conn.shape[0]
108:     noisy_conn_lil = noisy_conn.tolil(copy=True)          # efficient insertion
109:     sigma = sigma_rs.tolil(copy=False)
110:     if lam is None:
111:         # compute lambda based on desired proportion of active block pairs
112:         # assume that the average block connects to 5 others
113:         rho = .1 #5 * B / (B * (B - 1)/2)  
114:         lam = lambda_for_activation(rho)  # default Î» for 5% of zero pairs
115:     total_added = 0
116:     for r in range(B):
117:         ### set block sizes to k_val
118:         #   We have to release k anyway, so we set all block sizes to k_val.
119:         #   This allows us to put strict bounds on the connectivity matrix.
120:         n_noisy[r] = k_val
121:         # check where non-zero counts
122:         present = {c: i for i, c in enumerate(noisy_conn_lil.rows[r])}
123:         # ---------- a) process existing nnz ------------------------
124:         for idx, c in enumerate(noisy_conn_lil.rows[r]):
125:             # account for upper-triangle only
126:             if c < r:
127:                 continue
128:             val   = noisy_conn_lil.data[r][idx]
129:             sig   = float(sigma[r, c]) # type: ignore
130:             # lasso regression with soft thresholding and clamping
131:             N_rs  = n_possible_fn(k_val, k_val, r == c)
132:             lasso_shrink = np.sign(val) * max(abs(val) - lam * sig, 0)
133:             new   = min(max(round(lasso_shrink), 0), N_rs)
134:             noisy_conn_lil.data[r][idx] = int(new)
135:         # ---------- b) add noise to zero cells (upper-tri only) ----
136:         for s in range(r, B):
137:             if s in present or s < r:                 # already processed nnz
138:                 continue
139:             N_rs = n_possible_fn(k_val, k_val, r == s)
140:             sig0 = sigma_zero_fun(N_rs)
141:             z = rng.normal(0.0, sig0)
142:             if abs(z) < round_thresh:
143:                 continue
144:             # lasso regression with soft thresholding
145:             lasso_shrink = np.sign(z) * max(abs(z) - lam * sig0, 0)
146:             m = min(round(lasso_shrink), N_rs)
147:             if m <=0:
148:                 continue
149:             noisy_conn_lil[r, s] = m
150:             if r != s:
151:                 noisy_conn_lil[s, r] = m
152:             total_added += m
153:     # ---------- finish   ------------------------------------------
154:     conn_csr = csr_array(noisy_conn_lil, dtype=int)
155:     conn_sym = sp.triu(conn_csr, k=0, format='csr')
156:     conn_sym = conn_sym + conn_sym.T - sp.diags(conn_sym.diagonal())
157:     conn_sym.data = conn_sym.data.astype(int)
158:     print(f"[LASSO]    Added {total_added} edges to previously-zero pairs")
159:     return conn_sym, n_noisy

================
File: src/tests/test_noise.py
================
  1: # ---------------------------------------------------------------------
  2: # tests/test_dp_noise.py
  3: # ---------------------------------------------------------------------
  4: import numpy as np
  5: import scipy.sparse as sp
  6: import pytest
  7: from sbm.io import SBMFit
  8: from sbm.noisy_fit import (
  9:     create_sbm_noise,
 10:     HeterogeneousGaussNoise,
 11:     NaiveDegreeGaussNoise,
 12:     NaiveEdgeCountGaussNoise,
 13: )
 14: from sbm.sampling import sample_sbm_graph_from_fit
 15: # ---------------------------------------------------------------------
 16: # helpers
 17: # ---------------------------------------------------------------------
 18: def _make_sbm(block_sizes, P):
 19:     """
 20:     Create an SBMFit with integer edge counts according to prob-matrix P.
 21:     P must be square len(block_sizes) Ã len(block_sizes), symmetric.
 22:     """
 23:     k_vec = np.array(block_sizes, int)
 24:     B = len(k_vec)
 25:     data, rows, cols = [], [], []
 26:     for r in range(B):
 27:         for s in range(r, B):
 28:             N = k_vec[r] * k_vec[s] if r != s else k_vec[r] * (k_vec[r] - 1) // 2
 29:             m = int(round(P[r, s] * N))
 30:             if m > 0:
 31:                 rows.append(r); cols.append(s); data.append(m)
 32:     M = sp.csr_array((data, (rows, cols)), shape=(B, B))
 33:     M = M + M.T - sp.diags(M.diagonal())
 34:     return SBMFit(
 35:         block_sizes=list(block_sizes),
 36:         block_conn=M,
 37:         directed_graph=False,
 38:         neg_loglike=-1.0,
 39:         metadata={},
 40:     )
 41: def _extract_sigma_e(noise_obj):
 42:     """Return 1-D array of Ï_e values stored (heterogeneous variant)."""
 43:     if isinstance(noise_obj, HeterogeneousGaussNoise):
 44:         return noise_obj.sigma_e.data
 45:     raise ValueError
 46: # ---------------------------------------------------------------------
 47: # parametrisation -----------------------------------------------------
 48: EPS, DELTA, ALPHA = 1.0, 1e-6, 0.999
 49: RNG = np.random.default_rng(0)
 50: # ---------------------------------------------------------------------
 51: # 1. factory returns correct subclass ---------------------------------
 52: @pytest.mark.parametrize("ntype,cls", [
 53:     ("heterogeneous_gaussian",       HeterogeneousGaussNoise),
 54:     ("naive_degree_gaussian",  NaiveDegreeGaussNoise),
 55:     ("naive_edge_count_gaussian", NaiveEdgeCountGaussNoise),
 56: ])
 57: def test_factory_returns(ntype, cls):
 58:     sbm = _make_sbm([3, 3], np.zeros((2, 2)))
 59:     nz = create_sbm_noise(sbm, EPS, DELTA, ALPHA, noise_type=ntype)
 60:     assert isinstance(nz, cls)
 61: # ---------------------------------------------------------------------
 62: # 2. hetero Ï_e differ when p differs ---------------------------------
 63: def test_heterogeneous_noise_varies():
 64:     P = np.array([[0.2, 0.9, 0.05],
 65:                   [0.9, 0.2, 0.05],
 66:                   [0.05,0.05, 0.01]])
 67:     sbm = _make_sbm([3, 3, 3], P)
 68:     oz  = create_sbm_noise(sbm, EPS, DELTA, ALPHA, noise_type="heterogeneous_gaussian")
 69:     sig = _extract_sigma_e(oz)
 70:     assert len(np.unique(sig)) > 1, "Ï_e should vary for different p_rs"
 71: # ---------------------------------------------------------------------
 72: # 3. hetero Ï_e identical when all p equal ----------------------------
 73: def test_heterogeneous_noise_equal():
 74:     P = np.full((3, 3), 0.3)
 75:     sbm = _make_sbm([3, 3, 3], P)
 76:     oz  = create_sbm_noise(sbm, EPS, DELTA, ALPHA,
 77:                            noise_type="heterogeneous_gaussian")
 78:     sig = _extract_sigma_e(oz)
 79:     print(f'sigma_e: {sig}')
 80:     # diagonal Ïâs should all be identical.
 81:     # Account for the fact that only upper-tri is stored.
 82:     assert np.allclose(diag, diag[0])
 83:     # â¦ off-diagonals identical to each other â¦
 84:     off  = sig[[1, 2, 5]]
 85:     assert np.allclose(off, off[0])
 86:     # â¦ but OFF â  DIAG because N_rr â  N_rs
 87:     assert not np.allclose(diag[0], off[0])
 88: # ---------------------------------------------------------------------
 89: # 4. naive Ï scalars are equal for every coord ------------------------
 90: @pytest.mark.parametrize("ntype", ["naive_degree_gaussian",
 91:                                    "naive_edge_count_gaussian"])
 92: def test_naive_sigma_equal(ntype):
 93:     P = np.array([[0.4, 0.4],
 94:                   [0.4, 0.4]])
 95:     sbm = _make_sbm([4, 4], P)
 96:     nz  = create_sbm_noise(sbm, EPS, DELTA, ALPHA, noise_type=ntype)
 97:     assert np.all(nz.sigma_n == nz.sigma_n[0])
 98:     assert nz.sigma_n_scalar == nz.sigma_e_scalar # type: ignore
 99: # ---------------------------------------------------------------------
100: # 5. zero & one probabilities handled (no inf / NaN) ------------------
101: @pytest.mark.parametrize("pdiag,poff", [(0.0, 0.0), (1.0, 0.0),
102:                                         (0.0, 1.0), (1.0, 1.0)])
103: def test_zero_one_probabilities(pdiag, poff):
104:     P = np.array([[pdiag, poff],
105:                   [poff,  pdiag]])
106:     sbm = _make_sbm([3, 3], P)
107:     nz  = create_sbm_noise(sbm, EPS, DELTA, ALPHA,
108:                            noise_type="heterogeneous_gaussian")
109:     assert not np.isnan(nz.sigma_n).any(), \
110:         f'sigma_n should not contain NaN, got {nz.sigma_n}'
111:     sig = _extract_sigma_e(nz)
112:     assert not np.isnan(sig).any() and not np.isinf(sig).any(),\
113:         f'sigma_e should not contain NaN or inf, got {sig}'
114: # ---------------------------------------------------------------------
115: # 6. big blocks memory usage (no excessive RAM) -----------------------
116: def test_big_blocks_memory():
117:     B = 300
118:     k = 3
119:     sizes = [k] * B
120:     P = np.full((B, B), 0.1)
121:     np.fill_diagonal(P, 0.2)
122:     sbm = _make_sbm(sizes, P)          # builds sparse counts
123:     nz = create_sbm_noise(sbm, 1.0, 1e-6, 0.999,
124:                           noise_type="heterogeneous_gaussian"
125:                           )
126:     # should finish < 1 s and < 200 MB RAM
127: # ---------------------------------------------------------------------
128: # 7. sampling integrity (no counts exceed max possible) ---------------
129: def test_sample_integrity():
130:     P = np.array([[0.8, 0.3],
131:                   [0.3, 0.05]])
132:     sbm   = _make_sbm([10, 20], P)
133:     noise = create_sbm_noise(sbm, EPS, DELTA, ALPHA,
134:                              noise_type="heterogeneous_gaussian")
135:     sbm_noisy = noise.sample_sbm_fit(RNG)
136:     # check sizes positive
137:     assert min(sbm_noisy.block_sizes) >= 1
138:     # check counts â¤ possible
139:     k = sbm_noisy.block_sizes
140:     conn = sbm_noisy.block_conn
141:     rr, cc = conn.nonzero()
142:     for r, c in zip(rr, cc):
143:         N = k[r] * k[c] if r != c else k[r] * (k[r]-1) // 2
144:         assert conn[r, c] <= N
145:     # can we sample a surrogate graph?
146:     g = sample_sbm_graph_from_fit(sbm_noisy, RNG)
147:     assert g.adjacency.shape[0] == sum(k)
148:     # undirected check
149:     assert (g.adjacency != g.adjacency.T).nnz == 0

================
File: src/tests/test_post_processing.py
================
  1: """
  2: Unitâtests for sbm.post_process.constrained_lasso
  3: ------------------------------------------------
  4: The tests focus exclusively on the *postâprocessing* step and therefore
  5: construct tiny synthetic inputs instead of going through the full
  6: `HeterogeneousGaussNoise.sample_sbm_fit` pipeline.
  7: The invariants we check are:
  8:   1. No negative edge counts are returned.
  9:   2. All counts are *integers* and *symmetric* (upperâtriangle mirrored).
 10:   3. Every count is <= the maximum possible edges
 11:      N_rs = k_r*k_s for râ s,  k_r*(k_râ1)/2 for r=s,  where every k_r == k_val.
 12:   4. The routine overwrites all released block sizes with `k_val`.
 13: Two deterministic cornerâcase tests are followed by a stochastic
 14: property test that runs 50 random scenarios; this should still complete
 15: in well under 100â¯ms.
 16: """
 17: import numpy as np
 18: import scipy.sparse as sp
 19: import pytest
 20: # ---------------------------------------------------------------------
 21: # system under test
 22: # ---------------------------------------------------------------------
 23: from sbm.post_process import constrained_lasso
 24: from sbm.noisy_fit import n_possible  # helper already used by the library
 25: # ---------------------------------------------------------------------
 26: # helpers
 27: # ---------------------------------------------------------------------
 28: def _csr_symmetric_from_dense(mat: np.ndarray) -> sp.csr_array:
 29:     """Return *exactly* the upperâtriangle incl. diagonal as CSR."""
 30:     r, c = np.triu_indices(mat.shape[0])
 31:     data = mat[r, c]
 32:     nz_mask = data != 0
 33:     return sp.csr_array((data[nz_mask], (r[nz_mask], c[nz_mask])), shape=mat.shape)
 34: def _make_sigma_rs(pattern: sp.csr_array, *, sigma: float = 1.0) -> sp.csr_array:
 35:     """Return a symmetric Ï matrix that shares *pattern*'s sparsity."""
 36:     return sp.csr_array((np.full_like(pattern.data, sigma, dtype=float), pattern.indices, pattern.indptr), shape=pattern.shape)
 37: RNG = np.random.default_rng(0)
 38: SIGMA_ZERO = lambda N: 1.0  # simple constant Ï for zero pairs
 39: # ---------------------------------------------------------------------
 40: # 1. deterministic cornerâcases
 41: # ---------------------------------------------------------------------
 42: def test_negative_and_too_large_values_are_clamped():
 43:     """Negative counts become zero; overly large counts are capped at N_rs."""
 44:     k_val = 3
 45:     B = 2
 46:     # construct noisy_conn with impossible values
 47:     dense = np.array([
 48:         [ -2, 10],   # â2 on diagonal 0, 10 offâdiag
 49:         [  0,  5]    # 5 on diag 1 (will be ignored, only upperâtri processed)
 50:     ], dtype=float)
 51:     noisy_conn = _csr_symmetric_from_dense(dense)
 52:     sigma_rs   = _make_sigma_rs(noisy_conn, sigma=0.5)  # arbitrary Ï
 53:     n_noisy    = np.array([k_val, k_val]) + 1  # wrong on purpose
 54:     conn_out, n_out = constrained_lasso(
 55:         n_noisy=n_noisy,
 56:         noisy_conn=noisy_conn,
 57:         sigma_rs=sigma_rs,
 58:         k_val=k_val,
 59:         sigma_zero_fun=SIGMA_ZERO,
 60:         rng=RNG,
 61:         lam=1.0,
 62:         n_possible_fn=n_possible,
 63:     )
 64:     conn_dense = conn_out.toarray()
 65:     # invariants ------------------------------------------------------
 66:     assert (conn_dense >= 0).all()
 67:     assert np.issubdtype(conn_dense.dtype, np.integer)
 68:     # diag 0: max possible = 3*2/2 = 3 ; offâdiag: 3*3 = 9
 69:     assert conn_dense[0, 0] <= 3
 70:     assert conn_dense[0, 1] <= 9
 71:     # symmetry
 72:     assert conn_dense[0, 1] == conn_dense[1, 0]
 73:     # block sizes all set to k_val
 74:     assert (n_out == k_val).all()
 75: def test_zero_matrix_remains_valid():
 76:     """Allâzero input should stay zero (aside from possible added edges)."""
 77:     k_val = 4
 78:     B = 3
 79:     noisy_conn = sp.csr_array((B, B), dtype=float)
 80:     sigma_rs   = sp.csr_array((B, B), dtype=float)
 81:     n_noisy    = np.ones(B, dtype=int) * k_val
 82:     conn_out, _ = constrained_lasso(
 83:         n_noisy=n_noisy,
 84:         noisy_conn=noisy_conn,
 85:         sigma_rs=sigma_rs,
 86:         k_val=k_val,
 87:         sigma_zero_fun=SIGMA_ZERO,
 88:         rng=RNG,
 89:         lam=0.0,          # turn off shrinkage so only zeroâpair addition matters
 90:         round_thresh=10**10,  # large threshold â keep zeros
 91:         n_possible_fn=n_possible,
 92:     )
 93:     print(noisy_conn.toarray())
 94:     print(conn_out.toarray())
 95:     assert conn_out.nnz == 0, "No edges should be added when threshold is huge"
 96:     assert conn_out.shape == (B, B)
 97: # ---------------------------------------------------------------------
 98: # 2. stochastic property test
 99: # ---------------------------------------------------------------------
100: @pytest.mark.parametrize("seed", range(50))
101: def test_randomised_invariants(seed: int):
102:     """For many random inputs the core invariants must always hold."""
103:     rng = np.random.default_rng(seed)
104:     B      = rng.integers(2, 6)            # 2Â â¤Â BÂ â¤Â 5
105:     k_val  = int(rng.integers(2, 6))       # 2Â â¤Â kÂ â¤Â 5
106:     # generate random noisy counts in [â5, 2*N_rs]
107:     dense  = np.zeros((B, B), dtype=float)
108:     for r in range(B):
109:         for s in range(r, B):
110:             N_rs = n_possible(k_val, k_val, r == s)
111:             dense[r, s] = rng.integers(-5, 2*N_rs + 1)
112:     noisy_conn = _csr_symmetric_from_dense(dense)
113:     sigma_rs   = _make_sigma_rs(noisy_conn, sigma=1.0)
114:     n_noisy    = rng.integers(1, k_val + 3, size=B)  # arbitrary wrong values
115:     conn_out, n_out = constrained_lasso(
116:         n_noisy=n_noisy,
117:         noisy_conn=noisy_conn,
118:         sigma_rs=sigma_rs,
119:         k_val=k_val,
120:         sigma_zero_fun=SIGMA_ZERO,
121:         rng=rng,
122:         lam=1.0,
123:         n_possible_fn=n_possible,
124:     )
125:     # ----- checks ----------------------------------------------------
126:     conn_dense = conn_out.toarray()
127:     assert (conn_dense >= 0).all(), "negative counts returned"
128:     assert np.issubdtype(conn_dense.dtype, np.integer), "counts not integer"
129:     assert np.allclose(conn_dense, conn_dense.T), "matrix not symmetric"
130:     for r in range(B):
131:         for s in range(r, B):
132:             N_rs = n_possible(k_val, k_val, r == s)
133:             assert conn_dense[r, s] <= N_rs, "count exceeds N_rs"
134:     # every block size released as k
135:     assert (n_out == k_val).all()

================
File: .repomix/bundles.json
================
1: {
2:   "bundles": {}
3: }

================
File: notebooks/convergence_figures_25-06-2025.ipynb
================
  1: {
  2:  "cells": [
  3:   {
  4:    "cell_type": "markdown",
  5:    "id": "af425169",
  6:    "metadata": {},
  7:    "source": [
  8:     "# Notebook for visualizing the convergence of the MCMC algorithm"
  9:    ]
 10:   },
 11:   {
 12:    "cell_type": "code",
 13:    "execution_count": null,
 14:    "id": "828ee0d9",
 15:    "metadata": {},
 16:    "outputs": [],
 17:    "source": [
 18:     "import numpy as np\n",
 19:     "import pandas as pd\n",
 20:     "import matplotlib.pyplot as plt"
 21:    ]
 22:   },
 23:   {
 24:    "cell_type": "code",
 25:    "execution_count": 69,
 26:    "id": "9f091b92",
 27:    "metadata": {},
 28:    "outputs": [],
 29:    "source": [
 30:     "import sys\n",
 31:     "from pathlib import Path\n",
 32:     "logs_path = Path(\"/Users/lmmi/anon_sbm/logs\")\n",
 33:     "\n",
 34:     "# find all log files in the logs directory\n",
 35:     "log_files = list(logs_path.glob(\"*.csv\"))"
 36:    ]
 37:   },
 38:   {
 39:    "cell_type": "code",
 40:    "execution_count": 70,
 41:    "id": "e8adb1d1",
 42:    "metadata": {},
 43:    "outputs": [],
 44:    "source": [
 45:     "def determine_name(file_name, dataset_names):\n",
 46:     "    \"\"\"\n",
 47:     "    Determine the name of the dataset based on the file name.\n",
 48:     "    \"\"\"\n",
 49:     "    for name in dataset_names:\n",
 50:     "        if name in file_name:\n",
 51:     "            return name\n",
 52:     "    return \"unknown\"\n",
 53:     "dataset_names = [ \"congress_twitter\", \"caltech_fb\", \"eu_email\", ]"
 54:    ]
 55:   },
 56:   {
 57:    "cell_type": "code",
 58:    "execution_count": 71,
 59:    "id": "23eabf12",
 60:    "metadata": {},
 61:    "outputs": [],
 62:    "source": [
 63:     "df_list = []\n",
 64:     "\n",
 65:     "for log_file in log_files:\n",
 66:     "    df = pd.read_csv(log_file)\n",
 67:     "    df[\"name\"] = determine_name(log_file.name, dataset_names)\n",
 68:     "\n",
 69:     "    df_list.append(df)\n",
 70:     "\n",
 71:     "df = pd.concat(df_list, ignore_index=True)"
 72:    ]
 73:   },
 74:   {
 75:    "cell_type": "code",
 76:    "execution_count": 72,
 77:    "id": "afc3941c",
 78:    "metadata": {},
 79:    "outputs": [
 80:     {
 81:      "name": "stderr",
 82:      "output_type": "stream",
 83:      "text": [
 84:       "/var/folders/y6/j9fbqcvx6lb5l99614n30y4c0000gn/T/ipykernel_88748/2982452800.py:32: UserWarning: FigureCanvasAgg is non-interactive, and thus cannot be shown\n",
 85:       "  fig.show()\n"
 86:      ]
 87:     },
 88:     {
 89:      "data": {
 90:       "image/png": "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5IGuqKgISUlJGDduHACgadOmcHJyQlJSEvr06QMAuHLlCm7duqXQq0dERERERGRMogt0urh16xYyMzNx69YtFBYWIiUlBQBQq1YtuLu7Y8eOHUhPT0fLli3h6uqKxMRELFiwAFOmTJFfY/To0fjyyy8xdepUDB8+HPv378fmzZuxa9cueZ1JkyZhyJAhaNasGVq0aIHPP/8cubm5GDZsGADA09MT0dHRmDRpEipWrAgPDw+MHz8erVq1UrvCJRERERERkaGsOtDNnj0ba9eulT9+6aWXAAAHDhxA+/bt4eTkhBUrVuDdd9+FIAioVasW/u///g8jRoyQnxMSEoJdu3bh3XffxbJly1ClShV88803iIqKktd54403cO/ePcyePRtpaWkICwvDnj17FBZK+eyzzyCVStGnTx/k5eUhKioKsbGxZngViIiIiIjIXoluDp094xw6IiIiIiLShc1vW0BERERERGSrGOiIiIiIiIisFAMdERERERGRlWKgIyIiIiIislIMdERERERERFaKgY6IiIiIiMhKMdARERERERFZKQY6IiIiIiIiK8VAR0REREREZKUY6IiIiIiIiKwUAx0REREREZGVYqAjIiIiIiKyUgx0REREREREVoqBjoiIiIiIyEox0BEREREREVkpBjoiIiIiIiIrxUBHRERERERkpRjoiIiIiIiIrBQDHRERERERkZVioCMiIiIiIrJSDHRERERERERWioGOiIiIiIjISjHQERERERERWSkGOiIiIiIiIivFQEdERERERGSlGOiIiIiIiIisFAMdERERERGRlWKgIyIiIiIislIMdERERERERFaKgY6IiIiIiMhKMdARERERERFZKUdtKn344Yd6XVwikWDWrFl6nUtERERERESaSQRBEMqqJJUqd+RJJBL5n0teQnZcEARIJBIUFhYao512IScnB56ensjOzoaHh4elm0NERERERCKnVQ/dgQMHlI59+umn2LdvHwYNGoQ2bdrA398f6enpOHToEL7//ntERUVh0qRJRm8wERERERERFdOqh660b775BpMmTUJycjIaNGigVH7u3Dm0bt0ay5Ytw/Dhw43SUHvAHjoiIiIiItKFXoGuUaNGaNWqFb766iu1dUaMGIE///wT586dM6iB9oSBjoiIiIiIdKHXKpdXr15FpUqVNNapVKkS/vnnH70aRURERERERGXTK9D5+vril19+gbrOvaKiIvzyyy/w8fExqHFERERERESknl6B7s0338TZs2fx2muv4cyZMwplKSkpeO2113D+/HkMHDjQKI0kIiIiIiIiZXrNoXv27Blee+01JCUlQSKRoHz58vD19cW9e/eQm5sLQRAQGRmJ7du3w9XV1RTttkmcQ0dERERERLrQq4fO1dUV+/btw7fffot27drB2dkZt27dgrOzM9q3b49vv/0We/fuZZgjIiIiIiIyIb166Mg02ENHRERERES60KuHjoiIiIiIiCzP0ZCTb9y4gfXr1yMlJQU5OTnw8PBAWFgYBg4ciOrVqxupiURERERERKSK3kMuly1bhqlTp6KgoEBp+wInJycsWbIE77zzjlEaaS845JKIiIiIiHSh15DLnTt34t1334Wnpyfmz5+PI0eO4Pr160hOTsaCBQvg6emJSZMmYdeuXcZuLxEREREREf1Lrx66jh074uzZs0hJSUGVKlWUym/fvo2XXnoJTZo0QVJSklEaag/YQ0dERERERLrQq4fu1KlTeOONN1SGOQAIDg5Gv379cPLkSYMaR0REREREROrpFejy8/NRvnx5jXXc3d2Rn5+vV6OIiIiIiIiobHoFujp16mDHjh0oKChQWV5QUICdO3eiTp06BjWOiIiIiIiI1NMr0A0ePBhXrlxBVFSU0rDKEydOoFu3brhy5QqGDBlilEYSERERERGRMr0WRSksLESfPn2wfft2SCQSlCtXDn5+fsjIyMCTJ08gCAL+85//4Mcff4RUyr3LtcVFUYiIiIiISBd6pS0HBwds27YN8fHxaN++PZydnXHr1i04OzujQ4cOWLt2LX766SeGOSIiIiIiIhPSe2NxMj720BERERERkS7YhUZERERERGSlHA05+caNG1i/fj1SUlKQk5MDDw8PhIWFYeDAgahevbqRmkhERERERESq6D3kctmyZZg6dSoKCgpQ+hJOTk5YsmQJ3nnnHaM00l5wyCUREREREelCryGXO3fuxLvvvgtPT0/Mnz8fR44cwfXr15GcnIwFCxbA09MTkyZNwq5du4zdXiIiIiIiIvqXXj10HTt2xNmzZ5GSkoIqVaoold++fRsvvfQSmjRpgqSkJKM01B6wh46IiIiIiHShVw/dqVOn8MYbb6gMcwAQHByMfv36KW06TkRERERERMaj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",
 91:       "text/plain": [
 92:        "<Figure size 1000x600 with 1 Axes>"
 93:       ]
 94:      },
 95:      "metadata": {},
 96:      "output_type": "display_data"
 97:     }
 98:    ],
 99:    "source": [
100:     "marker_styles = {\n",
101:     "    \"congress_twitter\": \"o\",\n",
102:     "    \"caltech_fb\": \"s\",\n",
103:     "    \"eu_email\": \"D\",\n",
104:     "}\n",
105:     "colors = {\n",
106:     "    \"congress_twitter\": \"teal\",\n",
107:     "    \"caltech_fb\": \"salmon\",\n",
108:     "    \"eu_email\": \"black\",\n",
109:     "}\n",
110:     "\n",
111:     "\n",
112:     "fig, ax = plt.subplots(figsize=(10, 6))\n",
113:     "\n",
114:     "for name, group in df.groupby(\"name\"):\n",
115:     "    group = group.sort_values(\"iteration\")\n",
116:     "    ax.plot(\n",
117:     "        group[\"iteration\"],\n",
118:     "        group[\"neg_log_likelihood\"],\n",
119:     "        label=name,\n",
120:     "        linewidth=0,\n",
121:     "        marker=marker_styles[name], # type: ignore\n",
122:     "        )\n",
123:     "\n",
124:     "plt.legend(fontsize=12)\n",
125:     "\n",
126:     "ax.set_ylabel(\"Negative Log Likelihood\", fontsize=14)\n",
127:     "ax.set_xlabel(\"MCMC Iteration\", fontsize=14)\n",
128:     "\n",
129:     "\n",
130:     "ax.spines[['top', 'right']].set_visible(False)\n",
131:     "fig.show()"
132:    ]
133:   },
134:   {
135:    "cell_type": "code",
136:    "execution_count": null,
137:    "id": "666c6cc1",
138:    "metadata": {},
139:    "outputs": [],
140:    "source": []
141:   }
142:  ],
143:  "metadata": {
144:   "kernelspec": {
145:    "display_name": "anon_sbm_notebook",
146:    "language": "python",
147:    "name": "python3"
148:   },
149:   "language_info": {
150:    "codemirror_mode": {
151:     "name": "ipython",
152:     "version": 3
153:    },
154:    "file_extension": ".py",
155:    "mimetype": "text/x-python",
156:    "name": "python",
157:    "nbconvert_exporter": "python",
158:    "pygments_lexer": "ipython3",
159:    "version": "3.13.5"
160:   }
161:  },
162:  "nbformat": 4,
163:  "nbformat_minor": 5
164: }

================
File: notebooks/likelihood_test.ipynb
================
   1: {
   2:  "cells": [
   3:   {
   4:    "cell_type": "code",
   5:    "execution_count": 2,
   6:    "metadata": {},
   7:    "outputs": [],
   8:    "source": [
   9:     "import numpy as np\n",
  10:     "import scipy.sparse as sp\n",
  11:     "from sbm.sbm import StochasticBlockModel"
  12:    ]
  13:   },
  14:   {
  15:    "cell_type": "code",
  16:    "execution_count": 32,
  17:    "metadata": {},
  18:    "outputs": [],
  19:    "source": [
  20:     "num_nodes = 1000\n",
  21:     "block_size = 50\n",
  22:     "# Generate a random sparse adjacency matrix\n",
  23:     "adjacency = sp.random(num_nodes, num_nodes, density=0.01, format='csr')\n",
  24:     "adjacency = adjacency + adjacency.T  # Make it symmetric\n",
  25:     "adjacency.data = np.ones_like(adjacency.data)  # Unweighted graph\n",
  26:     "\n",
  27:     "# Create an initial uniform random partition\n",
  28:     "initial_blocks = StochasticBlockModel.create_uniform_partition(num_nodes, block_size)\n",
  29:     "\n",
  30:     "# Initialize the SBM\n",
  31:     "sbm = StochasticBlockModel(adjacency, initial_blocks)"
  32:    ]
  33:   },
  34:   {
  35:    "cell_type": "code",
  36:    "execution_count": 33,
  37:    "metadata": {},
  38:    "outputs": [
  39:     {
  40:      "name": "stdout",
  41:      "output_type": "stream",
  42:      "text": [
  43:       "Initial Likelihood: -110207.47925966672\n"
  44:      ]
  45:     }
  46:    ],
  47:    "source": [
  48:     "# Compute the initial likelihood\n",
  49:     "initial_likelihood = sbm.compute_likelihood()\n",
  50:     "print(f\"Initial Likelihood: {initial_likelihood}\")"
  51:    ]
  52:   },
  53:   {
  54:    "cell_type": "code",
  55:    "execution_count": 34,
  56:    "metadata": {},
  57:    "outputs": [
  58:     {
  59:      "name": "stdout",
  60:      "output_type": "stream",
  61:      "text": [
  62:       "[True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True]\n"
  63:      ]
  64:     }
  65:    ],
  66:    "source": [
  67:     "block_0 = sbm.block_members[0]\n",
  68:     "sbm.split_block(0)\n",
  69:     "\n",
  70:     "test = [elem in block_0 for elem in sbm.block_members[0]]\n",
  71:     "print(test)"
  72:    ]
  73:   },
  74:   {
  75:    "cell_type": "code",
  76:    "execution_count": 35,
  77:    "metadata": {},
  78:    "outputs": [
  79:     {
  80:      "name": "stdout",
  81:      "output_type": "stream",
  82:      "text": [
  83:       "[True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True]\n"
  84:      ]
  85:     }
  86:    ],
  87:    "source": [
  88:     "block_1, block_2 = sbm.block_members[1], sbm.block_members[2]\n",
  89:     "\n",
  90:     "sbm.merge_blocks(1, 2)\n",
  91:     "\n",
  92:     "test = [elem in sbm.block_members[1] for elem in block_1] + [elem in sbm.block_members[1] for elem in block_2]\n",
  93:     "print(test)"
  94:    ]
  95:   },
  96:   {
  97:    "cell_type": "code",
  98:    "execution_count": 62,
  99:    "metadata": {},
 100:    "outputs": [],
 101:    "source": [
 102:     "sbm.split_block(0)"
 103:    ]
 104:   },
 105:   {
 106:    "cell_type": "code",
 107:    "execution_count": 63,
 108:    "metadata": {},
 109:    "outputs": [
 110:     {
 111:      "data": {
 112:       "text/plain": [
 113:        "dict_keys([3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 26])"
 114:       ]
 115:      },
 116:      "execution_count": 63,
 117:      "metadata": {},
 118:      "output_type": "execute_result"
 119:     }
 120:    ],
 121:    "source": [
 122:     "sbm.block_members.keys()"
 123:    ]
 124:   },
 125:   {
 126:    "cell_type": "code",
 127:    "execution_count": 64,
 128:    "metadata": {},
 129:    "outputs": [
 130:     {
 131:      "data": {
 132:       "text/plain": [
 133:        "{3: [361,\n",
 134:        "  569,\n",
 135:        "  298,\n",
 136:        "  110,\n",
 137:        "  288,\n",
 138:        "  972,\n",
 139:        "  595,\n",
 140:        "  10,\n",
 141:        "  67,\n",
 142:        "  436,\n",
 143:        "  281,\n",
 144:        "  52,\n",
 145:        "  476,\n",
 146:        "  791,\n",
 147:        "  760,\n",
 148:        "  388,\n",
 149:        "  926,\n",
 150:        "  928,\n",
 151:        "  45,\n",
 152:        "  40,\n",
 153:        "  393,\n",
 154:        "  474,\n",
 155:        "  237,\n",
 156:        "  226,\n",
 157:        "  814,\n",
 158:        "  447,\n",
 159:        "  884,\n",
 160:        "  833,\n",
 161:        "  62,\n",
 162:        "  834,\n",
 163:        "  387,\n",
 164:        "  448,\n",
 165:        "  788,\n",
 166:        "  179,\n",
 167:        "  801,\n",
 168:        "  318,\n",
 169:        "  64,\n",
 170:        "  629,\n",
 171:        "  968,\n",
 172:        "  911,\n",
 173:        "  568,\n",
 174:        "  450,\n",
 175:        "  735,\n",
 176:        "  1,\n",
 177:        "  410,\n",
 178:        "  30,\n",
 179:        "  389,\n",
 180:        "  215,\n",
 181:        "  478,\n",
 182:        "  319],\n",
 183:        " 4: [202,\n",
 184:        "  787,\n",
 185:        "  255,\n",
 186:        "  502,\n",
 187:        "  242,\n",
 188:        "  827,\n",
 189:        "  402,\n",
 190:        "  256,\n",
 191:        "  584,\n",
 192:        "  547,\n",
 193:        "  579,\n",
 194:        "  739,\n",
 195:        "  282,\n",
 196:        "  697,\n",
 197:        "  135,\n",
 198:        "  342,\n",
 199:        "  636,\n",
 200:        "  377,\n",
 201:        "  118,\n",
 202:        "  722,\n",
 203:        "  915,\n",
 204:        "  685,\n",
 205:        "  397,\n",
 206:        "  341,\n",
 207:        "  416,\n",
 208:        "  612,\n",
 209:        "  491,\n",
 210:        "  392,\n",
 211:        "  941,\n",
 212:        "  668,\n",
 213:        "  148,\n",
 214:        "  370,\n",
 215:        "  247,\n",
 216:        "  734,\n",
 217:        "  991,\n",
 218:        "  619,\n",
 219:        "  262,\n",
 220:        "  351,\n",
 221:        "  628,\n",
 222:        "  864,\n",
 223:        "  337,\n",
 224:        "  845,\n",
 225:        "  752,\n",
 226:        "  244,\n",
 227:        "  903,\n",
 228:        "  606,\n",
 229:        "  269,\n",
 230:        "  898,\n",
 231:        "  780,\n",
 232:        "  716],\n",
 233:        " 5: [352,\n",
 234:        "  210,\n",
 235:        "  473,\n",
 236:        "  807,\n",
 237:        "  676,\n",
 238:        "  353,\n",
 239:        "  534,\n",
 240:        "  813,\n",
 241:        "  88,\n",
 242:        "  58,\n",
 243:        "  198,\n",
 244:        "  715,\n",
 245:        "  519,\n",
 246:        "  945,\n",
 247:        "  264,\n",
 248:        "  357,\n",
 249:        "  53,\n",
 250:        "  934,\n",
 251:        "  877,\n",
 252:        "  217,\n",
 253:        "  437,\n",
 254:        "  653,\n",
 255:        "  746,\n",
 256:        "  737,\n",
 257:        "  461,\n",
 258:        "  953,\n",
 259:        "  458,\n",
 260:        "  346,\n",
 261:        "  414,\n",
 262:        "  329,\n",
 263:        "  902,\n",
 264:        "  106,\n",
 265:        "  295,\n",
 266:        "  695,\n",
 267:        "  480,\n",
 268:        "  994,\n",
 269:        "  206,\n",
 270:        "  592,\n",
 271:        "  44,\n",
 272:        "  171,\n",
 273:        "  876,\n",
 274:        "  105,\n",
 275:        "  758,\n",
 276:        "  57,\n",
 277:        "  128,\n",
 278:        "  7,\n",
 279:        "  811,\n",
 280:        "  145,\n",
 281:        "  985,\n",
 282:        "  977],\n",
 283:        " 6: [229,\n",
 284:        "  394,\n",
 285:        "  656,\n",
 286:        "  744,\n",
 287:        "  935,\n",
 288:        "  333,\n",
 289:        "  407,\n",
 290:        "  736,\n",
 291:        "  546,\n",
 292:        "  553,\n",
 293:        "  221,\n",
 294:        "  982,\n",
 295:        "  914,\n",
 296:        "  101,\n",
 297:        "  230,\n",
 298:        "  406,\n",
 299:        "  872,\n",
 300:        "  266,\n",
 301:        "  285,\n",
 302:        "  325,\n",
 303:        "  582,\n",
 304:        "  562,\n",
 305:        "  222,\n",
 306:        "  924,\n",
 307:        "  78,\n",
 308:        "  970,\n",
 309:        "  899,\n",
 310:        "  729,\n",
 311:        "  869,\n",
 312:        "  77,\n",
 313:        "  908,\n",
 314:        "  510,\n",
 315:        "  713,\n",
 316:        "  9,\n",
 317:        "  593,\n",
 318:        "  279,\n",
 319:        "  429,\n",
 320:        "  721,\n",
 321:        "  933,\n",
 322:        "  860,\n",
 323:        "  375,\n",
 324:        "  334,\n",
 325:        "  750,\n",
 326:        "  849,\n",
 327:        "  524,\n",
 328:        "  225,\n",
 329:        "  241,\n",
 330:        "  803,\n",
 331:        "  759,\n",
 332:        "  669],\n",
 333:        " 7: [92,\n",
 334:        "  196,\n",
 335:        "  770,\n",
 336:        "  530,\n",
 337:        "  740,\n",
 338:        "  189,\n",
 339:        "  777,\n",
 340:        "  699,\n",
 341:        "  144,\n",
 342:        "  463,\n",
 343:        "  404,\n",
 344:        "  270,\n",
 345:        "  890,\n",
 346:        "  320,\n",
 347:        "  315,\n",
 348:        "  403,\n",
 349:        "  310,\n",
 350:        "  350,\n",
 351:        "  802,\n",
 352:        "  293,\n",
 353:        "  29,\n",
 354:        "  587,\n",
 355:        "  846,\n",
 356:        "  852,\n",
 357:        "  86,\n",
 358:        "  453,\n",
 359:        "  523,\n",
 360:        "  249,\n",
 361:        "  939,\n",
 362:        "  34,\n",
 363:        "  912,\n",
 364:        "  0,\n",
 365:        "  776,\n",
 366:        "  812,\n",
 367:        "  340,\n",
 368:        "  512,\n",
 369:        "  187,\n",
 370:        "  672,\n",
 371:        "  677,\n",
 372:        "  190,\n",
 373:        "  878,\n",
 374:        "  893,\n",
 375:        "  605,\n",
 376:        "  411,\n",
 377:        "  228,\n",
 378:        "  665,\n",
 379:        "  751,\n",
 380:        "  439,\n",
 381:        "  5,\n",
 382:        "  844],\n",
 383:        " 8: [795,\n",
 384:        "  943,\n",
 385:        "  212,\n",
 386:        "  978,\n",
 387:        "  347,\n",
 388:        "  71,\n",
 389:        "  48,\n",
 390:        "  292,\n",
 391:        "  155,\n",
 392:        "  608,\n",
 393:        "  997,\n",
 394:        "  576,\n",
 395:        "  449,\n",
 396:        "  990,\n",
 397:        "  36,\n",
 398:        "  895,\n",
 399:        "  979,\n",
 400:        "  778,\n",
 401:        "  154,\n",
 402:        "  494,\n",
 403:        "  529,\n",
 404:        "  542,\n",
 405:        "  303,\n",
 406:        "  560,\n",
 407:        "  471,\n",
 408:        "  385,\n",
 409:        "  901,\n",
 410:        "  124,\n",
 411:        "  180,\n",
 412:        "  850,\n",
 413:        "  631,\n",
 414:        "  769,\n",
 415:        "  137,\n",
 416:        "  462,\n",
 417:        "  307,\n",
 418:        "  263,\n",
 419:        "  89,\n",
 420:        "  805,\n",
 421:        "  428,\n",
 422:        "  424,\n",
 423:        "  892,\n",
 424:        "  390,\n",
 425:        "  63,\n",
 426:        "  19,\n",
 427:        "  782,\n",
 428:        "  267,\n",
 429:        "  917,\n",
 430:        "  773,\n",
 431:        "  465,\n",
 432:        "  842],\n",
 433:        " 9: [76,\n",
 434:        "  733,\n",
 435:        "  49,\n",
 436:        "  43,\n",
 437:        "  614,\n",
 438:        "  885,\n",
 439:        "  618,\n",
 440:        "  164,\n",
 441:        "  423,\n",
 442:        "  117,\n",
 443:        "  516,\n",
 444:        "  565,\n",
 445:        "  166,\n",
 446:        "  771,\n",
 447:        "  717,\n",
 448:        "  859,\n",
 449:        "  691,\n",
 450:        "  159,\n",
 451:        "  495,\n",
 452:        "  153,\n",
 453:        "  678,\n",
 454:        "  227,\n",
 455:        "  692,\n",
 456:        "  981,\n",
 457:        "  181,\n",
 458:        "  857,\n",
 459:        "  126,\n",
 460:        "  950,\n",
 461:        "  55,\n",
 462:        "  622,\n",
 463:        "  129,\n",
 464:        "  731,\n",
 465:        "  554,\n",
 466:        "  556,\n",
 467:        "  220,\n",
 468:        "  162,\n",
 469:        "  238,\n",
 470:        "  925,\n",
 471:        "  309,\n",
 472:        "  662,\n",
 473:        "  673,\n",
 474:        "  831,\n",
 475:        "  72,\n",
 476:        "  107,\n",
 477:        "  815,\n",
 478:        "  514,\n",
 479:        "  706,\n",
 480:        "  847,\n",
 481:        "  233,\n",
 482:        "  467],\n",
 483:        " 10: [308,\n",
 484:        "  186,\n",
 485:        "  489,\n",
 486:        "  959,\n",
 487:        "  658,\n",
 488:        "  362,\n",
 489:        "  223,\n",
 490:        "  862,\n",
 491:        "  659,\n",
 492:        "  484,\n",
 493:        "  536,\n",
 494:        "  757,\n",
 495:        "  969,\n",
 496:        "  18,\n",
 497:        "  825,\n",
 498:        "  332,\n",
 499:        "  306,\n",
 500:        "  840,\n",
 501:        "  660,\n",
 502:        "  602,\n",
 503:        "  684,\n",
 504:        "  188,\n",
 505:        "  613,\n",
 506:        "  590,\n",
 507:        "  820,\n",
 508:        "  324,\n",
 509:        "  443,\n",
 510:        "  627,\n",
 511:        "  586,\n",
 512:        "  766,\n",
 513:        "  69,\n",
 514:        "  830,\n",
 515:        "  942,\n",
 516:        "  419,\n",
 517:        "  798,\n",
 518:        "  946,\n",
 519:        "  65,\n",
 520:        "  644,\n",
 521:        "  79,\n",
 522:        "  604,\n",
 523:        "  121,\n",
 524:        "  74,\n",
 525:        "  971,\n",
 526:        "  381,\n",
 527:        "  81,\n",
 528:        "  100,\n",
 529:        "  932,\n",
 530:        "  531,\n",
 531:        "  232,\n",
 532:        "  466],\n",
 533:        " 11: [762,\n",
 534:        "  355,\n",
 535:        "  955,\n",
 536:        "  451,\n",
 537:        "  904,\n",
 538:        "  109,\n",
 539:        "  749,\n",
 540:        "  621,\n",
 541:        "  689,\n",
 542:        "  231,\n",
 543:        "  626,\n",
 544:        "  305,\n",
 545:        "  167,\n",
 546:        "  98,\n",
 547:        "  938,\n",
 548:        "  37,\n",
 549:        "  427,\n",
 550:        "  284,\n",
 551:        "  793,\n",
 552:        "  958,\n",
 553:        "  724,\n",
 554:        "  312,\n",
 555:        "  848,\n",
 556:        "  415,\n",
 557:        "  528,\n",
 558:        "  867,\n",
 559:        "  645,\n",
 560:        "  158,\n",
 561:        "  661,\n",
 562:        "  954,\n",
 563:        "  920,\n",
 564:        "  354,\n",
 565:        "  910,\n",
 566:        "  59,\n",
 567:        "  965,\n",
 568:        "  208,\n",
 569:        "  441,\n",
 570:        "  358,\n",
 571:        "  623,\n",
 572:        "  54,\n",
 573:        "  497,\n",
 574:        "  966,\n",
 575:        "  112,\n",
 576:        "  125,\n",
 577:        "  532,\n",
 578:        "  379,\n",
 579:        "  365,\n",
 580:        "  138,\n",
 581:        "  634,\n",
 582:        "  214],\n",
 583:        " 12: [797,\n",
 584:        "  719,\n",
 585:        "  975,\n",
 586:        "  603,\n",
 587:        "  540,\n",
 588:        "  507,\n",
 589:        "  610,\n",
 590:        "  879,\n",
 591:        "  870,\n",
 592:        "  302,\n",
 593:        "  594,\n",
 594:        "  609,\n",
 595:        "  574,\n",
 596:        "  199,\n",
 597:        "  693,\n",
 598:        "  703,\n",
 599:        "  666,\n",
 600:        "  422,\n",
 601:        "  278,\n",
 602:        "  775,\n",
 603:        "  219,\n",
 604:        "  84,\n",
 605:        "  654,\n",
 606:        "  317,\n",
 607:        "  321,\n",
 608:        "  420,\n",
 609:        "  17,\n",
 610:        "  573,\n",
 611:        "  843,\n",
 612:        "  201,\n",
 613:        "  525,\n",
 614:        "  224,\n",
 615:        "  816,\n",
 616:        "  207,\n",
 617:        "  783,\n",
 618:        "  435,\n",
 619:        "  725,\n",
 620:        "  360,\n",
 621:        "  518,\n",
 622:        "  80,\n",
 623:        "  561,\n",
 624:        "  11,\n",
 625:        "  948,\n",
 626:        "  694,\n",
 627:        "  493,\n",
 628:        "  103,\n",
 629:        "  923,\n",
 630:        "  70,\n",
 631:        "  268,\n",
 632:        "  290],\n",
 633:        " 13: [13,\n",
 634:        "  989,\n",
 635:        "  929,\n",
 636:        "  374,\n",
 637:        "  195,\n",
 638:        "  236,\n",
 639:        "  446,\n",
 640:        "  39,\n",
 641:        "  973,\n",
 642:        "  625,\n",
 643:        "  161,\n",
 644:        "  630,\n",
 645:        "  464,\n",
 646:        "  682,\n",
 647:        "  345,\n",
 648:        "  768,\n",
 649:        "  680,\n",
 650:        "  549,\n",
 651:        "  455,\n",
 652:        "  192,\n",
 653:        "  633,\n",
 654:        "  23,\n",
 655:        "  20,\n",
 656:        "  883,\n",
 657:        "  589,\n",
 658:        "  533,\n",
 659:        "  87,\n",
 660:        "  475,\n",
 661:        "  996,\n",
 662:        "  947,\n",
 663:        "  686,\n",
 664:        "  283,\n",
 665:        "  384,\n",
 666:        "  376,\n",
 667:        "  259,\n",
 668:        "  323,\n",
 669:        "  326,\n",
 670:        "  274,\n",
 671:        "  165,\n",
 672:        "  398,\n",
 673:        "  781,\n",
 674:        "  747,\n",
 675:        "  149,\n",
 676:        "  838,\n",
 677:        "  240,\n",
 678:        "  598,\n",
 679:        "  741,\n",
 680:        "  204,\n",
 681:        "  700,\n",
 682:        "  457],\n",
 683:        " 14: [301,\n",
 684:        "  804,\n",
 685:        "  964,\n",
 686:        "  504,\n",
 687:        "  616,\n",
 688:        "  921,\n",
 689:        "  409,\n",
 690:        "  600,\n",
 691:        "  413,\n",
 692:        "  949,\n",
 693:        "  819,\n",
 694:        "  861,\n",
 695:        "  291,\n",
 696:        "  211,\n",
 697:        "  75,\n",
 698:        "  432,\n",
 699:        "  425,\n",
 700:        "  753,\n",
 701:        "  772,\n",
 702:        "  742,\n",
 703:        "  82,\n",
 704:        "  674,\n",
 705:        "  643,\n",
 706:        "  607,\n",
 707:        "  765,\n",
 708:        "  460,\n",
 709:        "  500,\n",
 710:        "  400,\n",
 711:        "  889,\n",
 712:        "  683,\n",
 713:        "  940,\n",
 714:        "  839,\n",
 715:        "  513,\n",
 716:        "  177,\n",
 717:        "  408,\n",
 718:        "  248,\n",
 719:        "  790,\n",
 720:        "  97,\n",
 721:        "  131,\n",
 722:        "  544,\n",
 723:        "  234,\n",
 724:        "  578,\n",
 725:        "  250,\n",
 726:        "  980,\n",
 727:        "  873,\n",
 728:        "  687,\n",
 729:        "  42,\n",
 730:        "  541,\n",
 731:        "  710,\n",
 732:        "  663],\n",
 733:        " 15: [197,\n",
 734:        "  380,\n",
 735:        "  28,\n",
 736:        "  728,\n",
 737:        "  134,\n",
 738:        "  254,\n",
 739:        "  8,\n",
 740:        "  566,\n",
 741:        "  216,\n",
 742:        "  962,\n",
 743:        "  314,\n",
 744:        "  277,\n",
 745:        "  6,\n",
 746:        "  708,\n",
 747:        "  829,\n",
 748:        "  796,\n",
 749:        "  701,\n",
 750:        "  515,\n",
 751:        "  779,\n",
 752:        "  114,\n",
 753:        "  2,\n",
 754:        "  368,\n",
 755:        "  832,\n",
 756:        "  287,\n",
 757:        "  823,\n",
 758:        "  763,\n",
 759:        "  642,\n",
 760:        "  243,\n",
 761:        "  66,\n",
 762:        "  15,\n",
 763:        "  535,\n",
 764:        "  272,\n",
 765:        "  391,\n",
 766:        "  548,\n",
 767:        "  205,\n",
 768:        "  983,\n",
 769:        "  858,\n",
 770:        "  808,\n",
 771:        "  265,\n",
 772:        "  720,\n",
 773:        "  26,\n",
 774:        "  327,\n",
 775:        "  570,\n",
 776:        "  709,\n",
 777:        "  527,\n",
 778:        "  789,\n",
 779:        "  868,\n",
 780:        "  581,\n",
 781:        "  151,\n",
 782:        "  421],\n",
 783:        " 16: [647,\n",
 784:        "  956,\n",
 785:        "  111,\n",
 786:        "  47,\n",
 787:        "  418,\n",
 788:        "  469,\n",
 789:        "  937,\n",
 790:        "  688,\n",
 791:        "  356,\n",
 792:        "  289,\n",
 793:        "  615,\n",
 794:        "  286,\n",
 795:        "  170,\n",
 796:        "  617,\n",
 797:        "  511,\n",
 798:        "  986,\n",
 799:        "  313,\n",
 800:        "  364,\n",
 801:        "  896,\n",
 802:        "  974,\n",
 803:        "  119,\n",
 804:        "  22,\n",
 805:        "  133,\n",
 806:        "  987,\n",
 807:        "  163,\n",
 808:        "  679,\n",
 809:        "  431,\n",
 810:        "  483,\n",
 811:        "  550,\n",
 812:        "  738,\n",
 813:        "  517,\n",
 814:        "  712,\n",
 815:        "  818,\n",
 816:        "  963,\n",
 817:        "  897,\n",
 818:        "  261,\n",
 819:        "  564,\n",
 820:        "  96,\n",
 821:        "  539,\n",
 822:        "  828,\n",
 823:        "  863,\n",
 824:        "  916,\n",
 825:        "  41,\n",
 826:        "  294,\n",
 827:        "  132,\n",
 828:        "  299,\n",
 829:        "  652,\n",
 830:        "  336,\n",
 831:        "  718,\n",
 832:        "  168],\n",
 833:        " 17: [675,\n",
 834:        "  73,\n",
 835:        "  25,\n",
 836:        "  276,\n",
 837:        "  809,\n",
 838:        "  386,\n",
 839:        "  127,\n",
 840:        "  257,\n",
 841:        "  442,\n",
 842:        "  331,\n",
 843:        "  245,\n",
 844:        "  417,\n",
 845:        "  786,\n",
 846:        "  572,\n",
 847:        "  891,\n",
 848:        "  995,\n",
 849:        "  485,\n",
 850:        "  113,\n",
 851:        "  456,\n",
 852:        "  841,\n",
 853:        "  412,\n",
 854:        "  152,\n",
 855:        "  235,\n",
 856:        "  481,\n",
 857:        "  599,\n",
 858:        "  338,\n",
 859:        "  596,\n",
 860:        "  646,\n",
 861:        "  650,\n",
 862:        "  824,\n",
 863:        "  396,\n",
 864:        "  330,\n",
 865:        "  316,\n",
 866:        "  24,\n",
 867:        "  745,\n",
 868:        "  454,\n",
 869:        "  115,\n",
 870:        "  707,\n",
 871:        "  784,\n",
 872:        "  61,\n",
 873:        "  952,\n",
 874:        "  508,\n",
 875:        "  498,\n",
 876:        "  184,\n",
 877:        "  866,\n",
 878:        "  213,\n",
 879:        "  927,\n",
 880:        "  150,\n",
 881:        "  900,\n",
 882:        "  558],\n",
 883:        " 18: [648,\n",
 884:        "  999,\n",
 885:        "  624,\n",
 886:        "  203,\n",
 887:        "  146,\n",
 888:        "  182,\n",
 889:        "  585,\n",
 890:        "  704,\n",
 891:        "  906,\n",
 892:        "  670,\n",
 893:        "  482,\n",
 894:        "  984,\n",
 895:        "  785,\n",
 896:        "  503,\n",
 897:        "  486,\n",
 898:        "  296,\n",
 899:        "  239,\n",
 900:        "  875,\n",
 901:        "  252,\n",
 902:        "  492,\n",
 903:        "  537,\n",
 904:        "  99,\n",
 905:        "  335,\n",
 906:        "  957,\n",
 907:        "  200,\n",
 908:        "  506,\n",
 909:        "  108,\n",
 910:        "  193,\n",
 911:        "  588,\n",
 912:        "  359,\n",
 913:        "  657,\n",
 914:        "  373,\n",
 915:        "  94,\n",
 916:        "  60,\n",
 917:        "  960,\n",
 918:        "  366,\n",
 919:        "  14,\n",
 920:        "  3,\n",
 921:        "  810,\n",
 922:        "  951,\n",
 923:        "  583,\n",
 924:        "  142,\n",
 925:        "  761,\n",
 926:        "  637,\n",
 927:        "  505,\n",
 928:        "  711,\n",
 929:        "  339,\n",
 930:        "  35,\n",
 931:        "  851,\n",
 932:        "  743],\n",
 933:        " 19: [50,\n",
 934:        "  349,\n",
 935:        "  156,\n",
 936:        "  853,\n",
 937:        "  251,\n",
 938:        "  620,\n",
 939:        "  160,\n",
 940:        "  822,\n",
 941:        "  275,\n",
 942:        "  4,\n",
 943:        "  792,\n",
 944:        "  767,\n",
 945:        "  472,\n",
 946:        "  577,\n",
 947:        "  907,\n",
 948:        "  580,\n",
 949:        "  723,\n",
 950:        "  611,\n",
 951:        "  147,\n",
 952:        "  992,\n",
 953:        "  172,\n",
 954:        "  998,\n",
 955:        "  348,\n",
 956:        "  521,\n",
 957:        "  575,\n",
 958:        "  21,\n",
 959:        "  651,\n",
 960:        "  854,\n",
 961:        "  591,\n",
 962:        "  176,\n",
 963:        "  837,\n",
 964:        "  918,\n",
 965:        "  635,\n",
 966:        "  571,\n",
 967:        "  976,\n",
 968:        "  56,\n",
 969:        "  826,\n",
 970:        "  174,\n",
 971:        "  311,\n",
 972:        "  271,\n",
 973:        "  496,\n",
 974:        "  913,\n",
 975:        "  855,\n",
 976:        "  557,\n",
 977:        "  139,\n",
 978:        "  209,\n",
 979:        "  552,\n",
 980:        "  369,\n",
 981:        "  638,\n",
 982:        "  218],\n",
 983:        " 20: [748,\n",
 984:        "  690,\n",
 985:        "  545,\n",
 986:        "  756,\n",
 987:        "  95,\n",
 988:        "  730,\n",
 989:        "  649,\n",
 990:        "  405,\n",
 991:        "  526,\n",
 992:        "  993,\n",
 993:        "  130,\n",
 994:        "  399,\n",
 995:        "  426,\n",
 996:        "  764,\n",
 997:        "  300,\n",
 998:        "  440,\n",
 999:        "  477,\n",
1000:        "  655,\n",
1001:        "  85,\n",
1002:        "  322,\n",
1003:        "  452,\n",
1004:        "  395,\n",
1005:        "  304,\n",
1006:        "  91,\n",
1007:        "  490,\n",
1008:        "  175,\n",
1009:        "  83,\n",
1010:        "  445,\n",
1011:        "  835,\n",
1012:        "  702,\n",
1013:        "  931,\n",
1014:        "  104,\n",
1015:        "  726,\n",
1016:        "  865,\n",
1017:        "  178,\n",
1018:        "  794,\n",
1019:        "  522,\n",
1020:        "  727,\n",
1021:        "  640,\n",
1022:        "  501,\n",
1023:        "  698,\n",
1024:        "  967,\n",
1025:        "  988,\n",
1026:        "  120,\n",
1027:        "  434,\n",
1028:        "  664,\n",
1029:        "  641,\n",
1030:        "  51,\n",
1031:        "  886,\n",
1032:        "  12,\n",
1033:        "  433,\n",
1034:        "  102,\n",
1035:        "  122,\n",
1036:        "  714,\n",
1037:        "  32,\n",
1038:        "  31,\n",
1039:        "  371,\n",
1040:        "  344,\n",
1041:        "  157,\n",
1042:        "  38,\n",
1043:        "  922,\n",
1044:        "  880,\n",
1045:        "  16,\n",
1046:        "  961,\n",
1047:        "  930,\n",
1048:        "  363,\n",
1049:        "  136,\n",
1050:        "  555,\n",
1051:        "  909,\n",
1052:        "  696,\n",
1053:        "  559,\n",
1054:        "  543,\n",
1055:        "  667,\n",
1056:        "  382,\n",
1057:        "  191],\n",
1058:        " 21: [567,\n",
1059:        "  817,\n",
1060:        "  383,\n",
1061:        "  116,\n",
1062:        "  68,\n",
1063:        "  888,\n",
1064:        "  944,\n",
1065:        "  33,\n",
1066:        "  401,\n",
1067:        "  430,\n",
1068:        "  881,\n",
1069:        "  499,\n",
1070:        "  260,\n",
1071:        "  754,\n",
1072:        "  372,\n",
1073:        "  919,\n",
1074:        "  185,\n",
1075:        "  821,\n",
1076:        "  905,\n",
1077:        "  123,\n",
1078:        "  732,\n",
1079:        "  90,\n",
1080:        "  273,\n",
1081:        "  705,\n",
1082:        "  871,\n",
1083:        "  141,\n",
1084:        "  551,\n",
1085:        "  836,\n",
1086:        "  671,\n",
1087:        "  27,\n",
1088:        "  93,\n",
1089:        "  563,\n",
1090:        "  936,\n",
1091:        "  639,\n",
1092:        "  488,\n",
1093:        "  487,\n",
1094:        "  328,\n",
1095:        "  774],\n",
1096:        " 22: [470,\n",
1097:        "  258,\n",
1098:        "  378,\n",
1099:        "  509,\n",
1100:        "  459,\n",
1101:        "  887,\n",
1102:        "  246,\n",
1103:        "  520,\n",
1104:        "  438,\n",
1105:        "  601,\n",
1106:        "  856,\n",
1107:        "  343,\n",
1108:        "  143,\n",
1109:        "  280,\n",
1110:        "  597,\n",
1111:        "  140,\n",
1112:        "  183,\n",
1113:        "  444,\n",
1114:        "  681],\n",
1115:        " 23: [894, 538, 253, 468, 194, 367, 173, 632, 479],\n",
1116:        " 24: [800, 46, 882, 799, 874],\n",
1117:        " 25: [169, 806],\n",
1118:        " 0: [297],\n",
1119:        " 26: [755]}"
1120:       ]
1121:      },
1122:      "execution_count": 64,
1123:      "metadata": {},
1124:      "output_type": "execute_result"
1125:     }
1126:    ],
1127:    "source": [
1128:     "sbm.block_members"
1129:    ]
1130:   },
1131:   {
1132:    "cell_type": "code",
1133:    "execution_count": 36,
1134:    "metadata": {},
1135:    "outputs": [
1136:     {
1137:      "ename": "KeyError",
1138:      "evalue": "2",
1139:      "output_type": "error",
1140:      "traceback": [
1141:       "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
1142:       "\u001b[0;31mKeyError\u001b[0m                                  Traceback (most recent call last)",
1143:       "Cell \u001b[0;32mIn[36], line 2\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[38;5;66;03m# Perform some partition manipulations\u001b[39;00m\n\u001b[0;32m----> 2\u001b[0m \u001b[43msbm\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mmerge_blocks\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;241;43m1\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m2\u001b[39;49m\u001b[43m)\u001b[49m\n\u001b[1;32m      3\u001b[0m sbm\u001b[38;5;241m.\u001b[39mmove_node(\u001b[38;5;241m10\u001b[39m, \u001b[38;5;241m3\u001b[39m)\n\u001b[1;32m      5\u001b[0m \u001b[38;5;66;03m# Compute the new likelihood\u001b[39;00m\n",
1144:       "File \u001b[0;32m~/anon_sbm/src/sbm/sbm.py:159\u001b[0m, in \u001b[0;36mStochasticBlockModel.merge_blocks\u001b[0;34m(self, block_a, block_b)\u001b[0m\n\u001b[1;32m    157\u001b[0m new_block_idx \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mmin\u001b[39m(block_a, block_b)\n\u001b[1;32m    158\u001b[0m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mblock_members[new_block_idx] \u001b[38;5;241m=\u001b[39m merged_nodes\n\u001b[0;32m--> 159\u001b[0m \u001b[38;5;28;01mdel\u001b[39;00m \u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mblock_members\u001b[49m\u001b[43m[\u001b[49m\u001b[38;5;28;43mmax\u001b[39;49m\u001b[43m(\u001b[49m\u001b[43mblock_a\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mblock_b\u001b[49m\u001b[43m)\u001b[49m\u001b[43m]\u001b[49m\n\u001b[1;32m    161\u001b[0m \u001b[38;5;66;03m# Update blocks mapping\u001b[39;00m\n\u001b[1;32m    162\u001b[0m \u001b[38;5;28;01mfor\u001b[39;00m node \u001b[38;5;129;01min\u001b[39;00m merged_nodes:\n",
1145:       "\u001b[0;31mKeyError\u001b[0m: 2"
1146:      ]
1147:     }
1148:    ],
1149:    "source": [
1150:     "# Perform some partition manipulations\n",
1151:     "sbm.merge_blocks(1, 2)\n",
1152:     "sbm.move_node(10, 3)\n",
1153:     "\n",
1154:     "# Compute the new likelihood\n",
1155:     "new_likelihood = sbm.compute_likelihood()\n",
1156:     "print(f\"New Likelihood: {new_likelihood}\")\n",
1157:     "\n",
1158:     "# Check minimum block size\n",
1159:     "min_size = sbm.min_block_size()\n",
1160:     "print(f\"Minimum Block Size: {min_size}\")"
1161:    ]
1162:   },
1163:   {
1164:    "cell_type": "code",
1165:    "execution_count": null,
1166:    "metadata": {},
1167:    "outputs": [],
1168:    "source": []
1169:   }
1170:  ],
1171:  "metadata": {
1172:   "kernelspec": {
1173:    "display_name": "anon_sbm",
1174:    "language": "python",
1175:    "name": "python3"
1176:   },
1177:   "language_info": {
1178:    "codemirror_mode": {
1179:     "name": "ipython",
1180:     "version": 3
1181:    },
1182:    "file_extension": ".py",
1183:    "mimetype": "text/x-python",
1184:    "name": "python",
1185:    "nbconvert_exporter": "python",
1186:    "pygments_lexer": "ipython3",
1187:    "version": "3.13.0"
1188:   }
1189:  },
1190:  "nbformat": 4,
1191:  "nbformat_minor": 2
1192: }

================
File: notebooks/sbm_visualize.ipynb
================
  1: {
  2:  "cells": [
  3:   {
  4:    "cell_type": "code",
  5:    "execution_count": 2,
  6:    "metadata": {},
  7:    "outputs": [
  8:     {
  9:      "name": "stdout",
 10:      "output_type": "stream",
 11:      "text": [
 12:       "Collecting networkx\n",
 13:       "  Using cached networkx-3.4.2-py3-none-any.whl.metadata (6.3 kB)\n",
 14:       "Using cached networkx-3.4.2-py3-none-any.whl (1.7 MB)\n",
 15:       "Installing collected packages: networkx\n",
 16:       "Successfully installed networkx-3.4.2\n"
 17:      ]
 18:     }
 19:    ],
 20:    "source": [
 21:     "!pip install networkx\n",
 22:     "!pip install matplotlib\n",
 23:     "!pip install numpy"
 24:    ]
 25:   },
 26:   {
 27:    "cell_type": "code",
 28:    "execution_count": 5,
 29:    "metadata": {},
 30:    "outputs": [
 31:     {
 32:      "data": {
 33:       "image/png": "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f/9qwwGzsrLYs2cP8+bNq/e9koWFBTNnzjTcX6xZswZPT0/D/eCPPXhPWFxcTEZGBgMGDACoduweZfjw4TXuNeryxhtvEBAQwKJFi3j++ecZPnw4v/rVr+q9LSGE+ZCEknii9e3bl61bt5KdnU10dDR//OMfycvLY/r06YYkRV3S09MpLCykW7duNV7r3r07er3eMFb/1q1bDx1W9yAvL69q37dp0wagWlLo7t27LF68GCcnJ+zs7HB2dmb48OEA5ObmAqDRaPjnP//Jnj17cHV1ZdiwYbz99tu1PjmkPqp6ENV3P2oTGBhIaGgooaGhzJw5k9WrVzNhwgReeeUV0tPT61zuzp07dR7nqterYuzWrVu9ejK99dZbfPPNN2zevLlaH4eGmDt3rmEI4TfffMPcuXPrjB+odR/8/PwMr1f926VLlxrz/XjZGzdukJubi4uLC87OztW+8vPzSUtLa9Q+CSGEEFUqKipYv349I0eOJD4+nps3b3Lz5k369+9PamoqkZGRhnnv3LlTr+tXXVatWkVQUBBarZa2bdvi7OzMrl27DPc1UHmd79ChQ7UhZT9248YNFEWhS5cuNa6PV65cqXF99PDwqJHsadOmTbX7rvreXyxcuJDjx48bruebNm2irKyMBQsW1OsYVJk7dy5xcXFcvHiRtWvXMnv27DoTUllZWbz44ou4urpiY2ODs7Mzvr6+ANWO3aNULVMf1tbWfPnll8THx5OXl8eKFSvqnTATQpgX6aEkBJUXxr59+9K3b1+6du3KkiVL2LRpU62fgDW3usaeK4oCVN7cjR49mqysLP7whz/g5+eHra0tSUlJLF68uFrzy1//+tdMnDiRb775hn379vHnP/+Zt956i4MHD9KrV6/Hsj+PMmrUKHbu3El0dPRjfTpaWFgYe/fu5e2332bEiBGNehTv008/jUajYdGiRZSUlDBz5sxmiLR2er0eFxeXOhujPtgXQQghhGiMgwcPkpyczPr161m/fn2N19esWdPgCt/arF69msWLFzN58mR+97vf4eLigoWFBW+99dZDH6pRG71ej0qlYs+ePbXeU9nZ2VX7/lH3XQ0xe/ZsXnrpJdasWcP//M//sHr1avr06VPvpFqV/v3706lTJ379618THx9f5wdWADNnzuTEiRP87ne/o2fPntjZ2aHX6xk7dmytDdHrUp9eVw/a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4cIF9e/fXydOnPB5FgD41XjkDQAAAEBAKSoqUmJiouLi4txrCQkJqqys9DivsrJSVqtVZrNZ8fHx+vHjhxwOh/uRt5qaGjmdTvf5SUlJamhoUFBQkGJiYv72/1utVlmtVi1evFgzZsxQaWmpJk2a5NN7BIBfjR1KAAAAAALKoEGDlJOTo507d7rXlixZovLycq1fv16PHj3S/v37tXv3bi1dulSSFBcXp3HjxmnevHm6fv26HA6HcnNzFRwc7L6GzWZTamqqJk6cqPPnz+vp06e6evWqVq1apVu3bunz58/Ky8tTRUWFnj17psrKSt28edPjPUwA8LugUAIAAAAQcNatW6fW1lb330lJSTp69KiOHDmigQMHavXq1Vq3bp3sdrv7nNLSUkVHR2vUqFGaPHmy5s6dq8jISPdxk8mkM2fOKD09XbNnz5bValV2draePXumqKgomc1mNTU1aebMmbJarZo+fbqysrK0du3atrx1APAJk8vlchkdAgAAAAAAAL8PdigBAAAAAADAKxRKAAAAAAAA8AqFEgAAAAAAALxCoQQAAAAAAACvUCgBAAAAAADAKxRKAAAAAAAA8AqFEgAAAAAAALxCoQQAAAAAAACvUCgBAAAAAADAKxRKAAAAAAAA8AqFEgAAAAAAALxCoQQAAAAAAACv/AEHVFK5QMppQAAAAABJRU5ErkJggg==",
 34:       "text/plain": [
 35:        "<Figure size 1200x500 with 3 Axes>"
 36:       ]
 37:      },
 38:      "metadata": {},
 39:      "output_type": "display_data"
 40:     }
 41:    ],
 42:    "source": [
 43:     "import networkx as nx\n",
 44:     "import matplotlib.pyplot as plt\n",
 45:     "import numpy as np\n",
 46:     "\n",
 47:     "def plot_sbm_graph(block_sizes, p_matrix):\n",
 48:     "    # Validate the connectivity matrix\n",
 49:     "    n_blocks = len(block_sizes)\n",
 50:     "    if p_matrix.shape != (n_blocks, n_blocks):\n",
 51:     "        raise ValueError(\"The connectivity matrix dimensions must match the number of blocks.\")\n",
 52:     "    if np.any(p_matrix < 0) or np.any(p_matrix > 1):\n",
 53:     "        raise ValueError(\"All probabilities in the connectivity matrix must be between 0 and 1.\")\n",
 54:     "\n",
 55:     "    # Generate Stochastic Block Model graph\n",
 56:     "    G = nx.stochastic_block_model(block_sizes, p_matrix)\n",
 57:     "\n",
 58:     "    # Get adjacency matrix\n",
 59:     "    adj_matrix = nx.to_numpy_array(G)\n",
 60:     "\n",
 61:     "    # Assign colors based on block membership\n",
 62:     "    colors = [G.nodes[node]['block'] for node in G.nodes]\n",
 63:     "\n",
 64:     "    # Plotting the graph\n",
 65:     "    pos = nx.spring_layout(G, seed=42)  # For consistent layout\n",
 66:     "    plt.figure(figsize=(12, 5))\n",
 67:     "\n",
 68:     "    # Subplot 1: SBM graph\n",
 69:     "    plt.subplot(1, 2, 1)\n",
 70:     "    nx.draw(G, pos, node_color=colors, cmap=plt.cm.tab10, with_labels=False,\n",
 71:     "            node_size=100, edge_color='gray')\n",
 72:     "    plt.title('Stochastic Block Model')\n",
 73:     "\n",
 74:     "    # Subplot 2: Adjacency matrix with visible block structure\n",
 75:     "    plt.subplot(1, 2, 2)\n",
 76:     "    plt.imshow(adj_matrix, cmap='Greys', interpolation='none')\n",
 77:     "    plt.colorbar(label='Edge Weight')\n",
 78:     "    plt.title('Adjacency Matrix')\n",
 79:     "    plt.xlabel('Nodes')\n",
 80:     "    plt.ylabel('Nodes')\n",
 81:     "\n",
 82:     "    # Overlay block boundaries for visual separation\n",
 83:     "    block_boundaries = np.cumsum([0] + block_sizes)\n",
 84:     "    for boundary in block_boundaries:\n",
 85:     "        plt.axhline(boundary - 0.5, color='red', linestyle='--', linewidth=0.5)\n",
 86:     "        plt.axvline(boundary - 0.5, color='red', linestyle='--', linewidth=0.5)\n",
 87:     "\n",
 88:     "    plt.tight_layout()\n",
 89:     "    plt.show()\n",
 90:     "\n",
 91:     "# Example usage\n",
 92:     "block_sizes = [5, 8, 10]  # Sizes of each block\n",
 93:     "p_matrix = np.array([[0, 0.1, 0.5],\n",
 94:     "                     [0.1, 0.6, 0.1],\n",
 95:     "                     [0.5, 0.1, 0.8]])  # Full inter-block connectivity matrix\n",
 96:     "\n",
 97:     "plot_sbm_graph(block_sizes, p_matrix)\n"
 98:    ]
 99:   },
100:   {
101:    "cell_type": "code",
102:    "execution_count": null,
103:    "metadata": {},
104:    "outputs": [],
105:    "source": []
106:   }
107:  ],
108:  "metadata": {
109:   "kernelspec": {
110:    "display_name": "anon_sbm",
111:    "language": "python",
112:    "name": "python3"
113:   },
114:   "language_info": {
115:    "codemirror_mode": {
116:     "name": "ipython",
117:     "version": 3
118:    },
119:    "file_extension": ".py",
120:    "mimetype": "text/x-python",
121:    "name": "python",
122:    "nbconvert_exporter": "python",
123:    "pygments_lexer": "ipython3",
124:    "version": "3.13.0"
125:   }
126:  },
127:  "nbformat": 4,
128:  "nbformat_minor": 2
129: }

================
File: planted_partitions/undirected_planted_partitions.py
================
  1: #!/usr/bin/env python3
  2: """
  3: undirected_planted_partition.py
  4: --------------------------------
  5: Simple smoke-test for the swap-only MCMC implementation.
  6: For each of 100 independent repetitions we
  7: 1.  Draw an undirected 100-node SBM with
  8:         â B = 10 blocks of size 10
  9:         â p_in  = 0.30   (within-block connection probability)
 10:         â p_out = 0.05   (between-block probability)
 11: 2.  Build an initial *random* equal-size partition with
 12:         UniformSmallBlockAssigner(min_block_size=10)             (code in block_assigner.py)
 13: 3.  Run the adaptive swap-only MCMC for `n_iter` iterations.
 14: 4.  Compute the Jaccard index between
 15:         â the set of node pairs co-clustered in the *final* state, and
 16:         â the same set for the planted partition.
 17: The script prints the mean, standard deviation and a histogram
 18: of the 100 Jaccard scores so you can eyeball whether the sampler
 19: typically finds the planted structure.
 20: Dependencies
 21: ------------
 22: Only `numpy`, `scipy` and the local `sbm` package (already required by
 23: your project).
 24: Author: Von NÃ¸genmand
 25: """
 26: from typing import Sequence, Hashable
 27: from collections.abc import Sequence
 28: import numpy as np
 29: from scipy.sparse import csr_array
 30: from scipy.optimize import linear_sum_assignment
 31: from sklearn.metrics import (
 32:     adjusted_rand_score,
 33:     normalized_mutual_info_score,
 34: )
 35: from tqdm import tqdm
 36: from sbm.graph_data import GraphData
 37: from sbm.block_assigner import (
 38:     UniformSmallBlockAssigner,
 39:     MetisBlockAssigner,
 40: )
 41: from sbm.model import SBMModel
 42: ###############################################################################
 43: # utility helpers
 44: ###############################################################################
 45: def planted_blocks(n_nodes: int, block_size: int, rng) -> dict[int, int]:
 46:     """Random planted partition: block 0 â nodes 0â9, block 1 â 10â19, â¦"""
 47:     random_nodes = rng.permutation(n_nodes)
 48:     # generate a random list of blocks for the nodes ensuring the correct block size
 49:     random_blocks = np.arange(n_nodes) // block_size
 50:     random_blocks = rng.permutation(random_blocks)
 51:     return {v: block for (v, block) in zip(random_nodes, random_blocks)}
 52: def sample_sbm(rng: np.random.Generator,
 53:                blocks: dict[int, int],
 54:                p_in: float,
 55:                p_out: float) -> csr_array:
 56:     """Generate an undirected loop-free adjacency matrix for a binary SBM."""
 57:     n = len(blocks)
 58:     adj = np.zeros((n, n), dtype=np.int8)
 59:     # probability matrix look-up
 60:     for u in range(n):
 61:         for v in range(u + 1, n):          # u < v â strict upper triangle
 62:             p = p_in if blocks[u] == blocks[v] else p_out
 63:             if rng.random() < p:
 64:                 adj[u, v] = adj[v, u] = 1  # symmetrise
 65:     return csr_array(adj)                 # sparse CSR
 66: def misclassification_rate(
 67:     true_labels: Sequence[Hashable],
 68:     est_labels: Sequence[Hashable],
 69: ) -> float:
 70:     """
 71:     Percentage of vertices whose community label is wrong *after*
 72:     optimally permuting the estimated labels to match the true ones.
 73:     Parameters
 74:     ----------
 75:     true_labels : sequence
 76:         Ground-truth block labels â length N.
 77:     est_labels  : sequence
 78:         Estimated block labels  â length N.
 79:     Returns
 80:     -------
 81:     float
 82:         Mis-classification rate in the interval [0, 1].
 83:     Notes
 84:     -----
 85:     * Label sets may use arbitrary hashables (str, int, â¦) and need not
 86:       have the same cardinality.  Any surplus estimated or true blocks
 87:       are matched to âdummyâ columns/rows filled with zeros.
 88:     * Uses the Hungarian algorithm (via `scipy.optimize.linear_sum_assignment`)
 89:       to maximise the number of correctly matched vertices.
 90:     """
 91:     true = np.asarray(true_labels)
 92:     est  = np.asarray(est_labels)
 93:     if true.shape != est.shape:
 94:         raise ValueError("true_labels and est_labels must have the same length")
 95:     # Map arbitrary labels to contiguous integers 0..T-1 and 0..E-1
 96:     true_ids,  true_inv  = np.unique(true, return_inverse=True)
 97:     est_ids,   est_inv   = np.unique(est,  return_inverse=True)
 98:     T, E = len(true_ids), len(est_ids)
 99:     N    = len(true)
100:     # Build contingency matrix C[e, t] = |{ i : est_i=e and true_i=t }|
101:     C = np.zeros((E, T), dtype=int)
102:     np.add.at(C, (est_inv, true_inv), 1)
103:     # Pad to square (Hungarian implementation needs it or we need to
104:     # maximise on rectangles by padding zeros).
105:     if E != T:
106:         dim = max(E, T)
107:         C_padded = np.zeros((dim, dim), dtype=int)
108:         C_padded[:E, :T] = C
109:         C = C_padded
110:     # Maximise trace(C[perm])  â  minimise âC for Hungarian
111:     row_ind, col_ind = linear_sum_assignment(-C)
112:     matched = C[row_ind, col_ind].sum()
113:     return 1.0 - matched / N
114: ###############################################################################
115: # main loop
116: ###############################################################################
117: def main(
118:     n_nodes = 100,
119:     block_size = 10,
120:     p_in = 0.30,
121:     p_out = 0.05,
122:     n_experiments = 10,
123:     n_iter = 3_000,
124:     rng_master = np.random.default_rng(42),
125:     temperature: float = 1
126: ):
127:     init_scores = []
128:     final_scores = []
129:     for rep in tqdm(range(n_experiments)):
130:         rng = np.random.default_rng(rng_master.integers(2**32))
131:         # --- 1. plant graph -----------------------------------------------------
132:         planted = planted_blocks(n_nodes, block_size, rng)
133:         adj     = sample_sbm(rng, planted, p_in, p_out)
134:         # --- 2. initial random partition ---------------------------------------
135:         gdata    = GraphData(adjacency_matrix=adj, directed=False)
136:         assigner = MetisBlockAssigner(graph_data=gdata,
137:                                             rng=rng,
138:                                             min_block_size=block_size
139:                                         )
140:         init_blocks = assigner.compute_assignment()
141:         init_scores.append(
142:             misclassification_rate(
143:                 true_labels=list(planted.values()),
144:                 est_labels=list(init_blocks.blocks.values())
145:             )
146:         )
147:         sbm = SBMModel(
148:                 initial_blocks=init_blocks,
149:                 rng=rng,
150:                 log=True,  # no logging
151:             )
152:         print(f"Initial ll {sbm.likelihood_calculator.ll:.3f}")
153:         sbm.fit(num_iterations=n_iter,
154:                 min_block_size=block_size,
155:                 initial_temperature=temperature,
156:                 cooling_rate=0.999)
157:         final_blocks = sbm.get_block_assignments()
158:         # --- 4. score -----------------------------------------------------------
159:         final_scores.append(
160:             misclassification_rate(
161:                 true_labels=list(planted.values()),
162:                 est_labels=list(final_blocks.values())
163:             )
164:         )
165:     # --- print results ----------------------------------------------------------
166:     print(f"Initial misclassification rate: {np.mean(init_scores):.3f} Â± {np.std(init_scores):.3f}")
167:     print(f"Final misclassification rate:   {np.mean(final_scores):.3f} Â± {np.std(final_scores):.3f}")
168: if __name__ == "__main__":
169:     main(
170:         n_nodes=300,
171:         block_size=3,
172:         p_in=0.5,
173:         p_out=0.01,
174:         n_experiments=1,
175:         n_iter=5_000,
176:         rng_master=np.random.default_rng(42),
177:         temperature=1e-2
178:     )

================
File: slurm_scripts/fit_sbm.sh
================
 1: #!/bin/sh
 2: ### General options
 3: #BSUB -q hpc
 4: #BSUB -J anon_sbm_fit
 5: #BSUB -n 1
 6: #BSUB -R "span[hosts=1]"
 7: #BSUB -R "rusage[mem=10GB]"
 8: #BSUB -M 20GB
 9: #BSUB -W 1:00
10: #BSUB -o slurm_outputs/anon_sbm_fit_%J.out
11: #BSUB -e slurm_outputs/anon_sbm_fit_%J.err
12: module purge
13: module load python3/3.12
14: source /zhome/c1/2/109045/anon_sbm_env/bin/activate
15: python3 src/pipelines/fit_sbm.py --fit_config /zhome/c1/2/109045/anon_sbm/configs/sbm_fit_block_size_experiments.yml

================
File: src/data_processing/process_caltech.py
================
 1: """
 2: Script for converting caltech-facebook data to simple edgelist format
 3: change from format:
 4:     %MatrixMarket matrix coordinate pattern symmetric 
 5:     769 769 16656
 6:     5 1
 7:     31 1
 8: to format:
 9:     769 769 16656
10:     5 1
11:     31 1
12: """
13: from pathlib import Path
14: if __name__ == "__main__":
15:     file_path = Path("data/raw/socfb-Caltech36/socfb-Caltech36.mtx")
16:     # read file
17:     with file_path.open("r") as f:
18:         lines = f.readlines()
19:     # process lines
20:     processed_lines = []
21:     # skip first two lines (Matrix Market header)
22:     for idx, line in enumerate(lines):
23:         if idx < 2:
24:             continue
25:         parts = line.split()
26:         if len(parts) >= 2:
27:             processed_lines.append(f"{parts[0]} {parts[1]}\n")
28:     # processed data goes in the "processed" folder in the parent-folder
29:     out_folder_path = Path("data/processed")
30:     out_file_path = out_folder_path / "caltech_fb.edgelist"
31:     # write to output file
32:     out_folder_path.mkdir(parents=True, exist_ok=True)
33:     with out_file_path.open("w") as f:
34:         f.writelines(processed_lines)
35:     print(f"Processed edgelist saved to {out_file_path}")

================
File: src/data_processing/process_congress_twitter.py
================
 1: """
 2: Script for converting congress data to simple edgelist format
 3: change from format:
 4:   0 4 {'weight': 0.002105263157894737}
 5:   0 12 {'weight': 0.002105263157894737}
 6:   0 18 {'weight': 0.002105263157894737}
 7:   0 25 {'weight': 0.004210526315789474}
 8: to format:
 9:   0 4
10:   0 12
11:   0 18
12:   0 25
13: """
14: from pathlib import Path
15: if __name__ == "__main__":
16:     file_path = Path("data/raw/congress_twitter/congress.edgelist")
17:     # read file
18:     with file_path.open("r") as f:
19:         lines = f.readlines()
20:     # process lines
21:     processed_lines = []
22:     for line in lines:
23:         parts = line.split()
24:         if len(parts) >= 2:
25:             processed_lines.append(f"{parts[0]} {parts[1]}\n")
26:     # processed data goes in the "processed" folder in the parent-folder
27:     out_folder_path = Path("data/processed")
28:     out_file_path = out_folder_path / "congress_twitter.edgelist"
29:     # write to output file
30:     out_folder_path.mkdir(parents=True, exist_ok=True)
31:     with out_file_path.open("w") as f:
32:         f.writelines(processed_lines)
33:     print(f"Processed edgelist saved to {out_file_path}")

================
File: src/data_processing/process_email_eu.py
================
 1: """
 2: Script for converting email-eu data to simple edgelist format
 3: change from format:
 4:     582 364 0
 5:     168 472 2797
 6:     168 912 3304
 7:     2 790 4523
 8: to format:
 9:     582 364
10:     168 472
11:     168 912
12:     2 790
13: while removing self-loops and duplicate edges.
14: """
15: from pathlib import Path
16: if __name__ == "__main__":
17:     file_path = Path("data/raw/email_eu/email-Eu-core-temporal.txt")
18:     # read file
19:     with file_path.open("r") as f:
20:         lines = f.readlines()
21:     # process lines
22:     processed_lines = []
23:     edgeset = set()
24:     for line in lines:
25:         parts = line.split()
26:         edge = tuple(sorted(( int(parts[0]), int(parts[1]) )))
27:         if edge not in edgeset:
28:             edgeset.add(edge)
29:             # only keep the first two parts of the line
30:             # and ignore the third part (weight)
31:             # also ignore self-loops
32:             if len(parts) >= 2 and parts[0] != parts[1]:
33:                 processed_lines.append(f"{parts[0]} {parts[1]}\n")
34:     # processed data goes in the "processed" folder in the parent-folder
35:     out_folder_path = Path("data/processed")
36:     out_file_path = out_folder_path / "eu_email.edgelist"
37:     # write to output file
38:     out_folder_path.mkdir(parents=True, exist_ok=True)
39:     with out_file_path.open("w") as f:
40:         f.writelines(processed_lines)
41:     print(f"Processed edgelist saved to {out_file_path}")

================
File: src/data_processing/process_enron_email.py
================
 1: """
 2: Script for converting enron-email data to simple edgelist format
 3: change from format:
 4:     # Directed graph (each unordered pair of nodes is saved once): Email-Enron.txt 
 5:     # Enron email network (edge indicated that email was exchanged, undirected edges)
 6:     # Nodes: 36692 Edges: 367662
 7:     # FromNodeId	ToNodeId
 8:     0	1
 9:     1	0
10:     1	2
11:     1	3
12: to format:
13:     0	1
14:     1	0
15:     1	2
16:     1	3
17: while removing self-loops and duplicate edges.
18: """
19: from pathlib import Path
20: if __name__ == "__main__":
21:     file_path = Path("data/raw/enron_email/email-Enron.txt")
22:     # read file
23:     with file_path.open("r") as f:
24:         lines = f.readlines()
25:     # process lines
26:     processed_lines = []
27:     edgeset = set()
28:     for index, line in enumerate(lines):
29:         if index >= 4:
30:             parts = line.split()
31:             edge = tuple(sorted(( int(parts[0]), int(parts[1]) )))
32:             if edge not in edgeset:
33:                 edgeset.add(edge)
34:                 if parts[0] != parts[1]:
35:                     processed_lines.append(f"{parts[0]} {parts[1]}\n")
36:     # processed data goes in the "processed" folder in the parent-folder
37:     out_folder_path = Path("data/processed")
38:     out_file_path = out_folder_path / "enron_email.edgelist"
39:     # write to output file
40:     out_folder_path.mkdir(parents=True, exist_ok=True)
41:     with out_file_path.open("w") as f:
42:         f.writelines(processed_lines)
43:     print(f"Processed edgelist saved to {out_file_path}")

================
File: src/data_processing/process_lastfm_asia.py
================
 1: """
 2: Script for converting lastfm-asia data to simple edgelist format
 3: remove the header and remove self-loops and duplicate edges.
 4: """
 5: from pathlib import Path
 6: if __name__ == "__main__":
 7:     file_path = Path("data/raw/lastfm_asia/lastfm_asia_edges.csv")
 8:     # read file
 9:     with file_path.open("r") as f:
10:         lines = f.readlines()
11:     # process lines
12:     processed_lines = []
13:     edgeset = set()
14:     for index, line in enumerate(lines):
15:         if index >= 1:
16:             parts = line.split(",")
17:             edge = tuple(sorted(( int(parts[0]), int(parts[1]) )))
18:             if edge not in edgeset:
19:                 edgeset.add(edge)
20:                 if len(parts) >= 1 and parts[0] != parts[1]:
21:                     processed_lines.append(f"{parts[0]} {parts[1]}\n")
22:     # processed data goes in the "processed" folder in the parent-folder
23:     out_folder_path = Path("data/processed")
24:     out_file_path = out_folder_path / "lastfm_asia.edgelist"
25:     # write to output file
26:     out_folder_path.mkdir(parents=True, exist_ok=True)
27:     with out_file_path.open("w") as f:
28:         f.writelines(processed_lines)
29:     print(f"Processed edgelist saved to {out_file_path}")

================
File: src/data_processing/process_wiki_vote.py
================
 1: """
 2: Script for converting wiki-voce data to simple edgelist format
 3: change from format:
 4:     # Directed graph (each unordered pair of nodes is saved once): Wiki-Vote.txt 
 5:     # Wikipedia voting on promotion to administratorship (till January 2008). Directed edge A->B means user A voted on B becoming Wikipedia administrator.
 6:     # Nodes: 7115 Edges: 103689
 7:     # FromNodeId	ToNodeId
 8:     30	1412
 9:     30	3352
10:     30	5254
11: to format:
12:     30	1412
13:     30	3352
14:     30	5254
15: while removing self-loops and duplicate edges.
16: """
17: from pathlib import Path
18: if __name__ == "__main__":
19:     file_path = Path("data/raw/wiki_vote/wiki-vote.txt")
20:     # read file
21:     with file_path.open("r") as f:
22:         lines = f.readlines()
23:     # process lines
24:     processed_lines = []
25:     edgeset = set()
26:     for index, line in enumerate(lines):
27:         if index >= 4:
28:             parts = line.split()
29:             edge = tuple(sorted(( int(parts[0]), int(parts[1]) )))
30:             if edge not in edgeset:
31:                 edgeset.add(edge)
32:                 # only keep the first two parts of the line
33:                 # and ignore the third part (weight)
34:                 # also ignore self-loops
35:                 if parts[0] != parts[1]:
36:                     processed_lines.append(f"{parts[0]} {parts[1]}\n")
37:     # processed data goes in the "processed" folder in the parent-folder
38:     out_folder_path = Path("data/processed")
39:     out_file_path = out_folder_path / "wiki_vote.edgelist"
40:     # write to output file
41:     out_folder_path.mkdir(parents=True, exist_ok=True)
42:     with out_file_path.open("w") as f:
43:         f.writelines(processed_lines)
44:     print(f"Processed edgelist saved to {out_file_path}")

================
File: src/metrics/__init__.py
================
 1: from .shortest_path import shortest_path_distance, avg_path_length_difference
 2: from .degree import degree_distance
 3: from .clustering import clustering_distance, avg_clustering_difference
 4: from .spectral import eigen_subspace_distance
 5: from .embedding import embedding_node2vec_ip_emd, embedding_prone_ip_emd
 6: from .community import infomap_codelength_difference, leiden_modularity_difference
 7: from .assortativity import assortativity_difference
 8: # registry maps a short name -> call-able
 9: REGISTRY = {
10:     "shortest_path": shortest_path_distance,
11:     "avg_path_length": avg_path_length_difference,
12:     "degree": degree_distance,
13:     "clustering": clustering_distance,
14:     "avg_clustering": avg_clustering_difference,
15:     "spectral": eigen_subspace_distance,
16:     "infomap": infomap_codelength_difference,
17:     "assortativity": assortativity_difference,
18:     "modularity": leiden_modularity_difference,
19:     "embedding_node2vec": embedding_node2vec_ip_emd,
20:     "embedding_prone": embedding_prone_ip_emd,
21: }

================
File: src/sbm/utils/logger.py
================
 1: # sbm/utils/logger.py
 2: import csv
 3: import time
 4: from pathlib import Path
 5: from typing import Union, TextIO
 6: class CSVLogger:
 7:     """
 8:     Minimal CSV logger for long-running SBM fits.
 9:     Each row contains:
10:         iteration, elapsed_seconds, neg_log_likelihood,
11:         accept_rate_window, temperature
12:     Parameters
13:     ----------
14:     file : str | pathlib.Path | TextIO
15:         Where to write.  If a path is given and the file does not yet
16:         exist, a header row is written automatically.
17:     log_every : int
18:         Only rows for which ``iteration % log_every == 0`` are written.
19:     """
20:     header = [
21:         "iteration",
22:         "elapsed_seconds",
23:         "neg_log_likelihood",
24:         "accept_rate_window",
25:         "temperature",
26:     ]
27:     def __init__(self,
28:                  file: Union[str, Path, TextIO],
29:                  *,
30:                  log_every: int = 1000,
31:                  ):
32:         self.log_every = int(log_every)
33:         self._start = time.time()
34:         # if prior log file exists, delete
35:         if isinstance(file, (str, Path)):
36:             file = Path(file)
37:             if file.exists():
38:                 file.unlink()
39:         # open the handle
40:         if isinstance(file, (str, Path)):
41:             self._own_handle = True
42:             path = Path(file)
43:             path.parent.mkdir(parents=True, exist_ok=True)
44:             first = not path.exists()
45:             self._fh = path.open("a", newline="")
46:             self._writer = csv.writer(self._fh)
47:             if first:
48:                 self._writer.writerow(self.header)
49:         else:                                  # file-like object supplied
50:             self._own_handle = False
51:             self._fh: TextIO = file
52:             self._writer = csv.writer(self._fh)
53:             # assume caller already wrote header
54:     # -----------------------------------------------------------------
55:     def log(self,
56:             iteration: int,
57:             neg_loglike: float,
58:             accept_rate_window: float,
59:             temperature: float,
60:             ) -> None:
61:         """
62:         Append a row
63:         """
64:         elapsed = time.time() - self._start
65:         self._writer.writerow([
66:             iteration,
67:             f"{elapsed:.3f}",
68:             f"{neg_loglike:.6f}",
69:             f"{accept_rate_window:.6f}",
70:             f"{temperature:.6f}",
71:         ])
72:         self._fh.flush()
73:     # -----------------------------------------------------------------
74:     def close(self):
75:         if self._own_handle:
76:             self._fh.close()
77:     # allow usage as a context manager -------------------------------
78:     def __enter__(self):
79:         return self
80:     def __exit__(self, exc_type, exc, tb):
81:         self.close()

================
File: src/sbm/utils/pipeline_utils.py
================
  1: from typing import Dict, Union, TypedDict, List, Literal
  2: from pathlib import Path
  3: import numpy as np
  4: import scipy.sparse as sp
  5: def load_csr_npz(fn: Path):
  6:     with np.load(fn) as z:
  7:         return sp.csr_matrix(
  8:             (z["data"], z["indices"], z["indptr"]),
  9:             shape=z["shape"]
 10:         )
 11: InitMethodName = Literal["metis", "random", "ProneKMeans"]
 12: class DatasetSpec(TypedDict):
 13:     name: str
 14:     path: str
 15: class SBMConfig(TypedDict):
 16:     force_undirected: bool
 17:     min_block_size: int
 18:     n_iter: int
 19:     temperature: float
 20:     cooling_rate: float
 21:     init_method: InitMethodName
 22: class LoggingConfig(TypedDict):
 23:     logging_folder: str
 24:     log_every: int
 25: class FitConfig(TypedDict):
 26:     seed: int
 27:     sbm: SBMConfig
 28:     logging: LoggingConfig
 29:     datasets: List[DatasetSpec]
 30: class EvalConfig(TypedDict):
 31:     n_surrogates: int
 32:     overwrite: bool
 33:     metrics: List[str]
 34: def clean_filename(name: str) -> str:
 35:     """
 36:     Clean the name of all special characters and spaces, replacing them with underscores.
 37:     """
 38:     name = name.replace(":", "_")
 39:     name = name.replace(".", "_")
 40:     name = name.replace(",", "_")
 41:     return name
 42: def sbmfit_folderpath(
 43:     base_dir: Path,
 44:     sbm_config: SBMConfig,
 45:     data_spec: DatasetSpec,
 46: ) -> Path:
 47:     """
 48:     Generate the folderpath for storing a fitted SBM model based on the fit configuration.
 49:     Filename is created by unrolling the fit_config dictionary, using all fields and their values. 
 50:     :param name: Name of the dataset. 
 51:     """
 52:     folder_name = data_spec["name"] + "_" + "_".join(
 53:         f"{k}_{v}" for k, v in sorted(sbm_config.items())
 54:     )
 55:     folder_name = clean_filename(folder_name)
 56:     return base_dir / f"sbm_fit_{folder_name}"
 57: def surrogate_statistics_filename(
 58:     base_dir: Path,
 59:     eval_configs: EvalConfig,
 60:     sbm_config: SBMConfig,
 61:     data_spec: DatasetSpec,
 62: ) -> Path:
 63:     """
 64:     Generate the folfor surrogate statistics based on evaluation and fit configurations.
 65:     :param eval_configs: Evaluation configuration dictionary.
 66:     :param fit_config: Fit configuration dictionary.
 67:     :return: Path object representing the filename.
 68:     """
 69:     file_name = (
 70:         f"{data_spec['name']}_"
 71:         f"surrogates_{eval_configs['n_surrogates']}_"
 72:         f"{'_'.join(eval_configs['metrics'])}_"
 73:         f"{'_'.join(f'{k}_{v}' for k, v in sorted(sbm_config.items()))}"
 74:     )
 75:     file_name = clean_filename(file_name)
 76:     return base_dir / f"{file_name}.csv"
 77: def dataset_filepath(
 78:     base_dir: Path,
 79:     dataset_name: str,
 80: )-> Path:
 81:     """
 82:     Generate the filepath for a dataset based on its name.
 83:     :param base_dir: Base directory where datasets are stored.
 84:     :param dataset_name: Name of the dataset.
 85:     :return: Path object representing the dataset file path.
 86:     """
 87:     dataset_name = clean_filename(dataset_name)
 88:     return base_dir / f"{dataset_name}.npz"
 89: ##### Helper functions #####
 90: def fit_config_to_dicts(fit_config: FitConfig) -> List[dict[str, str]]:
 91:     """ 
 92:     Convert FitConfig to a list of DatasetSpec dictionaries.
 93:     One dictionary per dataset.
 94:     """
 95:     configs = [
 96:         {
 97:             "name": ds["name"],
 98:             "path": ds["path"],
 99:             **fit_config["sbm"],
100:         }
101:         for ds in fit_config["datasets"]
102:     ]
103:     for config in configs:
104:         if "seed" in config:
105:             config["seed"] = str(fit_config["seed"])
106:     return configs
107: def eval_config_to_dict(eval_config: EvalConfig) -> dict[str, str]:
108:     """
109:     Convert EvalConfig to a dictionary.
110:     """
111:     return {
112:         "n_surrogates": str(eval_config["n_surrogates"]),
113:         "metrics": "_".join(
114:                 eval_config["metrics"]    
115:             )
116:     }

================
File: src/sbm/initial_partition.py
================
 1: import numpy as np
 2: import scipy.sparse as sp
 3: from scipy.sparse.linalg import eigsh
 4: from typing import Dict, Optional
 5: from sklearn.cluster import KMeans
 6: from scipy.sparse import csr_matrix
 7: class SpectralPartitioner:
 8:     def __init__(self, adjacency: csr_matrix, seed: Optional[int] = None):
 9:         """
10:         Initialize the SpectralPartitioner.
11:         :param adjacency: The adjacency matrix of the network (sparse CSR matrix).
12:         :param seed: Random seed for reproducibility.
13:         """
14:         self.adjacency: csr_matrix = adjacency.tocsr()
15:         self.num_nodes: int = self.adjacency.shape[0]
16:         self.rng = np.random.default_rng(seed)
17:         self.degree_vector = np.array(self.adjacency.sum(axis=1)).flatten()
18:         self.laplacian = self._compute_normalized_laplacian()
19:     def _compute_normalized_laplacian(self) -> csr_matrix:
20:         """
21:         Compute the normalized Laplacian matrix of the graph.
22:         :return: The normalized Laplacian matrix (sparse CSR matrix).
23:         """
24:         # Avoid division by zero
25:         with np.errstate(divide='ignore'):
26:             d_inv_sqrt = np.power(self.degree_vector, -0.5)
27:             d_inv_sqrt[np.isinf(d_inv_sqrt)] = 0.0
28:         D_inv_sqrt = sp.diags(d_inv_sqrt)
29:         L = sp.eye(self.num_nodes) - D_inv_sqrt @ self.adjacency @ D_inv_sqrt
30:         return L
31:     def partition(self, num_blocks: int) -> Dict[int, int]:
32:         """
33:         Partition the nodes into blocks using spectral clustering.
34:         :param num_blocks: The desired number of blocks.
35:         :return: A dictionary mapping node indices to block indices.
36:         """
37:         # Compute the first (num_blocks) eigenvectors of the normalized Laplacian
38:         # Use 'SM' to find eigenvalues closest to zero
39:         eigenvalues, eigenvectors = eigsh(
40:             self.laplacian, k=num_blocks, which='SM', tol=1e-6, maxiter=5000
41:         )
42:         # Normalize rows to unit length to improve clustering
43:         embedding = eigenvectors
44:         row_norms = np.linalg.norm(embedding, axis=1, keepdims=True)
45:         row_norms[row_norms == 0] = 1e-10  # Avoid division by zero
46:         embedding_normalized = embedding / row_norms
47:         # Use k-means clustering on the spectral embeddings
48:         kmeans = KMeans(n_clusters=num_blocks, random_state=self.rng.integers(1 << 32))
49:         labels = kmeans.fit_predict(embedding_normalized)
50:         # Map nodes to blocks
51:         blocks = {node: int(label) for node, label in enumerate(labels)}
52:         return blocks

================
File: src/sbm/sampling.py
================
  1: """ 
  2: Functions for sampling graph from SBM model
  3: """
  4: # sbm/sampling.py
  5: from typing import List, Optional
  6: import numpy as np
  7: from scipy.sparse import csr_array, coo_matrix
  8: from sbm.graph_data import GraphData
  9: from sbm.io import SBMFit
 10: def sample_adjacency_matrix(
 11:     block_sizes: List[int],
 12:     block_connectivity: csr_array,
 13:     rng: np.random.Generator,
 14:     directed: bool = False,
 15: ) -> csr_array:
 16:     """
 17:     Draw a random graph from the *profile* Bernoulli SBM specified by
 18:     `block_edge_counts` (edge counts m_rs) and `block_sizes`.
 19:     :param block_sizes: Sizes of the blocks.
 20:     :param block_connectivity: Sparse matrix of edge counts m_rs between blocks.
 21:     :param directed: Whether the graph is directed or undirected.
 22:     :param rng: Random number generator for reproducibility.
 23:     :return: Sparse adjacency matrix of the sampled graph.
 24:     """
 25:     block_sizes = list(map(int, block_sizes))
 26:     B = len(block_sizes)
 27:     N = sum(block_sizes)
 28:     # cumulative offsets â map local idx â global idx
 29:     offsets = np.cumsum([0] + block_sizes)
 30:     rows: list[int] = []
 31:     cols: list[int] = []
 32:     # ------------------------------------------------------------------
 33:     for r in range(B):
 34:         n_r = block_sizes[r]
 35:         off_r = offsets[r]
 36:         # -- diagonal block -------------------------------------------
 37:         m_rr = int(block_connectivity[r, r]) # type: ignore
 38:         if m_rr:
 39:             if directed:
 40:                 n_poss = n_r * (n_r - 1)
 41:                 p = m_rr / n_poss
 42:                 mask = (rng.random((n_r, n_r)) < p).astype(int)
 43:                 mask[np.diag_indices(n_r)] = 0
 44:                 rr, cc = np.nonzero(mask)
 45:                 rows.extend(off_r + rr)
 46:                 cols.extend(off_r + cc)
 47:             else:
 48:                 n_poss = n_r * (n_r - 1) // 2
 49:                 p = m_rr / n_poss
 50:                 triu_mask = rng.random((n_r, n_r)) < p
 51:                 tri_r, tri_c = np.triu_indices(n_r, k=1)
 52:                 sel = triu_mask[tri_r, tri_c]
 53:                 rr = tri_r[sel]; cc = tri_c[sel]
 54:                 rows.extend(off_r + rr)
 55:                 cols.extend(off_r + cc)
 56:                 rows.extend(off_r + cc)
 57:                 cols.extend(off_r + rr)
 58:         # -- off-diagonal blocks --------------------------------------
 59:         s_iter = range(B) if directed else range(r + 1, B)
 60:         for s in s_iter:
 61:             if s == r:
 62:                 continue
 63:             m_rs = int(block_connectivity[r, s]) # type: ignore
 64:             if m_rs == 0:
 65:                 continue
 66:             n_s = block_sizes[s]
 67:             off_s = offsets[s]
 68:             n_poss = n_r * n_s
 69:             p = m_rs / n_poss
 70:             mask = rng.random((n_r, n_s)) < p
 71:             rr, cc = np.nonzero(mask)
 72:             rows.extend(off_r + rr)
 73:             cols.extend(off_s + cc)
 74:             if not directed:
 75:                 # mirror block
 76:                 rows.extend(off_s + cc)
 77:                 cols.extend(off_r + rr)
 78:     data = np.ones(len(rows), dtype=np.int8)
 79:     adj = coo_matrix((data, (rows, cols)), shape=(N, N))
 80:     # ensure no duplicate edge
 81:     adj.sum_duplicates() 
 82:     adj.data.fill(1)
 83:     # convert to csr format
 84:     adj = csr_array(adj)
 85:     adj.sort_indices()
 86:     return adj
 87: def sample_sbm_graph(
 88:             block_sizes: List[int],
 89:             block_connectivity: csr_array,
 90:             directed:bool,
 91:             rng: np.random.Generator,
 92:             metadata: Optional[dict] = None
 93:     )->GraphData:
 94:     """
 95:     Sample a graph from a Stochastic Block Model (SBM) given block sizes and connectivity.
 96:     :param block_sizes: List of sizes for each block.
 97:     :param block_connectivity: Sparse matrix representing connectivity between blocks.
 98:     :param directed: Whether the graph is directed or undirected.
 99:     :param rng: Random number generator for reproducibility.
100:     :param metadata: Optional metadata to include in the graph data.
101:     :return: GraphData object containing the sampled graph.
102:     """
103:     if metadata is None:
104:         metadata = {}
105:     # Validate inputs
106:     if not isinstance(block_sizes, list) or not all(isinstance(size, int) for size in block_sizes):
107:         raise ValueError("block_sizes must be a list of integers.")
108:     if not isinstance(block_connectivity, csr_array):
109:         raise ValueError("block_connectivity must be a scipy.sparse.csr_array.")
110:     if len(block_sizes) != block_connectivity.shape[0] or len(block_sizes) != block_connectivity.shape[1]: #type: ignore
111:         raise ValueError("block_sizes length must match the dimensions of block_connectivity.")
112:     if not isinstance(directed, bool):
113:         raise ValueError("directed must be a boolean value.")
114:     if not isinstance(rng, np.random.Generator):
115:         raise ValueError("rng must be a numpy random Generator instance.")    
116:     adj = sample_adjacency_matrix(
117:         block_sizes=block_sizes,
118:         block_connectivity=block_connectivity,
119:         directed=directed,
120:         rng=rng
121:     )
122:     return GraphData(adjacency_matrix=adj, directed=directed)
123: def sample_sbm_graph_from_fit(sbm_fit: SBMFit, rng: np.random.Generator) -> GraphData:
124:     """
125:     Sample a graph from a Stochastic Block Model (SBM) fit.
126:     :param sbm_fit: SBMFit object containing block sizes and connectivity.
127:     :param rng: Random number generator for reproducibility.
128:     :return: GraphData object containing the sampled graph.
129:     """
130:     return sample_sbm_graph(
131:         block_sizes=sbm_fit.block_sizes,
132:         block_connectivity=sbm_fit.block_conn,
133:         directed=sbm_fit.directed_graph,
134:         rng=rng,
135:         metadata=sbm_fit.metadata
136:     )

================
File: src/sbm/stopping_criteria.py
================
 1: """ 
 2: Stopping criteria for the MCMC algorithm in the Stochastic Block Model (SBM).
 3: """
 4: class StoppingCriteria:
 5:     """
 6:     Base class for stopping criteria in the MCMC algorithm.
 7:     """
 8:     def __init__(self, stopping_configs: dict):
 9:         pass
10:     def should_stop(self, iteration: int, current_ll: float) -> bool:
11:         """
12:         Check if the stopping criteria are met.
13:         :param iteration: Current iteration number.
14:         :param current_ll: Current log-likelihood value.
15:         :return: True if the algorithm should stop, False otherwise.
16:         """
17:         raise NotImplementedError("Subclasses should implement this method.")

================
File: src/tests/planted_partition_tests.py
================
 1: # src/tests/test_regressions.py
 2: """
 3: Targeted regression tests for issues uncovered in the plantedâpartition script.
 4: * size-1 blocks must not crash likelihood computation
 5: * Î-dicts must use *matrix indices*, not block-IDs
 6: """
 7: import numpy as np
 8: import pytest
 9: from scipy.sparse import csr_array
10: from sbm.block_data import BlockData
11: from sbm.likelihood import compute_global_bernoulli_ll
12: from sbm.block_change_proposers import NodeSwapProposer
13: from sbm.block_data import BlockData
14: from sbm.graph_data import GraphData
15: # -------------------------------------------------------------------
16: # 1. size-1 diagonal must be ignored (or handled gracefully)
17: # -------------------------------------------------------------------
18: @pytest.mark.parametrize("singletons", [1, 3])
19: def test_singleton_blocks_allowed(singletons):
20:     """
21:     A partition containing blocks of size 1 must not raise or return NaN.
22:     """
23:     n = 6
24:     # make a path graph (any sparse graph works)
25:     rows = np.arange(n-1)
26:     cols = rows + 1
27:     data = np.ones(n-1, dtype=int)
28:     A = csr_array((data, (rows, cols)), shape=(n, n))
29:     A = A + A.T
30:     # put the first `singletons` nodes into their own blocks
31:     blocks = {v: v if v < singletons else singletons for v in range(n)}
32:     bd = BlockData(
33:         initial_blocks=blocks,
34:         graph_data=GraphData(adjacency_matrix=A, directed=False)
35:     )
36:     ll = compute_global_bernoulli_ll(bd)
37:     assert np.isfinite(ll), "likelihood should be finite even with size-1 blocks"
38: # -------------------------------------------------------------------
39: # 2. Î-dicts must reference matrix indices, not block-IDs
40: # -------------------------------------------------------------------
41: def test_delta_keys_are_matrix_indices():
42:     """
43:     When block IDs are non-contiguous (e.g. {0,10}), the delta_e keys
44:     must still be *matrix indices* (0 or 1), otherwise the likelihood
45:     updater crashes with an IndexError.
46:     """
47:     # two blocks with ids 0 and 10, one edge across
48:     adj = csr_array([[0,1],[1,0]])
49:     blocks = {0: 0, 1: 10}
50:     bd = BlockData(
51:         initial_blocks=blocks,
52:         graph_data=GraphData(adjacency_matrix=adj, directed=False)
53:     )
54:     proposer = NodeSwapProposer(bd)
55:     swap = [(0, 10)]  # move node 0 to block 10 -> will create a singleton & trigger Î
56:     _, delta_e, _ = proposer.propose_change(swap)
57:     # the only valid matrix indices are 0 and 1
58:     valid = {0,1}
59:     for (r, s) in delta_e:
60:         assert r in valid and s in valid, (
61:             "delta_e must use matrix indices (0..B-1), "
62:             "not raw block IDs"
63:         )

================
File: src/tests/test_block_assigner.py
================
  1: """PyTest suites for structural blockâmodel code.
  2: These unit tests focus on two invariants that *must* hold for the current
  3: pipeline:
  4: 1. **MetisBlockAssigner should only emit blocks whose sizes are either
  5:    `min_block_size` or `min_block_size + 1`.**  (Because the assigner first
  6:    builds blocks of exactly `min_block_size` vertices and then distributes any
  7:    leftovers oneâbyâone.)
  8: 2. **A SWAP move in the MCMC sampler must leave every block size unchanged.**
  9: The tests rely only on public APIs plus `_attempt_move`, which is part of the
 10: MCMC samplerâs stable interface (it is used by `fit` internally).  If the
 11: namesÂ or module paths differ in your codebase, tweak the imports at the top of
 12: each file â the assertions themselves should stay valid.
 13: Run with::
 14:     pytest -q tests/
 15: """
 16: # ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
 17: # tests/test_block_assigner.py
 18: # ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
 19: import networkx as nx
 20: import numpy as np
 21: import pytest
 22: # Adjust the import path to wherever MetisBlockAssigner lives in your project
 23: from sbm.block_assigner import MetisBlockAssigner
 24: from sbm.block_assigner import ProNEAndConstrKMeansAssigner
 25: from sbm.graph_data import gd_from_networkx
 26: @pytest.mark.parametrize(
 27:     "num_nodes,num_blocks,min_block_size,edge_p",
 28:     [
 29:         (97, 10, 8, 0.05),
 30:         (50, 5, 6, 0.10),
 31:         (23, 4, 5, 0.30),
 32:         (128, 16, 7, 0.02),
 33:     ],
 34: )
 35: def test_metis_block_sizes_are_balanced(num_nodes, num_blocks, min_block_size, edge_p):
 36:     """The initial partition must use only *min* and *min+1* sized blocks."""
 37:     G = nx.erdos_renyi_graph(
 38:             n=num_nodes,
 39:             p=edge_p,
 40:             seed=1,
 41:             directed=False
 42:         )
 43:     graph_data = gd_from_networkx(G)
 44:     assigner = MetisBlockAssigner(
 45:         graph_data=graph_data,
 46:         num_blocks=num_blocks,
 47:         min_block_size=min_block_size,
 48:         rng=np.random.default_rng(42),
 49:     )
 50:     block_data = assigner.compute_assignment()
 51:     # ensure that block_sizes correspond to 
 52:     # Ensure every vertex received exactly one label
 53:     assert len(block_data.blocks) == num_nodes
 54:     # Compute blockâsize histogram
 55:     _, counts = np.unique(
 56:         list(block_data.blocks.values()),
 57:         return_counts=True
 58:         )
 59:     # All block sizes must be either min_block_size or min_block_size+1
 60:     assert (counts >= min_block_size).all(), \
 61:         (
 62:             "MetisBlockAssigner produced illegal block sizes: "
 63:             f"{sorted(set(counts))}. Expected larger than {min_block_size}."
 64:         )
 65:     # The partition must contain exactly *num_blocks* nonâempty blocks.
 66:     assert len(counts) == num_blocks
 67: def test_ProNEKMeans_block_sizes_are_balanced():
 68:     """The ProNEKMeans assigner must also use only *min* and *min+1* sized blocks."""
 69:     num_nodes = 100
 70:     min_block_size = 8
 71:     num_blocks = num_nodes // min_block_size
 72:     edge_p = 0.05
 73:     G = nx.erdos_renyi_graph(
 74:             n=num_nodes,
 75:             p=edge_p,
 76:             seed=1,
 77:             directed=False
 78:         )
 79:     graph_data = gd_from_networkx(G)
 80:     assigner = ProNEAndConstrKMeansAssigner(
 81:         graph_data=graph_data,
 82:         min_block_size=min_block_size,
 83:         rng=np.random.default_rng(42),
 84:     )
 85:     block_data = assigner.compute_assignment()
 86:     # ensure that block_sizes correspond to 
 87:     # Ensure every vertex received exactly one label
 88:     assert len(block_data.blocks) == num_nodes, \
 89:         "ProNEKMeansBlockAssigner did not assign a label to every vertex."
 90:     # ensure that block sizes correspond to the number of blocks
 91:     assert len(block_data.block_sizes) == num_blocks  \
 92:         and len(set(block_data.blocks.values())) == num_blocks, \
 93:         "ProNEKMeansBlockAssigner did not produce the expected number of blocks."
 94:     # Compute blockâsize histogram
 95:     _, counts = np.unique(
 96:         list(block_data.blocks.values()),
 97:         return_counts=True
 98:         )
 99:     # All block sizes must be either min_block_size or min_block_size+1
100:     assert (counts >= min_block_size).all(), \
101:         (
102:             "ProNEKMeansBlockAssigner produced illegal block sizes: "
103:             f"{sorted(set(counts))}. Expected larger than {min_block_size}."
104:         )
105:     count_set = set(counts)
106:     # Ensure that the block sizes are either min_block_size or min_block_size + 1
107:     assert count_set.issubset({min_block_size, min_block_size + 1})
108:     # The partition must contain exactly *num_blocks* nonâempty blocks.
109:     assert len(counts) == num_blocks

================
File: src/tests/test_edge_delta.py
================
  1: # tests/test_edge_delta_equivalence.py
  2: """
  3: Unit tests that compare behaviour of sbm.edge_delta.EdgeDelta
  4: and its NumPy-accelerated subclass NumpyEdgeDelta.
  5: The tests are written against the public API actually used by
  6: block-change proposers and the likelihood calculator:
  7:     â¢ increment(counts, blocks_i, blocks_j)              :contentReference[oaicite:0]{index=0}
  8:     â¢ __getitem__, __len__, items                       :contentReference[oaicite:1]{index=1}
  9: """
 10: from __future__ import annotations
 11: import random
 12: from collections import defaultdict
 13: from itertools import combinations
 14: import numpy as np
 15: import pytest
 16: from sbm.edge_delta import EdgeDelta, NumpyEdgeDelta
 17: # --------------------------------------------------------------------------- #
 18: # helpers                                                                     #
 19: # --------------------------------------------------------------------------- #
 20: def _random_updates(
 21:     n_blocks: int,
 22:     n_updates: int,
 23:     *, rng: random.Random
 24: ) -> tuple[list[int], list[int], list[int]]:
 25:     """
 26:     Create a *single* batch of updates without duplicate (i, j) pairs
 27:     â this mirrors how `_compute_delta_edge_counts` builds its argument
 28:     lists before calling ``increment`` once per batch.                   :contentReference[oaicite:2]{index=2}
 29:     """
 30:     pairs = random.sample(list(combinations(range(n_blocks), 2)), k=n_updates)
 31:     counts = [rng.randint(-5, 5) for _ in range(n_updates)]
 32:     blocks_i, blocks_j = zip(*pairs)   # already i < j
 33:     return counts, list(blocks_i), list(blocks_j)
 34: def _build_two_deltas(
 35:     n_blocks: int,
 36:     counts: list[int],
 37:     blocks_i: list[int],
 38:     blocks_j: list[int],
 39: ) -> tuple[EdgeDelta, NumpyEdgeDelta]:
 40:     """
 41:     Convenience wrapper: build and *increment once* â just like the
 42:     real code does.                                                      :contentReference[oaicite:3]{index=3}
 43:     """
 44:     d_py  = EdgeDelta(n_blocks)
 45:     d_np  = NumpyEdgeDelta(n_blocks)
 46:     d_py.increment(counts, blocks_i, blocks_j)
 47:     d_np.increment(counts, blocks_i, blocks_j)
 48:     return d_py, d_np
 49: # --------------------------------------------------------------------------- #
 50: # public API parity tests                                                     #
 51: # --------------------------------------------------------------------------- #
 52: @pytest.mark.parametrize("n_blocks, n_updates, seed", [
 53:     (5,  6,  1),
 54:     (7, 10, 42),
 55:     (3,  2, 99),
 56: ])
 57: def test_increment_equivalence(n_blocks: int, n_updates: int, seed: int) -> None:
 58:     """After an identical batch update, both classes hold exactly the same deltas."""
 59:     rng = random.Random(seed)
 60:     counts, bi, bj = _random_updates(n_blocks, n_updates, rng=rng)
 61:     d_py, d_np = _build_two_deltas(n_blocks, counts, bi, bj)
 62:     # compare through the *public* interface â not private storage
 63:     pairs = set(d_py.items()) | set(d_np.items())
 64:     for (i, j), _ in pairs:
 65:         assert d_py[i, j] == d_np[i, j], \
 66:             f"Mismatch on pair {(i, j)}: python={d_py[i, j]}, numpy={d_np[i, j]}"
 67:     assert len(d_py) == len(d_np), \
 68:         f"__len__ diverged: python={len(d_py)}, numpy={len(d_np)}"
 69:     # full dict comparison (order-independent)
 70:     assert dict(d_py.items()) == dict(d_np.items())
 71: def test_getitem_default_zero() -> None:
 72:     """Both classes must return 0 for unseen (i,j) pairs."""
 73:     d_py  = EdgeDelta(4)
 74:     d_np  = NumpyEdgeDelta(4)
 75:     for pair in ((0, 0), (0, 1), (2, 3)):
 76:         assert d_py[pair] == d_np[pair] == 0
 77: def test_negative_and_positive_counts() -> None:
 78:     """Signed counts stay intact and are *not* silently truncated."""
 79:     counts  = [  5, -3,  2]
 80:     blocks_i = [0, 0, 1]
 81:     blocks_j = [1, 2, 2]
 82:     d_py, d_np = _build_two_deltas(3, counts, blocks_i, blocks_j)
 83:     assert dict(d_py.items()) == { (0, 1): 5, (0, 2): -3, (1, 2): 2 }
 84:     assert dict(d_py.items()) == dict(d_np.items())
 85: # --------------------------------------------------------------------------- #
 86: # integration smoke test â reproduces the exact public call-sequence used
 87: # by `_compute_delta_edge_counts`                                            #
 88: # --------------------------------------------------------------------------- #
 89: def test_two_step_update_matches() -> None:
 90:     """
 91:     `_compute_delta_edge_counts` issues *two* successive ``increment`` calls
 92:     on the *same* EdgeDelta instance.  Here we reproduce that pattern and make
 93:     sure the NumPy implementation yields identical final deltas after both
 94:     steps.                                                                   :contentReference[oaicite:4]{index=4}
 95:     """
 96:     n_blocks = 4
 97:     # step-1: neighbour blocks
 98:     counts1  = [ 2, -1]
 99:     blocks1a = [0, 1]
100:     blocks1b = [2, 2]
101:     # step-2: intra / inter old blocks
102:     counts2  = [ 7, -4, -3]
103:     blocks2a = [0, 0, 1]
104:     blocks2b = [1, 0, 1]
105:     py = EdgeDelta(n_blocks)
106:     npd = NumpyEdgeDelta(n_blocks)
107:     py.increment(counts1, blocks1a, blocks1b)
108:     py.increment(counts2, blocks2a, blocks2b)
109:     npd.increment(counts1, blocks1a, blocks1b)
110:     npd.increment(counts2, blocks2a, blocks2b)
111:     assert dict(py.items()) == dict(npd.items())

================
File: src/tests/test_global_ll.py
================
  1: """Tests that the *slow* and *fast* global Bernoulli logâlikelihood
  2: implementations are numerically identical on a variety of synthetic block
  3: partitions.
  4: We build *real* ``BlockData`` instances by constructing a synthetic graph
  5: (adjacency matrix) whose edge counts per block pair match a prescribed
  6: connectivity matrix.  This avoids touching the rest of the SBM pipeline
  7: while exercising exactly the code paths used by the likelihood routines.
  8: """
  9: from __future__ import annotations
 10: import random
 11: from typing import List, Sequence, Tuple
 12: import numpy as np
 13: import pytest
 14: import scipy.sparse as sp
 15: # ---------------------------------------------------------------------------
 16: # Functions under test
 17: # ---------------------------------------------------------------------------
 18: from sbm.likelihood import (
 19:     compute_global_bernoulli_ll,
 20:     compute_global_bernoulli_ll_fast,
 21: )
 22: from sbm.graph_data import GraphData
 23: # ---------------------------------------------------------------------------
 24: # Utility to create a BlockData instance whose *block_connectivity* matches a
 25: # given integer matrix ``conn`` (undirected only, because BlockData does not
 26: # implement the directed path).
 27: # ---------------------------------------------------------------------------
 28: try:
 29:     from sbm.block_data import BlockData  # type: ignore
 30: except ModuleNotFoundError:  # local fallback
 31:     from block_data import BlockData  # type: ignore
 32: def _node_ranges(sizes: Sequence[int]) -> List[Tuple[int, int]]:
 33:     """Return (start, stop) index for each block (Python halfâopen)."""
 34:     ranges = []
 35:     start = 0
 36:     for sz in sizes:
 37:         ranges.append((start, start + sz))
 38:         start += sz
 39:     return ranges
 40: def build_block_data(
 41:     block_sizes: Sequence[int],
 42:     conn: np.ndarray,
 43:     rng: random.Random,
 44: ) -> BlockData:
 45:     """Construct a *consistent* BlockData (undirected) for testing."""
 46:     B = len(block_sizes)
 47:     assert conn.shape == (B, B)
 48:     assert (conn == conn.T).all(), "Connectivity must be symmetric for undirected graphs."  # noqa: E501
 49:     # Total number of nodes & adjacency matrix
 50:     N = int(sum(block_sizes))
 51:     adj = sp.dok_array((N, N), dtype=np.int64)
 52:     ranges = _node_ranges(block_sizes)
 53:     for r in range(B):
 54:         nodes_r = list(range(*ranges[r]))
 55:         # Diagonal block r==r
 56:         e_rr = int(conn[r, r])
 57:         if e_rr:
 58:             # all unordered pairs inside block
 59:             possible = [(u, v) for i, u in enumerate(nodes_r) for v in nodes_r[i + 1 :]]
 60:             assert e_rr <= len(possible)
 61:             chosen = rng.sample(possible, e_rr)
 62:             for u, v in chosen:
 63:                 adj[u, v] = 1
 64:                 adj[v, u] = 1
 65:         for s in range(r + 1, B):
 66:             e_rs = int(conn[r, s])
 67:             if not e_rs:
 68:                 continue
 69:             nodes_s = list(range(*ranges[s]))
 70:             possible = [(u, v) for u in nodes_r for v in nodes_s]
 71:             assert e_rs <= len(possible)
 72:             chosen = rng.sample(possible, e_rs)
 73:             for u, v in chosen:
 74:                 adj[u, v] = 1
 75:                 adj[v, u] = 1
 76:     adj = adj.tocsr()
 77:     # Blocks mapping: node -> block_id (block IDs are 0..B-1)
 78:     blocks = {node: b for b, (start, stop) in enumerate(ranges) for node in range(start, stop)}
 79:     dummy_graph = GraphData(adj, directed=False)
 80:     return BlockData(initial_blocks=blocks, graph_data=dummy_graph)
 81: # ---------------------------------------------------------------------------
 82: # Sanity helper
 83: # ---------------------------------------------------------------------------
 84: def assert_ll_equal(bd: BlockData):
 85:     ll_slow = compute_global_bernoulli_ll(bd)
 86:     ll_fast = compute_global_bernoulli_ll_fast(bd)
 87:     assert np.isclose(ll_slow, ll_fast, rtol=1e-4, atol=1e-6), f"{ll_slow} != {ll_fast}"
 88: # ==========================================================================
 89: # TEST CASES
 90: # ==========================================================================
 91: # 1) Tiny hand-crafted graph -------------------------------------------------
 92: def test_tiny_example():
 93:     sizes = [3, 4]
 94:     conn = np.array([[2, 5],
 95:                      [5, 1]], dtype=np.int64)
 96:     bd = build_block_data(sizes, conn, rng=random.Random(0))
 97:     assert_ll_equal(bd)
 98: # 2) Singleton block present -------------------------------------------------
 99: def test_singleton_block():
100:     sizes = [1, 5, 2]
101:     conn = np.array([[0, 0, 0],
102:                      [0, 4, 3],
103:                      [0, 3, 1]], dtype=np.int64)
104:     # ensure symmetry
105:     conn = conn + conn.T - np.diag(conn.diagonal())
106:     bd = build_block_data(sizes, conn, rng=random.Random(1))
107:     assert_ll_equal(bd)
108: # 3) Random dense undirected graphs -----------------------------------------
109: @pytest.mark.parametrize("seed,B", [(2, 4), (3, 6)])
110: def test_random_dense(seed: int, B: int):
111:     rng = random.Random(seed)
112:     sizes = [rng.randint(2, 6) for _ in range(B)]
113:     conn = np.zeros((B, B), dtype=np.int64)
114:     for r in range(B):
115:         n_rr = sizes[r] * (sizes[r] - 1) // 2
116:         conn[r, r] = rng.randrange(n_rr + 1)
117:         for s in range(r + 1, B):
118:             n_rs = sizes[r] * sizes[s]
119:             val = rng.randrange(n_rs + 1)
120:             conn[r, s] = conn[s, r] = val
121:     bd = build_block_data(sizes, conn, rng)
122:     assert_ll_equal(bd)

================
File: src/tests/test_greedy_assign_helpers.py
================
  1: import numpy as np
  2: import scipy.sparse as sp
  3: from scipy.sparse import csr_array
  4: import pytest
  5: from collections import Counter, defaultdict
  6: from sbm.block_assigner import (
  7:     _boundary_vertices,
  8:     _movable_vertex,
  9:     _move,
 10:     categorize,
 11:     move_node_to_under,
 12:     move_node_from_over,
 13:     balance_k_plus_1_blocks,
 14:     _rebalance_to_min_size,
 15: )
 16: # ---------------------------------------------------------------------------
 17: # Minimal helper to build a fully connected small graph ---------------------
 18: # ---------------------------------------------------------------------------
 19: def full_graph_csr(n: int) -> csr_array:
 20:     rows, cols = np.triu_indices(n, 1)
 21:     data = np.ones_like(rows)
 22:     A = csr_array((data, (rows, cols)), shape=(n, n))
 23:     A = A + A.T  # undirected
 24:     return A
 25: # ---------------------------------------------------------------------------
 26: # Tests for categorize ------------------------------------------------------
 27: # ---------------------------------------------------------------------------
 28: def test_categorize_basic():
 29:     k = 3
 30:     sizes = {0: 2, 1: 3, 2: 4, 3: 5}
 31:     over2, over1, under = categorize(sizes, k)
 32:     assert over2 == {3}
 33:     assert over1 == {2}
 34:     assert under == {0}
 35: # ---------------------------------------------------------------------------
 36: # Tests for move_node_to_under -------------------------------------------
 37: # ---------------------------------------------------------------------------
 38: def test_move_node_to_under_correct():
 39:     k = 2
 40:     A = full_graph_csr(4)
 41:     # block 0 undersize (1), block 1 oversize (3)
 42:     blocks = {0: 0, 1: 1, 2: 1, 3: 1}
 43:     sizes = Counter(blocks.values())
 44:     members = defaultdict(set)
 45:     for v, b in blocks.items():
 46:         members[b].add(v)
 47:     rng = np.random.default_rng(0)
 48:     over2, over1, under = categorize(sizes, k)
 49:     move_node_to_under(
 50:         under=under,
 51:         over1=over1,
 52:         over2=over2,
 53:         rng=rng,
 54:         sizes=sizes,
 55:         k=k,
 56:         members=members,
 57:         blocks=blocks,
 58:         indptr=A.indptr,
 59:         indices=A.indices,
 60:     )
 61:     # After move, block 0 should have size 2, block 1 size 2
 62:     assert sizes[0] == k
 63:     assert sizes[1] == k
 64:     # No undersized blocks remain
 65:     _, _, under_new = categorize(sizes, k)
 66:     assert not under_new
 67: # ---------------------------------------------------------------------------
 68: # Tests for move_node_from_over --------------------------------------------
 69: # ---------------------------------------------------------------------------
 70: def test_move_node_from_over_shrink():
 71:     k = 3
 72:     A = full_graph_csr(8)
 73:     # block 0 size 2 (<k), block 1 size 6 (>k+1), others size 0
 74:     blocks = {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1}
 75:     sizes = Counter(blocks.values())
 76:     members = defaultdict(set)
 77:     for v, b in blocks.items():
 78:         members[b].add(v)
 79:     rng = np.random.default_rng(1)
 80:     over2, over1, under = categorize(sizes, k)
 81:     move_node_from_over(
 82:         under=under,
 83:         over1=over1,
 84:         over2=over2,
 85:         rng=rng,
 86:         sizes=sizes,
 87:         k=k,
 88:         members=members,
 89:         blocks=blocks,
 90:         indptr=A.indptr,
 91:         indices=A.indices,
 92:         r_target=0,
 93:     )
 94:     # block 0 size should have increased by 1, block1 decreased by1
 95:     assert sizes[0] == 2  # reached k
 96:     assert sizes[1] == 6
 97: # ---------------------------------------------------------------------------
 98: # Tests for balance_k_plus_1_blocks ----------------------------------------
 99: # ---------------------------------------------------------------------------
100: def test_balance_k_plus_1_blocks_shrink_and_enlarge():
101:     k = 2
102:     A = full_graph_csr(6)
103:     # create three blocks: 0 size 3 (k+1), 1 size 3 (k+1), 2 size 0 (empty)
104:     blocks = {0: 0, 1: 0, 2: 0, 3: 1, 4: 1, 5: 1}
105:     sizes = Counter(blocks.values())
106:     members = defaultdict(set)
107:     for v, b in blocks.items():
108:         members[b].add(v)
109:     rng = np.random.default_rng(3)
110:     r_target = 1  # we want exactly one k+1
111:     over2, over1, under = categorize(sizes, k)
112:     assert len(over1) == 2  # preâcondition
113:     # no possible balance to achieve
114:     balance_k_plus_1_blocks(
115:         over1=over1,
116:         over2=over2,
117:         rng=rng,
118:         sizes=sizes,
119:         k=k,
120:         members=members,
121:         blocks=blocks,
122:         indptr=A.indptr,
123:         indices=A.indices,
124:         r_target=r_target,
125:     )
126:     # After balancing, over1 should be 1
127:     over2_after, over1_after, under_after = categorize(sizes, k)
128:     assert len(over1_after) == len(over1) # no change made
129:     assert len(over2_after) == len(over2) # no change made
130:     assert not under_after and not under # no undersized introduced
131: # ---------------------------------------------------------------------------
132: # Test safety with empty sets ----------------------------------------------
133: # ---------------------------------------------------------------------------
134: def test_empty_sets_no_crash():
135:     k = 2
136:     A = full_graph_csr(3)
137:     blocks = {0: 0, 1: 0, 2: 0}
138:     sizes = Counter(blocks.values())
139:     members = defaultdict(set)
140:     for v, b in blocks.items():
141:         members[b].add(v)
142:     rng = np.random.default_rng(4)
143:     # empty over/under sets
144:     over2, over1, under = categorize(sizes, k)
145:     # should do nothing and not raise
146:     move_node_to_under(under, over1, over2, rng, sizes, k, members, blocks, A.indptr, A.indices)
147:     move_node_from_over(under, over1, over2, rng, sizes, k, members, blocks, A.indptr, A.indices, r_target=0)
148:     balance_k_plus_1_blocks(over1, over2, rng, sizes, k, members, blocks, A.indptr, A.indices, r_target=0)
149: # ---------------------------------------------------------------------------
150: # Integration test for _rebalance_to_min_size ------------------------------
151: # ---------------------------------------------------------------------------
152: def test_rebalance_removes_all_undersize():
153:     n = 25
154:     k = 3
155:     A = full_graph_csr(n)
156:     rng = np.random.default_rng(10)
157:     # start with random over/under assignment
158:     blocks = {i: rng.integers(0, 8) for i in range(n)}
159:     print(set(Counter(blocks.values()).values()))
160:     balanced = _rebalance_to_min_size(blocks.copy(), A, k, rng)
161:     sizes = Counter(balanced.values())
162:     print(set(sizes.values()))
163:     # No block smaller than k
164:     assert min(sizes.values()) >= k

================
File: src/tests/test_io.py
================
  1: # tests/test_io.py
  2: import json
  3: from pathlib import Path
  4: import numpy as np
  5: import scipy.sparse as sp
  6: from scipy.io import mmwrite
  7: import networkx as nx
  8: import pytest
  9: from sbm.io import SBMFit, SBMWriter, GraphLoader
 10: # ---------------------------------------------------------------------
 11: # helpers
 12: # ---------------------------------------------------------------------
 13: def _simple_adj(undirected: bool = True) -> sp.csr_array:
 14:     """
 15:     3-node graph:
 16:         0 â 1   and  (optionally) 1 â 2
 17:     """
 18:     rows, cols = [0, 1], [1, 0]            # 0â1 edge
 19:     if not undirected:
 20:         rows.append(1); cols.append(2)     # add 1â2 (makes it directed)
 21:     data = np.ones(len(rows), dtype=np.int8)
 22:     return sp.csr_array(sp.coo_matrix((data, (rows, cols)), shape=(3, 3)))
 23: def _assert_same_csr(a: sp.csr_array, b: sp.csr_array):
 24:     a.sort_indices()
 25:     b.sort_indices()
 26:     assert np.array_equal(a.data, b.data), f'Data arrays differ: {a.data} != {b.data}'
 27:     assert np.array_equal(a.indices, b.indices), f'Indices differ: {a.indices} != {b.indices}'
 28:     assert a.shape == b.shape, f'Shape differs: {a.shape} != {b.shape}'
 29: # ---------------------------------------------------------------------
 30: # 1. SBMWriter round-trip
 31: # ---------------------------------------------------------------------
 32: def test_sbmwriter_roundtrip(tmp_path: Path):
 33:     # --- build a tiny SBMFit ----------------------------------------
 34:     #adj = _simple_adj()
 35:     #blocks = {0: 0, 1: 0, 2: 1}
 36:     fit = SBMFit(
 37:         block_sizes   = [2, 1],
 38:         block_conn    = sp.csr_array([[1, .2],[.2, .1]]),
 39:         directed_graph= False,
 40:         neg_loglike   = -12.34,
 41:         metadata      = {"foo": "bar"},
 42:     )
 43:     # --- save & load ------------------------------------------------
 44:     SBMWriter.save(tmp_path, fit)
 45:     fit2 = SBMWriter.load(tmp_path)
 46:     # basic checks
 47:     assert fit2.block_sizes == [2, 1], f"Block sizes do not match: {fit2.block_sizes} != [2, 1]"
 48:     _assert_same_csr(fit.block_conn, fit2.block_conn)
 49:     assert fit2.neg_loglike == pytest.approx(fit.neg_loglike), "Negative log-likelihood does not match"
 50:     assert fit2.metadata["foo"] == "bar", "Metadata does not match"
 51: # ---------------------------------------------------------------------
 52: # 2. GraphLoader built-in formats
 53: # ---------------------------------------------------------------------
 54: @pytest.mark.parametrize("undirected", [True, False])
 55: def test_graphloader_npz(tmp_path: Path, undirected: bool):
 56:     adj = _simple_adj(undirected)
 57:     f = tmp_path / "g.npz"
 58:     sp.save_npz(f, adj)
 59:     g = GraphLoader.load(f)
 60:     _assert_same_csr(adj, g.adjacency)
 61:     assert g.directed == (not undirected)
 62: def test_graphloader_edges(tmp_path: Path):
 63:     # plain edge list (space-sep)
 64:     f = tmp_path / "toy.edges"
 65:     f.write_text("0 1\n1 2\n")  # unsymmetrised â directed
 66:     g = GraphLoader.load(f)
 67:     assert g.directed
 68:     assert g.num_nodes == 3
 69:     assert g.adjacency[1, 2] == 1
 70: def test_graphloader_mtx(tmp_path: Path):
 71:     adj = _simple_adj()
 72:     f = tmp_path / "toy.mtx"
 73:     mmwrite(str(f), adj)
 74:     g = GraphLoader.load(f)
 75:     _assert_same_csr(adj, g.adjacency)
 76:     assert not g.directed
 77: def test_graphloader_gml(tmp_path: Path):
 78:     # build with networkx
 79:     G = nx.Graph()
 80:     G.add_edge(0, 1); G.add_edge(1, 2)
 81:     f = tmp_path / "toy.gml"
 82:     nx.write_gml(G, f)
 83:     g = GraphLoader.load(f)
 84:     assert not g.directed
 85:     assert g.adjacency.nnz == 4      # undirected â 2 edges Ã2
 86: # ---------------------------------------------------------------------
 87: # 3. Registry decorator sanity check
 88: # ---------------------------------------------------------------------
 89: def test_register_new_loader(tmp_path: Path):
 90:     # create a fake extension ".foo"
 91:     ext = ".foo"
 92:     @GraphLoader.register(ext)
 93:     def _load_foo(path: Path):
 94:         # loader that ignores content, returns 2-node edge
 95:         rows, cols = [0], [1]
 96:         adj = sp.coo_matrix((np.ones(1, int), (rows, cols)), shape=(2, 2)).tocsr()
 97:         return adj, True
 98:     # create dummy file and load
 99:     f = tmp_path / f"dummy{ext}"
100:     f.write_text("ignored")
101:     g = GraphLoader.load(f)
102:     assert g.directed
103:     assert g.adjacency[0, 1] == 1
104:     assert f.suffix.lower() in GraphLoader.registry

================
File: src/tests/test_sampling.py
================
  1: import numpy as np
  2: import scipy.sparse as sp
  3: import pytest
  4: from sbm.sampling import (
  5:     sample_adjacency_matrix,
  6:     sample_sbm_graph_from_fit,
  7: )
  8: from sbm.io import SBMFit
  9: from sbm.graph_data import GraphData
 10: @pytest.fixture(scope="module")
 11: def rng():
 12:     return np.random.default_rng(12345)
 13: # --------------------------------------------------------------------
 14: # helpers
 15: # --------------------------------------------------------------------
 16: def csr_edges_between(adj: sp.csr_array, idx_a, idx_b, directed:bool = False):
 17:     """number of non-zero entries with row in A and col in B"""
 18:     sub = adj[idx_a][:, idx_b] # type: ignore
 19:     if (idx_a == idx_b) and not directed:
 20:         # self-edges, count only upper triangle
 21:         return sub.count_nonzero() // 2 # type: ignore
 22:     if directed:
 23:         # directed, count all edges
 24:         print('')
 25:         print(sub.toarray().tolist())
 26:         print(adj.toarray().tolist())
 27:         print('')
 28:     return sub.sum() # type: ignore
 29: def complete_block_edges(n, directed):
 30:     return n * (n - 1) if directed else n * (n - 1) // 2
 31: # --------------------------------------------------------------------
 32: # 1. full connectivity should yield a complete bipartite/clique
 33: # --------------------------------------------------------------------
 34: @pytest.mark.parametrize("directed", [False, True])
 35: def test_full_connectivity(rng, directed):
 36:     n1, n2 = 3, 4
 37:     sizes = [n1, n2]
 38:     # maximum possible edges
 39:     B = 2
 40:     conn = sp.csr_array((B, B), dtype=int)
 41:     conn[0, 0] = complete_block_edges(n1, directed)
 42:     conn[1, 1] = complete_block_edges(n2, directed)
 43:     conn[0, 1] = conn[1, 0] = n1 * n2
 44:     adj = sample_adjacency_matrix(sizes, conn, directed=directed, rng=rng)
 45:     idx0 = slice(0, n1)
 46:     idx1 = slice(n1, n1 + n2)
 47:     # --- within-block ------------------------------------------------
 48:     assert csr_edges_between(adj, idx0, idx0, directed) == conn[0, 0], \
 49:         (
 50:             f"expected {conn[0, 0]} edges within block 0. Got {csr_edges_between(adj, idx0, idx0)}. "
 51:             f"sizes: {sizes}, conn: {conn.toarray().flatten()}, directed: {directed}"
 52:         )
 53:     assert csr_edges_between(adj, idx1, idx1, directed) == conn[1, 1], \
 54:         (
 55:             f"expected {conn[1, 1]} edges within block 1"
 56:             f"sizes: {sizes}, conn: {conn}, directed: {directed}"
 57:         )
 58:     # --- between blocks ---------------------------------------------
 59:     expect = conn[0, 1]
 60:     assert csr_edges_between(adj, idx0, idx1, directed) == expect ,\
 61:         (
 62:             f"expected {expect} edges between blocks 0 and 1. Got {csr_edges_between(adj, idx0, idx1)}. "
 63:             f"sizes: {sizes}, conn: {conn.toarray().flatten()}, directed: {directed}"
 64:         )
 65:     assert csr_edges_between(adj, idx1, idx0, directed) == expect, \
 66:         (
 67:             f"expected {expect} edges between blocks 1 and 0. Got {csr_edges_between(adj, idx1, idx0)}. "
 68:             f"sizes: {sizes}, conn: {conn.toarray().flatten()}, directed: {directed}"
 69:         )
 70:     if directed:
 71:         # both directions filled
 72:         assert csr_edges_between(adj, idx1, idx0, directed) == expect, \
 73:                 f"expected {expect} edges between blocks 1 and 0. Got {csr_edges_between(adj, idx1, idx0)}. "
 74:     # --- no self-loops ----------------------------------------------
 75:     assert adj.diagonal().sum() == 0, \
 76:                 "expected no self-loops in the adjacency matrix"
 77: # --------------------------------------------------------------------
 78: # 2. zero connectivity must yield zero edges between blocks
 79: # --------------------------------------------------------------------
 80: def test_zero_connectivity(rng):
 81:     n1, n2 = 5, 6
 82:     sizes = [n1, n2]
 83:     conn = sp.csr_array([[10, 0],
 84:                          [0, 15]], dtype=int)
 85:     adj = sample_adjacency_matrix(sizes, conn, directed=False, rng=rng)
 86:     idx0 = slice(0, n1)
 87:     idx1 = slice(n1, n1 + n2)
 88:     assert csr_edges_between(adj, idx0, idx1) == 0
 89:     assert csr_edges_between(adj, idx1, idx0) == 0
 90: # --------------------------------------------------------------------
 91: # 3. large probabilistic block matches expected count Â±3Ï
 92: # --------------------------------------------------------------------
 93: def test_statistical_match(rng):
 94:     n1, n2 = 100, 200
 95:     sizes = [n1, n2]
 96:     p = 0.15
 97:     m = int(p * n1 * n2)
 98:     conn = sp.csr_array((2, 2), dtype=int)
 99:     conn[0, 1] = conn[1, 0] = m
100:     trials = 10
101:     errs = []
102:     for _ in range(trials):
103:         adj = sample_adjacency_matrix(sizes, conn, directed=False, rng=rng)
104:         idx0 = slice(0, n1)
105:         idx1 = slice(n1, n1 + n2)
106:         observed = csr_edges_between(adj, idx0, idx1)
107:         errs.append(observed - m)
108:     std = np.sqrt(n1 * n2 * p * (1 - p))
109:     assert max(map(abs, errs)) < 3 * std, \
110:         (
111:             f"expected observed edge counts to match {m} Â± 3Ï. Got {errs}. "
112:         )
113: # --------------------------------------------------------------------
114: # 4. directed vs undirected symmetry
115: # --------------------------------------------------------------------
116: def test_directed_flag(rng):
117:     sizes = [10, 10]
118:     B = 2
119:     conn = sp.csr_array((B, B), dtype=int)
120:     conn[0, 1] = conn[1, 0] = 10 * 10 / 2   # p = 0.5
121:     adj_d = sample_adjacency_matrix(sizes, conn, directed=True, rng=rng)
122:     assert (adj_d != adj_d.T).nnz > 0, \
123:         "expected directed graph to be asymmetric"
124:     adj_u = sample_adjacency_matrix(sizes, conn, directed=False, rng=rng)
125:     assert (adj_u != adj_u.T).nnz == 0
126: # --------------------------------------------------------------------
127: # 5. sampling via SBMFit wrapper
128: # --------------------------------------------------------------------
129: def test_sample_from_fit(rng):
130:     sizes = [2, 2]
131:     conn = sp.csr_array([[1, 2],
132:                          [2, 1]], dtype=int)
133:     fit = SBMFit(
134:         block_sizes    = sizes,
135:         block_conn     = conn,
136:         directed_graph = False,
137:         neg_loglike    = -1.0,
138:         metadata       = {},
139:     )
140:     g = sample_sbm_graph_from_fit(fit, rng)
141:     assert isinstance(g, GraphData)
142:     assert g.adjacency.shape == (4, 4)

================
File: src/tests/test_swaps.py
================
 1: # ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
 2: # tests/test_swap_move.py
 3: # ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
 4: import networkx as nx
 5: import numpy as np
 6: import pytest
 7: from sbm.block_assigner import MetisBlockAssigner
 8: from sbm.block_change_proposers import NodeSwapProposer
 9: from sbm.likelihood import LikelihoodCalculator
10: from sbm.mcmc import MCMCAlgorithm
11: from sbm.graph_data import gd_from_networkx
12: from sbm.block_data import BlockData
13: def _sizes_from_block_data(block_data: BlockData, num_blocks):
14:     """Helper used in both reference and postâmove checks."""
15:     sizes = np.zeros(num_blocks, dtype=int)
16:     for bid, nodes in block_data.block_members.items():
17:         if bid < num_blocks:
18:             sizes[bid] = len(nodes)
19:     return sizes
20: @pytest.mark.parametrize(
21:     "num_nodes,num_blocks,min_block_size,iterations,edge_p",
22:     [
23:         (80, 8, 8, 250, 0.05),
24:         (30, 6, 4, 100, 0.25),
25:         (10, 5, 2, 100, 0.25),
26:     ],
27: )
28: def test_swap_move_preserves_block_sizes(num_nodes, num_blocks, min_block_size, iterations, edge_p):
29:     """After *every* accepted SWAP move, blockâsize vector must be unchanged."""
30:     rng = np.random.default_rng(42)
31:     # old version of networkx can't take rng so use seed instead
32:     G = nx.erdos_renyi_graph(num_nodes, edge_p, seed=42, directed=False)
33:     graph_data = gd_from_networkx(G)
34:     # ââ Build initial state ââââââââââââââââââââââââââââââââââââââââââââââââ
35:     block_data = MetisBlockAssigner(
36:         graph_data=graph_data,
37:         num_blocks=num_blocks,
38:         min_block_size=min_block_size,
39:         rng=rng,
40:     ).compute_assignment()
41:     likelihood_calculator = LikelihoodCalculator(block_data=block_data)
42:     swap_proposer = NodeSwapProposer(block_data=block_data, rng=rng)
43:     mcmc = MCMCAlgorithm(
44:         block_data=block_data,
45:         likelihood_calculator=likelihood_calculator,
46:         change_proposer={"swap": swap_proposer},
47:         rng=rng,
48:     )
49:     reference_sizes = _sizes_from_block_data(block_data, num_blocks)
50:     # ââ Run many candidate swap moves ââââââââââââââââââââââââââââââââââââââ
51:     for iter in range(iterations):
52:         _delta_ll, accepted = mcmc._attempt_move(move_type="swap", temperature=1.0)
53:         if accepted:
54:             current_sizes = _sizes_from_block_data(mcmc.block_data, num_blocks)
55:             assert np.array_equal(reference_sizes, current_sizes), (
56:                 f"SWAP move {iter} changed block sizes:", reference_sizes, "â", current_sizes
57:             )
58:     # Final safeguard: after *all* moves sizes are still identical.
59:     final_sizes = _sizes_from_block_data(mcmc.block_data, num_blocks)
60:     assert np.array_equal(reference_sizes, final_sizes)

================
File: env_backup.yml
================
  1: name: anon_sbm
  2: channels:
  3:   - conda-forge
  4:   - defaults
  5: dependencies:
  6:   - bzip2=1.0.8
  7:   - ca-certificates=2024.9.24
  8:   - libexpat=2.6.4
  9:   - libffi=3.4.4
 10:   - libmpdec=4.0.0
 11:   - libsqlite=3.47.0
 12:   - libzlib=1.3.1
 13:   - ncurses=6.5
 14:   - openssl=3.4.0
 15:   - pip=24.3.1
 16:   - python=3.13.0
 17:   - python_abi=3.13
 18:   - readline=8.2
 19:   - tk=8.6.13
 20:   - xz=5.4.6
 21:   - pip:
 22:     - absl-py==2.3.0
 23:     - anon-sbm==0.1.0
 24:     - anyio==4.6.2.post1
 25:     - appnope==0.1.4
 26:     - argon2-cffi==23.1.0
 27:     - argon2-cffi-bindings==21.2.0
 28:     - arrow==1.3.0
 29:     - asttokens==2.4.1
 30:     - async-lru==2.0.4
 31:     - attrs==24.2.0
 32:     - babel==2.16.0
 33:     - beautifulsoup4==4.12.3
 34:     - bleach==6.2.0
 35:     - certifi==2024.8.30
 36:     - cffi==1.17.1
 37:     - charset-normalizer==3.4.0
 38:     - comm==0.2.2
 39:     - contourpy==1.3.1
 40:     - cycler==0.12.1
 41:     - debugpy==1.8.9
 42:     - decorator==5.1.1
 43:     - defusedxml==0.7.1
 44:     - executing==2.1.0
 45:     - fastjsonschema==2.20.0
 46:     - fonttools==4.55.0
 47:     - fqdn==1.5.1
 48:     - h11==0.14.0
 49:     - httpcore==1.0.7
 50:     - httpx==0.27.2
 51:     - idna==3.10
 52:     - immutabledict==4.2.1
 53:     - iniconfig==2.0.0
 54:     - ipykernel==6.29.5
 55:     - ipython==8.29.0
 56:     - ipywidgets==8.1.5
 57:     - isoduration==20.11.0
 58:     - jedi==0.19.2
 59:     - jinja2==3.1.4
 60:     - joblib==1.5.1
 61:     - json5==0.9.28
 62:     - jsonpointer==3.0.0
 63:     - jsonschema==4.23.0
 64:     - jsonschema-specifications==2024.10.1
 65:     - jupyter==1.1.1
 66:     - jupyter-client==8.6.3
 67:     - jupyter-console==6.6.3
 68:     - jupyter-core==5.7.2
 69:     - jupyter-events==0.10.0
 70:     - jupyter-lsp==2.2.5
 71:     - jupyter-server==2.14.2
 72:     - jupyter-server-terminals==0.5.3
 73:     - jupyterlab==4.2.6
 74:     - jupyterlab-pygments==0.3.0
 75:     - jupyterlab-server==2.27.3
 76:     - jupyterlab-widgets==3.0.13
 77:     - k-means-constrained==0.7.3
 78:     - kiwisolver==1.4.7
 79:     - markupsafe==3.0.2
 80:     - matplotlib==3.9.2
 81:     - matplotlib-inline==0.1.7
 82:     - mistune==3.0.2
 83:     - nbclient==0.10.0
 84:     - nbconvert==7.16.4
 85:     - nbformat==5.10.4
 86:     - nest-asyncio==1.6.0
 87:     - networkx==3.4.2
 88:     - notebook==7.2.2
 89:     - notebook-shim==0.2.4
 90:     - numpy==1.26.4
 91:     - ortools==9.14.6206
 92:     - overrides==7.7.0
 93:     - packaging==24.2
 94:     - pandas==2.3.0
 95:     - pandocfilters==1.5.1
 96:     - parso==0.8.4
 97:     - pathlib==1.0.1
 98:     - pexpect==4.9.0
 99:     - pillow==11.0.0
100:     - platformdirs==4.3.6
101:     - pluggy==1.5.0
102:     - prometheus-client==0.21.0
103:     - prompt-toolkit==3.0.48
104:     - protobuf==6.31.1
105:     - psutil==6.1.0
106:     - ptyprocess==0.7.0
107:     - pure-eval==0.2.3
108:     - pycparser==2.22
109:     - pygments==2.18.0
110:     - pymetis==2025.1.1
111:     - pyparsing==3.2.0
112:     - pytest==8.3.4
113:     - python-dateutil==2.9.0.post0
114:     - python-json-logger==2.0.7
115:     - pytz==2025.2
116:     - pyyaml==6.0.2
117:     - pyzmq==26.2.0
118:     - referencing==0.35.1
119:     - requests==2.32.3
120:     - rfc3339-validator==0.1.4
121:     - rfc3986-validator==0.1.1
122:     - rpds-py==0.21.0
123:     - scikit-learn==1.7.0
124:     - scipy==1.14.1
125:     - send2trash==1.8.3
126:     - setuptools==75.6.0
127:     - six==1.16.0
128:     - sniffio==1.3.1
129:     - soupsieve==2.6
130:     - stack-data==0.6.3
131:     - terminado==0.18.1
132:     - threadpoolctl==3.6.0
133:     - tinycss2==1.4.0
134:     - tornado==6.4.2
135:     - tqdm==4.67.1
136:     - traitlets==5.14.3
137:     - types-python-dateutil==2.9.0.20241003
138:     - typing-extensions==4.14.0
139:     - tzdata==2025.2
140:     - uri-template==1.3.0
141:     - urllib3==2.2.3
142:     - wcwidth==0.2.13
143:     - webcolors==24.11.1
144:     - webencodings==0.5.1
145:     - websocket-client==1.8.0
146:     - widgetsnbextension==4.0.13
147: prefix: /opt/anaconda3/envs/anon_sbm

================
File: pyproject.toml
================
1: [build-system]
2: requires = ["setuptools", "wheel"]
3: build-backend = "setuptools.build_meta"

================
File: README.md
================
1: # anon_sbm

================
File: tmp_test.py
================
 1: import numpy as np
 2: import scipy.sparse as sp
 3: import line_profiler
 4: from sbm.io import SBMFit
 5: from sbm.noisy_fit import create_sbm_noise
 6: EPS, DELTA, ALPHA = 1.0, 1e-6, 0.999
 7: RNG = np.random.default_rng(0)
 8: @line_profiler.profile
 9: def _make_sbm(block_sizes, P):
10:     """
11:     Create an SBMFit with integer edge counts according to prob-matrix P.
12:     P must be square len(block_sizes) Ã len(block_sizes), symmetric.
13:     """
14:     k_vec = np.array(block_sizes, int)
15:     B = len(k_vec)
16:     data, rows, cols = [], [], []
17:     for r in range(B):
18:         for s in range(r, B):
19:             N = k_vec[r] * k_vec[s] if r != s else k_vec[r] * (k_vec[r] - 1) // 2
20:             m = int(round(P[r, s] * N))
21:             if m > 0:
22:                 rows.append(r); cols.append(s); data.append(m)
23:     M = sp.csr_array((data, (rows, cols)), shape=(B, B))
24:     M = M + M.T - sp.diags(M.diagonal())
25:     return SBMFit(
26:         block_sizes=list(block_sizes),
27:         block_conn=M,
28:         directed_graph=False,
29:         neg_loglike=-1.0,
30:         metadata={},
31:     )
32: def test_sample_integrity():
33:     P = np.array([[0.8, 0.3],
34:                   [0.3, 0.05]])
35:     sbm   = _make_sbm([3, 4], P)
36:     print('check')
37:     noise = create_sbm_noise(sbm, EPS, DELTA, ALPHA,
38:                              noise_type="heterogeneous_gaussian")
39:     print('check 2')
40:     sbm_noisy = noise.sample_sbm_fit(RNG)
41:     print('check 3')
42: def test_big_blocks_memory():
43:     B = 100
44:     k = 3
45:     sizes = [k] * B
46:     P = np.full((B, B), 0.1)
47:     np.fill_diagonal(P, 0.2)
48:     sbm = _make_sbm(sizes, P)          # builds sparse counts
49:     nz = create_sbm_noise(sbm, 1.0, 1e-6, 0.999,
50:                           noise_type="heterogeneous_gaussian")
51: if __name__ == "__main__":
52:     test_sample_integrity()

================
File: notebooks/block_assigner_comparison_01-07-2025.ipynb
================
  1: {
  2:  "cells": [
  3:   {
  4:    "cell_type": "markdown",
  5:    "id": "03332c1a",
  6:    "metadata": {},
  7:    "source": [
  8:     "# Notebook for comparing the quality of block-assignment strategies"
  9:    ]
 10:   },
 11:   {
 12:    "cell_type": "code",
 13:    "execution_count": 1,
 14:    "id": "ca236c42",
 15:    "metadata": {},
 16:    "outputs": [],
 17:    "source": [
 18:     "from pathlib import Path\n",
 19:     "\n",
 20:     "import numpy as np\n",
 21:     "import pandas as pd\n",
 22:     "import scipy.sparse as sp\n",
 23:     "\n",
 24:     "from sbm.io import GraphLoader\n",
 25:     "from sbm.block_assigner import AssignerConstructor"
 26:    ]
 27:   },
 28:   {
 29:    "cell_type": "code",
 30:    "execution_count": 2,
 31:    "id": "75c16b11",
 32:    "metadata": {},
 33:    "outputs": [],
 34:    "source": [
 35:     "g = GraphLoader.load(\n",
 36:     "    Path(\"/Users/lmmi/anon_sbm/data/processed/congress_twitter.edgelist\"),\n",
 37:     "    force_undirected=True, # type: ignore\n",
 38:     "    )\n",
 39:     "#g = GraphLoader.load(\n",
 40:     "#    Path(\"/Users/lmmi/anon_sbm/data/processed/lastfm_asia.edgelist\"),\n",
 41:     "#    force_undirected=True, # type: ignore\n",
 42:     "#    )"
 43:    ]
 44:   },
 45:   {
 46:    "cell_type": "code",
 47:    "execution_count": 3,
 48:    "id": "e54ed4ac",
 49:    "metadata": {},
 50:    "outputs": [],
 51:    "source": [
 52:     "rng = np.random.default_rng(1) # type: ignore\n",
 53:     "k = 3"
 54:    ]
 55:   },
 56:   {
 57:    "cell_type": "code",
 58:    "execution_count": 4,
 59:    "id": "e8d0bf40",
 60:    "metadata": {},
 61:    "outputs": [],
 62:    "source": [
 63:     "assigner_const = AssignerConstructor(rng=rng)\n",
 64:     "uniform_assigner = assigner_const.create_assigner(\n",
 65:     "    graph_data=g,\n",
 66:     "    min_block_size=k, # type: ignore\n",
 67:     "    init_method=\"uniform\", # type: ignore\n",
 68:     "    )\n",
 69:     "prone_assigner = assigner_const.create_assigner(\n",
 70:     "    graph_data=g,\n",
 71:     "    min_block_size=k, # type: ignore\n",
 72:     "    init_method=\"prone_and_kmeans\", # type: ignore\n",
 73:     "    )\n",
 74:     "metis_assigner = assigner_const.create_assigner(\n",
 75:     "    graph_data=g,\n",
 76:     "    min_block_size=k, # type: ignore\n",
 77:     "    init_method=\"metis\", # type: ignore\n",
 78:     "    )\n",
 79:     "metis_ref_assigner = assigner_const.create_assigner(\n",
 80:     "    graph_data=g,\n",
 81:     "    min_block_size=k, # type: ignore\n",
 82:     "    init_method=\"metis_refine\", # type: ignore\n",
 83:     "    )"
 84:    ]
 85:   },
 86:   {
 87:    "cell_type": "code",
 88:    "execution_count": 10,
 89:    "id": "6030cfba",
 90:    "metadata": {},
 91:    "outputs": [
 92:     {
 93:      "name": "stdout",
 94:      "output_type": "stream",
 95:      "text": [
 96:       "[158, 83]\n",
 97:       "[158]\n"
 98:      ]
 99:     }
100:    ],
101:    "source": [
102:     "uniform_blocks = uniform_assigner.compute_assignment()\n",
103:     "#prone_blocks = prone_assigner.compute_assignment()\n",
104:     "metis_blocks = metis_assigner.compute_assignment()\n",
105:     "metis_ref_blocks = metis_ref_assigner.compute_assignment()"
106:    ]
107:   },
108:   {
109:    "cell_type": "code",
110:    "execution_count": 11,
111:    "id": "8b91f480",
112:    "metadata": {},
113:    "outputs": [
114:     {
115:      "name": "stdout",
116:      "output_type": "stream",
117:      "text": [
118:       "{3, 4}\n",
119:       "{2, 3, 4, 5}\n",
120:       "{3, 4}\n"
121:      ]
122:     }
123:    ],
124:    "source": [
125:     "print(set(uniform_blocks.block_sizes.values()))\n",
126:     "#print(set(prone_blocks.block_sizes.values()))\n",
127:     "print(set(metis_blocks.block_sizes.values()))\n",
128:     "print(set(metis_ref_blocks.block_sizes.values()))"
129:    ]
130:   },
131:   {
132:    "cell_type": "code",
133:    "execution_count": 12,
134:    "id": "399008f8",
135:    "metadata": {},
136:    "outputs": [
137:     {
138:      "name": "stdout",
139:      "output_type": "stream",
140:      "text": [
141:       "\n",
142:       "Small graph likelihood comparison:\n",
143:       "    Uniform assignment likelihood: 8261.40\n",
144:       "    Metis assignment likelihood: 4820.68\n",
145:       "    Metis-refine assignment likelihood: 4862.17\n",
146:       "\n"
147:      ]
148:     }
149:    ],
150:    "source": [
151:     "# compute likelihood of the assignments\n",
152:     "from sbm.likelihood import compute_global_bernoulli_ll_fast\n",
153:     "\n",
154:     "uniform_nll = -compute_global_bernoulli_ll_fast(uniform_blocks)\n",
155:     "#prone_ll = compute_global_bernoulli_ll_fast(prone_blocks)\n",
156:     "metis_nll = -compute_global_bernoulli_ll_fast(metis_blocks)\n",
157:     "metis_ref_nll = -compute_global_bernoulli_ll_fast(metis_ref_blocks)\n",
158:     "\n",
159:     "print(f\"\"\"\n",
160:     "Small graph likelihood comparison:\n",
161:     "    Uniform assignment likelihood: {uniform_nll:.2f}\n",
162:     "    Metis assignment likelihood: {metis_nll:.2f}\n",
163:     "    Metis-refine assignment likelihood: {metis_ref_nll:.2f}\n",
164:     "\"\"\")"
165:    ]
166:   },
167:   {
168:    "cell_type": "code",
169:    "execution_count": null,
170:    "id": "f3633444",
171:    "metadata": {},
172:    "outputs": [],
173:    "source": []
174:   },
175:   {
176:    "cell_type": "code",
177:    "execution_count": null,
178:    "id": "f2c3d8e0",
179:    "metadata": {},
180:    "outputs": [],
181:    "source": []
182:   }
183:  ],
184:  "metadata": {
185:   "kernelspec": {
186:    "display_name": "Python 3",
187:    "language": "python",
188:    "name": "python3"
189:   },
190:   "language_info": {
191:    "codemirror_mode": {
192:     "name": "ipython",
193:     "version": 3
194:    },
195:    "file_extension": ".py",
196:    "mimetype": "text/x-python",
197:    "name": "python",
198:    "nbconvert_exporter": "python",
199:    "pygments_lexer": "ipython3",
200:    "version": "3.12.11"
201:   }
202:  },
203:  "nbformat": 4,
204:  "nbformat_minor": 5
205: }

================
File: notebooks/move_type_comparisons_30-06-2025.ipynb
================
  1: {
  2:  "cells": [
  3:   {
  4:    "cell_type": "code",
  5:    "execution_count": 14,
  6:    "id": "0c56f619",
  7:    "metadata": {},
  8:    "outputs": [],
  9:    "source": [
 10:     "# Notebook for comparing move-types and their resulting likelihood trajectories"
 11:    ]
 12:   },
 13:   {
 14:    "cell_type": "code",
 15:    "execution_count": 15,
 16:    "id": "ca236c42",
 17:    "metadata": {},
 18:    "outputs": [],
 19:    "source": [
 20:     "from pathlib import Path\n",
 21:     "\n",
 22:     "import numpy as np\n",
 23:     "import pandas as pd\n",
 24:     "import scipy.sparse as sp\n",
 25:     "\n",
 26:     "from sbm.io import GraphLoader\n",
 27:     "from sbm.model import SBMModel\n",
 28:     "\n",
 29:     "from sbm.utils.pipeline_utils import (\n",
 30:     "    sbmfit_folderpath,\n",
 31:     "    FitConfig,\n",
 32:     ")"
 33:    ]
 34:   },
 35:   {
 36:    "cell_type": "code",
 37:    "execution_count": 60,
 38:    "id": "75c16b11",
 39:    "metadata": {},
 40:    "outputs": [],
 41:    "source": [
 42:     "g = GraphLoader.load(\n",
 43:     "    Path(\"/Users/lmmi/anon_sbm/data/processed/congress_twitter.edgelist\"),\n",
 44:     "    force_undirected=True, # type: ignore\n",
 45:     "    )"
 46:    ]
 47:   },
 48:   {
 49:    "cell_type": "code",
 50:    "execution_count": 61,
 51:    "id": "e54ed4ac",
 52:    "metadata": {},
 53:    "outputs": [],
 54:    "source": [
 55:     "rng = np.random.default_rng(1) # type: ignore"
 56:    ]
 57:   },
 58:   {
 59:    "cell_type": "code",
 60:    "execution_count": null,
 61:    "id": "e8d0bf40",
 62:    "metadata": {},
 63:    "outputs": [],
 64:    "source": [
 65:     "from sbm.block_assigner import AssignerConstructor\n",
 66:     "\n",
 67:     "assigner_const = AssignerConstructor(rng=rng)\n",
 68:     "assigner = assigner_const.create_assigner(\n",
 69:     "    graph_data=g,\n",
 70:     "    min_block_size=5, # type: ignore\n",
 71:     "    init_method=\"metis_refine\", # type: ignore\n",
 72:     "    )"
 73:    ]
 74:   },
 75:   {
 76:    "cell_type": "code",
 77:    "execution_count": 68,
 78:    "id": "ecbbb1c7",
 79:    "metadata": {},
 80:    "outputs": [],
 81:    "source": [
 82:     "min_block_size = 5\n",
 83:     "cooling_rate = 0.9999\n",
 84:     "max_blocks = None\n",
 85:     "patience  = int(1e3)\n",
 86:     "return_nll = True"
 87:    ]
 88:   },
 89:   {
 90:    "cell_type": "code",
 91:    "execution_count": 69,
 92:    "id": "51e49a44",
 93:    "metadata": {},
 94:    "outputs": [
 95:     {
 96:      "name": "stdout",
 97:      "output_type": "stream",
 98:      "text": [
 99:       "Stopping early after 34602 iterations due to patience limit.\n"
100:      ]
101:     }
102:    ],
103:    "source": [
104:     "initial_blocks = assigner.compute_assignment()\n",
105:     "uniform_swap_model = SBMModel(\n",
106:     "    initial_blocks=initial_blocks,\n",
107:     "    rng=rng,\n",
108:     "    change_freq = { # probabilities of trying each move type\n",
109:     "        \"uniform_swap\": 1,\n",
110:     "    },\n",
111:     ")\n",
112:     "\n",
113:     "uniform_nll = uniform_swap_model.fit(\n",
114:     "    min_block_size=min_block_size,\n",
115:     "    cooling_rate=cooling_rate,\n",
116:     "    max_blocks=max_blocks,\n",
117:     "    patience=10**3,\n",
118:     "    return_nll=True,\n",
119:     ")\n",
120:     "block_data = uniform_swap_model.block_data"
121:    ]
122:   },
123:   {
124:    "cell_type": "code",
125:    "execution_count": 72,
126:    "id": "b50abed4",
127:    "metadata": {},
128:    "outputs": [
129:     {
130:      "name": "stdout",
131:      "output_type": "stream",
132:      "text": [
133:       "Stopping early after 28371 iterations due to patience limit.\n"
134:      ]
135:     }
136:    ],
137:    "source": [
138:     "initial_blocks = assigner.compute_assignment()\n",
139:     "mix_swap_model = SBMModel(\n",
140:     "    initial_blocks=initial_blocks,\n",
141:     "    rng=rng,\n",
142:     "    change_freq = { # probabilities of trying each move type\n",
143:     "        #\"uniform_swap\": 0.5,\n",
144:     "        \"edge_based_swap\": 1,\n",
145:     "    },\n",
146:     ")\n",
147:     "\n",
148:     "mix_nll = mix_swap_model.fit(\n",
149:     "    min_block_size=min_block_size,\n",
150:     "    cooling_rate=cooling_rate,\n",
151:     "    max_blocks=max_blocks,\n",
152:     "    patience=10**3,\n",
153:     "    return_nll=True,\n",
154:     ")"
155:    ]
156:   },
157:   {
158:    "cell_type": "code",
159:    "execution_count": 74,
160:    "id": "10298ee8",
161:    "metadata": {},
162:    "outputs": [
163:     {
164:      "data": {
165:       "image/png": "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441qvXv37njkkUdK7bUnT56MqKioAvtXr16NESNGlFo7iIhKg6lUXoWIiDwiOzsbwcHBl/z8SpUqubU9RETegD3ARERe2BO8aNEiTJgwAZqmqeXAgQPq2JYtW9CvXz9EREQgNjYWgwcPxsmTJx3PlZ7jhx56SPUeV6xYEX369FH733vvPTRr1gxlypRB9erV8eCDDyI9PV0dW7hwIYYNG4bU1FTH67388suFpkAcOnQIN9xwg3r9yMhI3HbbbUhMTHQcl+e1bNkS33//vXpuuXLlMHDgQJw5c6bU7h8R0cUwACYi8jIS+Hbs2BH33XcfEhIS1CJBa0pKCq666iq0atUKa9aswT///KOCTwlCnX377beq13fp0qWYOHGi2mcwGPDhhx9i69at6vj8+fPx1FNPqWOdOnVSQa4EtPbXe+KJJwq0y2q1quA3OTlZBehz587Fvn37cPvtt7uct3fvXkybNg0zZsxQi5z75ptvlug9IyIqDqZAEBF5Gek1lQA2PDwclStXduz/+OOPVfA7duxYx75vvvlGBce7du1C/fr11b569eph/PjxLtd0zieWntnXX38dDzzwAD799FP1WvKa0vPr/Hr5zZs3D5s3b8b+/fvVa4rvvvsOTZo0UbnC7dq1cwTKklNctmxZtS291PLcN954w233iIjocrAHmIjIR2zcuBELFixQ6Qf2pWHDho5eV7s2bdoUeO6///6Lnj17omrVqiowlaD01KlTOHfuXJFff/v27SrwtQe/onHjxmrwnBxzDrDtwa+Ii4tDUlLSJb1nIqKSwB5gIiIfITm71113Hd56660CxyTItJM8X2eSP3zttddi5MiRqhe2fPnyWLJkCYYPH64GyUlPszsFBQW5bEvPsvQKExF5CwbAREReSNISLBaLy77WrVtj6tSpqofVZCr6r++1a9eqAPTdd99VucDi119/vejr5deoUSMcPnxYLfZe4G3btqncZOkJJiLyFUyBICLyQhLkrly5UvXeSpUHCWBHjRqlBqDdcccdKudW0h5mz56tKjhcKHitW7cucnJy8NFHH6lBa1KhwT44zvn1pIdZcnXl9QpLjejVq5eqJDFo0CCsW7cOq1atwpAhQ9CtWze0bdu2RO4DEVFJYABMROSFpAqD0WhUPatSi1fKj1WpUkVVdpBgt3fv3ioYlcFtkoNr79ktTIsWLVQZNEmdaNq0KX744QeMGzfO5RypBCGD4qSig7xe/kF09lSGP//8E9HR0ejatasKiGvXro1ffvmlRO4BEVFJ0XRd10vs6kREREREXoY9wEREREQUUBgAExEREVFAYQBMRERERAGFATARERERBRQGwEREREQUUBgAExEREVFAYQBMRERERAGFATARERERBRQGwEREREQUUBgAExEREVFAYQBMRERERAGFATARERERIZD8PygTIG0v/GOiAAAAAElFTkSuQmCC",
166:       "text/plain": [
167:        "<Figure size 800x600 with 1 Axes>"
168:       ]
169:      },
170:      "metadata": {},
171:      "output_type": "display_data"
172:     }
173:    ],
174:    "source": [
175:     "# comparing initial methods\n",
176:     "import matplotlib.pyplot as plt\n",
177:     "fig, ax = plt.subplots(figsize=(8,6))\n",
178:     "\n",
179:     "ax.plot(np.arange(len(uniform_nll)),uniform_nll, label=\"Uniform Swap\", color=\"salmon\")# type: ignore\n",
180:     "\n",
181:     "ax.plot(np.arange(len(mix_nll)), mix_nll, label=\"Edge-biased swap\", color=\"slategrey\") # type: ignore\n",
182:     "\n",
183:     "ax.set_xlabel(\"Iteration\")\n",
184:     "ax.set_ylabel(\"Log Likelihood\")\n",
185:     "\n",
186:     "ax.legend()\n",
187:     "plt.show(fig)"
188:    ]
189:   },
190:   {
191:    "cell_type": "code",
192:    "execution_count": 58,
193:    "id": "73af6cbf",
194:    "metadata": {},
195:    "outputs": [],
196:    "source": [
197:     "uniform_swap_model = SBMModel(\n",
198:     "    initial_blocks=block_data,\n",
199:     "    rng=rng,\n",
200:     "    change_freq = { # probabilities of trying each move type\n",
201:     "        \"uniform_swap\": 1.0,\n",
202:     "    },\n",
203:     ")\n",
204:     "\n",
205:     "edge_swap_model = SBMModel(\n",
206:     "    initial_blocks=block_data,\n",
207:     "    rng=rng,\n",
208:     "    change_freq = { # probabilities of trying each move type\n",
209:     "    \"edge_based_swap\": 1.0,\n",
210:     "    },\n",
211:     ")\n",
212:     "triad_swap_model = SBMModel(\n",
213:     "    initial_blocks=block_data,\n",
214:     "    rng=rng,\n",
215:     "    change_freq = { # probabilities of trying each move type\n",
216:     "    \"triadic_swap\": 1.0,\n",
217:     "    },\n",
218:     ")\n",
219:     "cross_swap_model = SBMModel(\n",
220:     "    initial_blocks=block_data,\n",
221:     "    rng=rng,\n",
222:     "    change_freq = { # probabilities of trying each move type\n",
223:     "    \"cross_triangle\": 1.0,\n",
224:     "    },\n",
225:     ")\n",
226:     "mix_swap_model = SBMModel(\n",
227:     "    initial_blocks=block_data,\n",
228:     "    rng=rng,\n",
229:     "    change_freq = {\n",
230:     "    \"edge_based_swap\": 0.6,\n",
231:     "    \"triadic_swap\": 0.2,\n",
232:     "    \"twin_leaf\": 0.15,\n",
233:     "    \"uniform_swap\": 0.05\n",
234:     "    },\n",
235:     ")"
236:    ]
237:   },
238:   {
239:    "cell_type": "code",
240:    "execution_count": 49,
241:    "id": "574ec66f",
242:    "metadata": {},
243:    "outputs": [
244:     {
245:      "name": "stdout",
246:      "output_type": "stream",
247:      "text": [
248:       "Stopping early after 6552 iterations due to patience limit.\n"
249:      ]
250:     }
251:    ],
252:    "source": [
253:     "uniform_nll = uniform_swap_model.fit(\n",
254:     "    min_block_size=min_block_size,\n",
255:     "    cooling_rate=cooling_rate,\n",
256:     "    max_blocks=max_blocks,\n",
257:     "    patience=patience,\n",
258:     "    return_nll=return_nll,\n",
259:     ")"
260:    ]
261:   },
262:   {
263:    "cell_type": "code",
264:    "execution_count": 50,
265:    "id": "76f33e97",
266:    "metadata": {},
267:    "outputs": [
268:     {
269:      "name": "stdout",
270:      "output_type": "stream",
271:      "text": [
272:       "Stopping early after 11427 iterations due to patience limit.\n"
273:      ]
274:     }
275:    ],
276:    "source": [
277:     "edge_nll = edge_swap_model.fit(\n",
278:     "    min_block_size=min_block_size,\n",
279:     "    cooling_rate=cooling_rate,\n",
280:     "    max_blocks=max_blocks,\n",
281:     "    patience=patience,\n",
282:     "    return_nll=return_nll,\n",
283:     ")"
284:    ]
285:   },
286:   {
287:    "cell_type": "code",
288:    "execution_count": 51,
289:    "id": "96b956a2",
290:    "metadata": {},
291:    "outputs": [
292:     {
293:      "name": "stdout",
294:      "output_type": "stream",
295:      "text": [
296:       "Stopping early after 5153 iterations due to patience limit.\n"
297:      ]
298:     }
299:    ],
300:    "source": [
301:     "triad_nll = triad_swap_model.fit(\n",
302:     "    min_block_size=min_block_size,\n",
303:     "    cooling_rate=cooling_rate,\n",
304:     "    max_blocks=max_blocks,\n",
305:     "    patience=patience,\n",
306:     "    return_nll=return_nll,\n",
307:     ")"
308:    ]
309:   },
310:   {
311:    "cell_type": "code",
312:    "execution_count": 59,
313:    "id": "d5a89795",
314:    "metadata": {},
315:    "outputs": [
316:     {
317:      "name": "stdout",
318:      "output_type": "stream",
319:      "text": [
320:       "Stopping early after 1000 iterations due to patience limit.\n"
321:      ]
322:     }
323:    ],
324:    "source": [
325:     "mix_nll = mix_swap_model.fit(\n",
326:     "    min_block_size=min_block_size,\n",
327:     "    cooling_rate=cooling_rate,\n",
328:     "    max_blocks=max_blocks,\n",
329:     "    patience=patience,\n",
330:     "    return_nll=return_nll,\n",
331:     ")"
332:    ]
333:   },
334:   {
335:    "cell_type": "code",
336:    "execution_count": null,
337:    "id": "c9ffcc17",
338:    "metadata": {},
339:    "outputs": [],
340:    "source": [
341:     "rng.normal(0, 1, size=1000).A1 # to make sure rng is not empty\n",
342:     "oo\n",
343:     "o"
344:    ]
345:   },
346:   {
347:    "cell_type": "code",
348:    "execution_count": null,
349:    "id": "6dc70577",
350:    "metadata": {},
351:    "outputs": [
352:     {
353:      "data": {
354:       "image/png": "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",
355:       "text/plain": [
356:        "<Figure size 800x600 with 1 Axes>"
357:       ]
358:      },
359:      "metadata": {},
360:      "output_type": "display_data"
361:     }
362:    ],
363:    "source": [
364:     "import matplotlib.pyplot as plt\n",
365:     "fig, ax = plt.subplots(figsize=(8,6))\n",
366:     "\n",
367:     "ax.plot(np.arange(len(uniform_nll)),uniform_nll, label=\"Uniform Swap\", color=\"salmon\")# type: ignore\n",
368:     "\n",
369:     "ax.plot(np.arange(len(edge_nll)), edge_nll, label=\"Edge Swap\", color=\"teal\")# type: ignore\n",
370:     "\n",
371:     "ax.plot(np.arange(len(triad_nll)), triad_nll, label=\"Triadic Swap\", color=\"black\") # type: ignore\n",
372:     "\n",
373:     "ax.plot(np.arange(len(cross_nll)), cross_nll, label=\"Cross Triangle\", color=\"slategrey\") # type: ignore\n",
374:     "\n",
375:     "ax.set_xlabel(\"Iteration\")\n",
376:     "ax.set_ylabel(\"Log Likelihood\")\n",
377:     "\n",
378:     "ax.legend()\n",
379:     "plt.show(fig)"
380:    ]
381:   },
382:   {
383:    "cell_type": "code",
384:    "execution_count": null,
385:    "id": "fc1d104a",
386:    "metadata": {},
387:    "outputs": [],
388:    "source": []
389:   }
390:  ],
391:  "metadata": {
392:   "kernelspec": {
393:    "display_name": "Python 3",
394:    "language": "python",
395:    "name": "python3"
396:   },
397:   "language_info": {
398:    "codemirror_mode": {
399:     "name": "ipython",
400:     "version": 3
401:    },
402:    "file_extension": ".py",
403:    "mimetype": "text/x-python",
404:    "name": "python",
405:    "nbconvert_exporter": "python",
406:    "pygments_lexer": "ipython3",
407:    "version": "3.12.11"
408:   }
409:  },
410:  "nbformat": 4,
411:  "nbformat_minor": 5
412: }

================
File: src/data_processing/process_all.py
================
 1: # src/data_processing/process_all.py
 2: """ 
 3: Script to run all processing steps of all datasets.
 4: """
 5: import subprocess
 6: import sys
 7: def run(cmd):
 8:     print(">>", " ".join(cmd))
 9:     subprocess.check_call(cmd)
10: datasets = [
11:     "data_processing.process_congress_twitter",
12:     "data_processing.process_email_eu",
13:     "data_processing.process_caltech",
14:     "data_processing.process_wiki_vote",
15:     "data_processing.process_enron_email",
16:     "data_processing.process_lastfm_asia",
17: ]
18: if __name__ == "__main__":
19:     python = sys.executable
20:     for dataset in datasets:
21:         run([python, "-m", dataset])

================
File: src/metrics/clustering.py
================
 1: """ 
 2: Implementation of the clustering coefficient distance metric.
 3: This module computes the absolute difference in the clustering coefficients
 4: between two graphs represented by their adjacency matrices.
 5: """
 6: # metrics/clustering.py
 7: from typing import Optional
 8: import numpy as np
 9: import networkx as nx
10: from scipy.sparse import csr_array
11: ###############################################################################
12: ### Clustering coefficient distributional distance ----------------------------
13: ###############################################################################
14: def clustering_distance(
15:         emp_adj: csr_array,
16:         sur_adj: csr_array,
17:         directed: Optional[bool] = False,
18:         rng: np.random.Generator = np.random.default_rng(1)
19:     ) -> float:
20:     """ 
21:     Compute absolute 
22:     Parameters
23:     ----------
24:     emp_adj, sur_adj : scipy.sparse.csr_matrix
25:         Adjacency of empirical and surrogate graphs (directed or undirected).
26:     directed : bool, optional
27:         If True, compute directed degree distribution.
28:         If False, compute undirected degree distribution.
29:     rng : np.random.Generator, optional
30:         Random number generator for sampling (default: np.random.default_rng(1)).
31:     Returns
32:     -------
33:     float
34:         Distance (lower = more similar).
35:     """
36:     if directed:
37:         raise NotImplementedError(
38:             "Directed clustering coefficient is not implemented yet."
39:         )
40:     else:
41:         # Undirected clustering coefficient
42:         emp_graph = nx.from_scipy_sparse_matrix(emp_adj)
43:         sur_graph = nx.from_scipy_sparse_matrix(sur_adj)
44:         emp_clustering = nx.average_clustering(emp_graph)
45:         sur_clustering = nx.average_clustering(sur_graph)
46:         return abs(emp_clustering - sur_clustering)
47: ###############################################################################
48: # Average clustering coefficient difference -------------------------------
49: ###############################################################################
50: def avg_clustering_difference(
51:     emp_adj: csr_array,
52:     sur_adj: csr_array,
53:     *,
54:     rng: np.random.Generator = np.random.default_rng(1),
55: ) -> float:
56:     """Absolute difference in *average* clustering coefficient.
57:     (The existing *clustering_distance* compares the *distribution*; this
58:     variant is the scalar average.)
59:     """
60:     emp_C = nx.average_clustering(nx.from_scipy_sparse_matrix(emp_adj))
61:     sur_C = nx.average_clustering(nx.from_scipy_sparse_matrix(sur_adj))
62:     return abs(emp_C - sur_C)

================
File: src/metrics/degree.py
================
 1: """ 
 2: Implementation of the degree distribution distance metric.
 3: This module computes the Earth-mover distance (1-D Wasserstein distance)
 4: between the degree distributions in two graphs represented by
 5: their adjacency matrices.
 6: """
 7: # metrics/degree.py
 8: from typing import Optional
 9: import numpy as np
10: from scipy.stats import wasserstein_distance #  1-D EMD
11: from scipy.sparse import csr_array
12: def degree_distance(
13:         emp_adj: csr_array,
14:         sur_adj: csr_array,
15:         directed: Optional[bool] = False,
16:         in_degree: Optional[bool] = False,
17:         out_degree: Optional[bool] = False,
18:         rng: np.random.Generator = np.random.default_rng(1)
19:     ) -> float:
20:     """ 
21:     Earth-mover (1-D Wasserstein) distance between the degree distributions
22:     of two graphs.
23:     Parameters
24:     ----------
25:     emp_adj, sur_adj : scipy.sparse.csr_matrix
26:         Adjacency of empirical and surrogate graphs (directed or undirected).
27:     directed : bool, optional
28:         If True, compute directed degree distribution.
29:         If False, compute undirected degree distribution.
30:     in_degree : bool, optional
31:         If True, compute in-degree distribution (for directed graphs).
32:         Ignored if `directed` is False.
33:     out_degree : bool, optional
34:         If True, compute out-degree distribution (for directed graphs).
35:         Ignored if `directed` is False.
36:     rng : np.random.Generator, optional
37:         Random number generator for sampling (default: np.random.default_rng(1)).
38:     Returns
39:     -------
40:     float
41:         Distance (lower = more similar).
42:     """
43:     if directed:
44:         raise NotImplementedError(
45:             "Directed degree distribution is not implemented yet."
46:         )
47:     else:
48:         if in_degree or out_degree:
49:             raise Warning(
50:                 "in_degree and out_degree are ignored for undirected graphs."
51:             )
52:         # Undirected degree distribution
53:         emp_degrees = np.asarray(emp_adj.sum(axis=0)).flatten()
54:         sur_degrees = np.asarray(sur_adj.sum(axis=0)).flatten()
55:         emp_dist = np.bincount(emp_degrees)
56:         sur_dist = np.bincount(sur_degrees)
57:         # Normalize distributions
58:         emp_dist = emp_dist / emp_dist.sum()
59:         sur_dist = sur_dist / sur_dist.sum()
60:         # Compute Earth-mover distance
61:         distance = wasserstein_distance(emp_dist, sur_dist)
62:         return distance

================
File: src/pipelines/evaluate_surrogates.py
================
 1: """
 2:     Generate surrogate SBM graphs and evaluate them against empirical data.
 3: """
 4: import argparse
 5: import yaml
 6: import csv
 7: from pathlib import Path
 8: import numpy as np
 9: from itertools import product
10: from multiprocessing import Pool, cpu_count
11: from metrics import REGISTRY
12: from sbm.io import SBMWriter
13: from sbm.sampling import sample_sbm_graph_from_fit
14: from sbm.io import GraphLoader
15: from sbm.utils.pipeline_utils import (
16:     sbmfit_folderpath,
17:     surrogate_statistics_filename,
18:     FitConfig,
19:     EvalConfig,
20: )
21: #######################
22: ### Configuration Types 
23: #######################
24: def _genetate_and_evaluate(sbm_config, ds, eval_config, rng):
25:     # Load empirical graph
26:     g = GraphLoader.load(
27:             Path(ds["path"]),
28:             force_undirected=sbm_config["force_undirected"], # type: ignore
29:         )
30:     emp = g.adjacency
31:     # load fitted model
32:     fit_folder_path = sbmfit_folderpath(
33:         base_dir=Path("results/sbm_fits"),
34:         sbm_config=sbm_config,# type: ignore
35:         data_spec=ds,
36:     )
37:     # load the sbm fit
38:     sbm_fit = SBMWriter.load(fit_folder_path)
39:     # check if metrics have been cached earlier
40:     out = surrogate_statistics_filename(
41:         base_dir=Path("results/surrogate_statistics"),
42:         eval_configs=eval_config,
43:         sbm_config=sbm_config,# type: ignore
44:         data_spec=ds,
45:     )
46:     out.parent.mkdir(exist_ok=True)
47:     if out.exists() and not eval_config["overwrite"]:
48:         return
49:     # Generate surrogates and campare metrics
50:     results = []
51:     for i in range(eval_config["n_surrogates"]):
52:         surr = sample_sbm_graph_from_fit(
53:             sbm_fit=sbm_fit,
54:             rng=rng,
55:         )
56:         surr = surr.adjacency
57:         row = {"dataset": ds["name"], "surrogate": f'surr_{i}'}
58:         for m in eval_config["metrics"]:
59:             row[m] = REGISTRY[m](emp, surr)
60:         results.append(row)
61:     with out.open("w", newline="") as f:
62:         w = csv.DictWriter(f, fieldnames=results[0].keys())
63:         w.writeheader(); w.writerows(results)
64: ############################################
65: ### main function
66: ############################################
67: def main(fit_config: str, eval_config: str, parallel:bool): # type: ignore
68:     fit_config: FitConfig = yaml.safe_load(Path(fit_config).read_text())
69:     rng = np.random.default_rng(fit_config["seed"])
70:     data_config = fit_config["datasets"] # type: ignore
71:     eval_config: EvalConfig = yaml.safe_load(Path(eval_config).read_text())
72:     # Prepare arguments for the worker function
73:     args = [
74:         (sbm_config, ds, eval_config, rng)
75:         for sbm_config, ds in product(fit_config["sbm"], data_config)
76:     ][::-1]
77:     if parallel:
78:         # Create a pool of workers
79:         n_workers = max(1, cpu_count() - 1)  # Leave one core free
80:         with Pool(n_workers) as pool:
81:             # Execute the worker function in parallel
82:             pool.starmap(_genetate_and_evaluate, args)
83:     else:
84:         for sbm_config, ds in product(fit_config["sbm"], data_config):
85:             _genetate_and_evaluate(sbm_config, ds, eval_config, rng)
86: if __name__ == "__main__":
87:     p = argparse.ArgumentParser()
88:     p.add_argument("--fit_config", type=str, help="Path to the configuration file.")
89:     p.add_argument("--eval_config", type=str, help="Path to the configuration file.")
90:     p.add_argument("--parallel", action="store_true", help="Run in parallel leaving one core free.")
91:     args = p.parse_args()
92:     main(
93:         fit_config=args.fit_config,
94:         eval_config=args.eval_config,
95:         parallel=args.parallel,
96:     )

================
File: src/pipelines/run_all.py
================
 1: """ 
 2: Script to run fitting, generation, and evaluation pipelines in sequence.
 3: """
 4: import subprocess
 5: import sys
 6: def run(cmd):
 7:     print(">>", " ".join(cmd))
 8:     subprocess.check_call(cmd)
 9: CFG_FIT = "configs/sbm_fit_block_size_experiments.yml"
10: CFG_EVAL = "configs/surrogate_eval.yml"
11: if __name__ == "__main__":
12:     python = sys.executable
13:     run([
14:         python, "-m",
15:         "pipelines.fit_sbm",
16:         "--fit_config", CFG_FIT
17:     ])
18:     run([
19:         python, "-m",
20:         "pipelines.evaluate_surrogates",
21:         "--fit_config", CFG_FIT,
22:         "--eval_config", CFG_EVAL,
23:     ])

================
File: src/sbm/utils/util.py
================
 1: import numpy as np
 2: from pathlib import Path
 3: import networkx as nx
 4: from scipy.sparse.csgraph import connected_components
 5: from scipy.sparse import csr_array
 6: def set_random_seed(seed: int):
 7:     return np.random.default_rng(seed)
 8: def restrict_to_lcc(adj: csr_array, directed:bool) -> csr_array:
 9:     """ 
10:     resricts adjacency matrix to the largest connected component (LCC).
11:     """
12:     if directed:
13:         n_components, labels = connected_components(adj, directed=True)
14:     else:
15:         n_components, labels = connected_components(adj, directed=False)
16:     if n_components == 1:
17:         return adj
18:     largest_component = np.argmax(np.bincount(labels))
19:     mask = labels == largest_component
20:     adj_lcc = csr_array(adj[mask][:, mask]) # type: ignore
21:     return adj_lcc
22: def _nx_graph(adj: csr_array, *, directed: bool = False) -> nx.Graph:
23:     """Convert *adj* to a NetworkX (di)graph, restricted to its LCC."""
24:     adj_lcc = restrict_to_lcc(adj, directed)
25:     return (
26:         nx.from_scipy_sparse_matrix(adj_lcc, create_using=nx.DiGraph() if directed else nx.Graph())
27:     )

================
File: src/sbm/edge_delta.py
================
  1: """
  2: Classes to build and hold changes in edge counts between blocks in a Stochastic Block Model (SBM).
  3: """
  4: from typing import DefaultDict, Tuple, List, Literal, Tuple, Iterator, Iterable, Literal
  5: from collections import defaultdict, Counter
  6: import numpy as np
  7: from numba import jit
  8: EdgeDeltas = Literal["PythonEdgeDelta", "NumpyEdgeDelta"]
  9: #### Pure python class for edge deltas #######
 10: class EdgeDelta: # edge-count changes between blocks
 11:     def __init__(self, n_blocks: int):
 12:         self._deltas: DefaultDict[Tuple[int, int], int] = defaultdict(int)
 13:     def _increment(self, count: int, block_i: int, block_j: int,
 14:      ) -> None:
 15:         """
 16:         Increment the edge count delta for a pair of blocks.
 17:         :param count: The change in edge count.
 18:         :param block_i: The first block index.
 19:         :param block_j: The second block index.
 20:         :return: Updated edge count delta.
 21:         """
 22:         if block_i < block_j:
 23:             self._deltas[(block_i, block_j)] = count
 24:         else:
 25:             self._deltas[(block_j, block_i)] = count
 26:     def __getitem__(self, pair: Tuple[int, int]) -> int:
 27:         """
 28:         Get the edge count delta for a pair of blocks.
 29:         :param pair: A tuple containing the block indices (i, j).
 30:         :return: The edge count delta for the pair.
 31:         """
 32:         if pair[0] < pair[1]:
 33:             return self._deltas.get(pair, 0)
 34:         else:
 35:             return self._deltas.get((pair[1], pair[0]), 0)
 36:     def __len__(self) -> int:
 37:         """
 38:         Return the number of non-zero edge count deltas.
 39:         :return: The number of non-zero edge count deltas.
 40:         """
 41:         return len([v for v in self._deltas.values() if v != 0])
 42:     def items(self) -> Iterator[Tuple[Tuple[int, int], int]]:
 43:         """
 44:         Yield tuple ((i, j), delta_e) for all stored pairs.
 45:         :return: An iterator over tuples of (block_i, block_j, delta_e).
 46:         """
 47:         for (i, j), delta_e in self._deltas.items():
 48:             yield (i, j), delta_e
 49:     def increment(self,
 50:                   counts: Iterable[int],
 51:                   blocks_i: Iterable[int],
 52:                   blocks_j: Iterable[int],
 53:      ) -> None:
 54:         """
 55:         Increment the edge counts deltas for a list of block pairs.
 56:         :param counts: List of changes in edge counts.
 57:         :param blocks_i: List of first block indices.
 58:         :param blocks_j: List of second block indices.
 59:         """
 60:         for count, block_i, block_j in zip(counts, blocks_i, blocks_j):
 61:             self._increment(count, block_i, block_j)
 62: ##### NumPy class for edge deltas ######
 63: class NumpyEdgeDelta(EdgeDelta):
 64:     """Sparse, symmetric (i <= j) container for edgeâcount deltas.
 65:     Overwrites the pureâPython :py:class:`EdgeDelta` class
 66:     Internally stores three *contiguous* oneâdimensional NumPy arrays
 67:     (`rows`, `cols`, `data`) in **COO** fashion as well as a Python
 68:     ``dict`` that maps the linearised pair key ``i * n_blocks + j`` to the
 69:     corresponding position in the arrays.  Only the *active* prefix
 70:     (``self.size``) of the arrays is considered valid â this makes the
 71:     structure friendly to NumbaâJITâd consumers that expect fixedâsize
 72:     buffers.
 73:     The class focuses on *fast incremental updates* (``O(1)`` expected)
 74:     and cheap vector export; memory usage is proportional to the number
 75:     of *nonâzero* block pairs actually visited by the MCMC chain.
 76:     """
 77:     __slots__ = ("n_blocks", "rows", "cols", "data", "size", "_key2idx")
 78:     def __init__(self,
 79:                  n_blocks: int,
 80:                  initial_capacity: int = 64
 81:     ):
 82:         self.n_blocks: int = int(n_blocks)
 83:         cap = max(1, initial_capacity)
 84:         self.rows: np.ndarray = np.empty(cap, dtype=np.int32)
 85:         self.cols: np.ndarray = np.empty(cap, dtype=np.int32)
 86:         self.data: np.ndarray = np.zeros(cap, dtype=np.int32)
 87:         self.size: int = 0
 88:         # auxiliary map for *O(1)* lookup â not accessed inside JIT code
 89:         self._key2idx: dict[int, int] = {}
 90:     ### function for printing the object
 91:     def __repr__(self) -> str:
 92:         """Return a string representation of the NumpyEdgeDelta object."""
 93:         return (f"NumpyEdgeDelta(n_blocks={self.n_blocks}, "
 94:                 f"size={self.size}, "
 95:                 f"rows={self.rows[:self.size]}, "
 96:                 f"cols={self.cols[:self.size]}, "
 97:                 f"data={self.data[:self.size]})")
 98:     # ------------------------------------------------------------------
 99:     # Private helpers
100:     # ------------------------------------------------------------------
101:     def _encode(self, i: int, j: int) -> int:
102:         """Encode an ordered pair (i â¤ j) into a unique scalar."""
103:         return i * self.n_blocks + j
104:     def _ensure_capacity(self):
105:         if self.size == len(self.rows):
106:             # double inâplace (amortised O(1))
107:             new_cap = len(self.rows) * 2
108:             self.rows = np.resize(self.rows, new_cap)
109:             self.cols = np.resize(self.cols, new_cap)
110:             self.data = np.resize(self.data, new_cap)
111:     def _increment(self, count: int, block_i: int, block_j: int):
112:         """Add *value* to entry (i, j) (symmetric pair)."""
113:         if block_i > block_j:
114:             block_i, block_j = block_j, block_i
115:         key = self._encode(block_i, block_j)
116:         idx = self._key2idx.get(key)
117:         if idx is None:
118:             self._ensure_capacity()
119:             idx = self.size
120:             self.size += 1
121:             self.rows[idx] = block_i
122:             self.cols[idx] = block_j
123:             self.data[idx] = count
124:             self._key2idx[key] = idx
125:         else:
126:             self.data[idx] += count
127:     # ------------------------------------------------------------------
128:     # Public API
129:     # ------------------------------------------------------------------
130:     def __getitem__(self, pair: Tuple[int, int]) -> int:
131:         i, j = pair
132:         if i > j:
133:             i, j = j, i
134:         idx = self._key2idx.get(self._encode(i, j))
135:         return 0 if idx is None else int(self.data[idx])
136:     def __len__(self) -> int:
137:         """Return the number of non-zero and *active* pairs."""
138:         #return self.size
139:         active_pairs = self.data[:self.size]
140:         print(f"Active pairs: {active_pairs}")
141:         return active_pairs[active_pairs != 0].shape[0]
142:     def __setitem__(self, pair: Tuple[int, int], value: int):
143:         i, j = pair
144:         current = self[pair]
145:         self._increment(i, j, value - current)
146:     def items(self) -> Iterator[Tuple[Tuple[int, int], int]]:
147:         """Yield triples ``(i, j, delta_e)`` for all stored pairs."""
148:         for k in range(self.size):
149:             yield (int(self.rows[k]), int(self.cols[k])), int(self.data[k])
150:     def to_coo(self) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
151:         """Return the *active* COO view (no copying)."""
152:         return (self.rows[:self.size], self.cols[:self.size], self.data[:self.size])
153:     def increment(self,
154:             counts: Iterable[int],
155:             blocks_i: Iterable[int],
156:             blocks_j: Iterable[int],
157:      ) -> None:
158:         """Vectorised equivalent of ``increment`` for ``NumpyEdgeDelta``.
159:         Parameters
160:         ----------
161:         counts : 1âD ``int`` array
162:             Changes in edge counts (positive or negative).
163:         blocks_i, blocks_j : 1âD ``int`` arrays
164:             Block indices *parallel* to ``counts``.
165:         Notes
166:         -----
167:         The function works fully in **NumPy** space â no Python loops â by
168:         linearising the symmetric pair ``(i, j)`` into a *key* and then
169:         accumulating duplicate keys with :pyfunc:`numpy.add.at`.
170:         """
171:         # ------------------------------------------------------------------
172:         # Ensure ndarray inputs (copy=False promotes views)
173:         # ------------------------------------------------------------------
174:         assert isinstance(counts, (list, np.ndarray)) and \
175:                 isinstance(blocks_i, (list, np.ndarray)) and \
176:                 isinstance(blocks_j, (list, np.ndarray)), \
177:             "Counts and block indices must be list or ndarray."
178:         counts = np.asarray(counts, dtype=np.int32)
179:         blocks_i = np.asarray(blocks_i, dtype=np.int32)
180:         blocks_j = np.asarray(blocks_j, dtype=np.int32)
181:         # ------------------------------------------------------------------
182:         # Normalise the pair ordering so that i â¤ j
183:         # ------------------------------------------------------------------
184:         swap_mask = blocks_i > blocks_j
185:         if swap_mask.any():
186:             blocks_i, blocks_j = blocks_i.copy(), blocks_j.copy()  # avoid aliasing
187:             blocks_i[swap_mask], blocks_j[swap_mask] = blocks_j[swap_mask], blocks_i[swap_mask]
188:         # ------------------------------------------------------------------
189:         # Encode pairs â scalar keys and reduce duplicates in *one* pass
190:         # ------------------------------------------------------------------
191:         n_blocks = self.n_blocks
192:         keys = blocks_i.astype(np.int64) * n_blocks + blocks_j
193:         # ``np.unique`` already sorts â good for cache locality
194:         uniq_keys, inverse = np.unique(keys, return_inverse=True)
195:         reduced = np.zeros_like(uniq_keys, dtype=np.int32)
196:         np.add.at(reduced, inverse, counts)
197:         # ------------------------------------------------------------------
198:         # Decode unique keys and perform bulk update via the fast method
199:         # ------------------------------------------------------------------
200:         rows = (uniq_keys // n_blocks).astype(np.int32)
201:         cols = (uniq_keys %  n_blocks).astype(np.int32)
202:         for r, c, dv in zip(rows, cols, reduced):
203:             if dv != 0:
204:                 self._increment(block_i=int(r), block_j=int(c), count=int(dv))

================
File: src/tests/likelihood_test.py
================
  1: # tests/test_likelihood.py
  2: """
  3: End-to-end tests for the Bernoulli likelihood calculators.
  4:  * We create a tiny 4-node undirected graph with two blocks.
  5:  * We compare every Îâ returned by the incremental code against the
  6:    ground-truth global likelihood difference.
  7: """
  8: from __future__ import annotations
  9: from collections import Counter
 10: from typing import Tuple, Dict
 11: import numpy as np
 12: #np.float_ = np.float64  # ensure float64 is used
 13: import pytest
 14: from scipy.sparse import csr_array
 15: from sbm.likelihood import (
 16:     compute_global_bernoulli_ll,
 17:     LikelihoodCalculator
 18: )
 19: from sbm.block_data import BlockData
 20: from sbm.graph_data import GraphData
 21: from sbm.block_change_proposers import NodeSwapProposer 
 22: ##############################################################################
 23: # Fixtures
 24: ##############################################################################
 25: @pytest.fixture(scope="module")
 26: def four_node_example() -> Tuple[BlockData, GraphData, Dict[int, int]]:
 27:     """
 28:     Graph:
 29:         0ââ1   Block 0: {0,1}      Edges: (0,1)
 30:         â  â   Block 1: {2,3}              (2,3)
 31:         2ââ3                              (0,2) (1,3)
 32:     The matrix is symmetrical (undirected, no loops).
 33:     """
 34:     adj = np.zeros((4, 4), dtype=int)
 35:     edges = [(0, 1), (2, 3), (0, 2), (1, 3)]
 36:     for u, v in edges:
 37:         adj[u, v] = 1
 38:         adj[v, u] = 1  # symmetric
 39:     adjacency = csr_array(adj)
 40:     blocks = {0: 0, 1: 0, 2: 1, 3: 1}  # Node to block mapping
 41:     graph_data: GraphData = GraphData(adjacency_matrix=adjacency, directed=False)
 42:     return BlockData(graph_data=graph_data, initial_blocks=blocks), graph_data, blocks
 43: ##############################################################################
 44: # Tests
 45: ##############################################################################
 46: def test_edge_counter(four_node_example):
 47:     """`_compute_edge_counts_between_node_and_blocks` returns correct counts."""
 48:     block_data, *_ = four_node_example
 49:     change_proposer = NodeSwapProposer(block_data)
 50:     counts = change_proposer._compute_edge_counts_between_node_and_blocks(node=0)
 51:     # Node 0 is linked to node-1 (block-0) and node-2 (block-1) â {0:1, 1:1}
 52:     assert counts == Counter({0: 1, 1: 1})
 53: def test_swap_same_block_zero_delta(four_node_example):
 54:     """
 55:     Swapping two nodes that are *already* in the same block must leave the
 56:     likelihood unchanged.
 57:     """
 58:     block_data, *_ = four_node_example
 59:     swap_proposer = NodeSwapProposer(block_data)
 60:     calc = LikelihoodCalculator(block_data)
 61:     # attempt to swap nodes 0 and 2
 62:     swap = [(0, block_data.blocks[1]), (1, block_data.blocks[0])]
 63:     swap, delta_e, delta_n = swap_proposer.propose_change(swap)
 64:     delta = calc.compute_delta_ll(delta_e=delta_e, delta_n=delta_n)
 65:     assert delta == pytest.approx(0.0, abs=1e-6)
 66: def test_delta_ll_matches_global_recompute(four_node_example):
 67:     """
 68:     delta ll from the incremental calculator must equal the brute-force recomputed
 69:     likelihood difference after the swap (0 â 2).
 70:     """
 71:     block_data_old, graph_data, blocks_old = four_node_example
 72:     adjacency = graph_data.adjacency
 73:     swap_proposer = NodeSwapProposer(block_data_old)
 74:     calc = LikelihoodCalculator(block_data_old)
 75:     # ---------- perform swap 0 â 2 -----------------------------------------
 76:     blocks_new = blocks_old.copy()
 77:     blocks_new[0], blocks_new[2] = blocks_new[2], blocks_new[0]
 78:     block_data_new = BlockData(
 79:         graph_data=GraphData(adjacency_matrix=adjacency, directed=False),
 80:         initial_blocks=blocks_new
 81:     )
 82:     ll_old = compute_global_bernoulli_ll(block_data_old)
 83:     ll_new = compute_global_bernoulli_ll(block_data_new)
 84:     expected_delta = ll_new - ll_old
 85:     swap = [(0, block_data_old.blocks[2]), (2, block_data_old.blocks[0])]
 86:     swap, delta_e, delta_n = swap_proposer.propose_change(swap)
 87:     delta_calc = calc.compute_delta_ll(delta_e=delta_e, delta_n=delta_n)
 88:     msg = (
 89:         f"Failed on swap (0 â 2) with blocks {blocks_old} â {blocks_new}\n"
 90:         f"delta_e: {delta_e}\n"
 91:     )
 92:     assert delta_calc == pytest.approx(expected_delta, rel=1e-6, abs=1e-6), msg
 93: def test_delta_edge_counts_consistency(four_node_example):
 94:     """
 95:     The raw `delta_e` returned by `_compute_delta_edge_counts_swap` should turn
 96:     the old connectivity into the new one *exactly* on every affected (r,s).
 97:     """
 98:     block_data_old, graph_data, blocks_old = four_node_example
 99:     adjacency = graph_data.adjacency
100:     swap_proposer = NodeSwapProposer(block_data_old)
101:     calc = LikelihoodCalculator(block_data_old)
102:     i, j = 0, 2  # the same swap as above
103:     proposed_changes = [(i, block_data_old.blocks[j]), (j, block_data_old.blocks[i])]
104:     delta_e = swap_proposer._compute_delta_edge_counts(
105:         proposed_changes= proposed_changes
106:     )
107:     conn_expected = block_data_old.block_connectivity.copy()
108:     for (r, s), de in delta_e.items():
109:         conn_expected[r, s] += de
110:     # Ground-truth connectivity after the swap
111:     blocks_new = blocks_old.copy()
112:     blocks_new[i], blocks_new[j] = blocks_new[j], blocks_new[i]
113:     block_data_new = BlockData(
114:         graph_data=GraphData(adjacency_matrix=adjacency, directed=False),
115:         initial_blocks=blocks_new
116:     )
117:     for (r, s), de in delta_e.items():
118:         assert (
119:             conn_expected[r, s] == block_data_new.block_connectivity[r, s]
120:         ), f"Mismatch on block pair ({r},{s})"
121: ###################################################
122: ### Randomized tests
123: ###################################################
124: def _er_graph_csr(n: int, p: float, *, seed: int) -> csr_array:
125:     """Undirected G(n,p) without self-loops, returned as CSR matrix."""
126:     rng = np.random.default_rng(seed)
127:     upper = rng.random((n, n)) < p                           # boolean mask
128:     upper = np.triu(upper, k=1)                              # keep strict upper
129:     adj = upper | upper.T                                    # symmetrise
130:     return csr_array(adj.astype(np.int8))
131: def _random_equal_blocks(n: int, block_size: int, *, seed: int) -> dict[int, int]:
132:     """Random permutation of vertices into equal-size blocks."""
133:     rng = np.random.default_rng(seed)
134:     perm = rng.permutation(n)
135:     blocks: dict[int, int] = {}
136:     for b in range(n // block_size):
137:         for v in perm[b * block_size : (b + 1) * block_size]:
138:             blocks[v] = b
139:     return blocks
140: def _pick_two_different_blocks(rng: np.random.Generator, blocks: dict[int, int]):
141:     n = len(blocks)
142:     i = rng.choice(n, size=1)[0]
143:     j = rng.choice(n-1, size=1)[0]
144:     if j >= i:
145:         j += 1
146:     return i, j
147: def _single_swap_calc_vs_bruteforce(
148:     graph_data: GraphData,
149:     blocks: dict[int, int],
150:     rng: np.random.Generator,
151:     tol: float = 1e-6,
152:     experiment_index: int = 0
153: ):
154:     """One random swap and check incremental delta ll against brute force."""
155:     # choose vertices in different blocks
156:     i, j = _pick_two_different_blocks(rng, blocks)
157:     # incremental path -------------------------------------------------
158:     block_data = BlockData(graph_data=graph_data, initial_blocks=blocks)
159:     print(block_data.blocks)
160:     swap_proposer = NodeSwapProposer(block_data)
161:     calc = LikelihoodCalculator(block_data)
162:     swap_instr = [(i, blocks[j]), (j, blocks[i])]
163:     _, delta_e, delta_n = swap_proposer.propose_change(swap_instr)
164:     delta_ll = calc.compute_delta_ll(delta_e=delta_e, delta_n=delta_n)
165:     # brute-force path -------------------------------------------------
166:     ll_before = compute_global_bernoulli_ll(block_data)
167:     new_blocks = blocks.copy()
168:     new_blocks[i], new_blocks[j] = new_blocks[j], new_blocks[i]
169:     block_data_after = BlockData(graph_data=graph_data, initial_blocks=new_blocks)
170:     ll_after = compute_global_bernoulli_ll(block_data_after)
171:     delta_brute = ll_after - ll_before
172:     # compute the delta_e in the brute-force way
173:     # only storing non-zero deltas in upper triangular matrix
174:     delta_e_brute = block_data_after.block_connectivity - block_data.block_connectivity
175:     delta_e_brute = {
176:         (r, s): de for (r, s), de in zip(
177:             np.argwhere(delta_e_brute != 0),
178:             delta_e_brute[delta_e_brute != 0]
179:         )
180:         if r <= s
181:     }
182:     # comparison and print informatino in case of failure
183:     msg = (
184:         f"Failed on experiment {experiment_index}"
185:         f"\nGraph: {graph_data.adjacency.toarray()}"
186:         f"\nBlocks: {blocks}"
187:         f"\nswap:         {i} <-> {j} (blocks {blocks[i]} <-> {blocks[j]})"
188:         f"\ndelta_e:   {delta_e}"
189:         f"\ndelta_e_brute:   {delta_e_brute}"
190:         f"\ndelta_inc:    {delta_ll:.12g}"
191:         f"\ndelta_brute:  {delta_brute:.12g}"
192:     )
193:     assert delta_ll == pytest.approx(delta_brute, rel=tol, abs=tol), msg
194: def test_delta_ll_random_swaps_er():
195:     """100 random swaps on independent ER-20 graph must all match brute force delta ll."""
196:     for index in range(100):
197:         n, p, b = 20, 0.1, 2
198:         rng = np.random.default_rng(1)
199:         adj = _er_graph_csr(n, p, seed=42)
200:         graph = GraphData(adjacency_matrix=adj, directed=False)
201:         blocks = _random_equal_blocks(n, block_size=b, seed=2)
202:         _single_swap_calc_vs_bruteforce(graph_data=graph,
203:                                         blocks=blocks,
204:                                         rng=rng,
205:                                         experiment_index=index,
206:                                         tol=1e-6
207:                                         )

================
File: src/tests/test_metrics.py
================
 1: import numpy as np, scipy.sparse as sp
 2: from scipy.sparse import csr_array
 3: from metrics import (
 4:     shortest_path_distance,
 5:     degree_distance,
 6:     clustering_distance
 7: )
 8: ### Helper functions to create graphs
 9: def _line_graph(n=6) -> csr_array:
10:     rows = np.arange(n-1); cols = rows + 1
11:     A = sp.coo_matrix((np.ones(n-1), (rows, cols)), shape=(n, n))
12:     A = A + A.T
13:     A = csr_array(A, dtype=np.int8)
14:     return A
15: def _er_graph(n: int=10, p: float=0.1, *, seed: int=1) -> csr_array:
16:     """Undirected G(n,p) without self-loops, returned as CSR matrix."""
17:     rng = np.random.default_rng(seed)
18:     upper = rng.random((n, n)) < p                           # boolean mask
19:     upper = np.triu(upper, k=1)                              # keep strict upper
20:     adj = upper | upper.T                                    # symmetrise
21:     return csr_array(adj.astype(np.int8))
22: #### test functions
23: def test_shortest_path_identical_line():
24:     A = _line_graph()
25:     print(A.toarray())
26:     assert shortest_path_distance(A, A, n_samples=None) == 0.0
27: def test_degree_identical_line():
28:     A = _line_graph()
29:     assert degree_distance(A, A) == 0.0
30: def test_clustering_identical_line():
31:     A = _line_graph()
32:     assert clustering_distance(A, A) == 0.0
33: def test_shortest_path_different_line():
34:     A = _line_graph(n=20)
35:     B = _line_graph(n=200)
36:     assert shortest_path_distance(A, B, n_samples=100) != 0.0
37: def test_degree_different_line():
38:     A = _line_graph(n=20)
39:     A = _line_graph(n=200)
40:     assert degree_distance(A, A) == 0.0
41: def test_clustering_identical_er():
42:     A = _er_graph(n=100)
43:     assert clustering_distance(A, A) == 0.0
44: def test_shortest_path_identical_er():
45:     A = _er_graph(p=0.9)
46:     assert shortest_path_distance(A, A, n_samples=None) == 0.0
47: def test_shortest_path_different_er():
48:     A = _er_graph(n=20, p=0.9)
49:     B = _er_graph(n=200, p=0.1)
50:     assert shortest_path_distance(A, B, n_samples=100) != 0.0
51: def test_degree_different_er():
52:     A = _er_graph()
53:     assert degree_distance(A, A) == 0.0
54: def test_clustering_different_er():
55:     A = _er_graph()
56:     assert clustering_distance(A, A) == 0.0

================
File: .gitignore
================
 1: # --------------------------------------------------------------------
 2: #  Python byte-code / build artefacts
 3: # --------------------------------------------------------------------
 4: __pycache__/
 5: *.py[cod]
 6: *.pyo
 7: *.so
 8: *.dylib
 9: *.egg-info/
10: build/
11: dist/
12: 
13: # --------------------------------------------------------------------
14: #  Virtual-envs
15: # --------------------------------------------------------------------
16: .venv/
17: .env/
18: .mamba/
19: *.conda_env/
20: 
21: # --------------------------------------------------------------------
22: #  Data & model artefacts  (generated by pipeline)
23: # --------------------------------------------------------------------
24: data/
25: models/
26: logs/
27: reports/
28: figures/
29: results/
30: 
31: # --------------------------------------------------------------------
32: #  Large numpy / scipy files anywhere but src/tests
33: # --------------------------------------------------------------------
34: *.npz
35: *.npy
36: *.pkl
37: *.h5
38: *.parquet
39: 
40: # --------------------------------------------------------------------
41: #  Jupyter checkpoints
42: # --------------------------------------------------------------------
43: .ipynb_checkpoints/
44: 
45: # --------------------------------------------------------------------
46: #  IDE / OS metadata
47: # --------------------------------------------------------------------
48: .idea/
49: .vscode/
50: *.swp
51: .DS_Store
52: Thumbs.db
53: 
54: # --------------------------------------------------------------------
55: #  Misc
56: # --------------------------------------------------------------------
57: *.bak
58: *.tmp
59: repomix-output.txt
60: *.lprof

================
File: requirements.txt
================
 1: pytest
 2: numpy==1.26.4
 3: scipy==1.12.0
 4: networkx
 5: metis
 6: ortools
 7: tqdm
 8: pyyaml
 9: nodevectors
10: scikit-learn
11: k-means-constrained
12: line_profiler
13: infomap
14: leidenalg
15: python-igraph

================
File: configs/sbm_fit_block_size_experiments.yml
================
 1: # -------------------------------------------------------------------
 2: #  Global defaults
 3: # -------------------------------------------------------------------
 4: seed: 42
 5: # -------------------------------------------------------------------
 6: #  Configuration for the SBM models fitting as list of dicts
 7: # Each item needs:
 8: #    min_block_size: minimum size of the blocks
 9: #    n_iter: number of iterations for the fitting
10: #    temperature: initial temperature for the simulated annealing
11: #    cooling_rate: cooling rate for the simulated annealing
12: #    force_undirected: whether to treat the graph as undirected
13: # -------------------------------------------------------------------
14: sbm:
15:   - min_block_size: 3
16:     cooling_rate: 0.9999
17:     force_undirected: true
18:     init_method: "metis"
19:   - min_block_size: 6
20:     cooling_rate: 0.9999
21:     force_undirected: true
22:     init_method: "metis"
23:   - min_block_size: 12
24:     cooling_rate: 0.9999
25:     force_undirected: true
26:     init_method: "metis"
27:   - min_block_size: 25
28:     cooling_rate: 0.9999
29:     force_undirected: true
30:     init_method: "metis"
31: # -------------------------------------------------------------------
32: #  Configuration for the logging
33: #  - logging_folder: folder to save the logs
34: #  - overwirte: set true to ignore cached results
35: #  - log_every: how often to log the results (in number of iterations)
36: # -------------------------------------------------------------------
37: logging:
38:   - logging_folder: "./logs/"
39:     overwrite: true           # set true to ignore cached results
40:     log_every: 1_000
41: # -------------------------------------------------------------------
42: #  List of empirical graphs to process
43: #  Each item needs:
44: #    name : label used for output folder (models/sbm/<name>/)
45: #    path : relative or absolute path to the processed graph file
46: # -------------------------------------------------------------------
47: datasets:
48: # small datasets (< 1000 nodes)
49:   - name: congress_twitter
50:     path: data/processed/congress_twitter.edgelist # undirected GML
51:   - name: caltech_fb 
52:     path: data/processed/caltech_fb.edgelist # undirected GML
53:   - name: eu_email
54:     path: data/processed/eu_email.edgelist # undirected GML
55: # medium datasets (1000 - 10_000 nodes):
56:   - name: lastfm_asia
57:     path: data/processed/lastfm_asia.edgelist # undirected GML
58:   - name: wiki_vote
59:     path: data/processed/wiki_vote.edgelist # undirected GML
60: # large datasets (10_000-100_000 nodes):
61:   - name: enron_email 
62:     path: data/processed/enron_email.edgelist # undirected GML

================
File: configs/surrogate_eval.yml
================
 1: # ---------------------------------------------------------------
 2: n_surrogates: 20 # graphs to sample per dataset
 3: overwrite: true # set true to ignore cached results
 4: # which similarity metrics to compute
 5: metrics:
 6:   - shortest_path
 7:   - avg_path_length
 8:   - degree
 9:   - clustering
10:   - avg_clustering
11:   - spectral
12:   - infomap
13:   - leiden
14:   - assortativity
15:   - embedding_node2vec
16:   - embedding_prone

================
File: notebooks/sbm_block_sizes_26-06-2025.ipynb
================
  1: {
  2:  "cells": [
  3:   {
  4:    "cell_type": "markdown",
  5:    "id": "09dbb184",
  6:    "metadata": {},
  7:    "source": [
  8:     "# Investigate SBM block sizes\n",
  9:     "We are attempting to learn SBM representations with a min-block size constraint.\n",
 10:     "\n",
 11:     "Optimally, we would like all blocks to have minimum size (gives smallest expected reconstruction error).\n",
 12:     "\n",
 13:     "The current implementation (Metis asigner) creates initial blocks, and their sizes never change. However, these initial blocks are not all minimum block size.\n",
 14:     "\n",
 15:     "Here we plot the actual block-size distributions and compare with pre-specified min-block-size."
 16:    ]
 17:   },
 18:   {
 19:    "cell_type": "code",
 20:    "execution_count": 1,
 21:    "id": "7097892b",
 22:    "metadata": {},
 23:    "outputs": [],
 24:    "source": [
 25:     "from pathlib import Path\n",
 26:     "import numpy as np\n",
 27:     "import pandas as pd\n",
 28:     "import matplotlib.pyplot as plt"
 29:    ]
 30:   },
 31:   {
 32:    "cell_type": "code",
 33:    "execution_count": 2,
 34:    "id": "8cb75b7b",
 35:    "metadata": {},
 36:    "outputs": [],
 37:    "source": [
 38:     "def get_min_block_size(string):\n",
 39:     "    # find index of substring 'min_block_size'\n",
 40:     "    index = string.find('min_block_size')\n",
 41:     "\n",
 42:     "    tail_string = string[index + len('min_block_size_'):]\n",
 43:     "    block_size = tail_string.split(\"_\")[0]\n",
 44:     "\n",
 45:     "    return int(block_size)"
 46:    ]
 47:   },
 48:   {
 49:    "cell_type": "code",
 50:    "execution_count": 4,
 51:    "id": "968e6b67",
 52:    "metadata": {},
 53:    "outputs": [
 54:     {
 55:      "name": "stdout",
 56:      "output_type": "stream",
 57:      "text": [
 58:       "Loading fit from /Users/lmmi/anon_sbm/data/sbm_fits/sbm_fit_congress_twitter_cooling_rate_0_999_force_undirected_True_init_method_ProneKMeans_max_n_iter_10000_min_block_size_3_patience_1000_temperature_1_0\n"
 59:      ]
 60:     },
 61:     {
 62:      "ename": "FileNotFoundError",
 63:      "evalue": "[Errno 2] No such file or directory: '/Users/lmmi/anon_sbm/data/sbm_fits/sbm_fit_congress_twitter_cooling_rate_0_999_force_undirected_True_init_method_ProneKMeans_max_n_iter_10000_min_block_size_3_patience_1000_temperature_1_0/block_sizes.json'",
 64:      "output_type": "error",
 65:      "traceback": [
 66:       "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
 67:       "\u001b[31mFileNotFoundError\u001b[39m                         Traceback (most recent call last)",
 68:       "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[4]\u001b[39m\u001b[32m, line 21\u001b[39m\n\u001b[32m     19\u001b[39m \u001b[38;5;28mprint\u001b[39m(\u001b[33mf\u001b[39m\u001b[33m\"\u001b[39m\u001b[33mLoading fit from \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mfit_folder_path\u001b[38;5;132;01m}\u001b[39;00m\u001b[33m\"\u001b[39m)\n\u001b[32m     20\u001b[39m min_block_size = get_min_block_size(\u001b[38;5;28mstr\u001b[39m(fit_folder_path))\n\u001b[32m---> \u001b[39m\u001b[32m21\u001b[39m sbm_fit = \u001b[43mSBMWriter\u001b[49m\u001b[43m.\u001b[49m\u001b[43mload\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfit_folder_path\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43msilence\u001b[49m\u001b[43m=\u001b[49m\u001b[38;5;28;43;01mTrue\u001b[39;49;00m\u001b[43m)\u001b[49m\n\u001b[32m     23\u001b[39m min_block_sizes.append([min_block_size] * \u001b[38;5;28mlen\u001b[39m(sbm_fit.block_sizes))\n\u001b[32m     24\u001b[39m block_sizes.append(sbm_fit.block_sizes)\n",
 69:       "\u001b[36mFile \u001b[39m\u001b[32m~/anon_sbm/src/sbm/io.py:51\u001b[39m, in \u001b[36mSBMWriter.load\u001b[39m\u001b[34m(path, silence)\u001b[39m\n\u001b[32m     48\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m silence:\n\u001b[32m     49\u001b[39m     \u001b[38;5;28mprint\u001b[39m(\u001b[33mf\u001b[39m\u001b[33m\"\u001b[39m\u001b[33mLoading SBM fit from \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mpath\u001b[38;5;132;01m}\u001b[39;00m\u001b[33m\"\u001b[39m)\n\u001b[32m---> \u001b[39m\u001b[32m51\u001b[39m \u001b[38;5;28;01mwith\u001b[39;00m \u001b[38;5;28;43mopen\u001b[39;49m\u001b[43m(\u001b[49m\u001b[43mpath\u001b[49m\u001b[43m \u001b[49m\u001b[43m/\u001b[49m\u001b[43m \u001b[49m\u001b[33;43m\"\u001b[39;49m\u001b[33;43mblock_sizes.json\u001b[39;49m\u001b[33;43m\"\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[33;43m'\u001b[39;49m\u001b[33;43mr\u001b[39;49m\u001b[33;43m'\u001b[39;49m\u001b[43m)\u001b[49m \u001b[38;5;28;01mas\u001b[39;00m sizes_file:\n\u001b[32m     52\u001b[39m     block_sizes = json.load(sizes_file)\n\u001b[32m     53\u001b[39m block_sizes = [\u001b[38;5;28mint\u001b[39m(size) \u001b[38;5;28;01mfor\u001b[39;00m size \u001b[38;5;129;01min\u001b[39;00m block_sizes]\n",
 70:       "\u001b[31mFileNotFoundError\u001b[39m: [Errno 2] No such file or directory: '/Users/lmmi/anon_sbm/data/sbm_fits/sbm_fit_congress_twitter_cooling_rate_0_999_force_undirected_True_init_method_ProneKMeans_max_n_iter_10000_min_block_size_3_patience_1000_temperature_1_0/block_sizes.json'"
 71:      ]
 72:     }
 73:    ],
 74:    "source": [
 75:     "import yaml\n",
 76:     "from sbm.utils.pipeline_utils import sbmfit_folderpath\n",
 77:     "from sbm.io import SBMWriter\n",
 78:     "\n",
 79:     "fit_config = yaml.safe_load(Path(\"/Users/lmmi/anon_sbm/configs/sbm_fit_block_size_experiments.yml\").read_text())\n",
 80:     "data_config = fit_config[\"datasets\"] # type: ignore\n",
 81:     "\n",
 82:     "min_block_sizes = []\n",
 83:     "block_sizes = []\n",
 84:     "for sbm_config in fit_config[\"sbm\"]:\n",
 85:     "    for ds in data_config:\n",
 86:     "\n",
 87:     "        # load fitted model\n",
 88:     "        fit_folder_path = sbmfit_folderpath(\n",
 89:     "            base_dir=Path(\"/Users/lmmi/anon_sbm/data/sbm_fits\"),\n",
 90:     "            sbm_config=sbm_config,# type: ignore\n",
 91:     "            data_spec=ds,\n",
 92:     "        )\n",
 93:     "        print(f\"Loading fit from {fit_folder_path}\")\n",
 94:     "        min_block_size = get_min_block_size(str(fit_folder_path))\n",
 95:     "        sbm_fit = SBMWriter.load(fit_folder_path, silence=True)\n",
 96:     "\n",
 97:     "        min_block_sizes.append([min_block_size] * len(sbm_fit.block_sizes))\n",
 98:     "        block_sizes.append(sbm_fit.block_sizes)\n"
 99:    ]
100:   },
101:   {
102:    "cell_type": "code",
103:    "execution_count": 35,
104:    "id": "7d83487f",
105:    "metadata": {},
106:    "outputs": [],
107:    "source": [
108:     "# flatten the lists\n",
109:     "min_block_sizes = np.array([ item for sublist in min_block_sizes for item in sublist ])\n",
110:     "block_sizes = np.array([ item for sublist in block_sizes for item in sublist ])"
111:    ]
112:   },
113:   {
114:    "cell_type": "code",
115:    "execution_count": 36,
116:    "id": "545352fa",
117:    "metadata": {},
118:    "outputs": [
119:     {
120:      "name": "stderr",
121:      "output_type": "stream",
122:      "text": [
123:       "/var/folders/y6/j9fbqcvx6lb5l99614n30y4c0000gn/T/ipykernel_92149/2968653449.py:7: UserWarning: FigureCanvasAgg is non-interactive, and thus cannot be shown\n",
124:       "  fig.show()\n"
125:      ]
126:     },
127:     {
128:      "data": {
129:       "image/png": "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bzmdawUhhyNvbkf9/fdmWd3GjWZcoIDUt680apRUpoy9vQEAACBvc/vEkS9fPgUHB9vdxnXJ6kxRXgpKP/xgwtGl3Js/v/TEEyYchYba2xsAAAAguflyO0k6cOCAQkJCVLFiRT388MM6cuTIVa9PTExUbGxsugfst3271KaN1LixCUj58kn9+kkHDkivvkpAAgAAgPtw65DUsGFDLV++XBs2bNDChQsVERGhJk2a6OzZs5m+Jjw8XIGBgamPUH77ttVPP0nt2km33y59/rkJR088YcLR4sVS+fJ2dwgAAACk59YhqW3bturatatq166t1q1b67PPPlN0dLTee++9TF8zatQoxcTEpD4iIyNzsGNcsmOH1L69dNtt0vr1kre39Nhj0v790uuvSxUq2N0hAAAAkDG3vycprSJFiqhq1ao6ePBgptf4+PjIx8cnB7tCWr/8Yu45+vhjM/bykh59VBo7VqpUyd7eAAAAgKxw65mkf4uLi9OhQ4dUOpfsC53VzRg8YdOGXbukTp2kW24xAcnLS3rkEWnfPmnZMgISAAAAcg+3DknPPfecvv32Wx0+fFg//PCDOnXqJG9vb3Xv3t3u1rLsWgEotwek3bulLl2kunWltWvNTn0PPyz9/rv05ptSlSp2dwgAAABkj1svtzt69Ki6d++u06dPq0SJErrzzju1bds2lShRwu7WssWyMt4OPDcHpF9/lSZNkj74wIwdDqlbN2n8eCkXnvcLAAAApHLrkLR69Wq7W3CatEFpzBhp6lR7+7lev/9uwtH771/+O3Xtau5DqlHD7u4AAACAG+fWIQnuY98+afJkafXqyzNgDzxgwtHNN9vbGwAAAOBMhCRc1R9/mHC0apWUkmJqnTubcFS7tr29AQAAAK5ASEKGDhyQpkyR3nnncjjq2NGEo7p17ewMAAAAcC1CEtI5dMiEo7fflpKTTe3++6WJE6V69WxtDQAAAMgRbr0FuCd58snLX0+bln7sDiIipMcfl6pVk1asMAHp3nuln36S1q0jIAEAACDvYCYpB2S0/fdrr5mH3duAHz5sQtvy5dLFi6bWtq2ZObrtNhsbAwAAAGxCSHKxjALSv5+3IygdOWLC0dKll8NR69YmHN1+e873AwAAALgLltu5UFaX1OXk0rvISKl/f6lyZTOTdfGidM890pYt0oYNBCQAAACAkORCr73m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xxQQEHDN1xQrVkxdu3ZV165d9cILL6hevXqaPXu2VqxYkeH1v//+u7p166bp06erVatWqfW4uDiVLl1amzZtuuI1RYoUuWYfAJAXMZMEAHlAmzZtdOHCBSUlJal169Z2t5NOiRIldOLEidRxbGysIiIicuzP9/b2lqR0OwBeEhAQoJCQEG3ZsiVdfcuWLapRo4YkM8O1c+fOq97f4+fnp08++US+vr5q3bq1zp49m60eCxQooEqVKqXubvdvf//9t+677z516dJFQ4YMSffcLbfcoqioKOXLl0+VK1dO98jqjCIA5DWEJADIA7y9vbV37179/vvvqaHAXdx9991666239N1332nPnj3q1auXS3uMjo5WVFSUjh8/rm+//VaTJ09W1apVddNNN2V4/fDhwzVjxgy9++672r9/v55//nnt3LlTgwYNkiR1795dwcHB6tixo7Zs2aI///xTH374obZu3ZrufQoWLKhPP/1U+fLlU9u2bRUXF5fhn/fJJ5+oZ8+eqUsB9+/fr9mzZ+uzzz5Thw4dMnxNly5d5O/vr4kTJyoqKir1kZycrJYtW6pRo0bq2LGjvvjiCx0+fFg//PCDxowZo59//vkGvpMA4LlYbgcAeURWlnjZYdSoUYqIiFD79u0VGBioKVOmuHQm6dLOfpfusWratKleeOGFTM97evbZZxUTE6Nhw4bp1KlTqlGjhv7zn/+oSpUqkswszxdffKFhw4apXbt2unjxomrUqJHhssZChQpp/fr1at26te6991599tlnKliwYLpratSoIX9/fw0bNkyRkZHy8fFRlSpVtGTJkkzvndq8ebMkqXz58unqERERqlChgj777DONGTNGffr00V9//ZX69750bxcAID2H9e+F4AAAAACQh7HcDgAAAADSICQBAAAAQBqEJAAAAABIg5AEAAAAAGkQkgAAAAAgDUISAAAAAKRBSAIAAACANAhJAAAAAJAGIQkAAAAA0iAkAQAAAEAahCQAAAAASIOQBAAAAABp/D9dke2IkjFNNAAAAABJRU5ErkJggg==",
130:       "text/plain": [
131:        "<Figure size 1000x600 with 1 Axes>"
132:       ]
133:      },
134:      "metadata": {},
135:      "output_type": "display_data"
136:     }
137:    ],
138:    "source": [
139:     "fig, ax = plt.subplots(figsize=(10, 6))\n",
140:     "\n",
141:     "ax.plot(min_block_sizes, block_sizes, marker='o', linestyle='-', color='b')\n",
142:     "ax.set_xlabel(\"Minimum Block Size\")\n",
143:     "ax.set_ylabel(\"Block Sizes\")\n",
144:     "\n",
145:     "fig.show()\n"
146:    ]
147:   },
148:   {
149:    "cell_type": "code",
150:    "execution_count": 49,
151:    "id": "879ee57b",
152:    "metadata": {},
153:    "outputs": [
154:     {
155:      "data": {
156:       "text/plain": [
157:        "<matplotlib.legend.Legend at 0x11ffcd6d0>"
158:       ]
159:      },
160:      "execution_count": 49,
161:      "metadata": {},
162:      "output_type": "execute_result"
163:     },
164:     {
165:      "data": {
166:       "image/png": "iVBORw0KGgoAAAANSUhEUgAAAucAAAHgCAYAAAAG6sPtAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjMsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvZiW1igAAAAlwSFlzAAAPYQAAD2EBqD+naQAARqVJREFUeJzt3Xl0VPX9//HXncnGkhVIQkIgCYggCChISpFav0YQWypqK7VWENGiRVzS1opVItYara2lrbRYu8CvLYragrZaClJxqbiB1I0dIms2loQEyDL38/sjZCQkE2ZCknuTPB/nzIHc+dx735nJTF5z876faxljjAAAAAA4zuN0AQAAAABqEc4BAAAAlyCcAwAAAC5BOAcAAABcgnAOAAAAuAThHAAAAHCJMKcLAADADXw+n6qrq50uA0AHFR4eLq/Xe9pxhHMAQKdmjFFBQYEOHz7sdCkAOri4uDglJyfLsqyAYwjnAIBOrS6YJyYmqmvXrk3+0gSA5jDG6OjRoyoqKpIk9e7dO+BYwjkAoNPy+Xz+YN6jRw+nywHQgXXp0kWSVFRUpMTExIAtLpwQCgDotOp6zLt27epwJQA6g7r3mqbObyGcAwA6PVpZALSFYN5rCOcAAACASxDOAQAAAJcgnAMAAFmWpQceeKBVtr1mzRpZlqXnn3++Vba/aNEiWZal/Pz8Vtl+e9DSz9+Xv/xlDR069LTj8vPzZVmWFi1a1GL7Plndc/v++++3yvYfeOAB17W1Ec4BAGiEbduqqalx/GbbdrPqrws1J98SExN18cUX61//+lcLP1oAWgpTKQIAcArbtnXo0CH5fD6nS5HX61V8fLw8nuYdT3vwwQeVkZEhY4wKCwu1aNEiXX755frHP/6hr371qy1crTOuv/56ffOb31RkZKTTpTjm2LFjCgsj1oXqvvvu0z333ON0GfXwLAIAcArbtuXz+fxHnJ1ijJHP55Nt280O5xMnTtSoUaP8X8+YMUNJSUl6+umnO0w493q9QV0WvSXt2bNH3bp1U3x8fJvuN5CoqCinS2iXwsLCXPehhrYWAAACsCxLHo/HsVtrfDCIi4tTly5dggokH3zwgSZOnKiYmBh1795dl1xyid5+++0G4w4fPqy77rpL6enpioyMVJ8+fTR16lSVlJQE3HZlZaW++tWvKjY2Vm+99VaTdfz617/WkCFD1LVrV8XHx2vUqFFasmSJ//5Te87r+ogbu91www3+9Wzb1vz58zVkyBBFRUUpKSlJM2fO1KFDh0772LzyyitKSUnRddddp1dffVXGmNOuE0hd/W+++aZuv/129erVS3FxcZo5c6aqqqp0+PBhTZ06VfHx8YqPj9fdd9/dYH+n9pzXPQbbtm3TDTfcoLi4OMXGxmr69Ok6evRo0LWtW7dOX/ziF9WlSxdlZGRo4cKFQa33n//8R+PGjVO3bt0UFxenK664Qhs3bmwwbu/evZoxY4ZSUlIUGRmpjIwM3Xrrraqqqgq47UOHDmn06NHq06ePNm/eHHBcdXW15s2bp7POOktRUVHq0aOHLrzwQq1atco/5tSe8xtuuCHgz87Jj29lZaVyc3M1YMAARUZGKi0tTXfffbcqKyuDenya4q6PCgAAoEWVlpaqpKRExhgVFRXp17/+tcrLy/Xtb3+7yfU++eQTjRs3TjExMbr77rsVHh6uJ598Ul/+8pf12muvKSsrS5JUXl6ucePGaePGjbrxxht1/vnnq6SkRC+++KL27Nmjnj17Ntj2sWPHdMUVV+j999/XK6+8ogsuuCBgHU899ZRuv/12ff3rX9cdd9yh48eP68MPP9Q777yjb33rW42uc9VVV2nAgAH1lq1bt07z589XYmKif9nMmTO1aNEiTZ8+Xbfffrt27typJ554Qh988IH++9//Kjw8PGBd48eP1+zZs/XnP/9ZS5YsUWZmpm688UbdcMMNSk1NbfKxDWT27NlKTk7WvHnz9Pbbb+t3v/ud4uLi9NZbb6lv3756+OGH9fLLL+uxxx7T0KFDNXXq1NNu85prrlFGRoby8vK0fv16/f73v1diYqIeffTR06576NAhXX755brmmmt07bXX6tlnn9Wtt96qiIgI3XjjjQHXe+WVVzRx4kRlZmbqgQce0LFjx/TrX/9aY8eO1fr165Weni5J2rdvn0aPHq3Dhw/rO9/5jgYNGqS9e/fq+eef19GjRxUREdFg2yUlJbr00kt18OBBvfbaa+rfv3/AOh544AHl5eXppptu0ujRo1VWVqb3339f69ev16WXXtroOjNnzlR2dna9ZStWrNBf//pX/8+Obdv62te+pjfffFPf+c53NHjwYH300Uf6xS9+oS1btmj58uWneWRPwwAA0EkdO3bMfPrpp+bYsWP1lldXV5vCwkJTXFxsDhw44NituLjYFBYWmurq6pC/tz/96U9GUoNbZGSkWbRoUYPxkkxubq7/68mTJ5uIiAizfft2/7J9+/aZ6Oho86Uvfcm/bO7cuUaS+fvf/95gm7ZtG2OMefXVV40k89xzz5kjR46Yiy66yPTs2dN88MEHp/0+rrjiCjNkyJCgvtedO3c2en9xcbHp27evOffcc015ebkxxpg33njDSDJ//etf641dsWJFo8sDqa6uNi+88IKZPHmyCQ8PN16v11x++eXm73//u6mqqgpqG3X1T5gwwf+YGWPMmDFjjGVZ5pZbbvEvq6mpMX369DEXXXRRvW2c+vzl5uYaSebGG2+sN+7KK680PXr0OG1NF110kZFkfv7zn/uXVVZWmhEjRpjExET/97Zz504jyfzpT3/yj6sbc+DAAf+y//3vf8bj8ZipU6f6l02dOtV4PB7z3nvvNdh/3eNQ99i89957Zv/+/WbIkCEmMzPT5Ofnn/Z7GD58uPnKV77S5Ji6xymQrVu3mtjYWHPppZeampoaY4wxf/7zn43H4zFvvPFGvbELFy40ksx///vfgNsL9J5zMtpaAADowBYsWKBVq1Zp1apV+stf/qKLL75YN910k/7+978HXMfn82nlypWaPHmyMjMz/ct79+6tb33rW3rzzTdVVlYmSfrb3/6m4cOH68orr2ywnVPbckpLSzV+/Hht2rRJa9as0YgRI05bf1xcnPbs2aP33nsvyO+44fdy7bXX6siRI1q2bJm6desmSXruuecUGxurSy+9VCUlJf7byJEj1b17d7366qtBbT8sLExf+9rXtGzZMu3Zs0ePPvqoPvvsM1111VXq06ePfvCDHzR5qfaTzZgxo95jlpWVJWOMZsyY4V/m9Xo1atQo7dixI6ht3nLLLfW+HjdunA4cOOB//k73vc2cOdP/dUREhGbOnKmioiKtW7eu0XX279+vDRs26IYbblBCQoJ/+bBhw3TppZfq5ZdfllR79Hn58uWaNGlSvXMi6pz6s7Nnzx5ddNFFqq6u1uuvv65+/fqdtv64uDh98skn2rp162nHNqaiokJXXnml4uPj9fTTT/vPa3juuec0ePBgDRo0qN7Pzv/93/9JUtA/O4EQzgEA6MBGjx6t7OxsZWdn67rrrtNLL72kc845R7fddlvAvt7i4mIdPXpUZ599doP7Bg8eLNu2tXv3bknS9u3bg5oPW5LuvPNOvffee3rllVc0ZMiQoNb54Q9/qO7du2v06NE666yzNGvWLP33v/8Nal2pdjaO//znP1qyZEm9FoitW7eqtLRUiYmJ6tWrV71beXm5ioqKgt5HncTERH3ve9/TW2+9pZtuuklFRUX62c9+poqKiqDW79u3b72vY2NjJUlpaWkNlgfTF9/YNutOYA1m/ZSUFP+HmToDBw6UpIBzyn/22WeSFPBnp6SkRBUVFSouLlZZWVnQPzvXX3+9ioqK9NprrwXdNvTggw/q8OHDGjhwoM4991z94Ac/0IcffhjUupJ08803a/v27Vq2bJl69OjhX75161Z98sknDX5u6h6b5vzsnIxwDgBAJ+LxeHTxxRdr//79zT6i2FxXXHGFjDF65JFHgp6/ffDgwdq8ebOeeeYZXXjhhfrb3/6mCy+8ULm5uaddd/ny5Xr00Uf14IMP6rLLLqt3n23bSkxM9P9V4dTbgw8+GNL3ZozRq6++quuvv17Jycn6wx/+oEsuuURPP/20YmJigtpGoBlnGltugjwBNdA2g13fLa666iodPnxYv/zlL4Ne50tf+pK2b9+uP/7xjxo6dKh+//vf6/zzz9fvf//70677y1/+Uk8//bSeeuqpBn/hsW1b5557bsCfne9+97uhfnv1cEIoAACdTE1NjaTakzkb06tXL3Xt2rXRmTA2bdokj8fjP5rbv39/ffzxx0Htd/LkyRo/frxuuOEGRUdH67e//W1Q63Xr1k1TpkzRlClTVFVVpauuuko/+clPNGfOnIBTCG7ZskXTpk3T5MmTde+99za4v3///nrllVc0duxYdenSJag6GpOfn6/Fixdr0aJFys/PV58+ffS9731PM2bM8J/42F7t27dPFRUV9Y6eb9myRZICfm917SaBfnZ69uypbt26qUuXLoqJiQn6Z2f27NkaMGCA5s6dq9jY2KDnJk9ISND06dM1ffp0lZeX60tf+pIeeOAB3XTTTQHXeeONN/T9739fd955p6677roG9/fv31//+9//dMkll7TKjEocOQcAoBOprq7WypUrFRERocGDBzc6xuv1avz48XrhhRfqtS8UFhZqyZIluvDCC/1Hg6+++mr973//07Jlyxpsp7Gjs1OnTtWvfvUrLVy4UD/84Q9PW++BAwfqfR0REaFzzjlHxpiAvdzl5eW68sorlZqaqsWLFzcaoK655hr5fD79+Mc/bnBfTU2NDh8+3GRdH330kbKzs5WZmamf/OQnOu+88/TSSy8pPz9fP/7xj9t9MJdqH4cnn3zS/3VVVZWefPJJ9erVSyNHjmx0nd69e2vEiBFavHhxvcfw448/1sqVK3X55ZdLqv0LzuTJk/WPf/xD77//foPtNPazc//99+v73/++5syZE9QHu1N/drp3764BAwY0Od3h/v37dc011+jCCy/UY4891uiYa665Rnv37tVTTz3V4L5jx44F3cYUCEfOAQDowP71r39p06ZNkmp7YZcsWaKtW7fqnnvuabLd4qGHHtKqVat04YUX6rvf/a7CwsL05JNPqrKyUj/96U/9437wgx/o+eef1ze+8Q3deOONGjlypA4ePKgXX3xRCxcu1PDhwxts+7bbblNZWZl+9KMfKTY2ttEj23XGjx+v5ORkjR07VklJSdq4caOeeOIJfeUrX1F0dHSj68ybN0+ffvqp7rvvPr3wwgv17uvfv7/GjBmjiy66SDNnzlReXp42bNig8ePHKzw8XFu3btVzzz2nX/7yl/r6178esK5169b5TwCdNm1avSkaO4qUlBQ9+uijys/P18CBA7V06VJt2LBBv/vd75qcZvKxxx7TxIkTNWbMGM2YMcM/lWJsbGy9ucIffvhhrVy5UhdddJF/SsL9+/frueee05tvvqm4uLhGt11aWqpZs2YpOjq6ySlBzznnHH35y1/WyJEjlZCQoPfff1/PP/+8brvttoDr3H777SouLtbdd9+tZ555pt59w4YN07Bhw3T99dfr2Wef1S233KJXX31VY8eOlc/n06ZNm/Tss8/q3//+d6MnuQaLcA4AQADGmKB7o1tr/2dq7ty5/v9HRUVp0KBB+u1vf1tvFo7GDBkyRG+88YbmzJmjvLw82batrKws/eUvf/HPcS7VHo184403lJubq2XLlmnx4sVKTEzUJZdcoj59+gTc/r333qvS0lJ/QJ81a1aj42bOnKm//vWvevzxx1VeXq4+ffro9ttv13333Rdw28XFxZJqP2Ccatq0aRozZowkaeHChRo5cqSefPJJ3XvvvQoLC1N6erq+/e1va+zYsU0+Pt/4xjfqXdCoI4qPj9fixYs1e/ZsPfXUU0pKStITTzyhm2++ucn1srOztWLFCuXm5mru3LkKDw/XRRddpEcffVQZGRn+campqXrnnXd0//33669//avKysqUmpqqiRMnqmvXrgG3v3DhQpWXl2v69OmKjo7WFVdc0ei422+/XS+++KJWrlypyspK9evXTw899JB+8IMfBNx2cXGxfD6fcnJyGtyXm5urYcOGyePxaPny5frFL36h//f//p+WLVumrl27KjMzU3fccYf/xNDmskx7OyMAAIAWcvz4ce3cuVMZGRn1epdt29ahQ4fk8/kcrK6W1+tVfHy8PB46UYH2LtB7zsk4cg4AwCk8Ho/i4+MdPWp+ci0Ec6DzIJwDANAIQjEAJ/CuAwAAALgE4RwAAABwCcI5AAAA4BKEcwAAAMAlCOcAgE6PWYUBtIVg3msI5wCATqvuKodHjx51uBIAnUHde01TV1hlKkUAQKfl9XoVFxenoqIiSVLXrl1lWZbDVQHoaIwxOnr0qIqKihQXFyev1xtwLFcIBQB0asYYFRQU6PDhw06XAqCDi4uLU3JycpMHAQjnAABI8vl8qq6udroMAB1UeHh4k0fM6xDOAQAAAJfghFAAAADAJQjnAAAAgEsQzgEAAACXIJwDAAAALkE4BwAAAFyCcA4AAAC4BOEcAAAAcAnCOQAAAOAShHMAAADAJQjnAAAAgEsQzgEAAACXIJwDAAAALkE4BwAAAFyCcA4AAAC4BOEcAAAAcAnCOQAAAOAShHMAAADAJQjnAAAAgEuEOV1AMGzb1r59+xQdHS3LspwuBwAAAKcwxujIkSNKSUmRx8Px3+ZqF+F83759SktLc7oMAAAAnMbu3bvVp08fp8tot9pFOI+OjpZU+2THxMQ4XA0AAABOVVZWprS0NH9uQ/O0i3Be18oSExNDOAcAAHAxWpDPDA1BAAAAgEsQzgEAAACXIJwDAAAALkE4BwAAAFyCcA4AAAC4BOEcAAAAcAnCOQAAAOAShHMAAADAJQjnAAAAgEsQzgEAAACXIJwDAAAALhFyOH/99dc1adIkpaSkyLIsLV++/LTrrFmzRueff74iIyM1YMAALVq0qBmlAgAAAB1byOG8oqJCw4cP14IFC4Iav3PnTn3lK1/RxRdfrA0bNujOO+/UTTfdpH//+98hFwsAAAB0ZGGhrjBx4kRNnDgx6PELFy5URkaGfv7zn0uSBg8erDfffFO/+MUvNGHChFB3DwAAAHRYIYfzUK1du1bZ2dn1lk2YMEF33nlnwHUqKytVWVnp/7qsrKy1ygvI5/PJGNPm++2ILMuS1+t1ugwAAADXa/VwXlBQoKSkpHrLkpKSVFZWpmPHjqlLly4N1snLy9O8efNau7SAfD6fDh06JNu2HauhI/F4PIqPjyegAwAAnEarh/PmmDNnjnJycvxfl5WVKS0trc32b4yRbduyLEuWZbXZfjuiuseSv0IAAACcXquH8+TkZBUWFtZbVlhYqJiYmEaPmktSZGSkIiMjW7u007IsSx4Ps02eCYI5AABA8Fo9eY4ZM0arV6+ut2zVqlUaM2ZMa+8aAAAAaFdCDufl5eXasGGDNmzYIKl2qsQNGzZo165dkmpbUqZOneoff8stt2jHjh26++67tWnTJv3mN7/Rs88+q7vuuqtlvgMAAACggwg5nL///vs677zzdN5550mScnJydN5552nu3LmSpP379/uDuiRlZGTopZde0qpVqzR8+HD9/Oc/1+9//3umUQQAAABOYZl20BBcVlam2NhYlZaWKiYmptX3V1NTo4MHD8rj8dBzfoZs25Zt20pISFBYmCvPPwYAAC2grfNaR0XyBAAAAFyCcA4AAAC4BOEcAAAAcAnCOQAAAOAShHMAAADAJQjnAAAAgEsQzgEAAACXIJwDAAAALkE4BwAAAFyCcA4AAAC4BOEcAAAAcAnCOQAAAOAShHMAAADAJQjnAAAAgEsQzgEAAACXIJwDAAAALkE4BwAAAFyCcA4AAAC4BOEcAAAAcAnCOQAAAOAShHMAAADAJQjnAAAAgEsQzgEAAACXIJwDAAAALkE4BwAAAFyCcA4AAAC4BOEcAAAAcAnCOQAAAOAShHMAAADAJQjnAAAAgEsQzgEAAACXIJwDAAAALkE4BwAAAFyCcA4AAAC4BOEcAAAAcAnCOQAAAOAShHMAAADAJQjnAAAAgEsQzgEAAACXIJwDAAAALkE4BwAAAFyCcA4AAAC4BOEcAAAAcAnCOQAAAOAShHMAAADAJQjnAAAAgEsQzgEAAACXIJwDAAAALkE4BwAAAFyCcA4AAAC4BOEcAAAAcAnCOQAAAOAShHMAAADAJQjnAAAAgEsQzgEAAACXIJwDAAAALkE4BwAAAFyCcA4AAAC4BOEcAAAAcIlmhfMFCxYoPT1dUVFRysrK0rvvvtvk+Pnz5+vss89Wly5dlJaWprvuukvHjx9vVsEAAABARxVyOF+6dKlycnKUm5ur9evXa/jw4ZowYYKKiooaHb9kyRLdc889ys3N1caNG/WHP/xBS5cu1b333nvGxQMAAAAdScjh/PHHH9fNN9+s6dOn65xzztHChQvVtWtX/fGPf2x0/FtvvaWxY8fqW9/6ltLT0zV+/Hhde+21pz3aDgAAAHQ2IYXzqqoqrVu3TtnZ2Z9vwONRdna21q5d2+g6X/ziF7Vu3Tp/GN+xY4defvllXX755QH3U1lZqbKysno3AAAAoKMLC2VwSUmJfD6fkpKS6i1PSkrSpk2bGl3nW9/6lkpKSnThhRfKGKOamhrdcsstTba15OXlad68eaGUBgAAALR7rT5by5o1a/Twww/rN7/5jdavX6+///3veumll/TjH/844Dpz5sxRaWmp/7Z79+7WLhMAAABwXEhHznv27Cmv16vCwsJ6ywsLC5WcnNzoOvfff7+uv/563XTTTZKkc889VxUVFfrOd76jH/3oR/J4Gn4+iIyMVGRkZCilAQAAAO1eSEfOIyIiNHLkSK1evdq/zLZtrV69WmPGjGl0naNHjzYI4F6vV5JkjAm1XgAAAKDDCunIuSTl5ORo2rRpGjVqlEaPHq358+eroqJC06dPlyRNnTpVqampysvLkyRNmjRJjz/+uM477zxlZWVp27Ztuv/++zVp0iR/SAcAAADQjHA+ZcoUFRcXa+7cuSooKNCIESO0YsUK/0miu3btqnek/L777pNlWbrvvvu0d+9e9erVS5MmTdJPfvKTlvsuAAAAgA7AMu2gt6SsrEyxsbEqLS1VTExMq++vpqZGBw8elMfjabQnHsGzbVu2bSshIUFhYSF/FgQAAO1EW+e1jorkCQAAALgE4RwAAABwCcI5AAAA4BKEcwAAAMAlCOcAAACASxDOAQAAAJcgnAMAAAAuQTgHAAAAXIJwDgAAALgE4RwAAABwCcI5AAAA4BKEcwAAAMAlCOcAAACASxDOAQAAAJcgnAMAAAAuQTgHAAAAXIJwDgAAALgE4RwAAABwCcI5AAAA4BKEcwAAAMAlCOcAAACASxDOAQAAAJcgnAMAAAAuQTgHAAAAXIJwDgAAALgE4RwAAABwCcI5AAAA4BKEcwAAAMAlCOcAAACASxDOAQAAAJcgnAMAAAAuQTgHAAAAXIJwDgAAALgE4RwAAABwCcI5AAAA4BKEcwAAAMAlCOcAAACASxDOAQAAAJcgnAMAAAAuQTgHAAAAXIJwDgAAALgE4RwAAABwCcI5AAAA4BKEcwAAAMAlCOcAAACASxDOAQAAAJcgnAMAAAAuQTgHAAAAXIJwDgAAALgE4RwAAABwCcI5AAAA4BKEcwAAAMAlCOcAAACASxDOAQAAAJcgnAMAAAAuQTgHAAAAXIJwDgAAALgE4RwAAABwCcI5AAAA4BLNCucLFixQenq6oqKilJWVpXfffbfJ8YcPH9asWbPUu3dvRUZGauDAgXr55ZebVTAAAADQUYWFusLSpUuVk5OjhQsXKisrS/Pnz9eECRO0efNmJSYmNhhfVVWlSy+9VImJiXr++eeVmpqqzz77THFxcS1RPwAAANBhWMYYE8oKWVlZuuCCC/TEE09IkmzbVlpammbPnq177rmnwfiFCxfqscce06ZNmxQeHt6sIsvKyhQbG6vS0lLFxMQ0axuhqKmp0cGDB+XxeOTx0PlzJmzblm3bSkhIUFhYyJ8FAQBAO9HWea2jCil5VlVVad26dcrOzv58Ax6PsrOztXbt2kbXefHFFzVmzBjNmjVLSUlJGjp0qB5++GH5fL6A+6msrFRZWVm9GwAAANDRhRTOS0pK5PP5lJSUVG95UlKSCgoKGl1nx44dev755+Xz+fTyyy/r/vvv189//nM99NBDAfeTl5en2NhY/y0tLS2UMgEAAIB2qdV7NmzbVmJion73u99p5MiRmjJlin70ox9p4cKFAdeZM2eOSktL/bfdu3e3dpkAAACA40JqAu7Zs6e8Xq8KCwvrLS8sLFRycnKj6/Tu3Vvh4eHyer3+ZYMHD1ZBQYGqqqoUERHRYJ3IyEhFRkaGUhoAAADQ7oV05DwiIkIjR47U6tWr/cts29bq1as1ZsyYRtcZO3astm3bJtu2/cu2bNmi3r17NxrMAQAAgM4q5LaWnJwcPfXUU1q8eLE2btyoW2+9VRUVFZo+fbokaerUqZozZ45//K233qqDBw/qjjvu0JYtW/TSSy/p4Ycf1qxZs1ruuwAAAAA6gJDntpsyZYqKi4s1d+5cFRQUaMSIEVqxYoX/JNFdu3bVm34wLS1N//73v3XXXXdp2LBhSk1N1R133KEf/vCHLfddAAAAAB1AyPOcO4F5ztsv5jkHAKBzYJ7zlkHyBAAAAFyCcA4AAAC4BOEcAAAAcAnCOQAAAOAShHMAAADAJQjnAAAAgEsQzgEAAACXIJwDAAAALkE4BwAAAFyCcA4AAAC4BOEcAAAAcAnCOQAAAOAShHMAAADAJQjnAAAAgEsQzgEAAACXIJwDAAAALkE4BwAAAFyCcA4AAAC4BOEcAAAAcAnCOQAAAOAShHMAAADAJQjnAAAAgEsQzgEAAACXIJwDAAAALkE4BwAAAFyCcA4AAAC4BOEcAAAAcAnCOQAAAOAShHMAAADAJQjnAAAAgEsQzgEAAACXIJwDAAAALkE4BwAAAFyCcA4AAAC4BOEcAAAAcAnCOQAAAOAShHMAAADAJQjnAAAAgEuEOV0AOjDblnfvZ/KWH5FJ7i2TcZYsD58HAQAAAiGco1WEbdukyDdWylN+xL+sJiZW3ssmyzN4mIOVAQAAuBeHMdHiwrZtUtS//ibrpGAuSSorle/ZxbI3fuhMYQAAAC5HOEfLsm1FvrFSkmQFGOJb8YKMbbddTQAAAO0E4RwtyrtvtzzlRwIGc0lS2WGZXTvaqiQAAIB2g3COFmUdLQ9u4JGy1i0EAACgHSKco0WZrt2DGxgd07qFAAAAtEOEc7QoX0qa7O7RMk0NiomT1TezrUoCAABoNwjnaFkejyrHjZekgAHde9kVzHcOAADQCBISWlzNgEE6PvFqyXvKNPrh4fJeM415zgEAAAIgnKNV1PQ/WyYySpJUlX5W7cKoLrIGnetgVQAAAO5GOEersI6UyXO0XMbj0dEvXyZ5vbUztBwscbo0AAAA1yKco1V4C/ZIknw9k2S6dJVS+0mS7B1bnSwLAADA1QjnaBXefbslSb7efWoXpPeXJJmdhHMAAIBACOdoFXVHzmuSU2sXZAyQJJn8bTLGdqosAAAAVyOco+VVVcpTUiTppCPnvdOkiEjp2FGpYJ+DxQEAALgX4RwtzluwT5YxsqNjZbpFS5Isr1fWidYW+s4BAAAaRzhHi/OfDFp31PwEK6N2SkX6zgEAABpHOEeL8+5vPJx76sL5ZztkamravC4AAAC3I5yjZdm2vAV7JTUM50pMlrp1l2qqZfZ85kBxAAAA7kY4R4vyHCyWVVUpEx4hu0divfssy5JVN2sLrS0AAAANNCucL1iwQOnp6YqKilJWVpbefffdoNZ75plnZFmWJk+e3Jzdoh3wt7Qkp0qehj9eHvrOAQAAAgo5nC9dulQ5OTnKzc3V+vXrNXz4cE2YMEFFRUVNrpefn6/vf//7GjduXLOLhfsF6jev4z8pdO8umcrjbVYXAABAexByOH/88cd18803a/r06TrnnHO0cOFCde3aVX/84x8DruPz+XTddddp3rx5yszMPKOC4W6nDefxPaS4BMm2ZT7b0ZalAQAAuF5I4byqqkrr1q1Tdnb25xvweJSdna21a9cGXO/BBx9UYmKiZsyYEdR+KisrVVZWVu8G97MqjshTdljGsmrbWgKNo7UFAACgUSGF85KSEvl8PiUlJdVbnpSUpIKCgkbXefPNN/WHP/xBTz31VND7ycvLU2xsrP+WlpYWSplwiHd/7Swtdo9etVcDDcCTWRvObcI5AABAPa06W8uRI0d0/fXX66mnnlLPnj2DXm/OnDkqLS3133bv3t2KVaKlnK6lpU7dkXMV7pepONLaZQEAALQbYaEM7tmzp7xerwoLC+stLywsVHJycoPx27dvV35+viZNmuRfZtt27Y7DwrR582b179+/wXqRkZGKjAx85BXu5N1f+yHK17vpv3RY3bpLSb1rw/nObbKGntcW5QEAALheSEfOIyIiNHLkSK1evdq/zLZtrV69WmPGjGkwftCgQfroo4+0YcMG/+1rX/uaLr74Ym3YsIF2lY6kplqe4trWJl9y00fOpc+nVLR30NoCAABQJ6Qj55KUk5OjadOmadSoURo9erTmz5+viooKTZ8+XZI0depUpaamKi8vT1FRURo6dGi99ePi4iSpwXK0b97C/bJsW3a37jIxsacdb2WcJb39OieFAgAAnCTkcD5lyhQVFxdr7ty5Kigo0IgRI7RixQr/SaK7du2Sp5GLz6Bj+/ziQ30kyzrteKtfZu1Fig4flDl0oHaKRQAAgE4u5HAuSbfddptuu+22Ru9bs2ZNk+suWrSoObuEy3kLgjsZtI4VGSUrta/M7nyZnVsJ5wAAAGrl2VrQSRgjT5AztZysbtYWplQEAACoRTjHGfMcOiDP8WMy3jDZvRrO2hPI5xcj2iZjTGuVBwAA0G4QznHGPHUtLUkpktcb9HpWn35SWLhUUS4VNX4RKwAAgM6EcI4zFuzFh05lhYXJ6pchidYWAAAAiXCOFtDccC5JVsZASWJKRQAAABHOcaaOHZX30AFJki85NeTVPZkn+s7zt8vYvhYtDQAAoL0hnOOMeAv2SpJ88T2kLl1D30BySu16VZUye3e3cHUAAADtC+EcZ+RMWlokybI8stIHSJLMDlpbAABA50Y4xxnx7q892t3ccC6dPKUi4RwAAHRuhHM0n88nb+H+2v/2Tmv2Zvx953vyZaqrWqQ0AACA9ohwjmbzFBfI8tXIjuoiE5fQ/A0l9JRiYiWfT2bXzpYrEAAAoJ0hnKPZ6vrN7d59JMtq9nYsy/q8tYW+cwAA0IkRztFs/pNBk5vfb17HQ985AAAA4RzNZEyLnAxax6rrO9+/V+bY0TPeHgAAQHtEOEezWGWl8hytkPF45Evqfebbi46VeiZJMjL52868QAAAgHaIcI5mqTtqbvdKlsLCW2SbngzmOwcAAJ0b4RzN4i2ou/hQ86dQPFVda4tN3zkAAOikCOdoFu++M7syaGOs9AG1s74cKJYpO9xi2wUAAGgvCOcIXVWlPAeKJLVwOI/qIuvE9mhtAQAAnRHhHCHzFuyVJcmOiZPp1r1Ft1033zmtLQAAoDMinCNk3n0tN4XiqfxTKu7cKmNMi28fAADAzQjnCJm3YK+kVgrnaRmSN0w6UiadaJ0BAADoLAjnCI1tt244Dw+XlZZeuyv6zgEAQCdDOEdIPAeKZFVXyUREyk7o1Sr7qOs7Nzu5GBEAAOhcCOcIiXf/iSkUk1MlT+v8+Pj7zvO3ydh2q+wDAADAjQjnCIk/nLdCS0sdK6WPFBklHT8mc6KFBgAAoDMgnCMkbRLOPV5Z6f0lMd85AADoXAjnCJpVXibPkVIZy5IvKaV195Xx+ZSKAAAAnQXhHEHz7q9tMbF7JkoRka26L09dON+1Q6amulX3BQAA4BaEcwTNu//ExYeSW6+lxa9XktQ9Wqqpkdn9WevvDwAAwAUI5wiav988Ja3V92VZlqyMAZJobQEAAJ0H4RzBqa6Sp7hAUhsdOddJrS2EcwAA0EkQzhEUb+F+WcbI7hYtEx3TJvv0nxS6d7dM5fE22ScAAICTCOcISr0pFC2rTfZpxSVI8T0kY8vkb2+TfQIAADiJcI6g+E8GbcX5zRtDawsAAOhMCOc4PWPkPXGlzrYO51bmQEmSTTgHAACdAOEcp+U5VCKr8rhMWLjsnkltum8ro/ZKoSoqkCk/0qb7BgAAaGuEc5yWd9+JfvOkFMnrbdN9W127S8m1VyOltQUAAHR0hHOclreg7mTQVEf2X9d3TmsLAADo6AjnOK3PZ2pp/YsPNcY/peKOrTLGOFIDAABAWyCco0nWsQp5Dh+UJPmSnTlybvXLlDweqfSQdOiAIzUAAAC0BcI5muQ/ap7QU4rq4kgNVkSkrD79JNF3DgAAOjbCOZpU7+JDDrLoOwcAAJ0A4RxN8rgsnJud22SM7WgtAAAArYVwjsB8NfIW7a/9r0Mng9ax+vSVwiOkoxVSYYGjtQAAALQWwjkC8hQVyPL5ZHfpKhMb72gtljes9sRQ0doCAAA6LsI5AvL3myf3kSzL4WpObm0hnAMAgI6JcI6A/OE8xdl+8zqezBPh/LMdMj6fw9UAAAC0PMI5GmeMP5zbye4I50rqLXXtJlVVyuzd5XQ1AAAALY5wjkZZpYfkOVYh4/HKl9jb6XIkSZblkZU+QJJkdmxxuBoAAICWRzhHo/xHzROTpbAwh6v53MlTKgIAAHQ0hHM06vOLDzk7heKp/H3nez6Tqap0uBoAAICWRThHo7wF7rj4UAPxPaTYeMn2yeza6XQ1AAAALYpwjoYqj8tzoFiS5Oud6nAx9VmWJSujru+cKRUBAEDHQjhHA979e2RJsmPjZbp2d7qcBjwn+s65GBEAAOhoCOdowLUtLSfUnRSqgn0yRyucLQYAAKAFEc7RwOcng7o0nEfHSL2SJRmZfGZtAQAAHQfhHPXZtrwF+yS5N5xLn7e20HcOAAA6EsI56vGUFMqqqZaJjJKd0MvpcgKyMmtPCqXvHAAAdCTNCucLFixQenq6oqKilJWVpXfffTfg2Keeekrjxo1TfHy84uPjlZ2d3eR4OMi2Fb7xw9r/xiVIxjhcUGBWv/6SZUkHS2RKDzldDgAAQIsIOZwvXbpUOTk5ys3N1fr16zV8+HBNmDBBRUVFjY5fs2aNrr32Wr366qtau3at0tLSNH78eO3du/eMi0fLCdu2Sd0WP6GID9+XJHkL96nb4icUtm2Tw5U1zorqIiul9gJJtLYAAICOwjImtMOjWVlZuuCCC/TEE09IkmzbVlpammbPnq177rnntOv7fD7Fx8friSee0NSpU4PaZ1lZmWJjY1VaWqqYmJhQym2WmpoaHTx4UB6PRx5Px+/8Cdu2SVH/+pskyTpped0PxvGJV6tmwKBmbdu2bdm2rYSEBIWFhZ1ZoafwrX5Z9purZZ17vsKuuq5Ftw0AAELT1nmtowopeVZVVWndunXKzs7+fAMej7Kzs7V27dqgtnH06FFVV1crISEh4JjKykqVlZXVu6GV2LYi31gpqX4wP/nryDdWSbbdpmUFw8o8cVLozq0K8TMmAACAK4UUzktKSuTz+ZSUlFRveVJSkgoKCoLaxg9/+EOlpKTUC/inysvLU2xsrP+WlpYWSpkIgXffbnnKjzQI5nUsSZ7yMnn37W7LsoJipaVLYWFS+RGppNDpcgAAAM5Ym/ZsPPLII3rmmWe0bNkyRUVFBRw3Z84clZaW+m+7d7svGHYU1tHyFh3XlqywcFlpGZIkm75zAADQAYQUznv27Cmv16vCwvpHKQsLC5WcnNzkuj/72c/0yCOPaOXKlRo2bFiTYyMjIxUTE1Pvhlbi8wU1zHTt3sqFNE/d1UINUyoCAIAOIKRwHhERoZEjR2r16tX+ZbZta/Xq1RozZkzA9X7605/qxz/+sVasWKFRo0Y1v9r2yrbl3fOZwrZ8Iu+ez9zRv22Mwj9ap6hX/1X7ZaBhkuzuMfKluLO1yN93nr9dxg7ugwYAAIBbhTx9Rk5OjqZNm6ZRo0Zp9OjRmj9/vioqKjR9+nRJ0tSpU5Wamqq8vDxJ0qOPPqq5c+dqyZIlSk9P9/emd+/eXd27u/NobEsK27ZJkW+slKf8iH+Z3T1alePGN3sGlDNlVZQravU/FfbZdkmSr0cveQ4Uy6jx2Voqx10quXTWGqt3Hymqi3T8mMz+vbJS+zpdEgAAQLOFHM6nTJmi4uJizZ07VwUFBRoxYoRWrFjhP0l0165d9aYf/O1vf6uqqip9/etfr7ed3NxcPfDAA2dWvcudPEXhyazyI4r619/OaIrCZte0fZMi//OyPMePyXi9qvzi/6l6+AUK275ZkW+slHXShwjTPUaV4y517ENEMCyPR1Z6f5lNH9fOd044BwAA7VjI85w7oV3Oc27b6rb4CVkBZkIxqg2/FdNmtc1R6apKRb2+0n8FUF/PRB0ff4XsHon1avbu2y3raLlM1+61rSxnWFtrznNex/fum7L/tUxWxlkKm3pLq+wDAAA0jXnOW0brpCX4pygMxJJknZii0NenX+vWsneXol55UZ6yUhlJVSO/qKqscZL3lKff42n1WlqDJ+Ms2ZLMrp0y1dWywsOdLgkAAKBZCOetJNipBz37dsmX2leyAs00fgZ8PkW887oi1r0lS5IdE6vj2V+r3V9H0jNR6h4jlZfJ7N4pK3Og0xUBAAA0C+G8lQQ79WDUO68rfNsmVQ8Zoeqzh9ae3NgCPAeKFbVyubwlRZKk6sHDdPxL46WIyBbZvptYliUr8yyZD9fJ7NwmEc4BAEA7RThvJb6UNNndo5vsOVdYeG2f94EieV9fqcj//kc1AwaresiI2n7v5hxNN0bhG95V5NpXZfl8sqO6qPLiy119UmdL8GQMkO/Ddcx3DgAA2jXCeWvxeFQ5bnyjs7XUnYF7/NKvqaZPP4Vv/ljhn2yQ90CRwjd/pPDNH8kX30PVQ85TzaBzZbp0bbj9Rk7etCrKFfXKPxS2J1+SVNOvv45f8lWZbh1/ykr/xYj27ZY5fkxWC/0FAgAAoC0RzluRL6VPo8tPnaKwevgFqh42Sp7CfQr/5AOFb/lU3kMH5H3zFZm3XlVN/7NVPeS82pM1LavxudMjo2T5amTV1MiEhavywktUPfT81ulldyErNl5K6CkdLJHJ3y5r0FCnSwIAAAgZ4bwVhW3dKEuSL7G3Ksde0vQUhZYlOzlVlcmpqhx3qcK3fKLwTz6Qt6hA4Vs/VfjWT2XHxsuXlKqwLR832Jen8rgkyRcbr2OTpsjE92iD79BdPJkDZR8sqW1tIZwDAIB2iHDeisI3fSRJqh50bmhTFEZEqnro+aoeer48RfsV/skGhW/+WJ7SQ/KUHmpwJc86RpLlq5GJjW+J8tsdK+Ms6f23ZO/cKq/TxQAAADSDO6/J3gFYhw7IW7RfxrJUM/CcZm/HTuytyosnqnzGHao8/wu12w60T0me8iPy7tvd7P21Z1bGAEmWVFwoc6TM6XIAAABCRjhvJeGba1tPfP36y3Tp1gIbjJDdKzmoocHOsd7RWF26Sr1TJYlZWwAAQLtEOG8NxvjDefXZLdf7HOzc6cGO64g8GQMkSTbhHAAAtEOE81bgKdgrT9lhmfAI1WS03AVx6uZONwHuN5Ls7jG1J5x2Uv4pFXdslTGBHikAAAB3Ipy3grqj5jX9z5bCw1tuwyfmTpfUIKDXfV057tKGM8F0IlbfDMnjlcoOSwdLnC4HAAAgJJ03xbUWn09hWz+V1LItLXVqBgzS8YlXy3SPrrfcdI/R8YlXd/grgZ6OFREpK612ZhxaWwAAQHvDVIotzLtruzzHj8nu2k2+Pumtso+aAYNUkzmwwRVCO/MR85NZGWfJfLaj9qTQUV90uhwAAICgEc5bWPimEy0tA4e2blj2eEKbO70TsTLOktb8W2bnNhljy7L40AIAANoHUktLqjyusBOtFNVcodIxVmpfKSJSOnZUKtjndDkAAABBI5y3oLDtm2X5auRL6Cm7Z5LT5XRaltcrq1+mJPrOAQBA+0I4b0H+WVrOHipZga7jibbgn1Jx5zaHKwEAAAge4byFWOVl8u7JlyRVD6SlxWmezBPh/LMdMr4ah6sBAAAIDuG8hYRt+VSWpJqUNJmYWKfLQWKy1LW7VF0ls2eX09UAAAAEhXDeQsI3fyTpREsLHGdZHlkZAySpdkpFAACAdoBw3gI8JUXylhTJeLyqHjDY6XJwgqeu73zHFocrAQAACA7hvAWE1Z0Imj5AiuricDWoY9X1ne/dJVNV6XA1AAAAp0c4P1PGKHzLSbO0wDWs+B5SXIJk2zKf7XC6HAAAgNMinJ8h795d8pQfkYmMqj1yDlfx953voO8cAAC4H+H8DIWdOBG0esAgKSzM4Wpwqrq+cy5GBAAA2gPC+ZmoqVH4tk21/6WlxZXqLkakwn0yFeXOFgMAAHAahPMzEJa/TVZVpezuMfKl9HW6HDTC6h4tJfaWJJl8rhYKAADcjXB+BvwtLWcPlSzL4WoQyOdTKtLaAgAA3I1w3lzHjynsxJFYWlrcrW5KRfrOAQCA2xHOmyl820ZZti1fzyTZPXo5XQ6aYPXLlCyPdOiAzOGDTpcDAAAQEOG8mcI21c5tXs1Rc9ezIqNkpaZJorUFAAC4G+G8GazSwwrbv1tGUs3AIU6XgyBYTKkIAADaAcJ5M9RdEdTXJ12me7TD1SAYdX3nZuc2GWMcrgYAAKBxhPNQGaOwzSdaWgbR0tJeWH3SpbBwqeKIVFzgdDkAAACNIpyHyFNcIO+hAzLeMNX0H+R0OQiSFRYmq2+GJMmm7xwAALgU4TxE4SeOmtdkDpQiIh2uBqGo6zs39J0DAACXIpyHwrYVtuUTSczS0h556vrOP9shY/scrgYAAKAhwnkIvHvy5TlaITuqi3x9M50uB6FKTpWiukiVx2X27XG6GgAAgAYI5yEIPzG3ec1Z50her8PVIFSWxyMrY4Ak5jsHAADuRDgPVnWVwnZsqv3voHMdLgbNRd85AABwM8J5kMJ2bJFVXS07Nl52UorT5aCZPHXhfPdOmeoqh6sBAACoj3AepLpZWqoHDpEsy+Fq0Gw9eknRsZLPJ7Nrp9PVAAAA1EM4D4J1tFzeXTskMUtLe2dZ1klXC6W1BQAAuAvhPAhhWzfKMka+pBSZ+B5Ol4Mz5G9t2bnN4UoAAADqI5wHwd/SwlHzDsF/Uui+PTLHjjpcDQAAwOcI56dhHTogb+E+GcuqnUIR7Z4VE1vbey4jk7/d6XIAAAD8COenUXfU3Nc3U6ZrN4erQUvxZA6URN85AABwF8J5U4z5vKWFuc07lLrWFptwDgAAXIRw3gRv4V55yg7LhIer5kSYQ8dgpfevnRKzpEimrNTpcgAAACQRzpsUvvkTSVJN5iApPMLhatCSrC5dZfXuI4nWFgAA4B6E80B8PoVv2yhJqh7ELC0dkZUxQBKtLQAAwD0I5wGE794pz/Fjsrt2k69PutPloBX4p1TcuVXGGIerAQAAIJw3YGxb5rPtilq3VpJqp0/08DB1RFbfDMnrlcpKpQPFTpcDAACgMKcLcBN744fyrVgulZX6H5iwLZ/Il9JXNQMGOVkaWoEVHiErLV0mf7vsnVvl7ZnodEkAAKCT45DwCfbGD+V7dnHtUdSTWMeOKupff1PYtk0OVYbWdHJrCwAAgNMI56ptZfGtWN7ofdaJfyPfWCXZdpvVhLbhD+fbNsv34TrZ+dtkXPo8G9uWnb9N9kfrXV0nACA0rfH+zu+M9ou2Fklm144GR8xPZkmyysvk3bdbvj792q4wtDpTdrj2P9VVspctqf1/TKy8l02WZ/Awx+o61cktV34urBMAEJrWeH/nd0b71qwj5wsWLFB6erqioqKUlZWld999t8nxzz33nAYNGqSoqCide+65evnll5tVbKs5UhbUMOtoeSsXgrZkb/xQ9vN/bnhHWal8zy6WvfHDti+qEYFartxWJwAgNK3x/s7vjPYv5HC+dOlS5eTkKDc3V+vXr9fw4cM1YcIEFRUVNTr+rbfe0rXXXqsZM2bogw8+0OTJkzV58mR9/PHHZ1x8i4mOCWqY6dq9lQtBW2mqlamOb8ULjv8ZsL3UCQAITUu8vxtjy1RXyxw7KnOkTPaBYvle+tsZbRPOs0yIEzxnZWXpggsu0BNPPCFJsm1baWlpmj17tu65554G46dMmaKKigr985//9C/7whe+oBEjRmjhwoVB7bOsrEyxsbEqLS1VTExwQToUxrZV88uHAra2GEmme4wqps1iWsUQ2bYt27aVkJCgsDD3dFHZ+dvkW/zb046zBp4jKzq2DSpqnDlSKrPl09OOc7pOAEBogn1/V89EyRsm1VRLNTX1//X5mrVv77Rb5Ukf0Kx1m9Laea2zCCktVVVVad26dZozZ45/mcfjUXZ2ttauXdvoOmvXrlVOTk69ZRMmTNDy5csD7qeyslKVlZX+r8vKgms7aS7L45H3ssm1fwY6Rd0nl2MXZsuWOCk0RK69uE+QrUxmy6dy6XdQT3upEwAQopLGOxMasKzaA4jBBPYgfwfCGSGF85KSEvl8PiUlJdVbnpSUpE2bGp9qsKCgoNHxBQUFAfeTl5enefPmhVLaGfMMHiZdM63BCRSme7SOjr1E1RlnEcybyePxyLKs0w9sS0G2MlnDL5AV36OViwnMHDog87/3TjvO6ToBAKEJ9v3dc/FEWalpUli4FBYm68S/tbdwKfzEco836L8KB/s7EM5wT5/BSebMmVPvaHtZWZnS0tJafb+ewcNknT1UZtcO2aWHZbpHy5OWoWhaWc6IZVnyer1Ol1GP1TdTioltcpYexcTJ+7VrZDn4/BvbVs3OLa6vEwAQmmDf3z0X/l/Q7+/B/m6z+maGWC3aUkjhvGfPnvJ6vSosLKy3vLCwUMnJyY2uk5ycHNJ4SYqMjFRkZGQopbUYy+ORlT6ACeA7uKZamep4L7vC8cDbXuoEAISmNd7f+Z3RMYT07ERERGjkyJFavXq1f5lt21q9erXGjBnT6DpjxoypN16SVq1aFXA80FY8g4fJe8202qMMJ4uJk/eaaa6ZC7a91AkACE1rvL/zO6P9C3m2lqVLl2ratGl68sknNXr0aM2fP1/PPvusNm3apKSkJE2dOlWpqanKy8uTVDuV4kUXXaRHHnlEX/nKV/TMM8/o4Ycf1vr16zV06NCg9snZv2hNxrZrL0R1pEyKjpHVN9OVRxXaS50AgNC0xvu7E78zyGstI+Se8ylTpqi4uFhz585VQUGBRowYoRUrVvhP+ty1a5c8Jz35X/ziF7VkyRLdd999uvfee3XWWWdp+fLlQQdzoLXVtTK5XXupEwAQmtZ4f+d3RvsV8pFzJ/BJDAAAwN3Iay2Dv4kDAAAALkE4BwAAAFyCcA4AAAC4BOEcAAAAcAnCOQAAAOAShHMAAADAJQjnAAAAgEsQzgEAAACXIJwDAAAALhHmdAHBqLuIaVlZmcOVAAAAoDF1Oa0dXHze1dpFOD9y5IgkKS0tzeFKAAAA0JQjR44oNjbW6TLaLcu0g483tm1r3759io6OlmVZ9e4rKytTWlqadu/erZiYGIcqRCA8P+7Hc+RuPD/ux3Pkbjw/bccYoyNHjiglJUUeD53TzdUujpx7PB716dOnyTExMTG86FyM58f9eI7cjefH/XiO3I3np21wxPzM8bEGAAAAcAnCOQAAAOAS7T6cR0ZGKjc3V5GRkU6Xgkbw/Lgfz5G78fy4H8+Ru/H8oL1pFyeEAgAAAJ1Buz9yDgAAAHQUhHMAAADAJQjnAAAAgEsQzgEAAACX6FDhPD09XZZl1bs98sgjTpfVqS1YsEDp6emKiopSVlaW3n33XadLgqQHHnigwWtl0KBBTpfVqb3++uuaNGmSUlJSZFmWli9fXu9+Y4zmzp2r3r17q0uXLsrOztbWrVudKbYTOt3zc8MNNzR4TV122WXOFNsJ5eXl6YILLlB0dLQSExM1efJkbd68ud6Y48ePa9asWerRo4e6d++uq6++WoWFhQ5VDATWocK5JD344IPav3+//zZ79mynS+q0li5dqpycHOXm5mr9+vUaPny4JkyYoKKiIqdLg6QhQ4bUe628+eabTpfUqVVUVGj48OFasGBBo/f/9Kc/1a9+9SstXLhQ77zzjrp166YJEybo+PHjbVxp53S650eSLrvssnqvqaeffroNK+zcXnvtNc2aNUtvv/22Vq1aperqao0fP14VFRX+MXfddZf+8Y9/6LnnntNrr72mffv26aqrrnKwaiAA04H069fP/OIXv3C6DJwwevRoM2vWLP/XPp/PpKSkmLy8PAergjHG5ObmmuHDhztdBgKQZJYtW+b/2rZtk5ycbB577DH/ssOHD5vIyEjz9NNPO1Bh53bq82OMMdOmTTNXXHGFI/WgoaKiIiPJvPbaa8aY2tdLeHi4ee655/xjNm7caCSZtWvXOlUm0KgOd+T8kUceUY8ePXTeeefpscceU01NjdMldUpVVVVat26dsrOz/cs8Ho+ys7O1du1aBytDna1btyolJUWZmZm67rrrtGvXLqdLQgA7d+5UQUFBvddTbGyssrKyeD25yJo1a5SYmKizzz5bt956qw4cOOB0SZ1WaWmpJCkhIUGStG7dOlVXV9d7DQ0aNEh9+/blNQTXCXO6gJZ0++236/zzz1dCQoLeeustzZkzR/v379fjjz/udGmdTklJiXw+n5KSkuotT0pK0qZNmxyqCnWysrK0aNEinX322dq/f7/mzZuncePG6eOPP1Z0dLTT5eEUBQUFktTo66nuPjjrsssu01VXXaWMjAxt375d9957ryZOnKi1a9fK6/U6XV6nYtu27rzzTo0dO1ZDhw6VVPsaioiIUFxcXL2xvIbgRq4P5/fcc48effTRJsds3LhRgwYNUk5Ojn/ZsGHDFBERoZkzZyovL4/L9gInmThxov//w4YNU1ZWlvr166dnn31WM2bMcLAyoH365je/6f//ueeeq2HDhql///5as2aNLrnkEgcr63xmzZqljz/+mPNo0G65Ppx/73vf0w033NDkmMzMzEaXZ2VlqaamRvn5+Tr77LNboToE0rNnT3m93gZnwhcWFio5OdmhqhBIXFycBg4cqG3btjldChpR95opLCxU7969/csLCws1YsQIh6pCUzIzM9WzZ09t27aNcN6GbrvtNv3zn//U66+/rj59+viXJycnq6qqSocPH6539JzfSXAj1/ec9+rVS4MGDWryFhER0ei6GzZskMfjUWJiYhtXjYiICI0cOVKrV6/2L7NtW6tXr9aYMWMcrAyNKS8v1/bt2+sFP7hHRkaGkpOT672eysrK9M477/B6cqk9e/bowIEDvKbaiDFGt912m5YtW6b//Oc/ysjIqHf/yJEjFR4eXu81tHnzZu3atYvXEFzH9UfOg7V27Vq98847uvjiixUdHa21a9fqrrvu0re//W3Fx8c7XV6nlJOTo2nTpmnUqFEaPXq05s+fr4qKCk2fPt3p0jq973//+5o0aZL69eunffv2KTc3V16vV9dee63TpXVa5eXl9f5ysXPnTm3YsEEJCQnq27ev7rzzTj300EM666yzlJGRofvvv18pKSmaPHmyc0V3Ik09PwkJCZo3b56uvvpqJScna/v27br77rs1YMAATZgwwcGqO49Zs2ZpyZIleuGFFxQdHe3vI4+NjVWXLl0UGxurGTNmKCcnRwkJCYqJidHs2bM1ZswYfeELX3C4euAUTk8X01LWrVtnsrKyTGxsrImKijKDBw82Dz/8sDl+/LjTpXVqv/71r03fvn1NRESEGT16tHn77bedLgnGmClTppjevXubiIgIk5qaaqZMmWK2bdvmdFmd2quvvmokNbhNmzbNGFM7neL9999vkpKSTGRkpLnkkkvM5s2bnS26E2nq+Tl69KgZP3686dWrlwkPDzf9+vUzN998sykoKHC67E6jsedGkvnTn/7kH3Ps2DHz3e9+18THx5uuXbuaK6+80uzfv9+5ooEALGOMafuPBAAAAABO5fqecwAAAKCzIJwDAAAALkE4BwAAAFyCcA4AAAC4BOEcAAAAcAnCOQAAAOAShHMAAADAJQjnAAAAgEsQzgEAAACXIJwDAAAALkE4BwAAAFyCcA4AAAC4xP8H9LjNs4014Q4AAAAASUVORK5CYII=",
167:       "text/plain": [
168:        "<Figure size 800x500 with 1 Axes>"
169:       ]
170:      },
171:      "metadata": {},
172:      "output_type": "display_data"
173:     }
174:    ],
175:    "source": [
176:     "fig, ax = plt.subplots(figsize=(8, 5))\n",
177:     "\n",
178:     "values, counts  = np.unique(min_block_sizes - block_sizes, return_counts=True)\n",
179:     "\n",
180:     "ax.plot(values, counts/counts.sum(), marker='o', linestyle='-', color='salmon')\n",
181:     "\n",
182:     "ax.fill_betweenx(y=[0, 1], x1=min(values), x2=0, color='#dddddd', alpha=0.5, label='Block size > min block size')\n",
183:     "\n",
184:     "fig.legend(fontsize=12)\n",
185:     "\n",
186:     "\n"
187:    ]
188:   },
189:   {
190:    "cell_type": "code",
191:    "execution_count": null,
192:    "id": "b8a60bad",
193:    "metadata": {},
194:    "outputs": [],
195:    "source": []
196:   },
197:   {
198:    "cell_type": "code",
199:    "execution_count": null,
200:    "id": "ec731210",
201:    "metadata": {},
202:    "outputs": [],
203:    "source": []
204:   },
205:   {
206:    "cell_type": "code",
207:    "execution_count": null,
208:    "id": "8198ec2d",
209:    "metadata": {},
210:    "outputs": [],
211:    "source": []
212:   },
213:   {
214:    "cell_type": "code",
215:    "execution_count": 1,
216:    "id": "fbbae561",
217:    "metadata": {},
218:    "outputs": [],
219:    "source": [
220:     "import numpy as np"
221:    ]
222:   },
223:   {
224:    "cell_type": "code",
225:    "execution_count": 2,
226:    "id": "995a8d86",
227:    "metadata": {},
228:    "outputs": [],
229:    "source": [
230:     "def fun(B, delta=0.05, Delta=10**3):\n",
231:     "    return np.log((B+B**2)/delta)*Delta"
232:    ]
233:   },
234:   {
235:    "cell_type": "code",
236:    "execution_count": null,
237:    "id": "17749985",
238:    "metadata": {},
239:    "outputs": [
240:     {
241:      "data": {
242:       "text/plain": [
243:        "np.float64(14615.015756511137)"
244:       ]
245:      },
246:      "execution_count": 3,
247:      "metadata": {},
248:      "output_type": "execute_result"
249:     }
250:    ],
251:    "source": [
252:     "fun()"
253:    ]
254:   },
255:   {
256:    "cell_type": "code",
257:    "execution_count": 4,
258:    "id": "e6fc7922",
259:    "metadata": {},
260:    "outputs": [
261:     {
262:      "data": {
263:       "text/plain": [
264:        "333"
265:       ]
266:      },
267:      "execution_count": 4,
268:      "metadata": {},
269:      "output_type": "execute_result"
270:     }
271:    ],
272:    "source": [
273:     "1000//3"
274:    ]
275:   },
276:   {
277:    "cell_type": "code",
278:    "execution_count": null,
279:    "id": "509dda70",
280:    "metadata": {},
281:    "outputs": [],
282:    "source": []
283:   }
284:  ],
285:  "metadata": {
286:   "kernelspec": {
287:    "display_name": "anon_sbm_notebook",
288:    "language": "python",
289:    "name": "python3"
290:   },
291:   "language_info": {
292:    "codemirror_mode": {
293:     "name": "ipython",
294:     "version": 3
295:    },
296:    "file_extension": ".py",
297:    "mimetype": "text/x-python",
298:    "name": "python",
299:    "nbconvert_exporter": "python",
300:    "pygments_lexer": "ipython3",
301:    "version": "3.13.5"
302:   }
303:  },
304:  "nbformat": 4,
305:  "nbformat_minor": 5
306: }

================
File: notebooks/surrogate_accuracy_26-06-2025.ipynb
================
  1: {
  2:  "cells": [
  3:   {
  4:    "cell_type": "markdown",
  5:    "id": "2b29dd78",
  6:    "metadata": {},
  7:    "source": [
  8:     "# Notebook for investigating network accuracy of surrogates"
  9:    ]
 10:   },
 11:   {
 12:    "cell_type": "markdown",
 13:    "id": "57bdcafc",
 14:    "metadata": {},
 15:    "source": []
 16:   },
 17:   {
 18:    "cell_type": "code",
 19:    "execution_count": 6,
 20:    "id": "dfb246da",
 21:    "metadata": {},
 22:    "outputs": [],
 23:    "source": [
 24:     "import numpy as np\n",
 25:     "import pandas as pd\n",
 26:     "import matplotlib.pyplot as plt"
 27:    ]
 28:   },
 29:   {
 30:    "cell_type": "code",
 31:    "execution_count": 7,
 32:    "id": "fc84799c",
 33:    "metadata": {},
 34:    "outputs": [],
 35:    "source": [
 36:     "import sys\n",
 37:     "from pathlib import Path\n",
 38:     "\n",
 39:     "### Load all surrogate statistics\n",
 40:     "folder_path = Path('/Users/lmmi/anon_sbm/results/surrogate_statistics')\n",
 41:     "\n",
 42:     "# find all log files in the logs directory\n",
 43:     "stat_files = list(folder_path.glob(\"*.csv\"))"
 44:    ]
 45:   },
 46:   {
 47:    "cell_type": "code",
 48:    "execution_count": 8,
 49:    "id": "707ac12e",
 50:    "metadata": {},
 51:    "outputs": [
 52:     {
 53:      "data": {
 54:       "text/plain": [
 55:        "36"
 56:       ]
 57:      },
 58:      "execution_count": 8,
 59:      "metadata": {},
 60:      "output_type": "execute_result"
 61:     }
 62:    ],
 63:    "source": [
 64:     "len(stat_files)"
 65:    ]
 66:   },
 67:   {
 68:    "cell_type": "code",
 69:    "execution_count": 9,
 70:    "id": "8ee87d6c",
 71:    "metadata": {},
 72:    "outputs": [],
 73:    "source": [
 74:     "def determine_block_size(stat_file):\n",
 75:     "    \"\"\"\n",
 76:     "    Determine min_block_size from the filename.\n",
 77:     "\n",
 78:     "    min_block_size is encoded in filename as *min_block_size_{min_block_size}*.csv\n",
 79:     "    \"\"\"\n",
 80:     "\n",
 81:     "    # drop .csv extension\n",
 82:     "    if stat_file.name.endswith('.csv'):\n",
 83:     "        stat_file = stat_file.with_suffix('')\n",
 84:     "\n",
 85:     "    # find location of substring 'min_block_size_'\n",
 86:     "    index = stat_file.name.find('min_block_size_')\n",
 87:     "\n",
 88:     "    tail = stat_file.name[index + len('min_block_size_'):]\n",
 89:     "    size = tail.split('_')[0]\n",
 90:     "\n",
 91:     "    # check if size is a digit\n",
 92:     "    if not size.isdigit():\n",
 93:     "        print(size)\n",
 94:     "        raise ValueError(f\"Invalid size in filename: {stat_file.name}\")\n",
 95:     "    return int(size)"
 96:    ]
 97:   },
 98:   {
 99:    "cell_type": "code",
100:    "execution_count": 10,
101:    "id": "f5f8ac7e",
102:    "metadata": {},
103:    "outputs": [],
104:    "source": [
105:     "df_list = []\n",
106:     "\n",
107:     "for stat_file in stat_files:\n",
108:     "    df = pd.read_csv(stat_file)\n",
109:     "    df[\"block_size\"] = determine_block_size(stat_file)\n",
110:     "    df['surrogate'] = [int(surrogate_str.split(\"_\")[1]) for surrogate_str in df['surrogate']]\n",
111:     "\n",
112:     "    df_list.append(df)\n",
113:     "\n",
114:     "df = pd.concat(df_list, ignore_index=True)"
115:    ]
116:   },
117:   {
118:    "cell_type": "code",
119:    "execution_count": null,
120:    "id": "782cc864",
121:    "metadata": {},
122:    "outputs": [],
123:    "source": []
124:   },
125:   {
126:    "cell_type": "code",
127:    "execution_count": 11,
128:    "id": "0ddc127e",
129:    "metadata": {},
130:    "outputs": [],
131:    "source": [
132:     "marker_styles = {\n",
133:     "    \"congress_twitter\": \"o\",\n",
134:     "    \"caltech_fb\": \"s\",\n",
135:     "    \"eu_email\": \"D\",\n",
136:     "    \"lastfm_asia\": \"x\",\n",
137:     "    \"wiki_vote\": \"+\",\n",
138:     "    \"enron_email\": \"+\",\n",
139:     "}\n",
140:     "\n",
141:     "# load nice colormaps\n",
142:     "from matplotlib import colormaps as cm\n",
143:     "\n",
144:     "cmap = cm.get_cmap(\"tab10\")\n",
145:     "\n",
146:     "colors = {\n",
147:     "    \"congress_twitter\": \"teal\",\n",
148:     "    \"caltech_fb\": \"salmon\",\n",
149:     "    \"eu_email\": \"black\",\n",
150:     "    \"lastfm_asia\": cmap(0),\n",
151:     "    \"wiki_vote\": cmap(0.5),\n",
152:     "    \"enron_email\": cmap(1),\n",
153:     "}"
154:    ]
155:   },
156:   {
157:    "cell_type": "code",
158:    "execution_count": 12,
159:    "id": "57a9d87f",
160:    "metadata": {},
161:    "outputs": [
162:     {
163:      "data": {
164:       "image/png": "iVBORw0KGgoAAAANSUhEUgAAA10AAAHbCAYAAAAwDfCzAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjMsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvZiW1igAAAAlwSFlzAAAPYQAAD2EBqD+naQAAq79JREFUeJzt3Qd4U2UXB/ADlE3Ze+8pe8jeyFL2RgVkOdgbERmyRGUrCirgAEQEUaZskY2yQTYyZe9dyPf8D9+NaZq0SZo06/97npjm3tv0Ftu399z3vOfEMplMJnHS77//Lm+//bakTp1aOnfuLNmzZ5eECRNGOK5EiRLOvjUREREREVFAieVK0BU7duz/3iBWrAj78ZbY/vTp0+ifIRERERERkR8LceWTZs2a5f4zISIiIiIiCkAuzXQRERERERGRB2e6LN29e1fOnj2rH2fJkkWSJEkS3bckIiIiIiIKGP8tznLSzp07pVq1apIiRQp54YUX9IGPq1evLrt27XLvWRIREREREQVTeuH27dulatWqEi9ePGnTpo0UKFBAtx8+fFjmzZsnjx8/lg0bNkiZMmU8cc5ERERERESBHXTVrFlTTp8+LX/88YekT58+3L5Lly5JhQoVJEeOHLJ69Wp3nisREREREVFwpBdipqtr164RAi5Ily6ddOnSRbZt2+aO8yMiIiIiIgq+oAt9usLCwuzuR38uy15e/g6Tgbdv39ZnIiJfxbGKiPwFxysKNi5FRuXLl5dPP/1U/vnnnwj7zpw5I5999pmmGAaKO3fuSLJkyfSZiMhXcawiIn/B8YqCjUsl48eMGSOVKlWS/PnzS+PGjSVv3ry6/ciRI7JkyRIJCQmRsWPHuvtciYiIiIISZoQQoKCIWYIECbx9OkQUE0FX8eLFZceOHTJkyBD55Zdf5P79+7o9UaJEUqdOHRk1apQULFjQlbcmIiIiIiuoDJ0yZUq98T1gwABvnw4ReTroevTokaxatUqyZ88uixcvlmfPnsmVK1d0X5o0aQJqLRcRERGRL4gfP74WMMMzEfkfpyMkTGs3b95ctmzZ8vwNYsfWioV4MOAiIiIi8oz27dvLN998o7NeRBTgM12xYsWSPHnyyNWrVz1zRkREREQUQeHCheXnn3+WQoUKaQCGrKOECRNGOK5JkyZeOT8icnNz5Llz50qfPn1k48aNki9fPgl0KGmKCju3bt2SpEmTevt0iMK786/IrlkipTqIhEbsnUfBg2MV+aKJq49KnNixpEeNPBH2TVl7TJ4+M0nvWs8LclHkHMkows1xtO7xdRyvKNiurVwqpIHGx6lSpZIXXnhBqlatavNOC37pJ0+e7JaTJKIoBoaN40Ty1WXQRUQ+BwHXhNVH9WPLwAsBF7b3YcDlsPXr13v7FIiCwx33X1u5FHRNmzbN/PHatWttHsOgi4iIiIxAyzLwsgy4bM2AkW1VqlTx9ikQUUwGXahYSETeM3HZXxLnyV3pUSapyMW9zzf+/3nKjtvyNG4S6V2/hHdPkojIRuA1bd1xefz0GQOuaDp06JD8888/+nG2bNnYqofIHbNbeIDVtZXCjFc0Zr2cDrrQk+vVV1+Vpk2bStu2bV3+wkTkujgXd8uE4+lFdn0tPUIWP9/4aw+ZEtZYJoQ1lz65j4kIgy4i8h0IsIyAK16c2Ay4XLRkyRJdV3/69Olw23PkyCETJkyQBg0aeO3ciPzarlnPUwot/drjv4+rDBKpNtjlt3e6xjsaIK9Zs8bcEJmIYl6PlvWlT9lQDbCm5Jqp2/CsAVfZUN1PRORLkFJoBFx4xmtyzvLly/WmN6BJMvql4oGPURcNVQtXrlzp0nt/+umnukY/QYIE8uKLL8qOHTsc+rz58+frkpJGjRq59HWJfAaKZnTZ+PzxypTn2/BsbMP+mK5eWK9ePW3Q9/XXX0swYIUd8lXGuoh48kQeS1ym6wQ5jlXkq6zXcHFNl2vKlSsnjx49kk2bNknixInD7bt3755UrFhRg6atW7c69b4//PCDvP766/L5559rwDVp0iT58ccf5ciRI5I2bVq7n4fZNnzNnDlzSsqUKbWcvaM4XpFPu7BHZEaV58FWxmJuecvYrhbSwC/8e++9J+fOnXPLiRCR83CxEi+2aMCF52C6eMH9IvzRfvjwobdPhYgiYSvAwjNeYztnvBy3b98+adeuXYSAC7ANvbtwjLOQlti5c2fp0KGDrg1D8IXMpshurqMsPZaZjBgxQoMuIvJA0FW0aFENtsaOHauLN+PHj693KSwfuHtBRDGQrvNMJF6sZ/ocTBcvjx8/1jurU6b8PwWAiHwS+nDZmtEyAi/sJ8dgFuv69et292MfjnF2LP3zzz+lZs2a4fqB4XVkM2YjR47UWbCOHTs69HUwQ4cbZZYPIp+FghlYw+XGVjwuVS9EPjHyd4nI99J1IBhmvHCzB2nOePYErG/46KOP5N9//9UbTVOnTpUyZcrYPR6pOEOHDtV0mzx58siHH36oqdiWM3PDhg2TmTNnys2bN6VChQoyffp0PRY2bNgg1apVs/neWFtRunRpD3yXRJ4XWePjYBir3Kl69erajqdOnTqaamhp+/btehPqpZdecuo9r169qrNW6dKlC7cdr//++2+bn/PHH3/IV199JXv27HH46+BGPWbFiPwCgq1oFM1wW9A1e/Zst54EEbknXQeCKfBCKs0333wjb731lsSLF89t74v1DagOZrm+oXbt2nbXN2zZskVat26tFxUvv/yyzJ07VxeV//XXX9pEHsaPH68XRHPmzNEqYwjQ8J4o+4w70+XLl5eLFy+Ge18cg16IpUqVctv3RkT+C+MIgi2so8JNoHz58ul2jE24OYPxCTd8POnOnTvy2muv6Q2k1KlTO/x5gwcP1nHVgJmuLFmyeOgsiXyPS4U0gg0Xe5Kvmbj6qMSJHctmYIWADOk6kd1dDhQIjj744ANNW0EAhspbCRMmjHAcKno5A4EWZpaMRvDoTYiLg+7du8ugQYMiHN+yZUtdxL506VLztrJly0qxYsU0cMMwmzFjRunbt6/069dP92M8wZ1k3MRq1apVhPd88uSJZMqUSb8mgi9HcKwiCnyXL1/WGzwrVqwI16cLM+sYnyIrfGEvvRDrtxYuXBiuAiHWjmFWHiXqLWF2q3jx4hInTpwI/VuRlogAMFeuXFF+XY5XFGxcmumCM2fOaInS9evX6wCAX8rKlSvrNDXyfLEYE7+UROR+TNd5DrNLBnuBCVKhkTrj7PoG3JV1dH0DtlvewQXMYhmVvE6dOqVpipZrJnCxgeAOn2sr6Prll1/k2rVrOpYSEaFo0IwZM/RmzsSJE/XhDsgSKFmypM6qG0EXgii87tatW4Tj8+fPL/v37w+3DYXVMAOG1EfOXhG5MehCOkylSpX0lxIXDcePH5ewsDDdh6lm5Priri/yfYmIPAU3fdzNlfUNCKhsHY/txn5jm71jrGH8ROCWOXNmu+eKGT48DFyYThS4kIY8cOBATVPGTW53wk0jzGwhlRlpi0ipxnWccdMH5eQx844ZNpyHkTZtSJ48uT5bbyeiaAZdAwYM0F+wbdu26V1k66ns+vXra9pPTCxgX7Rokc64IfBDOg4WpSOFB/nGji5gJyL/VKVKFQlEqA67atUqWbBgQaTHcWE6UXBBUINiPe6GFOkrV67I+++/r9demE1Dk2XjRhGymzDjT0Suc+k36Pfff9eF62nSpLFZxTBr1qxy/vz5aC1gR5CERegIunC3FymMtqBk9JAhQzRFB70pcFcGD1ywGIwF7Fhbgeo+6GWB92R/H6LAgRl4rHHAAx+7CrP1WKtw6dKlcNvxGtUSbcH2yI43nh19z1mzZkmqVKmkQYMGkZ4rUiCxHsJ4nD171sHvkoj80ejRo+WLL76QNWvWuP29kUqINWKYPce1EjKZDKiuGlkRNexzpjEyUTByKehCWiEWXdqDuyWulnF2tkFf1apVpXHjxlKgQAFduNmzZ08pUqSIpjgas1yYJke+ccOGDXUfqp1duHCBAwRRAMB6UvzuFy5cWCsH4oGPc+fOreuiorO+wWCsb7Au0WzAdsvjYfXq1ebjUa0QwZXlMUgFxIWN9XtizELQhXSeuHHjRnqutnokElHgQnEf3GzGjWOMcbVq1dKbM5YPXOsQUYAEXSVKlJBly5bZ3Ie1XfPnz9fKXc5ytUGf5cUKLmpQOcfId45qATsFdoU/e82CsR37yb8tX75c+wYC0owXL16sD3yM8QBVC5Ei4yzMtiMdGeXdDx8+rDP71usbLAtt4GYPvs4nn3yi676GDx8uu3btMi9CR0ZAr169ZNSoURoIYhE63gMVDS2rhcG6det03OrUqVM0/3WIKNAgowdLKZBRhLWnWFqB8cT6QUQBsqYLFxu4m4wLEaPqFtJkMN2Nix1cpBillj29gB2QVoMFnpgSR1rQZ599pnd/XF3AzsXpgQEl1W31rLLscUX+DeXiMXu9adMmTRs24G4vAh70ssGaJzQS9eT6BvTYQm8uzKi/++67ul4UM+mWi8qxFhaBW5cuXXRtKc4N74lF6dYFNPB+qBBGRGTJE+u5iCiGmFz0zTffmFKkSGGKHTu2KVasWObnZMmSmebOnevSe54/fx49w0xbtmwJt71///6mMmXK2P28p0+fmo4dO2bavXu36eOPP9ZzWL9+ve7bvHmzvueFCxfCfU7z5s1NLVq0sPl+w4YN08+xfty6dcul74u8Z/Kao6ZsA5fqs63X5N8SJUpkmjRpkt392IdjggXGKI5VRIHp3r17phIlSpimT59uCgQcryjYuNynC9UBkbqDdQvHjh3TNQ9YV4E849DQ0BhbwA6444zcZsAdacy0oaoX1ntZLmDPkCFDuPfEsbawa3rgMGa4MLM1bd1xefz0mc5wBVMvq0CGWaLr16/b3Y991jNJRET+COvbkXpsq4AZEfm+aNX/RDoP1iP0799fe0c0a9bM5YDL1QXstuBzjPRAZxawG7g4PbAgwIoXJ7YGXHhmwBU4qlevrs04ba3PxO84qpZaruckIvJnSJW2rM5MRP7D5ZkuT3GmQR/gGcdilg2BFhbWf/vtt9qHy3oBO9ZZIAgbOnSozQXsFJiwhssIuPCM1wy8AgPaQeDmCdZHYbzIly+fbkcxnR07dmgPwQ8//NDbp0lE5Ba4fmnevLlmG3Xt2lWvaRImTBjhOFQ4JCLf4nNBl7ML2BGQvf3229pMFAMPFp9/9913+j7OLmCnwGNZNAOBlvEaGHj5P1xwoJoXbr6gP5fRlD1btmxaUXDQoEERmrcTEfmrQoUK6TN6EaJ4jz0oSkZEviUWFnZ5+yR8HdIRUWYeVRKZaui/AVdU28m/oLn5jBkz9MaM0SIi2HGsIgpsaEfhyJquYcOGia/jeEXBxudmuojc5ekzk83AyniN/eS/MFONtaRYt8Wgi4iCJegiIv/EoIsCVu9I+nBxhiswoA8W+9YQUbDCLFGSJEm08jMRBXD1QiIibxo9erR88cUX2pidiCgY7Nq1S6sYooR8qlSpZOPGjbr96tWr0rBhQ9mwYYO3T5GI3DXThWVgWEvx1VdfycmTJ+XGjRsRjkHOcVhYmCtvT0TkkGnTpmmVLvQHRFENW5W8MBYtWbLEa+dIROQuW7Zs0VYZqOL86quvypdffhmu1ylmvnAjCn1KiSgAgi5UA5wwYYIuYMcvfYoUKdx/ZkREUUDlQgRVWbNm1Wpdx48fj3AMG4kSUaB49913pUCBArJt2za5c+dOuKALqlWrJnPmzPHa+VGQufOvyK5ZIqU6iISm9/bZBGbQhV/opk2byoIFC9x/RkREDuJ6LiIKJjt37tQWGfHjx5e7d+9G2I8ZMLTbIYqxoGvjOJF8dRl0eWpN14MHD6RmzZqufCoRkVvcv39fSpYsKZ9//rm3T4WIKEbEjRtXnj17Znf/+fPntbAGEQVI0FWjRg2920JE5C1YRH7q1CmmDxJR0ChbtqwsXLjQ5r579+7JrFmzpEqVKjF+XhRks1sX9jx/XNz7fBuejW3YT+4Luj777DPNJx4zZoxcu3bNlbcgIoo2VPBatWqVt0+DiChGjBgxQqsX1q9fX1asWKHb9u7dq2u7MPN/5coVGTp0qLdPkwIZ1nDNqPL88WuP59vwbGzDfrIplgmlCJ0UGhqq09sPHz40Nym17hGBu8+oohMI2DWdyDcdPnxYmjdvLsWLF5euXbvarF4IqHAYDDhWEQW+devWyVtvvSXHjh0Ltz1XrlwafPnLTBfHKz+FmSxjNgszXAi4XpkikqHo821Y28X1Xe4rpIEiGkzpISJvK1SokD4fOnRI5s6da/c4VDYkIgoEKBl/5MgR2bNnjwZeuAmOgAszXbw2I4+zFVQh4MpYzFtnFNhB1+zZs91/JkRETnr//fd5kUFEQQlte/AgogAOuoiIfMHw4cO9fQpERETBCTNeVQYxndCThTSMXFws6CxTpoykS5dOH/h45MiRuo+IKKZhbQBTCYmIiGIAgq1qgxl0eTLounDhgi5cR9CF5nwVKlTQB8qV4s5ziRIl5OLFi668NRGRU1DJC1UMUUI+VapUsnHjRt1+9epVadiwoWzYsMGl9/30008le/bsWijoxRdflB07dkR6/I8//ij58+fX4wsXLizLly8Ptx81i5AOmSFDBi32gV6H1gvhYdmyZfr1cEyKFCmkUaNGLp0/ERER+XnQNXDgQO14vnTpUl3AvmjRIn0cPHhQLxiwb9CgQe4/WyIiC1u2bJGKFStq8PLqq6+GaxqaOnVqnfn64osvnH7fH374Qfr06SPDhg2Tv/76S4oWLSq1a9eWy5cv2z2P1q1bS8eOHWX37t0aKOFx4MAB8zHjx4+XKVOmaDPn7du3S+LEifU9jSqw8NNPP8lrr70mHTp00DLQmzdvljZt2jh9/kRERORbXCoZnyZNGunSpYuMHj3a5v53331XZs6cqf0iAgHLmhL5pqpVq+rvJfoG3rlzR9KmTStr1qzR6l6A2fg5c+bIyZMnnXpfzDSVLl1apk2bpq8RzGXJkkW6d+9u84ZSy5YtdaYfN6Ism5hikTuCLAyzGTNmlL59+0q/fv10P84badkoTNSqVSsJCwvTmTWcM4I3V3CsIiJ/wfGKgo1LM124uMDFgj3p06fXY4iIPGnnzp06KxQ/fnybVQwzZcqkM+/OePz4sfz555+a/meIHTu2vt66davNz8F2y+MBs1jG8adOndLzsDwGFxsI7oxjMKN2/vx5/VpI30YaYt26dcPNlhERGbC84+zZs3LmzJkIDyIKkKCrYMGCMm/ePL04sfbkyRPdh2OIiDwpbty44VIKrSGISZIkiVPvibVgKMZhfWMJr+0FcNge2fHGc2THGLNxWBf73nvv6awZ1nRhNu/69es2v+6jR4/0brHlg4gCF9KRBw8erLP6uHGD2XE0hbd+EFGAlIzHmi6k06Ba4dtvvy158+bV7WjWh1Saffv26ZoIIiJPQgrfwoULpVevXhH2YbZ91qxZUqVKFfEHRvA4ZMgQbUAPOP/MmTNrkY6uXbtG+JyxY8dqOiIRBQdccyFlGmtGK1WqpDdmiCiAg67mzZvrBQ3WNrz55pvmtB6sW8Ddl6+//lqaNWvm7nMlIgoHAQeCqvr162shC0ABCswaffzxx7qudOjQoU69JwpwxIkTRy5duhRuO14jddoWbI/seOMZ25A2aHmM0dzU2G6ZJYC0yZw5c9pNF8IdbxT8MGCmC2vPiCgwoWhZp06dXCoQRER+2qerffv2cu7cOa3aNXfuXH3gY2xr166de8+SiMgGrIlCafbjx4/L66+/rttQrAKFfpAiiH1FihRx6j3jxYsnJUuWlLVr14abhcLrcuXK2fwcbLc8HlavXm0+Huk+CLwsj0GAhCqGxjH4mgiykDFgma59+vRpyZYtm82vi+OxAN3yQUSBCze50ZaHiIJkpsv8ySEhmt6DBxGRN6BSIQKVPXv2aOl4BEi5cuXSIMZWcQ1HYPYIN49KlSqladSTJk3S2X0U7QAEeCjSgfQ+6Nmzp864ffLJJzrrNn/+fO0fNmPGDN2P80AK5KhRoyRPnjwahGEGDhUNjT5cCJiQOYAy9ZitQqD10UcfmbMLiIjQexAVWm2lGxNRAARdv//+uz5Xrlw53OuoGMcTEXka0vSMVL3owppVpCaimTEKXeB9V65caS6EgXQ/VBk0lC9fXmf7UQADLTMQWP3888/ywgsvmI8ZMGCABm6Yhbt586b2F8N7opmyAUEWbmahV9eDBw90Jm/dunVct0FECjdrWrRooeMIAq+sWbNqOrS1lClTeuX8iCiafbpwcYE7tbgIQOqN8doevCX2I73HFZ9++qlefOBiB01Jp06dqnebbUE/sG+++cZcVhl3t8eMGRPueKRCYuGpdTlnXPA4gr0kiMgfcKwiCmyWN3siuw5z9forJnG8omDj0EzX+vXr9RkBl+VrT0DVQ6T2oAoi7vIirQcBEtKHUKTD2oYNG3QBPe40447xhx9+KC+99JIcPHhQ038MderU0UpglmshiIiIvG3i6qMSJ3Ys6VEjT4R9U9Yek6fPTNK71vMqwRTcMPvuato0EfnBTFdMQqBVunRpmTZtmr7G+gysb+jevbtWS4wK7u4gFQefbyysx0wX0nmQ7uMK3o0hIn/Asco/IbCasPqo9KmVN1zgZW87USDgeEXBJrarC9etK3VZwkwYjnEWmi3/+eefUrNmzf9OMHZsfb1161aH3uP+/fta8cs6nxkzYpgpy5cvn7z11lty7do1u+/BhqNERBRTEFAhsEKAhUALGHCRI7DsAw8iCtCgCwGMdU8aS5cvX5aNGzc6/b5Xr17VmSpjsboBr7G+y9HGzagIZhm4IbUQ674QKCL9EOdWt25duznPqEiGuy/GIxj63ky0+GNvDduxn4iIPB945R2yggEX2YVCPqikimujJEmS6AMfv/HGG/LPP/94+/SIyN0l4yPLKUbPnNDQUIlp48aN01LNCAotK4K1atXK/HHhwoW1bw9KSuO4GjVqRHifYGw4ivUE+CMP9tJbiHzZ3bt35caNG1rIxxoqfBH5Ooy909Ydl8dPn0m8OLEZcFEEf//9t1Y+xZKJWrVqSYECBczbcXP5119/lT/++EOzeojIT4MuVP+zrACIfjOoHGgNA8G+ffukXr16Tp9M6tSptfSp9SwaXqOxaGQ+/vhjDbrQvyKqZqg5c+bUr4Xg0FbQhSIbwVZow/jjbhl4Mb2FfN3Dhw9lxIgR8tVXX0WaMuwPlbyIMOYaARee8ZpjL1nC2nYsu9i9e7feRLaEKs64psExixcv9to5ElE0gy6slULfGsOdO3fClS41Zr8SJ06sDT5RYcdZqI6Iku9IAzQahqKQBl5369bN7ueNHz9eRo8eLatWrdJmplE5d+6cXqBlyJDB6XMMlsDLuNvKgIt82dtvv603gzBeVKpUif2syG9Z3+QyXgPHYDJgeUTfvn0jBFyAvoC4VpowYYLH2/UsWrRI2/Pg5jXW0aM3Ic4LPQaJKJpBF4pP4AE5cuSQyZMnS4MGDcTdkNbXrl07DZ7wy46S8WgoivxlQEVClILHuivAGi0EeGhMmj17dvPaLyPPGSlHuBPetGlTnS07ceKENinNnTu3lqKn8JjeQv4Ef/g7deokX3zxhbdPhchltrIKbGUfECHASZgwod39iRIl0mM83a4HxcqGDBki+fPn1xvmS5cu1es0HMtrKyI3FtI4deqURwIuaNmypaYKIpAqVqyY7NmzR5sYG8U1sID04sWL5uOnT5+uVQ+bNWumM1fGA+8BSFdEuiPON2/evNKxY0edTdu0aVPQpRC6mt5C5Kswu16iRAlvnwZRtKAPl62sAqO4BvYTQfHixeXLL7/UMuvWsP4cqdaujImYHevcubMGTgULFtTgCwHc119/bfP4qlWrSuPGjXVNGdbI9+zZU5d2YD0ZEbmxTxcCH0cEyuL1YOklYS+9hSmG5KvQgw8z4T/++KO3T8UnBMtYRRSs1q1bpxWZU6VKpQESbiYDZqSQao2lE7hRXa1aNYffEzeuEWAtXLjQvLQDkHWEdfpLliyJ9PNxGYnzws1t9ENFgQ9HcLyiYONS9UKk8TnSEZ2L1/0H01vIHw0dOlRatGghXbp0ka5du+qNHsxuW7Pu20dE5I/QA3X58uXSv39/LR5mCdlB3377rVMBV1TtelAV0R4ES1jugd6mGHc/++yzSAMuHIeHgT1QKdi4FHRhutk66MIv7OnTp7VkKXJ633nnHXedI3k5vcXYT+RrsHgbUMkLaTX28AYQEQUK9CHFmIc17EZfrmzZskVZ5dnd0BoIS0Cwdh4Fz7AmDNWhkXpoC9biY409UbAKcTWlJ7LmxFiEaSvfmHxX70j6cHGGi3wV1n46MutORBRoEGS5I9BytV0PKlijKJkxy3b48GENrOwFXcHYA5XILc2R7UHJeOQZT5w4UXr06OHutyciMhs+fLi3T4GIyGOQPQQoxY4bTMbrqKDSs6fb9VjD51imD1oLxh6oRB4NuoxfPKN0OxFRTHnw4IE+R1ZSmYjIXyCzCMFWq1atNDiKLNPIgOOdCbpcadeDZxyLyoUItLDODOvJUFGaiGIg6MJU8e+//67N9VDWlIjI01BNddiwYfpHHwvCjXSZ+vXr63asdSAi8kdo0QMIuCxfe6Jdz5UrVzRlGzfNkS5o3a4H6YQGBGRoTn/u3Dm9yYV+Xd99952+DxG5sWQ8fvHsraPA26GCGMqG4pc2ELCsKZFvQmWtihUralljVM1Czxhj+2+//SYpUqTQvjH58uWTYMCxioj8BccrCjYh7lq8jte4wMFU80svvSQhIR7JXCQiMhs0aJDeBEIlr8KFC4fbd+DAAalRo4Yes3jxYq+dIxGRu6A6IFL/0BPLlqVLl+p6+pMnT8b4uRFR5FyKjLh4nYh8wcaNG6Vv374RAi544YUXdBH4hAkTvHJuRETuhtY8KNFuD/YZZeTJx9z5V2TXLJFSHURCY7a8P/mG/xJ0XXT58mXZsWOHPvAxEVFMefLkSaRFMxIlSqTHuOLTTz/VRvAJEiTQNhgY4yLz448/6roGHI8gEGvMrFOvkSWQIUMGPWf02jl27JjNxvOWD+sGqEQU3CJrk7Fz505Jnjx5jJ4PORF0bRz3/JmCkstBF0qJonINLiDKlSunD3yMbWvWrHHvWRIR2YCCPV9++aXNvoBYL4CGySVKlHD6fX/44Qet5oVCHH/99ZcULVpUateubffG0pYtW6R169bSsWNHTXVE2WU8kOJoGD9+vEyZMkU+//xz2b59u7bXwHs+fPgw3HuNHDlSLl68aH50797d6fMnosAxefJkTSvEAwFXr169zK8tH6lSpdLUw3r16nn7lInIXYU0sD6iefPmWtUGZUTz5n3eWPfIkSNaMhQXJgsWLJDGjRtLIOBiTyLftG7dOqlTp45ebKC0seVYNGfOHLl27ZpW4KpWrZpT74uZrdKlS8u0adPMbTDQxBMBENaIWUPFLlTzwnoKQ9myZbWYEIIsDLMZM2bUVMh+/frpfownGENnz56t5aCNmS5cUOHhCo5VRIFn3rx5MnfuXP142bJlOq6gfLslBGO4kYN+W6gqiFl+XxcU4xVmtYyZrYt7RX7tIfLKFJEMRZ9vQ5ohUw2DhktBV6FChSRu3LiyadMmCQ0NjfBLhGpiT58+lYMHD0ogCIqBgchPYWa9f//+snfv3nDbcWGC9hUopuGMx48f6wXLwoULzY1CAT1sUCVxyZIlET4HFVsxM2YZLGGWDFVccV5Y1I4iQ5gFs6zqWqVKFX2NO9lG0IWZL6RE4j3btGkjvXv3drgwEccqosCGG0jvvfee0+OaLwqK8Wr92OcphfZUGSRSbXBMnhH5WyENXEBgnYF1wAX4xUGKzeDB/CEiIs/D2igEM+gtYywgR2+u9Oldu3uIXl+4aWT0pzHgNUrR24Kvbet4o0m88RzZMYCqY0iHTJkypaYsYhxFiqG9YiBoSoqH5UUMEQWu9evXe/sUyBkompGvbuQzXRQ0XAq6sFg8sqIZly5dMqf5EBHFBARZrgZavgKzZYYiRYpoQ9SuXbvK2LFjJX78+BGOx/YRI0bE8FkSkbf8/vvvDh1XuXJlj58LOcBW+iACroyB0ceWYiDowoJwrEEoU6aMNGzYMMJ6ry+++EIXohMRudM333yjz6+99pquYTBeRwVrTx2VOnVqiRMnjt48soTX9oI6bI/seOMZ21BwyPKYyJrIY21ZWFiYlom21eAZM2GWgRpmurD2jIgCU9WqVSOtXmjAbD0R+WHQZasJX5o0aaRJkya6ODx37ty67fjx43LhwgWd5Zo6daqm/RARuUv79u31ggM3fTALhNdRwfHOBF14XyxGR4VWY00XCmngNfp+2YLqrdhvuaZr9erVuh1y5MihgReOMYIsBEioYvjWW2/ZPZc9e/Zo8+e0adPa3I/ZL1szYEQUPOmFCLBwY2bGjBk6VrHNhI/CjBfWcDGlMGg5FHTt27fP5p0VLPQG/LLrm4WE6DYsBN+/f7+7z5WIgtypU6fMgZHla3fD7BEKZ6AFBmb0UYYZ1QlRIREQxKF6GNL7oGfPnloU45NPPpH69evL/PnzZdeuXXoRBEaZ51GjRkmePHk0CBs6dKjetDICu61bt2oQhoXyWC+L1yii8eqrr0qKFCk88n0SkX/BOGMPbkJVqlRJNmzYINWrV4/R8yIHINhi0Yyg5lDQZQRVRETehAIZkb12F5SAv3LlijYzRqELzE6h9LxRCOPMmTM6A2UoX768lnRGVbF3331XAytULnzhhRfMxwwYMEADty5dumgVRFR5xXuimTJgxgrB2vDhw7U4BgIzBF2W6YNERPZgTEIWAG4God8fEQVAyfhgExRlTQMd+mTsmvW8khCn9gMGGoJiFspWCjSgbxYqAqLiajDgWEUU3FBY58MPP5T79++Lr+N4RcHGoZku3NW1TCc0XkfFOJ7IJ4Iu9MpA6VYGXQEDs/B37961ux/7jDLyRET+zt71F2bPUdkQvQmRYkhEfhp0oWEn1iQ8ePBA11IYr6PC6jlE5GmRjUU7d+6U5MmTx+j5EBF5SmTXX0hcKlu2rFaQJiI/Dbq+/vpr/SWPGzduuNdEPj+7hYfRlNDy2V7/DPJ5kydP1odlgYohQ4ZEOA4pK7j726ZNGy+cJRGR+9m6/sJrFNvJlSuXFCxY0GvnRkRuCLqsyzI7UqY5Oj799FOdIscC9qJFi2r5eVQQs2XmzJnaq+fAgQP6GqWex4wZE+543P0ZNmyYHouLsAoVKsj06dN1sTsFMKzhQkqhJXSDN6B0KysJ+R2UTy9UqJA5vRBVBPGwvghJnDixjgdvv/22l86UiMi9PH39RUQ+VEgDizPRfHPQoEHSv39/t58QmiqjHPPnn3+ujUGxSP7HH3+UI0eO2OxV07ZtWw2iUD0MVcCwgBQNmg8ePGi+EMM2VPOZM2eOuVQzStofOnTIXDksMlzsGSAzXQi4XpnyvBs8cKbL76G8OioG1qhRw9un4hM4VhEFByzf+PPPP83VpZF2iJtMaOzuLzheUbBxqXohyiZj5sgTd5ARaJUuXVqmTZumr9HoD0Fe9+7dNdBzZCDCNDs+H8Ebvj30wunbt6/069dPj8EvOL6H2bNna3nVqHBgCAAX9ojMqCLSZaNIxufNaYkCDccq8mVPnz2TTWfOyMU7dyRDaKhUyppV4li0XiDH4Npl8ODBcvnyZb3GMWb306RJo5k+b7zxhvgDjlcUbBxKL7TWtGlTWbhwobz11ltuXdv1+PFjvXODwcSy70TNmjW1UaijM3FPnjyRlClTmpunIk0R72HALzmCO7ynraALPXLwsBwYiMj3oFqXIypXruzxcyEi+xYdPiw9V66UcxZ/TzMnTSqT69SRJgUKePXc/AmKZODaC70D0dMvb968uh3ZQNjXuXNnvZZ68803vX2qROSOoAuBCma5kNqDX3BMaydMmDDCcSVKlHDqfa9evaozVUYDUgNe//333w69x8CBA3VmywiyEHAZ72H9nsY+a0hFRK8LCiBII8QaLqYTBpSqVauykiqRHwRczRYsEOu0mvO3b+v2hS1aMPByEJZLoCT8mjVrzMXNANdjHTt2lOrVq8v48eMZdBEFStCFCx3Dpk2bIuzHdDcuhGL6QmfcuHEyf/582bBhg0NrtezBTFufPn3CzXQhxZH8GIItFs0IOOvXr4+wDeMO1jnMmDFD05MxLhCR91IKMcNlax0DtuGWSa+VK6VhvnxMNXQAbhZjuYRlwGXANtwUHzBggFfOjYg8EHR5qmR86tSpdRHopUuXwm3H6/TpI5+h+Pjjj/XiCnd/ihQpYt5ufB7eI0OGDOHeE9PztsSPH18fROTbqlSpEmmVL9wRxk0Y3P0lopiHNVyWKYW2Aq+zt2/rcVWzZ4/Rc/NHxYsXl6NHj9rdj332rm2IyA+DLk+VLEXjZVTfWbt2rTRq1Ei34U41Xnfr1s3u52EqffTo0bJq1SopVapUuH2oVojAC+9hDESYudq+fbvmRRNRYMJ6UNz1RbrwyJEjvX06REEJRTPceVywQwud+vXrS86cOaVLly7mpR0PHjzQqs8LFiyQ5cuXe/s0ifyS6dYNkfv37B+QKLHESpYiZoMu3DVGM1J7ZZqR8vPBBx/IunXrnH5vpPW1a9dOgyf02kLJ+Hv37kmHDh10PyoSohQ8LqSM/Ob3339f5s6dq2vLjHVaSZIk0YfRPHXUqFHal8soGY91X0ZgR0SB6fr169qbj4i8A1UK3XlcsLHM3DEgIwjXSkgjxLUMXLhwQcLCwjSjBzfG9+7d64WzJfLvgCts2jiRsDD7B4WESEi3QS4HXi4FXUjX6dSpk939KGO6ceNGl06oZcuWcuXKFQ2kEEBhdmrlypXmQhhnzpzRO9gGNDlGpZ5mzZqFex+UtEdlH8DAhMANd4VwAVaxYkV9z+is+yIi78N4YAt+z1HZEE3WkWJIgWXi6qMSJ3Ys6VEjYoP7KWuPydNnJuld63lVN/IulIVHlUIUzbC1rgsLFbAfx1FEqMRsvZwjVapUehPZEm46E1E0YIYrsoALsB/HxWTQBZGt6Tp+/LiERuOuFVIJ7aUTIuCzZDQGjOpckV7EFCOiwIILDXtjEQr6lC1bVssoU2BBwDVh9fN1LZaBFwIubO/DgMtnoDgGysKjSiF+Uy0DL+M3d1KdOiyiYYf1NQ8R+S+Hg645c+bow4B0vZkzZ9q8w7xv3z6pV6+e+86SiMjBoj54jQbpuXLlkoIFC3rt3MhzjEDLMvCyDLhszYCR96AcPMrC2+rThYCL5eKJKBg4HHSh6TDS/gx37twJl+ZnXOwkTpxY+0MgPZCIyJM8VdSH/CvwmrbuuDx++owBlw+vlWicPFQatGgqm/69JBfv35cMiRJJpfTpdIYL+6OzOD0YGsAbDd7ZEJ7If8UyIQfHSShGMXnyZGnQoIEEA1Q7TJYsmdy6dUuSJk3q7dMhIhu9uf78809zujHSDlEJFQvOg0kwjlV5h6zQgCtenNhydHRdb58OeWFxeiDDzW3c0EZ1QlR4Nl7b460+qa4IxvGKfJfp4jkJmzExyuNCuvSWWBkyx9yarlOnTrn0xYiI3G327Nna0BwFfIx7SLjoSJMmjYwZM0beeOMNb58ieQhSCo2AC894zZmu4FucHgwN4BFwWb4mIv8T4mrFMDxQBdCA8qSffPKJPHr0SFq3bs1y7ETkcSiSgX57qHKKaqV58z4voHDkyBHd17lzZ61uipRnCizWa7iM18DAiwKxATxuKqE5MgIwVl8m8j8ulQvq0aOHuRw7XLp0SapVqyaLFi3SfOOmTZvqx0REnoQ+fSgJj2bnXbt21XEIDwRZO3bskPLly2vzdFd8+umnmqaIi5sXX3xR3y8yP/74o+TPn1+PL1y4cIQGpbhgwlpX9NFBQ9OaNWvKsWPHbL4Xbl4hkMSM3Z49e1w6/0Bmq2gGnvEa27GfKNDgBhJKyE+ZMsXbp0IUeBIl1lTnSGE/jovJmS5cfPTs2dP8+ptvvtF84wMHDuh6rzp16sjHH38sTZo0cfnEiIiigl5+ffv2lbhx40bYh22tWrXSPn3O+uGHH7T56Oeff64BF5q0165dW2fQ0qZNG+H4LVu26Aw/mra//PLL2qwds/1//fWXvPDCC3oMgj9cLKEKrNGkHe956NChCHetjaanbHBqG/pw2SqaYbzGfqJAEz9+fEmfPr0+E5F7YU0p1pZqqrM9iRJHa+2pSzNd169fD3fhsXTpUp0CR4lmLPJEsPX333+7fFJERI5Aqs3Ro89TymzBPswYOWvChAmamtihQwctO4/gK1GiRFqi3hYUFsLNpv79+0uBAgXkgw8+kBIlSsi0adPMs1wI3N577z1p2LChFClSRG9WXbhwQX7++edw77VixQr57bff9MYV2YbGx/ZSCLGdjZEpkCu2YuzArBcRuRcCKhTJsPuI5rpTl2a6sED9n3/+Mffl2rZtm4wbN868PywsTB9ERJ40depUqV+/vuTMmVO6dOmiaXuAmXcESgsWLIiQ5hcVXMygEiKKcxhwMwnpgFu3brX5OdiOmTFLmMUyAioUH8KsHN7DgKpdmEXD52JGzkjVRrCHz0OQR0RkCanLGB8KFSqkARhSoI1xzxIzjYh8j0tBFy4ckCaDEp/olv7s2bNwhTOQLpMlSxZ3nicRkc4QWUNZeAQ8RkoeYAYJN36wfgoXJs6k6V29elXLLadLly7cdry2N4OPgMrW8dhu7De22TsGs2E4V6xHK1WqlLn8fWSw9gsPyxLM5L+ePnsmm86ckYt37kiG0FCplDWr9rEiMiCN2YAUZVv8pWQ8UbBxKejCrBbSdvr166dVdJAGgzUKgAsA3F1u06aNu8+ViIIcFpFb96hJlSqV5MkTPtUMd3/9cdYOTectZ9iigjVkI0aM8Oh5UcxYdPiw9Fy5Us5ZBM6ZkyaVyXXqSJMCBcTvF6dH0acrOovTg8m6desi7dNFFBO99zy57imQuRR04e7s5s2btaEdprWN/hGAWa+1a9dypouI3A4z656WOnVqnT1Dqp8lvMYidluwPbLjjWdsw+yb5THGmjNcTCHV0HqRPGa92rZtqwU4rCFAs0xrxEwXx17/DLiaLVgg1uU/zt++rdsXtmjht4FXTCxODyZVq1b19ilQEGOz8+iJVt4C1iRYBlyAIKxo0aJ6R5qIyN9gTCtZsqTePLK+mVSuXDmbn4PtlsfD6tWrzccjEwCBl+UxCJBQ6t44BinbSINEiXg8jLVoqKQ4evRom18XARrSvC0f5H8phZjhslVv0djWa+VKPc5feXpxejDB+tVffvnF7n4UNsMxRF5vdk6uzXShUg689tprOq1tvI7K66+/7tBxRESOQB9AqFy5crjXUTGOdxRmj9q1a6ezTGXKlNHKg/fu3dNqhsbYlilTJk3vA7TQQAVXNIhHYY/58+fLrl27ZMaMGbof42avXr1k1KhRmgpplIzHGjRjPWzWrFnDnUOSJEn0GVVhM2fO7NT5k//AGi7LlEJbgdfZ27f1uKp+mDZL7oW1nnfv3rW7H/uMQmdE5IdBFxZ346IBFbZwFxivo4LjGXT5qTv/iuyaJVKqg0io7XQqIm+l1mBsQXVCjEXGa3tQnMKVReUtW7aUK1euaDNjFLpACuDKlSvNhTDOnDmjFQ0NaMKM3lwoCf/uu+9qYIUKY0aPLkChDwRuqLKIqq8VK1bU97Tu0UXBBUUz3HkcBb7IxrydO3dK8uTJXW4I/9FHH+mYh4wlrDPFTSdbZs6cqTfg0Z8VkB0wZswYu8cTkUgsE65KomDcNcmWLVu411Exjvd3SANCKiXWsAVF+s6FPSIzqoh02SiS0fkeR0SesnHjRn3GrJLl66gYxwe6oBurAsCG06elmo31etbWt2vHma4ghT6AeBjXX1h3mjhxxMIj+L3HDR0UMvv222+d+hpIY8aNcsuG8D/++KPdhvBYZ1qhQgW94YQbRx9++KEsXrxYDh48qFkAjuB45X9MF89J2IyJUR4X0qW3pg6TCzNd1sFToARTRORfLIMn3C9Cc2TMeHG2iPwVysKjSiGKZti6A4o5DezHcRScEPSgL5eRXoigxjqwwewXAjHMOL399tvRaggPCL6WLVumDeEHDRoU4fjvv/8+3Osvv/xSfvrpJ123yiwnIjdWL6QATSnEAy7uDf8MSDNkqiH5EDQxRsEepLQgdY/IH6EPF8rCo0ohAizLwMtIIptUpw77dQV5by6jP1e1atU0jblGjRpue39XGsJbu3//vjx58oRF1IiiG3RVr15dnIW7LtbVvMiHYQ3XxnHht/3a47+PqwwSqeZ4/yAiT0PlPlQEtC6xTuRvUA4eZeFt9elCwOWv5eLJ/davX+/293SlIby1gQMHamEgBGr2sJk7+ZMPPvhAhg0bpr0w7TUi90jQhXLJ1gs3z549KydPntR8XKM86alTpzSfGNW22CvGz6BoRr66/81wIeB6ZYpIhqLPt3GWi3wQivpgMfdbb70VoX0FkT9BYNUwXz6tUoiiGRlCQzWlkDNcZAntJA4fPmye+YJVq1ZpWwkENFjPhWqqMWncuHFasRV9FCNL9WYz9wAQJM3OP/jgAy2kBcazOwKvEFcakv7xxx/SoEEDrV6Dssoh+AfW0vxhMmvWLL3jMXv27GifHMUgW+mDCLhYSIN8WOHChbVKINY7IADLnj279gq01qRJE6+cH5EzEGCxWAZFBqnUiRIlMgdduNnduHFjSZUqlc40od0FxkBUSfVkQ3jDxx9/rEHXmjVrpEiRIpEey2bu/i8Ymp1/YBFwGdwVeLm0pqtfv3662LJjx47h3ywkRBdiYjoav1ho/ElE5CmWd3vtDYaulIwnIvJFaKDev39/82vM9CNg2r17twZPaHeBIhjOBF2WDeGNvoFGQ/hu3brZ/bzx48frDBtm2tDTMCpIBWc6uP/TgMqPgypnAy53Bl4uBV379u3TRsn2oPHn9OnTXT4p8jLMeGENF1MKycetW7cu0p41RESBBOXVMatlWL58udSqVUsDLsDHK1ascPp9nW0IjxLxuAhFf0JkGKC3l9HU3WjsThQoAZe7Ai+XksUxhY2eDkgntIZt2IdjXG3Oh19g5AWjV8SOHTvsHot+EE2bNtXjceGFQcLa8OHDdZ/lI3/+/C6dW7C4GxZPtlzNqs9EvgzNkVFGPqoHEVEgyJAhg67pgosXL2rVwZdeesm8/+7du+EatzsKM2RIFcRFJZrBY+2YdUN4fD0Dbqyj6mGzZs30nIwH3oMoEAMuA47D8TE204Wc4jfffFPKli2rz7lz59btx44d02lt/LJ+9tlnTr8vgjXcbbFszle7dm27zflQohRFPJo3by69e/e2+75Y74F8Y4OxBo1su3fjumxdOE9ylXxRkqRg+VfyXfj9xziBNaa2LF26VHr06KFFf4iI/F3Dhg1l6tSp8vDhQ13CgXQ9rOmyTD80ips5C6mE9tIJrdf2o18YUaAYNmyY08e7MtvlUvSBXGHkEA8ZMkQ/NtJ70Kw0TZo0GjRhbZenm/OVLl1aH2Brv2WQFdViUCLyP/jDjzu79mDfP//8E6PnRETkKaNGjZIrV67It99+K8mTJ9eiZcZsFApTLFy4UN555x1vnyaRXxkxYoTDM13G8a5wecoHRTSQ/7tr1y7zRU22bNk0H9iVmSR3NOezBzNwSHdEymK5cuU0Jzlr1qx2jw/GXhJ3b1zXGS64dOpEuGdInCIlZ73IJ0W2pmvnzp16YUJEFAiwXur777+3u+/cuXNa3ZCIHGfMWjkSeI0cOdLlNV3RyrNDcIUUQzx8oTmfLUhTxJ2gfPnyaT4yotNKlSrJgQMHJDQ01ObnBGMviX1rVmhKoaXVM6aaPy7XrLWUb97WC2dGFN7kyZP1YQRcvXr10ll3WwvO0TcQfWuIiAIdblSjdyoReSbwik7ABQG/uKlu3f83/BXRHhIIwjAjt2DBgggl74O5l0SRmnV1DZcxw4WAq1aX7pIuRy7zTBeRL8D6TqzTNNILUVELD0sIxhInTqxlkN9++20vnSkRUfTgIg/jGW4sIajC66jgeHc0cvW6O/+K7JolUqoDqymT1wOv6AZcPhV0Rac5nzOQapQ3b145fvy43WOCsZdEEhvpgwi40uV8XiSFyJd6cxn9uapVqybvvfee1KhRw9unRUTkdkYF5oEDB2o/LbwOqqBr4ziRfHUZdJFXAy93BFwul4z3BMvmfAajOR/WYbkLFtafOHFCS5sSkX9bv349Ay4iCli4DsLSC1wjGa+jerAZPFH0IMAyZpndFXD5VNAFSOmbOXOmzJkzR/tQvPXWWxGa81kW2kDxDZSnxwMfnz9/Xj+2nMXq16+fbNy4UdOQtmzZoqVVMaNm3CmniJBKiDVcTCkkX4ff93nzwq9FXLVqlVSuXFlTiY21X0RE5CezWxf2PH9c3Pt8G56NbdhPFAMQaOEmhjtnjX0mvdBozodSqJjSQ3dzNOizbs5n2fTvwoULUrx4cfNrNOXDA81QjZ4SqOSDAOvatWtazr5ixYqybds2/ZhsQ5ohi2aQP0DPQFTqMm6inDp1Sm+spEqVSiuW4kZOwoQJtbUFERH5OKzhQkqhpV97/PdxlUEi1f67+e7rTLduiNy/Z/+ARIklVrIUMXlK5EWxTGiuFc10vRs3bmiPLmuRlWX3JyikgYpAqIaWNGlSb58OEf0fbsj0799fZ7QBVUdx4wXBF9aJ4kYOWkb89ddfEgw4VhEFlhw5ckTaFsMWHI9lFH45XmEmy5jNwgwXAq5XpohkKPp8G9Z2+cn6LgRcYdPGiYSF2T8oJERCug1i4BUkXJrpQid0XNx89dVXOoNkD/OKiciT8Mcas1qG5cuXS61atTTgAny8YsUKL54hUdR4N5zsQeaOddCF/qgHDx6UggULajscOHLkiBw6dEheeOEFXR/vt2wFVQi4MhYTv4Pf6cgCLsB+HMff76DgUtCFEsxYd9WoUSPteZUiRXD/sKCxMPpcoew6GwgTxRwUxMH6T0AfPjRYN9aAGjPxlinJRL6Gd8MpMugzaunnn3/Wx+rVqyMUEcK2Fi1ayAcffBDDZ0lEjnDpamTRokXSqVMn+emnn7Qxabt27Ww+gsW9G9e1sTCeiSjmNGzYUKZOnSo9evTQm0Bo9YA1XYa9e/dKzpw5XXrvTz/9VLJnzy4JEiTQohw7duyI9Pgff/xR8ufPr8cXLlxYZ90sIQUb61URKGKdWc2aNTX10VKDBg00LRvvgeNee+01XbtKAcyZu+EU9DCGdO/e3WbVVszsd+vWTdtoBATMeGENl5+kExJ5JOjCVHeJEiVc+VQir81Gbvnxe32mwDFq1Chp0qSJfPvtt3L58mW9K2wU3sF6gYULF8pLL73k9Pv+8MMPWoRj2LBhuh6saNGiUrt2bf0atqAyKop5oOH67t27NQDE48CBA+Zjxo8fL1OmTJHPP/9ctm/frs2b8Z5I1zag7xgatyNVCDe1sC6jWbNmLv3bEFHgwY0ay5Rqa9jnD+u5HIJgC0UzGHRRMBfSaN++vZZyx53dYGBrsScu3o2ZrUunTsjqGVOlVpfu2lAYUG6dqYa+49LJ4/Ld4F7y6thJbPgcJFDq9c6dO1rdMG7cuE59Lma2SpcuLdOmTTO/V5YsWfQO86BBgyIcj4IdGBOXLl1q3la2bFmtwIogC8Msqin27dvXXPQD4wkCRASKrVq1snkev/zyiwZvjx49cuh7YCEN/2O6eE7CZkyM8riQLr0lVobMMXJO5LuwZiskJET++OMPSZIkSbh9GO8qVKig45XlDR9fFejjVTD8biOVFTcnUechIBpy+8KaruvXw88O4B8WecMow9y1a1dNh0HvK2spUwZu0IE1XEgptITAy4A+Vyy7TuQ9WMuFP+jOQs8/rA2z7AmI90I64NatW21+DrZjZswSZrGw9gJQTRFtMPAeBpwbgjt8rq2gC+Pu999/L+XLl7cbcCEYw8PyIoaIAnt2H7PfSGXGDfDcuXObZ8Cw1v7SpUtBc0OcvB9wId0VjGcGXm4IulAJzLp6Du7cIo0GFQyDsXohimbkKvlipDNd5F3Ws5GWz8DZSP9jdIgfMmSIBkJ4HRUc78wfgqtXr+rYZaQpGvD677//tvk5CKhsHY/txn5jm71jDAMHDtQZtvv37+tsmeXsmbWxY8fqHUYiCg6Y+cZ6UYwTY8aMCbcPM+u4JsMNH6KYCrgMDLzcFHThH9LZPhGBLomNC3YEXExd8x2cjQw8w4cP17EIFxzx4sXT1+4OurwNfcewNuyff/7RgOr111/XwMvWGIzZOMsZNsx0IQ2SiAIX1qnigRs2GCcgW7Zskj491z75lESJtfJoVJVJ9Tg/D7gCJfCauPqoxIkdS3rUyBNh35S1x+TpM5P0rpXXs0GXIxc2RL6Gs5GBB2sVInvtDpjZR7o00nQs4bW9ixpsj+x44xnbUJXQ8hjcnbb++njkzZtXChQooEHUtm3bpFy5chG+Lqo14kFEwQfjCgMt34UWD2j1EEg9+CILuAIh8IoTO5ZMWH1UP7YMvBBwYXufaARcLlcvfOONN7T6lj0orYxjggUu3jFrwot434KZSMw86uP/gZYxG4kHUwvJFsygobno2rVrwwV3eG0r8AFstzze6JljHJ8jRw69OLI8BrNSGEftvafxdcFy3RYF6N3wyPjh3XAieh54oUiG3UeABVwGHOeP/eJ61MijgRUCLARa1gGXrRkwp5hcECtWLNP3339vd//8+fNNsWPHNgWKW7duocKjPpN/+vfEMdPHLerrc6AZOXKk/k7imdwDY1j8+PFNs2fPNh06dMjUpUsXU/LkyU3//vuv7n/ttddMgwYNMh+/efNmU0hIiOnjjz82HT582DRs2DBT3LhxTfv37zcfM27cOH2PJUuWmPbt22dq2LChKUeOHKYHDx7o/m3btpmmTp1q2r17t+n06dOmtWvXmsqXL2/KlSuX6eHDhy6PVRN+O2KavOaozeOxHfvJu57dvG56duGs/cfN694+RSK347WVf8F1Bv5/OfrA8f5q8pqjpmwDl5ryvLtcn+39DXWWQ+mFzkIzTzT/JPIVgTobiTtJH40ZLbUK5tZnf53SdxRmjJxdX4rjne1bgxLwV65c0bt1WDeBFMCVK1eaC2GcOXNGC3kYUGFw7ty52pT03XfflTx58mjlQpR3NgwYMEDLyqPq682bN6VixYr6nmiEDChtj8bzKL+L45CGWKdOHX3P6KQQejpdgqJP73b70R1vIgo+WGPs6EyXcby/6lEjj0xbd1weP30m8eLEjv4Ml7N9upYsWaIPQF+ZypUrS86cOSMch4uJNWvWaHrO+vXrJRAEei8J8k/GVH+m5Eml90uVZOJvm+T8zdta0S9QAy+USLYOunbt2iUHDx6UggULSr58+XQbmgsfOnRIgx6MRbNmzZJgYG+ssk6PcGu6hBc9ffZMNp05Ixfv3JEMoaFSCe1LLIJh8j3s60PBem0VCD/7jqYY+vt1yJT//41EwIXAy11/Kx2e6cIFjNH7ARc9WIuAXjaWsD1x4sQakE2YMCHaJ0dEwVc9KDK44WMJs0l4YP1UjRo1wu3DNvQT9Me8cncz/ljgj4hx987fA65Fhw9Lz5Ur5ZxFb7LMSZPK5Dp1pEmBAl49N7KNfX0oWAXKz75xzpEFXoEScPWxukkJ0f2b6fBMlyWk1Xz33XfSpk0bCQbBdjeG/COlMGmC5ylnmVIkkxali8iCnfvk/I1buu32w0fS/90hfj3wOaJIkSLat8Zevy58/wjK9u/fL8EgqrEq75AV5nSJo6Prij8HXM0WLNCFA5aMOdCFLVow8PKTG0X+foEW05DaHBnc/EbKsq3+qr4mWK6tAvFnPxC/J7CXBeKu7BCX1nR5okwzETk+0L1UKI+8VCj8WhwEXobfDh7167tpjjp27JikSpXK7n7sc3Y9V6DCHw0j4MIzXvvjTBdSCjHDZetuIbbhMrPXypXSMF8+phr6iGCdmfeE7NmzOxRMIfCqVKmS/rtWqFAhRs6Ngudn39aMl78HXIA+XLYCK+M19sf4TFewCZa7MeT7MMuMX9nQBPGjnOm68/CR/nEO5JskWLMVEhIif/zxhyRJkiTcvjt37ujFBr7/AwcOSDAIhjVdG06flmpz5kR53Pp27aRq9uwxck5kX7CsAYkpWJ86ZcoUOXv2rLRt21Zy585tvgGFYj5oktyhQwc5fvy4ZiRhHETBnmrVqomvCfRrq2D42Q+EdWoxyeXqhStWrNB1W3/99Zf+wtiK3Z4+fRrd8yMiG9WDEFDhYQkBFwppWB8fyEaNGiXNmjWT/Pnza5ENywuQOXPmaPNhYy1qsLIVYFmu8bJ87Q9QNMOdx5Hv9PUBXrhFXR368ePHGlQlT5483L7hw4drVdQHDx7IpEmT9N8ShYTwd8AXg65AFiw/+zhnfzxvb3Ep9+Knn36Sl19+WS9oWrVqpXeSW7durR+jVDzWWThTVpKIHIPBzd76pUC6e+YorOdavny5pEmTRsaMGaNN2fEYO3aspE2bVpYuXarHBLPI0iWwPbrpEjENVQrdeRx5Du6Ae/L4YPT5559Lp06dIgRckDJlSt03bdo0c3o1xkPromfkefzZJ7fNdOGCpkyZMprSc+PGDZk+fbr+YlevXl1Onz4tZcuW1X46ROT5XGqkEmINF56DKeAyvPTSS/pAP61//vlHtyHFJn369N4+NZ/QO5I+XP40w2VAWXhUKTx/+7bNdV1Y7YL9OI68K5j6+sSUa9euyf379+3uR48/9Bg0YBzkKpKYx599cttMF8rHY1YrTpw4up4Cnjx5Yl7k+fbbb8uHH37oylsTkZMzXkgz/O3gMXO6YTAFXJZwcfHiiy/qgwFX4EJxjEmVK+rH1uUEjNcTK1dkEQ0fwJl59ytdurRMnjzZZkXWffv2ydSpU/WmuOHw4cOSOXPmGD5L4s8+uW2mK1GiRBIvXjz9GFPc8ePHl4sXL5r3p0uXTk6dOuXKWxNRkFcPIoqM6dYNabByocwXkT6SQM5b3DvMJM/kE3mo+025c0usZCm8eq4UHH19YhKCKqzPKl68uJQrV868jhVrvLZu3aoFKVBoAx4+fCgbNmzQda/+9Pst9+/ZPyBRYr/5vebPPrkl6MqXL5/OdhmKFSsm3377rbz66qsSFhamFXSyMrWDyOOMwZrVgyho4IIsLEwai0gDuSt/SBy5KLEkg5ikojyVODgm7P/H+cnFWaBXA4vs4pMXnc7BmnnMco0bN05WrVolO3fuNKdUI8towIAB5pktlI3fvXu3+FPAFTZtnP5+2xUSIiHdBgVE4MWf/eDjUv5F48aNZcmSJfLo0fN0piFDhujdFMx6YUH7pk2bZNCgQS6d0KeffqopihgskCa0Y8cOu8cePHhQmjZtau5bgWo90X1PIn+DQRvFbDh4U7BBgFVFnkorCdNnDbgCoOIZ1uDgGa8DOd2KF52uyZgxo85mHTlyRGez8MDH2ObXqYT/v6ESKeyPbCbMB/Fnn6IVdPXr10+7oiOtEFDJEEEXquZ07dpV1q5dq+WbnfXDDz9Inz599C4fStEXLVpUateuLZcvX7Z5PBaT5syZU+/42FvD4ex7EhER+UKJ6UANvHCTlBedFEz4s08+1xwZs1BYJGqUO8Xd+yxZskj37t2jnDnDTFavXr304a73DJYGfuR/AinvndwnGMYq08VzEjZjYpTHhXTpLbEyZA6Inj68SCNLKI6BJsknT57UCtLWl3G4sMfNb38brwLxd5vILc2R4fr167JmzRotEw8oE4+y8egN4Sw0+0MvicGDB5u3xY4dW2rWrKmLQ13h6nsibdJInTQGBiJfEYh579GBJuxogLx+/XqdwcYFauHChfUPOS48KlSooMV9iPy1iao/N08l98L6+Q4dOkjcuHF1fX2KFBHHeB+6l04BaOLqoxIndiybLUemrD2mvR8ja1USzFwOutD5HGXhEdhY/oKjqiEWcjpaKtNw9epVvXiyvjjC67///tulc3T1PdGHjD0TKCDy3gM86Lp586bUqVNH12kmSZJEe9RgFhvwukePHvL6669r42Qifwy4DAy8yLj2QuXCFStWSOrUqb19OhSEEHBNWH1UP7YMvBBwYXsfBlzuXdOFPxQIqjBjtHz5cjlx4oQ+8DG2jR492q/z0DEzhrvkxuPs2bORf8Kdf0XWj33+TEQxBinCKKiDKl5ItbG8AYQ+giiVjHGJyBdhrbEnj6fAc+HCBXnjjTcYcJHXINBCYIUAC4GWdcBlawaMojHT9fnnn8srr7yiFQwtIb0Qd52xb/r06U7dkcMAgoukS5cuhduO1642OnX1PVEgxCgS4hAEWxvHieSrKxLKpqy+guueAt/PP/+sM1u1atWSa9euRdifN29emT17tlfOjTwkUWJNn40qvVaP83HIqHB0pss4noIbSsYj8CLyJiOwQqA1bd1xefz0GQMuTwVdmP1BcGVPvXr1tJqhM5CWWLJkSV2D0ahRI3PRC7zu1q2bK6fpkfck/8B1T8EBYxFu9tjz5MkT7R1IgQO/r/i9DYQbKo40TzWwmAbBhAkTpHnz5lK3bl0pX768BPINldEbt8nI9Vvk/WrlZUiVsn51QyUYIMAyAq54cWIz4PJU0IWF6du3b5e33nrL5n7swzHOQmn3du3aSalSpaRMmTLadwtrNLBoFLA2I1OmTLrmCrCezGjSjI/Pnz8ve/bs0bUcRpf2qN7TZZjdMtIJL+4N/wyY8eKsl8+se7I5eAfJuqdAlitXLm0FYc9vv/0mBQsWjNFzIs/TgCpAfm8dCbwYcJEBa+lR8a9SpUo6tmXNmlUzeqyrF1pnIvnbDZUPJk6SEeu36HY8xy5VTob27uU3N1SCAVIKjYALz3jNwMsDa7qQXojqf71795bjx4/r7BEe+Bgl27dt26bHOKtly5by8ccf6x+fYsWKaQC1cuVKcyEM9Aa7ePGi+XhMsWNBKR7Yjs/Fx+gX5uh7umzXLJEZVZ4/fu3xfBuejW3YTz4BARcGbaz2wTNeU2DA7/rXX3+t/fiM9Vy44ED1UTRtx+86ege6wtmm6qigmD9/fj0e1ROt15IZDW8zZMggCRMm1PWvx449z4cHVIHt2LGjztxhPwJKrOHBDSUKbLaapxoYcJGlffv2aTNkBFt3797VG8/79++P8PD0mIe1tE2bNtXjMebihrY7IKAa9eUsGfbRJ+G24zW2M+DyDZZruI6OrhthjRfZYXJBkiRJTIkSJTLFjh1bHyEhIfowXidMmNAUGhoa7pE0aVKTv7p16xau5vTZ7PZFk+n87uePXbNNpmFJnz8b27CfvObZhbOmx8P7mIZVK6//76wf2I79OM5fv7eoHv74vTnr2bNnpk6dOplixYplSpEihT6nT5/eFDduXP34zTffdOl958+fb4oXL57p66+/Nh08eNDUuXNnU/LkyU2XLl2yefzmzZtNceLEMY0fP9506NAh03vvvafnsH//fvMx48aNMyVLlsz0888/m/bu3Wtq0KCBKUeOHKYHDx7o/hUrVpjat29vWrVqlenEiROmJUuWmNKmTWvq27dv9MYq8hsjR44MN07hNVFMcHbM27Fjh6lfv36mefPm6Zg7ceJEp7+mrfHK+nfA+sHfCe+bvOaoKdvApfrsyHb6j0vNkdu3b693NpyFZn4B2XD0wp7ns1tdNopkLOaNUyQraLI4om1Lc3qCLcOqlZdh3//gd00WuV4toj/++ENnmoyZd8wStWjRQipXruzS+znbVB0z6khbXrp0qXlb2bJldXYds/4YZjNmzCh9+/aVfv366X6MJ5hxR6GPVq1a2TyPjz76SIsSoTKjI4KhOXKgQ+VfzHCiaAZnuCimODvmWcJsF7Kc8HCG9XjlaAsFzv56F/t0xfCaLlYDI19nmQ9uj+aJT5wk74//WPxJIBUScJeKFSvqwx1caaqO7Vg/aql27dpaXRFOnTol//77r76HARcbuNDB59oLunAxkjJlSrvnykbugQcXk7ygJAOWVQDSCS1fR8U43lNjnisiG6/Ys85/RBZQcU2XB9Z0WcNdXAwEQbv2AAUzqgxi4QxfulNslQ9uD47zx55yCKgwQ2f3EUQBF6CIzrx582Ty5Mly7tw53YbG6NevX9dndzVVR+BkC7ZHdrzx7Mx7YtZu6tSpka5JQ1EhBG/GA3emgw1+f3GB6I+/x0RRwSwS1nka11fG66genh7zXBHZeMWedRQMXJrpsnb58mX9JV+9erVUr15dgg6CrWr/3SEi73Jl8OYdM/+EGz5I2UNKDErDI+0ZRSwyZ86si8xxgYJUFGfTXnwhiERbDpSG7ty5s93jcGfacoYNd46DKfCyvDvOu9/+4e6N67JvzQopUrOuJElhfxaXnkOhIIxrcePGDffaH0U2XrFnHQUDtwRd4MLSMCKP4OAdPLDmCbNbAwcOlBo1amiTZAPupDZp0kR++uknp4IuV5qqY3tkxxvP2IbqhZbHYN2XJVRlrVatmvbgmTFjRqTn6nQj9wBiKx2JgZfvu3fjumxdOE9ylXyRQZeDa+gje+0Orox5rohsvGLPOgoGbkkvBH+980LBVX7ZGgdv/zZz5kzt3zdmzJgIwQsUKVJEjh496nJTdYPRVL1cuXI2PwfbLY8HzPwbxyMTABcvlsfgLi96Glq+J2a4qlatql8fhYeQNkcRRbb+A9uZakiB6P79+5IqVSq92eROrox53vrbzb/Z5M/c9hedM12BIxDWSHDwDg5nz57VGSF7EidO7FJxCaTAIKCbM2eOHD58WBvBWzdqt1x03rNnT+0J9sknn8jff/8tw4cPl127dkm3bt3MN6Uw2zZq1Cj55ZdftI8O3gMVDRs1ahQu4MICePQWvHLliq6ncOeaikDgyIJ7Bl6+l1J46eTx549TJ3Qbno1t2E9RS5QokYSEhOi45m7OjnlYY4a+p3jgY4xf+BhrUaODPesooJnc4PHjx6YNGzaYbt68aQpEwdT7JtD6xNjr+eHv3xc9lyVLFtPQoUP146tXr2pvrrVr15r3o9dM3rx5XXrvqVOnmrJmzaq9a8qUKWPatm2beV+VKlVM7dq1C3f8ggUL9Gvh+EKFCpmWLVsWoacYzjVdunSm+PHjm2rUqGE6cuSIef+sWbPs9qZxVKCPVVH18OHvuW/avOA708ct6tt9YD855q233jJVq1ZNxxN3c2bMO3XqlM3fORznjvEq0K5FiMCloKtDhw7hfhmtbd++XY8JFIF+IQPPbl43jejf1+Ygiu3Y7684eAeunj17mtKkSaPNhI2ga926dboPTYbRoHjIkCGmYBHoYxX+/zoTdOF48r4716+Z/j1xTB97f5qpgRaejW3YT47ZuHGj3tRBcPPdd9+Z/vjjD9Off/4Z4REI4xX+VuN3mH+zKaiDLvwSfP/995F2No8dO7YpUAT6hQwCqmE1KkZ68YL9/h54cfAOPJhdL1KkiCk0NNRUr149HXdq165tqlChgn5csmRJ071790zBItDHKs50+b9/ty3ToAvP5Dz8HTMeGOOsH8Z2fxDo4xWRNbdVL7SuvpUwYUJPvDV5wAejR8uItX9Eegz2xx492u8aCRvYcDQwoULhtm3bdC3VwoULJUGCBLJx40bJlSuXtgLo378/x6IAwgpnfurOv88fcPXof88XMv7XdoV9Lh2CAjtE5J8098KRA5csWaIPmD17tlSuXFly5swZ4bibN2/KmjVrtBLO+vXrJRBgIT4u7m7duiVJkyaVQOJMF3jghQz5iocPH2pJdVQtxHhEgT1WOTNucZzyMevHimwcpx/efRJX9t3MIEWSX5QkcZ88319lEHtdBqFgGa+InA660EkcZZmNsqUoMYoqOpZQoQtVdRBwTZgwQfLmzSuBIJAHBlQpdKbyJP4fo5QskS/ALNaUKVMibSAcTKIaqxCsYAYQven8PSixF3gx4PLxma6Le0V+7SHyyhSRDEWfb+NMl0suXrwoly9flty5c3ukoqGnBfK1Ffm3p8+eyaYzZ+TinTuSITRUKmXNKnHc0MLF4XdAqdA7d+7oAxfpX331lfm18cAvEAaBpUuXBkzAFeicbQzMRsLkS1544QU5ffq0t0/Dr4IUjN+BUFLdVmlpBlw+CgFVxmLPH0aghWdjGwMupyDrKH/+/JI5c2YpUaKE9vuDq1evSvHixWXx4sXePkX6v4mrj8qUtcds7sN27CffsujwYck+ebJUmzNH2ixapM94je3R5VLYhpmONm3aRPuLk/fhAmVE/74OHYvjeEFDvmT06NHyxRdfaEozOTcrFEiBF2bgGXBRMPj111+lSZMmkjp1ap21tsxUwbZMmTLpEhDyDXFix5IJNgIvvMZ27Pfn2aANp0/LvP379Rmv/d2iw4el2YIFcs6qv+f527d1e3QDL4fTCy1hVgtrt7JkyRKueMbnn38ujx49kqZNm0qZMmUkUAT6FLjp4jkZ0baljFi/xe4xw6qVl2Hf/yCxMmSO0XMjikyDBg20GfGJEyckR44c+rAunIELcmM9aqCzNVZx/RP5FKQZ7polUqoDZ7hcULp0aUmSJImumb927ZqkSZNGbzpVr1493I2oM2fOiK8L9Gsr6wCrT6280qNGngiv/RGCj54rV4YLTjInTSqT69SRJgUKiD96+uyZzmhZB1yGWP//Hk/17OlyqqFL1Qu7dOkip06d0qphxi9O2bJl5dy5c7pGaPLkybJy5UqpWrWqSydFMW9IlbL6bCvwQsBl7CfyJfv27dOgKmvWrPL06VM5fvx4hGOwP1g5UijH2M/Ai2IEAi0WzXDZgQMHdM28PenSpdN1XuQ7jMAKgda0dcfl8dNnfh9wYdbHesbGmA1a2KKFXwZem86csRtwAb7fs7dv63FVs2ePuaDrjz/+kK5du5pff/fddzrTtWXLFilUqJDUqFFDRo0axaDLXyRKLBISYjPwMgdcKJqC44h8CNdzuacyKQMvIv+QKFEiuXfvnt39J0+elFSpUsXoOVHUEGAZAVe8OLH9NuDCbBBmuGylyGEbbnH2WrlSGubL55bCEzEJRTPceZwtLv2LYLEm8oYNv/zyi1SsWFFnu0JDQ+X111+XvXv3SjBd3GCGz1/XR8RKlkJCug2SkC69NYUQa7cwO4BnvMZ27MdxROQfsN7Dk8cTUcyrVq2azJkzR8LCwiLs+/fff2XmzJny0ksveeXcyL5Ja45qwBUntugzXvsjZ2aD/E2G0FC3Hue2ma7kyZPrLzc8ePBANm3aJEOGDPnvTUNCtKx8sN1N9ue7xRpQ/T+oQgNkf22CTMElqnULuHmAhslYYB5saYaoNOpMDz5WJiXyfVizhRvcWNvVvHlzHddWrVol69at07VcWKbPGyi+5c35W2TlnhtyM+S83Ip7UZI9ySCT1oj8ffWqfN6qvPiTmJgN8haUhceaLaRJmiJZ04XjYjToKl++vHz22WdashRrt9CktGHDhub9R48eDTcTFmwVwfw18CLyN9mzZ3comELgValSJf29rFChggQDYwxyJPBiMQ0i/5AvXz5d4tGzZ0/9nUWQ9dFHH+k+LOn49NNPdVwk3wy4wHheuUfkTdniV4FXTMwGeQvSIVEIBOvScFVhGXgZVxmT6tSJVtqkS9ULsVgd09fGeoq+ffuaf+mxmB2/8HXq1NFp7kBgq8LOyCHvyrAxY+1+zoh3B8v7o583kyYiz5g1a5Y2Rz579qy0bdtWm4TCsWPHZO7cuZItWzbp0KGDjllYe4rKq7hRhBSdQGQ9VoXduCYpmzaTO+s32P2cpNWqyrWfFkpICq4DIfInN27c0LENbXxy5syplQz9SaBXL8T6pxyjv5Pbjx6aAy1LmPFKFj+BnBzyqt+sfzIq/EU1GxSdCn++WJkxS9KkGnBFt0CISzNduLA5cuSIHDp0SH9hLO+qIK1w2rRpUrTo/xsgBqCoAi4w9jPwIvIcFPB5/PixXngg7dnS8OHDda0pUqAnTZqkd4VLliypaXSBGnRZ23TypNypgoJGsUTWr494QLVqcrtKFT2uWkkGXUS+DrPS6NOFxvApUqTQNENLBw8elJ9++smp1GLyDKxrOvvslEhc2/sRiN16JtGqhheIs0HehsAKhUDw/wVpkpi1Q0qhO74nl98hbty4GlhZT2OjkAZSDaMzvW1MjyMl6MUXX5QdO3ZEevyPP/6oqY44vnDhwrJ8+fJw+9u3b68pSJYPzMS5mlIYVcBlwHH+WlyDyB+gN2CnTp0iBFyQMmVK3YebQICKXm+88Yb8+eefEiwuGmtrq1TRACscvMZ2y+OIyKfhZhJaZURWUp7rM31DoK5/QlCCsvCZrGYnMcPlr+XirSHAQiDcunBhfXZXEBk7OtPC48aNk9q1a0vx4sXNgdH169e1h4StfjmO+OGHH6RPnz66EPSvv/7SwA5fw17fCZSpb926tXTs2FF2794tjRo10gcGHksIsi5evGh+zJs3z6XzMxaoJqvQRpKVb2XzGGzHfsvjicj90Bw0sqI9KK185coV8+v06dPrGohgkSFRov9eWAZeFgFXhOOIyG/hGixevHjePg0K8PVPCKxO9+wp69u1k7lNmugzUgoDIeDyJJfSC9EEuUqVKrqOIk+ePPL333/L3bt3zXeXUUHnn3/+0SbJzkLA1rlzZ12HYdzJXrZsmXz99dcyaNCgCMfjayCg6t+/v77GzNLq1av17jY+1xA/fny94HJbRTDTM0le6VXddmvL/HABF7bf3PSd+Xgi8gyk1mAMaNCggc5yW8Ld4KlTp0qZMmXM2w4fPiyZM2eWYFEpfTrJJM/kgsQSE5I/EGhZBFvYmklMehz5hrtn/5Z98yZLkdY9JUmW/N4+HfIBv//+u2zY8N+6zEWLFtm8sX3z5k29cW09FlLgVsPzhdkg8nDQhQAHC9L37NkjadOm1YclzDQtXbrU6ffF2gyk/gwe/F+3evS/qlmzpmzdutXm52A7ZsYsYWbs559/DrcNAxbOEznQ1atX1+bN9hoIPnr0SB+Ws3oGrRZ055YM++gTfW0ZeFkGXHiNPlesCEbkOQiqsD4Ls+3lypUzF9LABQnGBizORqENQJVVjAPNmjWTYIE/ihPkobSShBpgaeD1f3gNn8hDv86/DzT3LpyUrX+elVxVTjLoIrV+/XrzDVwsj0DQhYctBQsW1HHR36FggyfW1MSkYFj/RDEQdP3222/Su3dv/eVGeo81VNHBLJgrTZdR/TBduvB3XfEas2m2oF+YreONPmKAmTAsPM2RI4ecOHFC3n33Xalbt65elMWJEyfCe44dOzbSGaqhvXvJs11bZcT65zNcCLSSlWspsULimgOuYdXK63FE5DlFihSR/fv3a6ozetXs3LlTt6Nq4dtvvy0DBgwwz2xhzSdSkINNYwmT+fJA+kgCOW8RdGGGCwEX9hOR78I41q1bN02Nxs1jZPE0bdo03DEIxhIlSqTjnL+zVT0OM0IIYPwtfc1Y/2Tr+3FHNTwKgqAL1cAiK02KWTBf0qrVf2uvMO2OC7VcuXLpXe8aNWpEOB4zbZazZ5jpypIlS7hjhlQpq88IvIyAyxT2xBxwGfuJyLMyZsxons1yJxT0QSsM3MDB2lLrVEVbBX0ws41WGki7/vDDD6VevXrm/UbTUrTSQBoQ+oVNnz5dj7VsfIp0amQRYF0GjnMHBFYN5K78IXHkosSSDGKSivJUIt5yIm+lFGKGCy4d3B7uGRJnzMlZryCWMGFCfcCpU6f0+gsBViBCwIWZIet0PKToYbs/FmrwZDU8CoKgCzNcyDHu2rWrzf1I7UO6j7NSp06tM0+XLl0Ktx2v7a3HwnZnjjdm4vC1kIJkK+jC+i88ooLAam/GCrL7/wEXAq9GbfvLkDxPo/xcInIvFMhBwR2kGCZOnDha72UU9MEdZVRQRcl5pC2jVYZ1OrVlQR/Mkr/88svaIwxp1igGhNLOMH78eA0O58yZo7PuCNDwnmi9YdydRop18+bNNVXyq6++kmhLlFgkJEQkLEwDrCpiY2zCfhxHXoM1XEgptLR61Z8ieIhIuZJZpPyA6V46O/IlmMW3hmJC8+fP12URuNFj6xh/SSnEjJCt9U/Yhnn6XitXagDjbwEL1z+Ry0FXr169pF27djpjhAsEQHM+BDFIy0PaHvpEOAt3dtFHZ+3atXrBYrwvXmNq3RZcnGA/zsmAQhrYHlkhEKRFZsiQQaJzITPtQWbZnTmnFD+3UZZ8/5E0bNtfdmeuItOenJRuCc/xQoYoBixZskQGDhyoDZGN33+s20S6cq1atXR2yRhPvFXQB7NcCNzee+89bakB33zzjaZC4yaVMRtvpDXPnj1b3CFWshQS0m2QyP179g9KlFiPI+9B0Qys4TJmuBBw1apdUtIVetE800UEqNS8fft2c4Vm3KgpW7as+TV6p65bt86lG9/ehpkgyxQ8W4HX2du3/aqvFZEll24VvPrqq9qgDxcQefPm1W244MiXL5/ebRkzZozTFzkG3F1G+g3uBqPS2FtvvaVln42Ln9dffz1coY2ePXvKypUr5ZNPPtF1X+hhsWvXLnOQhqqKuBDatm2bpv0gQMNFD+6G4y6zK3CB8lmxtjI5LKf0LpteFn3UQ55eOKvPeI3t2M8LGSLP+vXXX3W9JmauEVxZloPHtkyZMsmsWbNcKuiDAj7OFPSxPB4wvhjHIyUIaYqWx+DiCLNo9t7TEbizjfRny4c1jEOxMmS2//D3cerOvyLrxz5/9lNIHUz3Yr3nj/8HWng2tjG1kCyLamDMM2BWHQHX999/r8/I8vHXqsmB2teKKFozXTBkyBB57bXXdEYLM1yYkcI6KQwGSN9zVcuWLbWvDsqy4yKlWLFiGlQZxTLOnDmjF0CG8uXL66CDABAFMrA+AneOjZQepCuidDSCOKyPwPqPl156Se9EO5JCaM+zeAmkT6280qPGf+sxoGejzBIr9Jg8fRY8vYCIvAU3fypXrqwXIpi9xk0XS5jxRgsLbxf0MZ6jKvrjrKiK/gQFBFsbx4nkqysSGv22IES+DONFdotZHlzvlCpVStObATP0WIvqjwK5rxWRy0EXAh8s5MyaNatWMbRVaAOBE/a7ArNU9tIJLXtVGJDiaKQ5WsPiU1Q1c7fetZ7P8NliHYgRkWfgzi5SAe1BUGOvsXogcKToD/kXpBJiDRdTCskWrFc1CuyEhYXpNVH37t3N+0NDQ+XWrVvijwK9rxWRS+mFWAS+ePFiu/t/+eUXPYaIyJNQwQvpx/acPHnSbj++mCzoYzw7W/QnKpitRy8yy0fQzG5d2PP8cXHv8214Nrb5eaohimYwpZBsKVGihC7BQPsLVDtFtehXXnnFvB9tcaxn1P2trxX819ziOfa1okDg0k+u5boJW548eRIuBZCIyBPQGBmpw7jjaysNBxcnSCd2taCPwSjoY69Aj1HQx5JlQR/chEJwZXkMZqWwID6yoj9kx65ZIjOq6OPuor6y5UpWfTa26X6iAIRAC7P3SClEajH6dVm2ssANcbSj8Ff/nIsjXfLVkkxWN5Aww4Xt2E8U8OmFuECw7BmD9RNIM7SGY1BMw+XKgERETlyAoHJX6dKlNcUYDUKRTozqXVjLZfTGchZS9lChFRc2uKBB5UHrgj4o0oE1VUZBnypVqmhBn/r16+sYiII+M2bM0P04L1RYHTVqlK47NUrGY42pZdEhjKnXr1/XZ6wrQ78uQOGfJEmSuOlfLQCU6vB8DZeI3Nu9QbZ+s0Zy1esoSYpXfb6fa7soQGFMwtpStKlInjy5jjuW119oCm+5zd/EiR1LVu65IX1r1pdiueOZ+1rtOf5YJq05JgVr2e8RS+TzTA4aPny4KXbs2A49YsWKZRo9erQpUNy6dQtTe/pMRL7lwIEDpho1apjHHuNRrVo106FDh1x+36lTp5qyZs1qihcvnqlMmTKmbdu2mfdVqVLF1K5du3DHL1iwwJQ3b149vlChQqZly5aF2//s2TPT0KFDTenSpTPFjx9fz/nIkSPhjsF7/r8ycrjH+vXrHTrnYByr/t22zPRxi/r6TET+w954NXnNUVO2gUv12dZrIn8VC/9xJDhDWWPcWcHhAwYM0Eo5yC22hLu5WOSJ1BzcjQkUmOVDeWcsTg2aNRPkN80k2eX+uRs3bpgrqaKCKor9BJtgGavu3rgu925c148v7dkgq3/4WWq1bCTpij2f6UqcIqUkSZHSy2dJ5H62MoxscbWQma+MV1PWHpMJq49KvDix5fHTZzarRRP5G4eDLktGHrFRlj3QBcuFDPmXRYcPS8+VK8M1k0TeOxYiNylQwKvnRt4RLGPVlh+/l60L59ndX65ZaynfvG2MnhNRTMB6edzgjgrSk/19vMo7ZIUGXAi8jo5+nk5MFJM39/atWSFFatZ12008p0vG379/X6ZMmaJVw4Il6CL/FoizQQi4mi1YEKGsLkrtYvvCFi0CPvBCY+DvvvtOfvvtN63YhSpeKJeM9U9o1t6mTRstikGBB38Ec5V83kT40qkTsnrGVKnVpbuky5HLPNNFFIi+/vrrCEEXAqzTp0/LN998I2nTppV33nlH/B1muoyAC894zZkuiknIpsDNPfyt8VrQhWArJCRE0wgp8ARagBKIs0H4f4TvydYUNbbhz3GvlSulYb58fv3/LjL79++Xhg0byj///KMpz7hbikITqOr1119/yY8//qhFNtC+ooCf/n8m+/AH0PqPIAKudDlze+2ciGJC+/bt7e4bOHCgvPjii37bp8s6tdBIKTReAwOvwJ8NCmQuXZEhtXDhwoVRlo4n/wtQsk+eLNXmzJE2ixbpM15juz/PBlkGXJazQf76fSEotv6eLOG38uzt23pcILp79640aNBAe1whsDp79qyu57J8RpXACxcuaP+ayPp4EREFCtwMR4XViRMnSqAEXIBnvMZ27PfnAAWp0XgOtNkgY42tv7t747pcOnn8+ePUCd2GZ2NbdP/fOT3TBa1atdKypOiR07lzZ8mePbskTJgwwnHWhTbIdwVaulogzwZhFtKdx/mbWbNm6WJy9LyqWvX/JcItoJT74MGD9Y5vrVq1ZPbs2QGRbkO2IZUQa7iYUkj0vKcgehT6q6fPTDaLZhivsd9feSJdjdwLs3bW64WRvu6u9cIuBV2WFzqbNm2KsB8zYMg59oeFnBSYAYozs0FVs2cXf4K0T3ce52+WLVumDY9tBVyWqlevrkHXr7/+yqArgOHihUUzKNihKMXvv/8uH330kRQvXlz8Ve9aee3uY2qhD1aPtZgNMvhz9dgiHl4vHOLqnWYKHIEYoATybBDW2WFdGmYhbQXKCJKxH8cF6nquHj16OHQsAq/Jkyd7/JyIiLxdvRA3vFEq/rPPPovx86LgCVA8PRsUyOuFXQq62rVr55YvTr4hEAOUQJ4NwmwjCoEg7RN/ei0DL+NP8aQ6dfxmVtJZ169fl/Tp0zt0bLp06fR4eo6Lnon82/vvvx8h6MLrFClSSK5cuTQLAMXOyDcEYoDC6rGuC3HHonYsXIcsWbJoBbFgEgjV/gIxQAn02SCsr8M6O1uVGRFw+dP6O1dKxceNG9ehY3Hx8fjxY4+fk7/gmgIi/zZ8+HBvnwIFeYASLNVjE3tgvbDLQdfOnTtlwIAB8scff+jCTWPau1KlSjJ+/HgpVaqUBLpAKUceiAFKMMwG4WcM6+z8Peh3BXrSoDR8VE6dOhUj5+M37l+zeA6sP5BEFFgCYWY+WAKUQJTEA+uFXQq6tm/frovY0Xi0U6dO5j44hw8flnnz5knlypVlw4YNUqZMGQlUgVTtL1ADlGCYDcL/E39ZZ+dOQ4cO1UdUjKI+wSzcmoKj+/97TpTKb9cUEAWLN954w+nPwZj31VdfOf15n376qRbiQPXDokWLytSpUyO9jkM/RIzDuAmWJ08e+fDDD6VevXriLpyZ932sHuucWCYXmm3VrFlTf8kwy2W9tgK9cypUqCA5cuSQ1atXS6BUBULzVTQcTJo0qaYUon+VveITxszQqZ49/SpQsTVzlyUAApRASAGl/8yZM8fpzwmWdajWYxWgL4z1mgJL/rimgChYoCWPszeOcPzJkyed+pwffvhBXn/9dfn888+13cakSZM0qDpy5IikTZs2wvFbtmzRG+xjx46Vl19+WebOnatBFzIQXnjhBZfHK0voi/Td4F7y6thJATEzFAgzd+SFoCs0NFQXc/bv39/mfqQXfvDBB3LHjwovODMwbDh9WhsHR2V9u3Z+NwvBAIXIf9m6iLl79m+5d+H5Bdilg9tl9ao/pVbtkpKu0PN1Bokz5pQkWfJ79byJyLsQaJUuXVqmTZumr7FsBOv0u3fvLoMGDYpwfMuWLbXx/NKlS83bypYtK8WKFdPAzeXxyqran601UAxYyF+5lF6ItVthYWF296M/F44JVIFY7S/Y09WIAlWS44slycZxz188SIy29ZLuyExJd2bS821VBolkGezVcyQi70GxoT///FObyhtwDYespq1bt9r8HGzv06dPuG21a9eWn3/+OVrnEojV/oiiFXSVL19ec3/btGkj2bJlC7fvzJkz2iMCKYaBKhCr/RFRgCrVQSRf3ecf794gcnqNSOUBIsX/31w61LHy+0TkHQ8fPpRevXpJoUKFdObJnilTpujaejw7WuEVrl69qjfL0WLDEl7//fffNj8H675sHY/tkVWexcNypisYqv0RRSvoGjNmjOby5s+fXxo3bix58z7vII7c3yVLlmiZZuT5BqpArPZHRAEKQdX/A6vEt+5IudRfSeKcJUUyFvP2mRGRA2bMmCGzZ8+WQ4cORXpc/fr1tap0kSJF5K233hJfg+vCESNGRHoMq/1RIHMpB7B48eJawbBOnTryyy+/yMiRI/Xx66+/6rZt27Zp5ZtAZVT7A+vlrf5c7Y+IAluSZKFSPs0ZfSYi/7BgwQJp2rSp5MyZM9Lj0By5efPmWkXaGalTp5Y4ceJoITRLeG2vET22O3M8IH0R67eMh9HjlShYuBwVFCxYUBYvXqzTwxcvXtQHPl60aJHuC3RGOfJMVhV3MMPlT+XiiSiIYMYLa7iYUkjkN/bv3y8VK1Z0ePnHvn37nHp/tP8pWbKkrF271rwNhTTwuly5cjY/B9stjwdUrLZ3PMSPH18LZlg+IsNy5BRooj0Vg8WWyOPFw13FM7BeDGVSEyRIoBV1duzYEenxKGuKVEccX7hwYVm+fHm4/SjQiGqLGTJkkIQJE+ri0GPHjkX7PBFYne7ZU6sUzm3SRJ9RJp4BFxH5JARb1QYz6CLys0IXCIwcgeMs1005CkUxZs6cqS05sC4M6YmoTtihQwfdj3LyloU2evbsKStXrpRPPvlE130NHz5cdu3aJd26dRN3N6dltUIKFC5HSTdu3NCCGf369ZOOHTtqAz/LB7a5Ar0i8Ms/bNgw7feANEVUxLl8+bLN49EronXr1vr1du/eLY0aNdLHgQMHwpWwx8JSlDFFWmTixIn1PbE41V3V/loXLqzPTCkkCgzeuPlz/fp1adu2rd4BTp48uY5rd+/e9cj3R0T+IWPGjOGuaSKD43C8s1AC/uOPP9YxCmXf9+zZo0GVUSwDRdKQ0WQ5o4beXFhvhuu0hQsXauVCR3t0EQUlkwtWrlxpSpIkiSlWrFimZMmSmbJnzx7hkSNHDlfe2lSmTBnTO++8Y3799OlTU8aMGU1jx461eXyLFi1M9evXD7ftxRdfNHXt2lU/fvbsmSl9+vSmjz76yLz/5s2bpvjx45vmzZvn0DndunUL9TL0mYgC3/z5803x4sUzff3116aDBw+aOnfubEqePLnp0qVLNo/fvHmzKU6cOKbx48ebDh06ZHrvvfdMcePGNe3fv998zLhx43S8/Pnnn0179+41NWjQQMfJBw8emI+pU6eOqWjRoqZt27aZNm3aZMqdO7epdevWDp83xyqiwNOlSxdTypQp7Y4/BuzHccb1j6/jeEXBxqWgq1ChQnoxsG/fPreezKNHj/TCZfHixeG2v/7663qBYkuWLFlMEydODLft/fffNxUpUkQ/PnHihP5S7969O9wxlStXNvXo0cOh8+LAQBRcvHHzB8EaxpmdO3eaj1mxYoXe3Dp//rxD582xiijw4DomUaJEeu2FGzK2YPsLL7ygxx0/ftzkDzheUbBxKRfu+PHj0qNHD02hcafIekXY6/0QVa8I49mZ90Q+NIqCWD6IKLgahSL9z5lGoZbHA1KYjeNPnTql443lMcmSJdO0ReMYPCOlsFSpUuZjcDy+NtKibeFYRRT4ULUQFQyR4oe0vjx58kiTJk2kXbt2+oy2Pdh++vRpmT9/vlYxJKIA6dOFX/g7d+5IoLLXS4IXNOTPQkNDJVYs6yYHFBONQh25+YPntGnThtuPnocpU6a0e4OIYxUFKo5XEXtwoSrhhx9+KEuXLtX1Uwas4ercubP26IqqrLwvQbYVcLyiYBmrXAq6Ro0aJe+88460adNGF5q7iyd6RRjP2IYF7JbHYLGoLajQg2IehvPnz2sZ/CxZskTjuyPyLvRFiapEL/kXjlUUqDheRYTrrenTp+sDN74RrODfCBd9/si4ec/xioJlrHIo6EIqobU0adJIgQIFpFatWvoLg2DJEqK+yZMni6u9IlCB0LJXhL0ypEaviF69etnsFZEjRw4NvHCMEWRhoEK6jr2O7eglgYchSZIk2sTPXjSL98O/AY5x9x+J0qVLy86dO2P8PZz9HEePd+Q4d3zP/iS636+jP3/++oc5pnnr5g+Osa7SGhYWphUN7X1djlXOf547jw22sQo4XvkG/Pv4+78RZuj8dbyKibHKmeN5beUfY5VDQde0adPs7sM0ty2uBF2Au7bIU8a6hjJlysikSZMi9IrIlCmTptUYvSKqVKmivSIw/Y58ZvSKQBlT4zwQkGF2DmmRCMKGDh2qv+xGYBcVrKnInDlzlMc50uzPWbj4i+57uvIezn6Oo8c7cpw7vmd/4q7v1xM/f8HIWzd/cOzNmzd1PRm+Pqxbt06/NtZ+OSIYxypnP8+dxwbbWAUcr8hd/Hm8iomxypnjeW3lH2OVQ0EX/ujHFPSKuHLlivaKwDoGXKBY94qwbMJs9Ip477335N1339XAyrpXBPKcEbh16dJFL2rQ2R3viX46vg5pnN54D2c/x9HjHTnOHd+zPwm279cfeOPmDzIH6tSpo2sz0FPwyZMnGuS1atXKpb47wTJWOft57jw2GH93g/F7psAT3Z/jmBirnDme11b+8f3GQglDb5+Ev8Mda1QiYw46eQN//jwDM/wfffSR+eYPGqwbM05Vq1bV9RWzZ88O1xwZN39QQQyBFZqy16tXz7wfQy2aviMQM27+oME8Ko8ZkEqIQOvXX3/Vm0tNmzbVr4u0QXfgzwp5G38GyVH8WaFA+/lzS9CFil644EC38nz58und4GD6BUHZZtzxxqJ2y/UVRDGBP3/kKP6skLfxZ5AcxZ8VCrSfP4eDLtz1xR3XLVu26EJzA+7INm/eXHvbGFCydNu2beGOIyIiIiIiCkYON0f+5ZdftOGeZSCFylqdOnXSxWqzZs2S/fv3y7hx4+Sff/6R0aNHe+qciYiIiIiIAi/oOnTokJQtWzbctvXr12vRi969e+ui80KFCmnRihYtWsjy5cs9cb5ERERERESBGXRdu3YtQgM7lD9GVa7GjRuH216hQgWtMkhERERERBTsHA66ULIdVbwsbdq0SRIlSiRFixaN0OcGDyIiIiIiomDncNCFfjVz5syRO3fu6OuDBw/Kjh07pHbt2hISEhKhmqEjDe/8Gb5/FBBB0RAEnljrVrlyZS0sQuRO6KiOMuJI302cOLFkzZpVU3iPHj0a7rj27dvrzLP1I3/+/F47d/I+jlUUUzhWUXRxvKJAHq8cao4M6C9TunRp7T+DE/zzzz/1i6KUorXFixdL9erVJZChWAgCUKxlQ+PS+/fvy08//SQNGjSQL774QhsxE7nDhx9+KJs3b9Y/REWKFNEZZ1QTLVGihFYJtWwEjrKmX375ZbjPR58JCl4cqyimcKyi6OJ4RYE8XjnVpwvl4lGV8OTJk5ItWzbp16+f1KxZM9wxGzZskO7du8snn3wiL730kgSTp0+fSsmSJeXhw4c620fkDvi9w0yzZcrusWPHpHDhwtKsWTP57rvvzHdjFi5cKHfv3vXi2ZI/4FhFnsCxijyB4xUFynjl8EwXlC9fXpYtWxbpMVWrVtXS8cEIpfNRbARTlkTugt87a8aM8+HDh23+gbp3715QNSgn53CsIk/gWEWewPGKAmW8cnhNF9mG/wFXr16VEydOyMSJE2XFihVSo0YNb58WBThMUF+6dClCA3KkYmBAwLR3ypQp5Z133uHdZFIcq8gbOFaRKzheUSCOV07NdFFEffv21TxjiB07tjRp0kRzQok86fvvv5fz58/LyJEjzdsyZMigffKQj/zs2TNZuXKlfPbZZ7J3715N+7UueEPBhWMVeQPHKnIFxysKxPHKqTVdFBHyi8+dOycXLlyQBQsWaG7o9OnTtcQ+kad+5l588UWdAkfbBqRe2DNmzBgZMmSIzJs3T1q1ahWj50m+hWMVxTSOVeQqjlcUiOMVgy43Q/GQmzdvyvbt27W6I5E7oboOmo8/efJEq+ugulNkHjx4IEmSJJEOHTpEqLxDwY1jFXkSxypyJ45XFAjjFdd0uRkqnmCxp3Wdf6LounXrltStW1f/8GB6O6pBARImTCipUqWS69evx8g5kv/gWEWewrGK3I3jFQXCeMXEaTdD9Gv8TyRyF5TKfeWVV/QPzpo1a6RgwYIOfR76nWAxcpo0aTx+juRfOFaRJ3CsIk/geEWBMF5xpstFly9fjrAN05LffPONRsCO/o8jigrKlLZs2VK2bt0qP/74o5QrV87mwIFBwNoHH3yg1Xjq1KkTQ2dLvoZjFcUUjlUUXRyvKJDHK850uahr165y+/ZtqVy5smTKlEnzQVH1BAvx0BgauZ5E7qri9Msvv+jdGExlGw37DK+++qr+/BUvXlxat24t+fPn1+2rVq2S5cuX66DQsGFDL509eRvHKoopHKsoujheUSCPVyyk4aL58+fLV199pY2gr127JqGhodoxvXv37tKgQQNvnx4FEDQc37hxo939+BVGLjJ+9rAAFNWecAcnd+7c0rZtW+nXr5/EjRs3Rs+ZfAfHKoopHKsoujheUSCPVwy6iIiIiIiIPIhruoiIiIiIiDyIQRcREREREZEHMegiIiIiIiLyIAZdREREREREHsSgi4iIiIiIyIMYdBEREREREXkQgy4iIiIiIiIPYtBFRERERETkQQy6KIJYsWLJ8OHDPfLeGzZs0PdfuHCheFL79u0le/bsHv0aRORdHKuIyF9wvCIGXUFg9uzZ+sto+UibNq1Uq1ZNVqxYIf7kypUr0rNnT8mfP78kTJhQv48yZcrIwIED5e7du94+PSKKBo5VROQvOF6Rs0Kc/gzyWyNHjpQcOXKIyWSSS5cu6YBRr149+fXXX+Xll18WX3f9+nUpVaqU3L59W9544w0dHK5duyb79u2T6dOny1tvvSVJkiTRY2fOnCnPnj3z9ikTkQs4VhGRv+B4RY5i0BVE6tatq79Yho4dO0q6dOlk3rx5fjEwfPXVV3LmzBnZvHmzlC9fPtw+DBbx4sUzv44bN64XzpCI3IFjFRH5C45X5CimFwax5MmT6zRySEjUsffu3bt1YEmaNKne8ahRo4Zs27YtwnE3b96U3r17a85v/PjxJXPmzPL666/L1atX7b73o0ePdGBKliyZbNmyxe5xJ06ckDhx4kjZsmUj7MN5JUiQwG7ecdWqVSOkARgP3JWyPP9evXpJlixZ9Pxz584tH374Ie/sEHkRxyqOVUT+guMVxyt7ONMVRG7duqW/oJgCv3z5skydOlVzdV999dVIP+/gwYNSqVIl/eUbMGCA3un44osv9Jdt48aN8uKLL+pxeC8cd/jwYZ2iLlGihH69X375Rc6dOyepU6eO8N4PHjyQhg0byq5du2TNmjVSunRpu+eRLVs2efr0qXz77bfSrl07p773IUOGSKdOncJt++6772TVqlWauwz379+XKlWqyPnz56Vr166SNWtWHagGDx4sFy9elEmTJjn1NYnINRyrOFYR+QuOVxyvHGaigDdr1iwT/ldbP+LHj2+aPXt2hOOxb9iwYebXjRo1MsWLF8904sQJ87YLFy6YQkNDTZUrVzZve//99/VzFy1aFOE9nz17ps/r16/XY3788UfTnTt3TFWqVDGlTp3atHv37ii/j3///deUJk0a/fz8+fOb3nzzTdPcuXNNN2/ejHBsu3btTNmyZbP7Xps3bzbFjRvX9MYbb5i3ffDBB6bEiRObjh49Gu7YQYMGmeLEiWM6c+ZMlOdIRK7jWBURxyoi38TxKiKOV5Fj0BVEA8Onn35qWr16tT6+++47U506dUwhISGmn376ye7AEBYWZkqUKJGpRYsWEd63a9euptixY5tu3bqlrwsVKmQqWrRopOdiDAxffvmlqVy5cqZ06dKZDhw44PD3ggEJAwI+zxjgMGiNHDnSPPhENTBcvHjRlCFDBlPp0qVNDx8+NG8vUqSI/ptcuXIl3GPNmjX6dfBvRkSew7EqPI5VRL6L41V4HK+ixqAriAaGnTt3htv+9OlT/WXAL8mjR49sDgz4JcLroUOHRnjfSZMm6T7jFztBggSmtm3bOjQwJEmSRAel/fv3u/Q9YRA4cuSIacqUKaZMmTLpe86cOTPKgeHJkyemSpUqmdKmTWs6e/ZsuH0JEya0edfKeEyYMMGlcyUix3Cs+g/HKiLfxvHqPxyvHMNCGkEsduzY2k8CObXHjh2L0a+NXGOMQePGjXNpISUWaebNm1e6d+8uv//+u34v33//fZSf179/f9m6dassWLBAF6JawnnUqlVLVq9ebfPRtGlTp8+TiKKPYxXHKiJ/wfGK45U9LKQR5MLCwvTZXvO7NGnSSKJEieTIkSMR9v3999/6C4lqNJArVy45cOCAQ1+3UaNG8tJLL2klnNDQUO0F4aqcOXNKihQpdICLzPz583XBJh5Y1GkN549/h5o1a7p8LkTkGRyr/sOxisi3cbz6D8er/3CmK4g9efJEfvvtN+3BUKBAAZvHoIwofoGXLFkip0+fNm9HA8C5c+dKxYoVtfIO4G7F3r17ZfHixRHe5/nMengodzplyhT5/PPPtet5VLZv3y737t2LsH3Hjh3ayC9fvnx2PxcDFirsoJoQuq7b0qJFC71Tg6o71lDu1BhEiShmcawKj2MVke/ieBUex6v/cKYriKxYsULvoADKmuIXG1PfgwYNMv9y2zJq1CidAsYg8Pbbb2vvCZQ1RQ+I8ePHh5teXrhwoTRv3lzLmpYsWVI7naOsKX75ixYtGuG9u3Xrps33UHYUvSTeffddu+eBcqaY5m7cuLG+NwY0lFD9+uuvtY9EZJ/boUMHfa5cubKWM7WEZoC4o4Pzx7mirwXuEuFrYCDav3+/fl8YGG2VZiUi9+JYxbGKyF9wvOJ45TAH135RgJU1xcLMYsWKmaZPnx6uMo2tsqbw119/mWrXrq2LNFFxp1q1aqYtW7ZE+FrXrl0zdevWTRdgovJN5syZdeHl1atXI5Q1tTRgwADdPm3aNLvfx759+0z9+/c3lShRwpQyZUpdLIqFqs2bN9fzs2S92BMf21vEiX8fA0qtDh482JQ7d249f5RcLV++vOnjjz82PX782OF/cyJyHscqjlVE/oLjFccrZ8XCfxwP0YiIiIiIiMgZXNNFRERERETkQQy6iIiIiIiIPIhBFxERERERkQcx6CIiIiIiIvIgBl1EREREREQexKCLiIiIiIjIgxh0EREREREReRCDLiIiIiIiIg9i0EVERERERORBDLqIiIiIiIg8iEEXERERERGRBzHoIiIiIiIi8iAGXURERERERB7EoIuIiIiIiMiDGHQRERERERF5EIMuIiIiIiIiD2LQRURERERE5EEMuoiIiIiIiDyIQRcREREREZEHMegiIiIiIiLyIAZdREREREREHsSgi4iIiIiIyIMYdBEREREREXkQgy4iIiIiIiIPYtBFRERERETkQQy6iIiIiIiIPIhBFxERERERkQcx6CIiIiIiIvIgBl1EREREREQexKCLiIiIiIjIgxh0EREREREReRCDLiIiIiIiIg9i0EVERERERORBDLqIiIiIiIg8iEEXERERERGRBzHoIiIiIiIi8iAGXURERERERB7EoIuIiIiIiMiDGHQRERERERF5EIMuIiIiIiIiD2LQRURERERE5EEMuoiIiIiIiDyIQRcREREREZEHMegiIiIiIiLyoBBPvnmwefr0qTx58sTbp0FBLG7cuBInThxvnwYRERERWWDQ5QYmk0n+/fdfuXnzprdPhUiSJ08u6dOnl1ixYnn7VIiIiIiIQZd7GAFX2rRpJVGiRLzYJa8F//fv35fLly/r6wwZMnj7lIiIiIiIQZd7UgqNgCtVqlTePh0KcgkTJtRnBF74mWSqIREREZH3sZBGNBlruDDDReQLjJ9Fri8kIiIi8g0MutyEKYXkK/izSERERORbGHQRERERERF5EIMuIjfKnj27TJo0ydunQUREREQ+hEGXj3j67JlsOH1a5u3fr894TTGratWq0qtXr2i9x86dO6VLly7hUv1+/vnncMcMHz5cihUrFq2vQ0RERET+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xnbs9zTMYKGgxI8//qipd5jxwgyWJQRlgwcPliJFimiVQay7QqADISEhMmXKFG2CjAqCKLkeU1DgA7NXKHKB9WaY+UKgZMB5Yhbv9ddf15muFi1aaKokmjbbMmHCBEmRIoWUL19eAy+kXZYoUSLGvh8iIiIiCjysXhhNrBRHvoY/k0RERES+hTNdREREREREHsSgi3waqgiibLutB9IEiYiIiIh8HQtpkE9DYQ+sw7IFxTuIiIiIiHwdgy7yaSlTptQHEREREZG/YnohERERERGRBzHoIiIiIiIi8iAGXURERERERB7EoIuIiIiIiMiDGHQRERERERF5EIMucsnw4cOlWLFiHv86sWLFkp9//tnlz9+8ebMULlxY4saNK40aNZINGzboe968edOt50lEREREZA9LxnuZ6dYNkfv37B+QKLHESpZCfF379u01kIlOgOQJffr00eBwxYoV2lB5z5493j4lIiIiIgoyDLq8HHCFTRsnEhZm/6CQEAnpNsgvAi9fdOLECW2wnDlzZm+fChEREREFKaYXehNmuCILuAD7I5sJi4Znz57J+PHjJXfu3BI/fnzJmjWrjB49WvcNHDhQ8ubNK4kSJZKcOXPK0KFD5cmTJ3ZTDefMmSNLlizR1D08kMYHZ8+elRYtWkjy5Mm1yXHDhg3l9OnT4T7/66+/lkKFCuk5ZMiQQbp16xZu/9WrV6Vx48Z6Lnny5JFffvklyu8NXwPnce3aNXnjjTf049mzZ4dLOyxSpIgkSJBAypYtKwcOHHDp35CIiIiIKCoMuoLY4MGDZdy4cRpQHTp0SObOnSvp0qXTfaGhoRqkYPvkyZNl5syZMnHiRJvv069fPw2s6tSpIxcvXtRH+fLlNUirXbu2vtemTZs00EGKH457/Pixfu706dPlnXfekS5dusj+/fs1oEIQaGnEiBH6/vv27ZN69epJ27Zt5fr165F+b1myZNHzSJo0qUyaNEk/btmypXl///795ZNPPpGdO3dKmjRp5JVXXrEbVBIRERERRQfTC4PUnTt3NJiaNm2atGvXTrflypVLKlasqB+/99575mOzZ8+ugdX8+fNlwIABEd4LgVTChAnl0aNHkj59evP27777TmfTvvzyS51pglmzZumsF2bCXnrpJRk1apT07dtXevbsaf680qVLR1gv1rp1a/14zJgxMmXKFNmxY4cG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unwIUgmxhsuTKYXWEFghCDGCrpQpU0rBggU17S9fvnxRfj7WTK1YsUJnourXry/37t1z+hwwa4VUQKQ5GgU0DJkyZZLly5fLjh07pGjRovLmm29Kx44d5b333jMfgzVhKJ6B80baI9abIXDDjBi+t5deekkKFy6sa89Qyt4I1oiIiIiIYkIsk2XeFjnt4cOHcurUKcmRI4em2hF5G38miYiIiHwLb/kTERERERF5EIMu8qhChQppCqKth3VTZCIiIiKiQMSS8eRRWI/15MkTm/vSpUsX4+dDRERERBTTGHSRR2XLls3bp0BERERE5FVMLyQiIiIiIvIgBl1EREREREQexKCLiIiIiIjIgxh0EREREREReRCDLiIiIiIiIg9i0EVERERERORBDLqIHHT69GmJFSuW7NmzR19v2LBBX9+8edPbp0ZEREREPoxBly+586/I+rHPn8nnZMmSRS5evCgvvPCCt0+FiIiIiPwIgy5fgmBr4zi/DboeP34sgSxOnDiSPn16CQlhT3EiIiIichyDriD27NkzGTt2rOTIkUMSJkwoRYsWlYULF4ZLnVu7dq2UKlVKEiVKJOXLl5cjR46YP3/48OFSrFgx+fLLL/U9EiRIoNvPnDkjDRs2lCRJkkjSpEmlRYsWcunSpQif9+2330r27NklWbJk0qpVK7lz5060z9vy3FetWiXFixfXY6pXry6XL1+WFStWSIECBfS82rRpI/fv3zd/3sqVK6VixYqSPHlySZUqlbz88sty4sQJu+mFRERERESOYNDlbZjVurDn+ePi3ufb8Gxs8+CsFwKXb775Rj7//HM5ePCg9O7dW1599VXZuHGj+ZghQ4bIJ598Irt27dIZnjfeeCPcexw/flx++uknWbRokQYjCIgQcF2/fl3fZ/Xq1XLy5Elp2bJluM9DMPPzzz/L0qVL9YFjx40b57bzNoK7adOmyZYtW+Ts2bMa/E2aNEnmzp0ry5Ytk99++02mTp1qPv7evXvSp08f/V4RbMaOHVsaN26s3xMRERERkauYJ+Vtu2Y9Tym09GuP/z6uMkik2mC3f9lHjx7JmDFjZM2aNVKuXDndljNnTvnjjz/kiy++kC5duui20aNHS5UqVfTjQYMGSf369eXhw4fmWS2kFCIASpMmjb5GkLV//345deqUroEC7C9UqJDs3LlTSpcurdsQyMyePVtCQ0P19WuvvaaBDr5edM7bOFcYNWqUVKhQQT/u2LGjDB48WIM9HA/NmjWT9evXy8CBA/V106ZNw32tr7/+Wr+vQ4cOcR0XEREREbmMQZe3leogkq/ufzNcCLhemSKSoejzbaHpPfJlMUOF1LpatWqF244gCil5hiJFipg/zpAhgz4jTS9r1qz6cbZs2cwBFxw+fFiDLSPggoIFC2rKHvYZQRfSCo2Ay3hvvK+7ztv63NOlS6cpkkbAZWzbsWOH+fWxY8fk/fffl+3bt8vVq1fNM1xIl2TQRURERESuYtDlbQiqrAMrBFwZi3n0y969e1efkWaXKVOmcPvix49vXssUN25c83asZwLLdLvEiRO79PUt39d4b0fS+KI6b3tfA+8f1dd85ZVXNIicOXOmZMyYUfch2Ar0AiFERERE5FkMuoIUZp8QpGAWxzIlz2BZQMIZKFKB9VN4GLNdSM9DLyt8TU+ft6uuXbumRUIQcFWqVEm3IWWRiIiIiCi6GHT5Esx4YQ2Xh1IKw32p0FDp16+fFqHAjA6q9t26dUs2b96slf0w4+OKmjVrSuHChaVt27ZatCIsLEzefvttDZBQBdHT592uXTuX3jdFihRasXDGjBma6oigDmvYiIiIiIiii0GXL0Gw5YGiGfZ88MEHuh4L1QBRYRDrrkqUKCHvvvuuyxX7kLK3ZMkS6d69u1SuXFkrANapUydclUBPnrercJ7z58+XHj16aEphvnz5ZMqUKVK1alW3nTcRERERBadYJpPJ5O2T8Geo5IdKfZZ9qoi8iT+TRERERL6FfbqIiIiIiIg8iEEX+RSspUqSJIndB/YTEREREfkTrukin4JS7Xv27Il0PxERERGRP2HQRT4lJCREcufO7e3TICIiIiJyG6YXugnrkZCv4M8iERERkW9h0BVNcePG1ef79+97+1SIwv0sGj+bRERERORdTC+Mpjhx4mifqMuXL+vrRIkSaa8qIm/McCHgws8ifibxs0lERERE3sc+XW6Af8J///1Xbt686e1TIdKAK3369Az+iYiIiHwEgy43evr0qTx58sSdb0nkFKQUcoaLiIiIyLcw6CIiIiIiIvIgFtIgIiIiIiLyIAZdREREREREHsSgi4iIiIiIyIMYdBEREREREXkQgy4iIiIiIiIPYtBFRERERETkQQy6iIiIiIiIxHP+B4LShCo8u8BUAAAAAElFTkSuQmCC",
165:       "text/plain": [
166:        "<Figure size 1000x300 with 3 Axes>"
167:       ]
168:      },
169:      "metadata": {},
170:      "output_type": "display_data"
171:     }
172:    ],
173:    "source": [
174:     "### Visualize reconstruction error across block sizes and datasets\n",
175:     "fig, ax = plt.subplots(\n",
176:     "    figsize=(10, 3),\n",
177:     "    ncols = 3,\n",
178:     "    sharex=True,\n",
179:     "    sharey=False,\n",
180:     "    # set spacing between subplots\n",
181:     "    gridspec_kw={'wspace': 0.7}\n",
182:     "    )\n",
183:     "\n",
184:     "for group in df.groupby(['block_size', 'dataset']):\n",
185:     "    block_size, dataset = group[0]\n",
186:     "    group_data = group[1]\n",
187:     "\n",
188:     "    marker = marker_styles[dataset]\n",
189:     "    color = colors[dataset]\n",
190:     "\n",
191:     "    # plot the shortest-path reconstruction error for each surrogate\n",
192:     "    path_errors = group_data['shortest_path'].mean()\n",
193:     "    ax[0].plot(\n",
194:     "        [block_size],\n",
195:     "        [path_errors],\n",
196:     "        label=f\"{dataset}\",\n",
197:     "        marker=marker,\n",
198:     "        linewidth=0,\n",
199:     "        color=color\n",
200:     "    )\n",
201:     "\n",
202:     "    # plot the degree-dist reconstruction error for each surrogate\n",
203:     "    degree_errors = group_data['degree'].mean()\n",
204:     "    ax[1].plot(\n",
205:     "        [block_size],\n",
206:     "        [degree_errors],\n",
207:     "        marker=marker,\n",
208:     "        linewidth=0,\n",
209:     "        color=color\n",
210:     "    )\n",
211:     "\n",
212:     "    clustering_errors = group_data['clustering'].mean()\n",
213:     "    ax[2].plot(\n",
214:     "        [block_size],\n",
215:     "        [clustering_errors],\n",
216:     "        marker=marker,\n",
217:     "        linewidth=0,\n",
218:     "        color=color\n",
219:     "    )\n",
220:     "        \n",
221:     "ax[0].set_ylabel('Shortest-path distribution error', fontsize=12)\n",
222:     "ax[1].set_ylabel('Degree distribution error', fontsize=12)\n",
223:     "ax[2].set_ylabel('Clustering distribution error', fontsize=12)\n",
224:     "\n",
225:     "xticks = df['block_size'].unique()[::3]\n",
226:     "for axis in ax:\n",
227:     "    axis.set_xscale('log')\n",
228:     "    axis.set_xticks(xticks)\n",
229:     "    axis.set_xticklabels(xticks, fontsize=12)\n",
230:     "    axis.spines[['top', 'right']].set_visible(False)\n",
231:     "    axis.set_xlabel('Block size', fontsize=12)\n",
232:     "\n",
233:     "    axis.set_xlabel('Block Size')\n",
234:     "\n",
235:     "\n",
236:     "### Construct legend from single axis\n",
237:     "handles, labels = ax[0].get_legend_handles_labels()\n",
238:     "legend_set = set(zip(labels, handles))\n",
239:     "\n",
240:     "by_label = dict(legend_set)\n",
241:     "ax[0].legend(\n",
242:     "    by_label.values(),\n",
243:     "    by_label.keys(),\n",
244:     "    loc='lower left',\n",
245:     "    bbox_to_anchor=(0, -1),\n",
246:     "    fontsize=10,\n",
247:     "    )\n",
248:     "\n",
249:     "plt.show(fig)"
250:    ]
251:   },
252:   {
253:    "cell_type": "code",
254:    "execution_count": 13,
255:    "id": "1f49754b",
256:    "metadata": {},
257:    "outputs": [],
258:    "source": [
259:     "import numpy as np\n",
260:     "\n",
261:     "rng = np.random.default_rng(42)"
262:    ]
263:   },
264:   {
265:    "cell_type": "code",
266:    "execution_count": 14,
267:    "id": "c965ecb3",
268:    "metadata": {},
269:    "outputs": [],
270:    "source": [
271:     "import scipy.sparse as sp\n",
272:     "\n",
273:     "a = sp.random(100, 100, density=0.1, format='csr', random_state=rng)"
274:    ]
275:   },
276:   {
277:    "cell_type": "code",
278:    "execution_count": 15,
279:    "id": "dac2e459",
280:    "metadata": {},
281:    "outputs": [
282:     {
283:      "data": {
284:       "text/plain": [
285:        "array([[0.        , 0.        , 0.        , ..., 0.        , 0.        ,\n",
286:        "        0.        ],\n",
287:        "       [0.        , 0.        , 0.        , ..., 0.        , 0.        ,\n",
288:        "        0.        ],\n",
289:        "       [0.48176355, 0.75232891, 0.        , ..., 0.        , 0.        ,\n",
290:        "        0.86413683],\n",
291:        "       ...,\n",
292:        "       [0.        , 0.        , 0.        , ..., 0.        , 0.        ,\n",
293:        "        0.        ],\n",
294:        "       [0.        , 0.42176606, 0.        , ..., 0.        , 0.        ,\n",
295:        "        0.        ],\n",
296:        "       [0.        , 0.        , 0.        , ..., 0.        , 0.        ,\n",
297:        "        0.        ]])"
298:       ]
299:      },
300:      "execution_count": 15,
301:      "metadata": {},
302:      "output_type": "execute_result"
303:     }
304:    ],
305:    "source": [
306:     "a.toarray()"
307:    ]
308:   },
309:   {
310:    "cell_type": "code",
311:    "execution_count": 16,
312:    "id": "3aa9b937",
313:    "metadata": {},
314:    "outputs": [
315:     {
316:      "data": {
317:       "text/plain": [
318:        "<1x100 sparse matrix of type '<class 'numpy.float64'>'\n",
319:        "\twith 8 stored elements in Compressed Sparse Row format>"
320:       ]
321:      },
322:      "execution_count": 16,
323:      "metadata": {},
324:      "output_type": "execute_result"
325:     }
326:    ],
327:    "source": [
328:     "# flatten the \n",
329:     "a[0, :]"
330:    ]
331:   },
332:   {
333:    "cell_type": "code",
334:    "execution_count": 1,
335:    "id": "5eed144f",
336:    "metadata": {},
337:    "outputs": [],
338:    "source": [
339:     "from sbm.noisy_fit import HeterogeneousGaussNoise, NaiveDegreeGaussNoise, create_sbm_noise\n",
340:     "from sbm.io import SBMWriter\n",
341:     "from pathlib import Path\n",
342:     "import numpy as np"
343:    ]
344:   },
345:   {
346:    "cell_type": "code",
347:    "execution_count": 2,
348:    "id": "8354f69a",
349:    "metadata": {},
350:    "outputs": [
351:     {
352:      "name": "stdout",
353:      "output_type": "stream",
354:      "text": [
355:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_caltech_fb_cooling_rate_0_999_force_undirected_True_init_method_ProneKMeans_min_block_size_12_n_iter_100000_temperature_1_0\n"
356:      ]
357:     }
358:    ],
359:    "source": [
360:     "sbm = SBMWriter.load(\n",
361:     "    Path(\"/Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_caltech_fb_cooling_rate_0_999_force_undirected_True_init_method_ProneKMeans_min_block_size_12_n_iter_100000_temperature_1_0\")\n",
362:     ")"
363:    ]
364:   },
365:   {
366:    "cell_type": "code",
367:    "execution_count": 4,
368:    "id": "2a0f1cea",
369:    "metadata": {},
370:    "outputs": [
371:     {
372:      "ename": "ValueError",
373:      "evalue": "index pointer size (2081) should be (65)",
374:      "output_type": "error",
375:      "traceback": [
376:       "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
377:       "\u001b[31mValueError\u001b[39m                                Traceback (most recent call last)",
378:       "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[4]\u001b[39m\u001b[32m, line 2\u001b[39m\n\u001b[32m      1\u001b[39m rng = np.random.default_rng(\u001b[32m0\u001b[39m)\n\u001b[32m----> \u001b[39m\u001b[32m2\u001b[39m noiser = \u001b[43mcreate_sbm_noise\u001b[49m\u001b[43m(\u001b[49m\n\u001b[32m      3\u001b[39m \u001b[43m    \u001b[49m\u001b[43msbm\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43meps\u001b[49m\u001b[43m=\u001b[49m\u001b[32;43m1.0\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mdelta\u001b[49m\u001b[43m=\u001b[49m\u001b[32;43m1e-6\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43malpha\u001b[49m\u001b[43m=\u001b[49m\u001b[32;43m0.999\u001b[39;49m\u001b[43m,\u001b[49m\n\u001b[32m      4\u001b[39m \u001b[43m    \u001b[49m\u001b[43mnoise_type\u001b[49m\u001b[43m=\u001b[49m\u001b[33;43m\"\u001b[39;49m\u001b[33;43mheterogeneous_gaussian\u001b[39;49m\u001b[33;43m\"\u001b[39;49m\n\u001b[32m      5\u001b[39m \u001b[43m    \u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m      7\u001b[39m \u001b[38;5;28;01massert\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(noiser, NaiveDegreeGaussNoise)\n\u001b[32m      8\u001b[39m \u001b[38;5;28mprint\u001b[39m(noiser.sigma_n_scalar, noiser.sigma_e_scalar)\n",
379:       "\u001b[36mFile \u001b[39m\u001b[32m~/anon_sbm/src/sbm/noisy_fit.py:346\u001b[39m, in \u001b[36mcreate_sbm_noise\u001b[39m\u001b[34m(sbm, eps, delta, alpha, clip_p, weight_clip, noise_type)\u001b[39m\n\u001b[32m    343\u001b[39m sigma_e_data = (np.sqrt(c_e_val * data_w_e) * S_sum) / R \u001b[38;5;66;03m# type: ignore\u001b[39;00m\n\u001b[32m    345\u001b[39m \u001b[38;5;66;03m# build sparse Ï matrix upper tri\u001b[39;00m\n\u001b[32m--> \u001b[39m\u001b[32m346\u001b[39m sigma_e = \u001b[43msp\u001b[49m\u001b[43m.\u001b[49m\u001b[43mcsr_array\u001b[49m\u001b[43m(\u001b[49m\u001b[43m(\u001b[49m\u001b[43msigma_e_data\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m    347\u001b[39m \u001b[43m                        \u001b[49m\u001b[43mnp\u001b[49m\u001b[43m.\u001b[49m\u001b[43marray\u001b[49m\u001b[43m(\u001b[49m\u001b[43mdata_sigma_idx\u001b[49m\u001b[43m)\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m    348\u001b[39m \u001b[43m                        \u001b[49m\u001b[43mnp\u001b[49m\u001b[43m.\u001b[49m\u001b[43marange\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;28;43mlen\u001b[39;49m\u001b[43m(\u001b[49m\u001b[43mdata_sigma_idx\u001b[49m\u001b[43m)\u001b[49m\u001b[43m \u001b[49m\u001b[43m+\u001b[49m\u001b[43m \u001b[49m\u001b[32;43m1\u001b[39;49m\u001b[43m)\u001b[49m\u001b[43m)\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m    349\u001b[39m \u001b[43m                       \u001b[49m\u001b[43mshape\u001b[49m\u001b[43m=\u001b[49m\u001b[43m(\u001b[49m\u001b[43mB\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mB\u001b[49m\u001b[43m)\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    350\u001b[39m sigma_e = sigma_e + sigma_e.T - sp.diags(sigma_e.diagonal())\n\u001b[32m    352\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m noise_type == \u001b[33m\"\u001b[39m\u001b[33mheterogeneous_gaussian\u001b[39m\u001b[33m\"\u001b[39m:\n",
380:       "\u001b[36mFile \u001b[39m\u001b[32m/opt/homebrew/Caskroom/miniforge/base/envs/anon_sbm_notebook_arm/lib/python3.12/site-packages/scipy/sparse/_compressed.py:107\u001b[39m, in \u001b[36m_cs_matrix.__init__\u001b[39m\u001b[34m(self, arg1, shape, dtype, copy)\u001b[39m\n\u001b[32m    104\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m dtype \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n\u001b[32m    105\u001b[39m     \u001b[38;5;28mself\u001b[39m.data = \u001b[38;5;28mself\u001b[39m.data.astype(dtype, copy=\u001b[38;5;28;01mFalse\u001b[39;00m)\n\u001b[32m--> \u001b[39m\u001b[32m107\u001b[39m \u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43mcheck_format\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfull_check\u001b[49m\u001b[43m=\u001b[49m\u001b[38;5;28;43;01mFalse\u001b[39;49;00m\u001b[43m)\u001b[49m\n",
381:       "\u001b[36mFile \u001b[39m\u001b[32m/opt/homebrew/Caskroom/miniforge/base/envs/anon_sbm_notebook_arm/lib/python3.12/site-packages/scipy/sparse/_compressed.py:168\u001b[39m, in \u001b[36m_cs_matrix.check_format\u001b[39m\u001b[34m(self, full_check)\u001b[39m\n\u001b[32m    166\u001b[39m \u001b[38;5;66;03m# check index pointer\u001b[39;00m\n\u001b[32m    167\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m (\u001b[38;5;28mlen\u001b[39m(\u001b[38;5;28mself\u001b[39m.indptr) != major_dim + \u001b[32m1\u001b[39m):\n\u001b[32m--> \u001b[39m\u001b[32m168\u001b[39m     \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mValueError\u001b[39;00m(\u001b[33m\"\u001b[39m\u001b[33mindex pointer size (\u001b[39m\u001b[38;5;132;01m{}\u001b[39;00m\u001b[33m) should be (\u001b[39m\u001b[38;5;132;01m{}\u001b[39;00m\u001b[33m)\u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m    169\u001b[39m                      \u001b[33m\"\u001b[39m\u001b[33m\"\u001b[39m.format(\u001b[38;5;28mlen\u001b[39m(\u001b[38;5;28mself\u001b[39m.indptr), major_dim + \u001b[32m1\u001b[39m))\n\u001b[32m    170\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m (\u001b[38;5;28mself\u001b[39m.indptr[\u001b[32m0\u001b[39m] != \u001b[32m0\u001b[39m):\n\u001b[32m    171\u001b[39m     \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mValueError\u001b[39;00m(\u001b[33m\"\u001b[39m\u001b[33mindex pointer should start with 0\u001b[39m\u001b[33m\"\u001b[39m)\n",
382:       "\u001b[31mValueError\u001b[39m: index pointer size (2081) should be (65)"
383:      ]
384:     }
385:    ],
386:    "source": [
387:     "rng = np.random.default_rng(0)\n",
388:     "noiser = create_sbm_noise(\n",
389:     "    sbm, eps=1.0, delta=1e-6, alpha=0.999,\n",
390:     "    noise_type=\"heterogeneous_gaussian\"\n",
391:     "    )\n",
392:     "\n",
393:     "assert isinstance(noiser, NaiveDegreeGaussNoise)\n",
394:     "print(noiser.sigma_n_scalar, noiser.sigma_e_scalar)\n",
395:     "noisy_fit = noiser.sample_sbm_fit(rng)\n"
396:    ]
397:   },
398:   {
399:    "cell_type": "code",
400:    "execution_count": null,
401:    "id": "114a6e02",
402:    "metadata": {},
403:    "outputs": [],
404:    "source": []
405:   }
406:  ],
407:  "metadata": {
408:   "kernelspec": {
409:    "display_name": "Python 3",
410:    "language": "python",
411:    "name": "python3"
412:   },
413:   "language_info": {
414:    "codemirror_mode": {
415:     "name": "ipython",
416:     "version": 3
417:    },
418:    "file_extension": ".py",
419:    "mimetype": "text/x-python",
420:    "name": "python",
421:    "nbconvert_exporter": "python",
422:    "pygments_lexer": "ipython3",
423:    "version": "3.12.11"
424:   }
425:  },
426:  "nbformat": 4,
427:  "nbformat_minor": 5
428: }

================
File: src/metrics/shortest_path.py
================
  1: """ 
  2: Metrics functions to compare the shortest-path properties of two graphs.
  3: """
  4: # metrics/shortest_path.py
  5: from typing import Optional
  6: import numpy as np
  7: import networkx as nx
  8: from scipy.stats import wasserstein_distance #  1-D EMD
  9: from scipy.sparse import csr_array
 10: from sbm.utils.util import restrict_to_lcc, _nx_graph
 11: import networkx as nx
 12: from typing import  Hashable, List, Union
 13: ### Aliases  --------------------------------------------------------
 14: Number = Union[int, float]
 15: ### Helpers ---------------------------------------------------------
 16: def _average_path_length(
 17:     G: nx.Graph,
 18:     *,
 19:     n_samples: Optional[int],
 20:     rng: np.random.Generator,
 21: ) -> float:
 22:     """Return â¨dâ© â¡ mean shortestâpath length in *G*.
 23:     If *n_samples* is None or the graph is small (â¤ 2000 nodes), the exact
 24:     average is computed. Otherwise *n_samples* node pairs are sampled.
 25:     """
 26:     n = G.number_of_nodes()
 27:     if n <= 1:
 28:         return 0.0
 29:     if n_samples is None or n <= 2000:
 30:         return nx.average_shortest_path_length(G)
 31:     # --- sample pairs ---------------------------------------------------------
 32:     nodes = list(G)
 33:     path_lens: List[int] = []
 34:     for _ in range(int(n_samples)):
 35:         u, v = rng.choice(nodes, size=2, replace=False)
 36:         try:
 37:             path_lens.append(nx.shortest_path_length(G, u, v))
 38:         except nx.NetworkXNoPath:
 39:             # Ignore unreachable pairs â corresponds to infinite distance.
 40:             pass
 41:     return float(np.mean(path_lens)) if path_lens else np.inf
 42: def all_unique_shortest_distances(
 43:     G: nx.Graph,
 44:     weight: str | None = None,
 45:     cutoff: Number | None = None,
 46:     directed: bool = False,
 47: ) -> List[Number]:
 48:     """
 49:     Return a list containing the length of every unique shortest path in *G*.
 50:     Parameters
 51:     ----------
 52:     G : networkx.Graph
 53:         The input graph (directed or undirected, weighted or unweighted).
 54:     weight : str or None, default=None
 55:         Edge-attribute key to use as weight.  ``None`` â treat edges as unit-weight.
 56:     cutoff : int | float | None, default=None
 57:         Ignore paths longer than *cutoff* (same semantics as NetworkX).
 58:     Returns
 59:     -------
 60:     distances : list[Number]
 61:         One entry per unordered, connected node pair.  
 62:         Unreachable pairs are silently skipped.
 63:     """
 64:     # 1.  Choose the correct all-pairs iterator
 65:     if weight is None:
 66:         # Unweighted â¢ multi-source breadth-first search
 67:         iterator = nx.all_pairs_shortest_path_length(G, cutoff=cutoff)  # :contentReference[oaicite:0]{index=0}
 68:     else:
 69:         # Weighted â¢ repeated Dijkstra
 70:         iterator = nx.all_pairs_dijkstra_path_length(G, cutoff=cutoff, weight=weight)  # :contentReference[oaicite:1]{index=1}
 71:     # 2.  Collect unique unordered pairs
 72:     seen: set[frozenset[Hashable]] = set()
 73:     distances: List[Number] = []
 74:     for u, length_dict in iterator:
 75:         for v, d in length_dict.items():
 76:             if u == v:                       # skip self-loops (distance 0)
 77:                 continue
 78:             pair = frozenset((u, v))         # unordered representation
 79:             if pair in seen:                 # already counted via (v, u)
 80:                 continue
 81:             seen.add(pair)
 82:             distances.append(d)
 83:     return distances
 84: ###############################################################################
 85: ### --- Metrics --------------------------------------------------------
 86: ###############################################################################
 87: def shortest_path_distance(
 88:         emp_adj: csr_array,
 89:         sur_adj: csr_array,
 90:         n_samples: Optional[int]=10_000,
 91:         rng:np.random.Generator = np.random.default_rng(1)
 92:     ) -> float:
 93:     """
 94:     Earth-mover (1-D Wasserstein) distance between the distributions
 95:     of all-pairs shortest-path lengths.
 96:     Parameters
 97:     ----------
 98:     emp_adj, sur_adj : scipy.sparse.csr_matrix
 99:         Adjacency of empirical and surrogate graphs (undirected).
100:     n_samples : int, optional
101:         Number of samples to use for the distributions.
102:         If None, all pairs are used.
103:     Returns
104:     -------
105:     float
106:         Distance (lower = more similar).
107:     """
108:     emp_adj = restrict_to_lcc(emp_adj, directed=False)
109:     sur_adj = restrict_to_lcc(sur_adj, directed=False)
110:     emp_graph_size = emp_adj.shape[0] # type: ignore
111:     sur_graph_size = sur_adj.shape[0] # type: ignore
112:     if n_samples is None:
113:         # Use all pairs if n_samples is None, generated using networkx (returns iterator)
114:         x = all_unique_shortest_distances(
115:             nx.from_scipy_sparse_matrix(emp_adj),
116:             weight=None,
117:             cutoff=None
118:         )
119:         y = all_unique_shortest_distances(
120:             nx.from_scipy_sparse_matrix(sur_adj),
121:             weight=None,
122:             cutoff=None
123:         )
124:     else:
125:         n_samples_emp = int(min(
126:             n_samples,
127:             emp_graph_size * (emp_graph_size - 1) // 2,
128:         ))
129:         n_samples_sur = int(min(
130:             n_samples,
131:             sur_graph_size * (sur_graph_size - 1) // 2,
132:         ))
133:         emp_pair_part_1 = rng.choice(emp_graph_size, size=n_samples_emp, replace=True)
134:         emp_pair_part_2 = rng.choice(emp_graph_size-1, size=n_samples_emp, replace=True)
135:         emp_pair_part_2[emp_pair_part_2 >= emp_pair_part_1] += 1
136:         emp_pairs = np.column_stack((emp_pair_part_1, emp_pair_part_2))
137:         sur_pair_part_1 = rng.choice(sur_graph_size, size=n_samples_sur, replace=True)
138:         sur_pair_part_2 = rng.choice(sur_graph_size-1, size=n_samples_sur, replace=True)
139:         sur_pair_part_2[sur_pair_part_2 >= sur_pair_part_1] += 1
140:         sur_pairs = np.column_stack((sur_pair_part_1, sur_pair_part_2))
141:         def sample_shortest_paths(adj, pairs):
142:             G = nx.from_scipy_sparse_matrix(adj)
143:             path_lengths = []
144:             for pair in pairs:
145:                 try:
146:                     length = nx.shortest_path_length(G, source=pair[0], target=pair[1])
147:                     path_lengths.append(length)
148:                 except nx.exception.NodeNotFound:
149:                     raise Warning(
150:                         f"Node {pair[0]} or {pair[1]} not found in the graph."
151:                     )
152:             return path_lengths
153:         x = sample_shortest_paths(emp_adj, emp_pairs)
154:         y = sample_shortest_paths(sur_adj, sur_pairs)
155:     return wasserstein_distance(x, y)
156: ###############################################################################
157: # Average pathâlength difference -------------------------------------------
158: ###############################################################################
159: def avg_path_length_difference(
160:     emp_adj: csr_array,
161:     sur_adj: csr_array,
162:     *,
163:     n_samples: Optional[int] = 10_000,
164:     rng: np.random.Generator = np.random.default_rng(1),
165:     restrict_to_lcc: bool = True,
166: ) -> float:
167:     """Absolute difference of average shortestâpath lengths.
168:     Parameters
169:     ----------
170:     n_samples : int | None
171:         If *None*, compute the exact average; otherwise sample this many
172:         (unordered) node pairs.
173:     """
174:     G_emp = _nx_graph(emp_adj, directed=False)
175:     G_sur = _nx_graph(sur_adj, directed=False)
176:     if restrict_to_lcc:
177:         G_emp = G_emp.subgraph(max(nx.connected_components(G_emp), key=len))
178:         G_sur = G_sur.subgraph(max(nx.connected_components(G_sur), key=len))
179:     d_emp = _average_path_length(G_emp, n_samples=n_samples, rng=rng)
180:     d_sur = _average_path_length(G_sur, n_samples=n_samples, rng=rng)
181:     return abs(d_emp - d_sur)

================
File: src/sbm/block_change_proposers.py
================
  1: from typing import List, Optional, Tuple, DefaultDict, Literal
  2: from collections import defaultdict, Counter
  3: import numpy as np
  4: from sbm.block_data import BlockData
  5: from sbm.edge_delta import EdgeDelta, NumpyEdgeDelta
  6: ### Aliases 
  7: CombinationDelta= DefaultDict[Tuple[int, int], int] # changes in possible pairs between blocks
  8: ProposedValidChanges = List[Tuple[int, int]]  # list of proposed node-block pairs
  9: ChangeProposerName = Literal["uniform_swap", "edge_based_swap", "triadic_swap"]
 10: ChangeProposers = Literal["NodeSwapProposer", "EdgeBasedSwapProposer", "TriadicSwapProposer"]
 11: ### ChangeProposer classes for proposing block changes in the SBM
 12: # These classes handle the logic of proposing valid changes to the block assignments
 13: # and computing the resulting edge deltas for the block connectivity matrix.
 14: class ChangeProposer:
 15:     """ 
 16:     Class to propose block-assignment changes for the MCMC algorithm.
 17:     Handles min block size constraints. All functions return None
 18:     if a  and ensures valid moves.
 19:     Proposers shoudl always change block-id to block-adjacency idx before
 20:     computing deltas.
 21:     """
 22:     def __init__(self,
 23:                  block_data: BlockData,
 24:                  rng: np.random.Generator=np.random.default_rng(1),
 25:                  use_numpy: bool = False,
 26:                  ):
 27:         self.block_data = block_data
 28:         self.rng = rng
 29:         self.min_block_size = 1
 30:         self.use_numpy = use_numpy
 31:         # Direct CSR pointers for O(1) edge sampling
 32:         self._indptr = self.block_data.graph_data.adjacency.indptr
 33:         self._indices = self.block_data.graph_data.adjacency.indices
 34:     def propose_change(self,
 35:         changes: Optional[ProposedValidChanges] = None,
 36:         )-> Tuple[ProposedValidChanges, EdgeDelta, CombinationDelta]:
 37:         raise NotImplementedError("This method should be overridden by subclasses.")
 38:     def _compute_delta_edge_counts(self, proposed_changes: ProposedValidChanges) -> EdgeDelta:
 39:         """
 40:         Compute the edge deltas for the proposed change.
 41:         :param change: Proposed change as a list of (node, target_block) tuples.
 42:         :return: EdgeDelta containing the changes in edge counts between blocks.
 43:         """
 44:         raise NotImplementedError("This method should be overridden by subclasses.")
 45:     # -----------------------------------------------------------------------------
 46:     def _compute_edge_counts_between_node_and_blocks(self,
 47:                                                node: int,
 48:                                                ) -> Counter[int]:
 49:         """
 50:         Compute the number of edges between a node and each affected block.
 51:         :param node: The node to move.
 52:         :param affected_blocks: The blocks affected by the move.
 53:         :return: A dictionary mapping block IDs to edge counts with the node.
 54:         k_i: Counter[int]: number of edges between node and each affected block.
 55:         returns a Counter object where keys are block IDs and values are edge counts.
 56:         """
 57:         if self.block_data.directed:
 58:             raise NotImplementedError("Directed graphs are not supported yet.")
 59:         else:
 60:             #neighbors = self.block_data.graph_data.adjacency[:, [node]].indices  # type: ignore
 61:             neighbors = self.block_data.graph_data.adjacency[[node], :].indices  # type: ignore
 62:             blocks_among_neighbors = [
 63:                 self.block_data.block_indices[
 64:                     self.block_data.blocks[neighbor]
 65:                 ] for neighbor in neighbors
 66:             ]
 67:             k_i = Counter(blocks_among_neighbors)
 68:             return k_i
 69: class NodeSwapProposer(ChangeProposer):
 70:     def propose_change(self,
 71:         changes: Optional[ProposedValidChanges] = None,
 72:     ) -> Tuple[ProposedValidChanges, EdgeDelta, CombinationDelta]:
 73:         """
 74:         Propose swapping two nodes between different blocks.
 75:         :return: Tuple of (node1, node2) or None if no valid swap.
 76:         """
 77:         if changes is not None:
 78:             if len(changes) != 2:
 79:                 raise ValueError("NodeSwapProposer requires exactly two nodes to swap.")
 80:             proposed_changes = changes
 81:         else:
 82:             # Select two different blocks
 83:             block1, block2 = self.rng.choice(
 84:                 self.block_data.block_connectivity.shape[0],
 85:                 #list(self.block_data.block_sizes.keys()),
 86:                 size=2,
 87:                 replace=False
 88:             )
 89:             # Select one node from each block
 90:             # Note: changing to list is inefficient for large blocks.
 91:             # However, having memberships being lists allow for fast 
 92:             # membership updates.
 93:             # Change if large blocks are common.
 94:             node1 = self.rng.choice(
 95:                 list(self.block_data.block_members[block1])
 96:             )
 97:             node2 = self.rng.choice(
 98:                 list(self.block_data.block_members[block2])
 99:             )
100:             proposed_changes :ProposedValidChanges = [(node1, block2), (node2, block1)]
101:         delta_e: EdgeDelta = self._compute_delta_edge_counts(
102:                 proposed_changes=proposed_changes,
103:                 use_numpy=self.use_numpy,
104:             )
105:         delta_n: CombinationDelta = defaultdict(int)
106:         return proposed_changes, delta_e, delta_n
107:     def _compute_delta_edge_counts(self,
108:             proposed_changes: ProposedValidChanges,
109:             use_numpy: bool = False,
110:         )-> EdgeDelta:
111:         """
112:         Compute the changes in edge counts between blocks due to swapping
113:         node i and node j.
114:         :param i: The index of the first node being swapped.
115:         :param j: The index of the second node being swapped.
116:         :param k_i: The edges between the moving node and its neighbor blocks.
117:         :param source_block: The block from which the node is moved.
118:         :param target_block: The block to which the node is moved.
119:         :return: A Counter mapping block pairs to changes in edge counts.
120:         """
121:         if self.block_data.directed:
122:             raise NotImplementedError("Directed graphs are not supported yet.")
123:         (i, old_block_j), (j, old_block_i) = proposed_changes
124:         if use_numpy:
125:             delta_e = NumpyEdgeDelta(
126:                 n_blocks=len(self.block_data.block_sizes)
127:             )
128:         else:
129:             delta_e = EdgeDelta(
130:                 n_blocks=len(self.block_data.block_sizes)
131:             )
132:         # compute the edge counts for the blocks of i and j
133:         # on block-adjacency idx level
134:         k_i = self._compute_edge_counts_between_node_and_blocks(i)
135:         k_j = self._compute_edge_counts_between_node_and_blocks(j)
136:         affected_blocks = set(k_i.keys()) | set(k_j.keys())
137:         # new implementation with combined increment function
138:         neighbor_blocks = affected_blocks - {old_block_i, old_block_j}
139:         # build increment lists for neighbor blocks
140:         counts = [
141:             -k_i[t] + k_j[t] for t in neighbor_blocks
142:         ] + [
143:             -k_j[t] + k_i[t] for t in neighbor_blocks
144:         ]
145:         blocks_i = [old_block_i] * len(neighbor_blocks) + [old_block_j] * len(neighbor_blocks)
146:         block_j = list(neighbor_blocks) + list(neighbor_blocks)
147:         delta_e.increment(
148:             counts = counts,
149:             blocks_i = blocks_i,
150:             blocks_j = block_j,
151:         ) 
152:         # Add the changes for the old blocks of i and j
153:         has_edge_ij = bool(self.block_data.graph_data.adjacency[i, j])
154:         delta_e.increment(
155:             counts=[
156:                 k_i[old_block_i] - k_i[old_block_j] + k_j[old_block_j] - k_j[old_block_i] + 2 * has_edge_ij,
157:                 k_j[old_block_i] - k_i[old_block_i] - has_edge_ij,
158:                 k_i[old_block_j] - k_j[old_block_j] - has_edge_ij
159:             ],
160:             blocks_i=[old_block_i, old_block_i, old_block_j],
161:             blocks_j=[old_block_j, old_block_i, old_block_j]
162:         )
163:         return delta_e
164: # -----------------------------------------------------------------------------
165: #  Edgeâbased swap proposer
166: # -----------------------------------------------------------------------------
167: class EdgeBasedSwapProposer(NodeSwapProposer):
168:     """A Peixotoâstyle *edgeâconditioned* twoâvertex swap.
169:     1. Pick a **crossâblock edge** ``(i,j)`` uniformly at random.
170:     2. Swap the block labels of its endâpoints.
171:     The proposal is *symmetric* (uniform over edges), so the Metropolisâ
172:     Hastings acceptance probability is simply ``min(1, exp(Îâ/T))``.
173:     """
174:     def __init__(
175:         self,
176:         block_data,
177:         rng: np.random.Generator = np.random.default_rng(1),
178:         use_numpy: bool = True,
179:         max_trials: int = 128,
180:     ) -> None:
181:         super().__init__(block_data=block_data, rng=rng, use_numpy=use_numpy)
182:         self.max_trials = max_trials
183:         # Direct CSR pointers for O(1) edge sampling
184:         self._indptr = self.block_data.graph_data.adjacency.indptr
185:         self._indices = self.block_data.graph_data.adjacency.indices
186:     # ------------------------------------------------------------------
187:     def propose_change(
188:         self,
189:         changes: Optional[ProposedValidChanges] = None,
190:     ) -> Tuple[ProposedValidChanges, EdgeDelta, CombinationDelta]:
191:         if changes is not None:
192:             return super().propose_change(changes=changes)
193:         n = self.block_data.graph_data.num_nodes  # type: ignore[attr-defined]
194:         blocks = self.block_data.blocks
195:         for _ in range(self.max_trials):
196:             i = int(self.rng.integers(n))
197:             # get i's neighbor index-range (adj is csr format)
198:             istart, iend = self._indptr[i], self._indptr[i + 1]
199:             if iend == istart:
200:                 continue  # isolated vertex
201:             # pick a random neighbor j
202:             j = int(self.rng.choice(self._indices[istart:iend]))
203:             bi, bj = blocks[i], blocks[j]
204:             if bi == bj:
205:                 continue  # need a crossâblock edge
206:             proposed_changes: ProposedValidChanges = [(i, bj), (j, bi)]
207:             break
208:         else:  # all trials failed â fall back to uniform swap
209:             return super().propose_change(changes=None)
210:         delta_e = self._compute_delta_edge_counts(
211:             proposed_changes=proposed_changes,
212:             use_numpy=self.use_numpy,
213:         )
214:         delta_n: CombinationDelta = defaultdict(int)  # block sizes unchanged
215:         return proposed_changes, delta_e, delta_n
216: # -----------------------------------------------------------------------------
217: #  Triadic informed swap   (new implementation)
218: # -----------------------------------------------------------------------------
219: class TriadicSwapProposer(NodeSwapProposer):
220:     """A *threeâvertex* informed swap.
221:     Strategy
222:     --------
223:     1. Pick a random vertex ``i`` (block *A*).
224:     2. Choose a random neighbour ``j`` with ``block(j) = B \neq A``.
225:     3. Search in block *B* for a vertex ``l \ne j`` that has **at least one**
226:        neighbour in block *A*.
227:     4. Swap the block labels of ``i`` and ``l``.
228:     Swapping these two vertices reduces the expected number of *cross* edges by
229:     converting:
230:     * all edges from ``i`` into *B* to *internal*, and
231:     * all edges from `l``` into *A* to *internal*,
232:     while typically adding fewer new cross edges because ``i`` and ``j'`` were
233:     originally âboundaryâ vertices.
234:     The proposal distribution is still *symmetric* because every triad is
235:     selected with the same probability in either direction, so the usual MH
236:     acceptance rule applies.
237:     """
238:     def __init__(
239:         self,
240:         block_data,
241:         rng: np.random.Generator = np.random.default_rng(1),
242:         use_numpy: bool = False,
243:         max_trials: int = 128,
244:         candidate_trials: int = 64,
245:     ) -> None:
246:         super().__init__(block_data=block_data, rng=rng, use_numpy=use_numpy)
247:         self.max_trials = max_trials            # attempts to find (i,j)
248:         self.candidate_trials = candidate_trials  # attempts to find jâ² per (i,j)
249:         self._indptr = self.block_data.graph_data.adjacency.indptr
250:         self._indices = self.block_data.graph_data.adjacency.indices
251:     # ------------------------------------------------------------------
252:     def propose_change(
253:         self,
254:         changes: Optional[ProposedValidChanges] = None,
255:     ) -> Tuple[ProposedValidChanges, EdgeDelta, CombinationDelta]:
256:         # Explicitâchanges path used in unit tests
257:         if changes is not None:
258:             return super().propose_change(changes=changes)
259:         n = self.block_data.graph_data.num_nodes  # type: ignore[attr-defined]
260:         blocks = self.block_data.blocks
261:         for _ in range(self.max_trials):
262:             # ---- step 1: pick i ------------------------------------------------
263:             i = int(self.rng.integers(n))
264:             # find i's neighbour index-range (adj is csr format)
265:             istart, iend = self._indptr[i], self._indptr[i + 1]
266:             if iend == istart:
267:                 continue  # isolated â try another
268:             # ---- step 2: pick neighbour j in a *different* block --------------
269:             neighs_i = self._indices[istart:iend]
270:             j = int(self.rng.choice(neighs_i))
271:             a, b = blocks[i], blocks[j]
272:             if a == b:
273:                 continue  # need a cross edge iâj
274:             # ---- step 3: find jâ² in block b that touches block a --------------
275:             block_b_members = self.block_data.block_members[b]
276:             # change to list and randomlize order
277:             block_b_members = list(block_b_members)
278:             self.rng.shuffle(block_b_members)
279:             for l in block_b_members[:self.candidate_trials]:
280:                 if l in (i, j):
281:                     continue
282:                 # find neighbors of l in block a
283:                 lstart, lend = self._indptr[l], self._indptr[l + 1]
284:                 l_neighbors = self._indices[lstart:lend]
285:                 l_neighbor_in_block_a = any(
286:                     blocks[neighbor] == a for neighbor in l_neighbors
287:                 )
288:                 if not l_neighbor_in_block_a:
289:                     continue  # l must touch block a
290:                 proposed_changes: ProposedValidChanges = [(i, b), (l, a)]
291:                 delta_e = self._compute_delta_edge_counts(
292:                     proposed_changes=proposed_changes,
293:                     use_numpy=self.use_numpy,
294:                 )
295:                 delta_n: CombinationDelta = defaultdict(int)
296:                 return proposed_changes, delta_e, delta_n
297:             # could not find jâ² â back to outer loop
298:             continue
299:         # ---- fallback --------------------------------------------------------
300:         # If every attempt failed (e.g. almost perfect partition), fall back to
301:         # a plain uniform swap to keep the chain ergodic.
302:         return super().propose_change(changes=None)
303: # -----------------------------------------------------------------------------#
304: #  Cross-triangle (cross-wedge) swap proposer                                   #
305: # -----------------------------------------------------------------------------#
306: class CrossTriangleSwapProposer(NodeSwapProposer):
307:     """
308:     Swap the *odd* vertex of an open cross-wedge.
309:     1. Draw a **cross edge** (i,j) uniformly at random.
310:     2. Pick a random neighbour k of j such that block(k) == block(i) (i.e. an
311:        *open wedge* i-j-k with i,k in the same block, j outside that block).
312:     3. Swap the block labels of *i* and *j*.
313:     When i-k are **not directly connected**, the move converts two cross edges
314:     (i,j) and (j,k) into one cross edge (i,j) and one *internal* edge (j,k),
315:     giving a positive Î log-likelihood in expectation.  Proposal is symmetric.
316:     """
317:     def __init__(
318:         self,
319:         block_data: BlockData,
320:         rng: np.random.Generator = np.random.default_rng(1),
321:         use_numpy: bool = True,
322:         max_trials: int = 256,
323:         neighbour_trials: int = 8,
324:     ) -> None:
325:         super().__init__(block_data=block_data, rng=rng, use_numpy=use_numpy)
326:         self.max_trials = max_trials
327:         self.neighbour_trials = neighbour_trials
328:         self._indptr = self.block_data.graph_data.adjacency.indptr
329:         self._indices = self.block_data.graph_data.adjacency.indices
330:     # ------------------------------------------------------------------
331:     def propose_change(
332:         self,
333:         changes: Optional[ProposedValidChanges] = None,
334:     ) -> Tuple[ProposedValidChanges, EdgeDelta, CombinationDelta]:
335:         if changes is not None:                     # path for unit tests
336:             return super().propose_change(changes)
337:         n = self.block_data.graph_data.num_nodes    # type: ignore[attr-defined]
338:         blocks = self.block_data.blocks
339:         for _ in range(self.max_trials):
340:             # ---- pick a random edge -----------------------------------------
341:             i = int(self.rng.integers(n))
342:             istart, iend = self._indptr[i], self._indptr[i + 1]
343:             if istart == iend:
344:                 continue                            # i is isolated
345:             j = int(self.rng.choice(self._indices[istart:iend]))
346:             bi, bj = blocks[i], blocks[j]
347:             if bi == bj:
348:                 continue                            # need a cross edge
349:             # ---- search a neighbour k of j inside block bi ------------------
350:             jstart, jend = self._indptr[j], self._indptr[j + 1]
351:             nbrs_j = self._indices[jstart:jend]
352:             if len(nbrs_j) == 0:
353:                 continue
354:             # sample up to neighbour_trials neighbours
355:             cand = self.rng.choice(
356:                 nbrs_j,
357:                 size=min(self.neighbour_trials, len(nbrs_j)),
358:                 replace=False,
359:             )
360:             k = next((int(v) for v in cand if blocks[v] == bi and v != i), None)
361:             if k is None:
362:                 continue                            # wedge not found
363:             # ---- valid cross-wedge: swap i and j ----------------------------
364:             proposed_changes: ProposedValidChanges = [(i, bj), (j, bi)]
365:             delta_e = self._compute_delta_edge_counts(
366:                 proposed_changes=proposed_changes,
367:                 use_numpy=self.use_numpy,
368:             )
369:             delta_n: CombinationDelta = defaultdict(int)
370:             return proposed_changes, delta_e, delta_n
371:         # fallback to uniform swap
372:         return super().propose_change(changes=None)
373: # -----------------------------------------------------------------------------#
374: #  Twin-leaf swap proposer                                                     #
375: # -----------------------------------------------------------------------------#
376: class TwinLeafSwapProposer(NodeSwapProposer):
377:     """
378:     Swap two *leaves* whose neighbours lie in each otherâs blocks.
379:     1. Pick a random **leaf** i (deg=1) whose neighbour u is in block B != block(i).
380:     2. Inside block B, look for another leaf k (deg=1, kâ i) whose sole neighbour
381:        v lies in block A = block(i).
382:     3. Swap the labels of i and k.
383:     This move removes two cross edges and introduces *zero* new ones, because
384:     leaves have no other connections.  Works great on heavy-tailed networks.
385:     """
386:     def __init__(
387:         self,
388:         block_data: BlockData,
389:         rng: np.random.Generator = np.random.default_rng(1),
390:         use_numpy: bool = True,
391:         max_trials: int = 256,
392:         partner_trials: int = 32,
393:     ) -> None:
394:         super().__init__(block_data=block_data, rng=rng, use_numpy=use_numpy)
395:         self.max_trials = max_trials
396:         self.partner_trials = partner_trials
397:         self._indptr = self.block_data.graph_data.adjacency.indptr
398:         self._indices = self.block_data.graph_data.adjacency.indices
399:     # ------------------------------------------------------------------
400:     def _is_leaf(self, v: int) -> bool:
401:         return (self._indptr[v + 1] - self._indptr[v]) == 1
402:     # ------------------------------------------------------------------
403:     def propose_change(
404:         self,
405:         changes: Optional[ProposedValidChanges] = None,
406:     ) -> Tuple[ProposedValidChanges, EdgeDelta, CombinationDelta]:
407:         if changes is not None:
408:             return super().propose_change(changes)
409:         n = self.block_data.graph_data.num_nodes    # type: ignore[attr-defined]
410:         blocks = self.block_data.blocks
411:         for _ in range(self.max_trials):
412:             # ---- step 1: choose a random leaf i -----------------------------
413:             i = int(self.rng.integers(n))
414:             if not self._is_leaf(i):
415:                 continue
416:             # unique neighbour of i
417:             u = int(self._indices[self._indptr[i]])
418:             a, b = blocks[i], blocks[u]
419:             if a == b:
420:                 continue                            # internal leaf â ignore
421:             # ---- step 2: search leaf partner k in block b -------------------
422:             block_b_members = list(self.block_data.block_members[b])
423:             if len(block_b_members) <= 1:
424:                 continue
425:             self.rng.shuffle(block_b_members)
426:             trials = 0
427:             for k in block_b_members:
428:                 if trials >= self.partner_trials:
429:                     break
430:                 trials += 1
431:                 if k == i or (not self._is_leaf(k)):
432:                     continue
433:                 v = int(self._indices[self._indptr[k]])
434:                 if blocks[v] != a:                  # neighbour must lie in block a
435:                     continue
436:                 # ---- valid twin leaves found: swap i,k ----------------------
437:                 proposed_changes: ProposedValidChanges = [(i, b), (k, a)]
438:                 delta_e = self._compute_delta_edge_counts(
439:                     proposed_changes=proposed_changes,
440:                     use_numpy=self.use_numpy,
441:                 )
442:                 delta_n: CombinationDelta = defaultdict(int)
443:                 return proposed_changes, delta_e, delta_n
444:             # partner not found â try another i
445:             continue
446:         # fallback
447:         return super().propose_change(changes=None)

================
File: src/sbm/graph_data.py
================
 1: from scipy.sparse import csr_array
 2: import networkx as nx
 3: class GraphData:
 4:     def __init__(self, adjacency_matrix: csr_array, directed=False):
 5:         if not isinstance(adjacency_matrix, csr_array):
 6:             raise ValueError("Adjacency matrix must be a scipy.sparse.csr_array")
 7:         self.adjacency = adjacency_matrix.astype(int)
 8:         self.directed: bool= directed
 9:         self.num_nodes = self.adjacency.shape[0] # type: ignore
10:         if directed:
11:             self.total_edges = int(self.adjacency.sum())
12:         else:
13:             self.total_edges = int(self.adjacency.sum() / 2)  # For undirected graphs
14:         def __len__(self):
15:             return self.num_nodes
16: def gd_from_networkx(G: nx.Graph) -> GraphData:
17:     """
18:     Create a GraphData instance from a NetworkX graph.
19:     """
20:     if not hasattr(G, 'adjacency'):
21:         raise ValueError("The provided graph must have an adjacency matrix.")
22:     # for new version of networkx
23:     #adj = nx.to_scipy_sparse_matrix(G)
24:     # for old version of networkx
25:     adj = nx.to_scipy_sparse_matrix(G)
26:     adj = csr_array(adj)
27:     return GraphData(adj, directed=G.is_directed())

================
File: src/sbm/model.py
================
  1: from typing import Dict, Optional
  2: import numpy as np
  3: from scipy.sparse import csr_array
  4: from sbm.block_data import BlockData
  5: from sbm.likelihood import (
  6:     LikelihoodCalculator,
  7:     LikelihoodType,
  8: )
  9: from sbm.block_change_proposers import (
 10:     NodeSwapProposer,
 11:     EdgeBasedSwapProposer,
 12:     TriadicSwapProposer,
 13:     CrossTriangleSwapProposer,
 14:     TwinLeafSwapProposer
 15: )
 16: from sbm.node_mover import NodeMover
 17: from sbm.mcmc import MCMCAlgorithm
 18: from sbm.io import SBMFit
 19: from sbm.utils.logger import CSVLogger
 20: class SBMModel:
 21:     def __init__(self,
 22:                 initial_blocks: BlockData,
 23:                 rng: np.random.Generator,
 24:                 likelihood_type: LikelihoodType = "bernoulli",
 25:                 log: bool = True,
 26:                 change_freq = { # probabilities of trying each move type
 27:                     "edge_based_swap": 1.0,
 28:                 }
 29:         ):
 30:         self._best_block_assignment = None
 31:         self._best_block_conn = None
 32:         self.block_data = initial_blocks
 33:         self.rng = rng
 34:         self.likelihood_calculator = LikelihoodCalculator(
 35:             block_data=self.block_data,
 36:             likelihood_type=likelihood_type
 37:             )
 38:         self.move_executor = NodeMover(
 39:             block_data=self.block_data,
 40:             )
 41:         change_proposer = {
 42:             "uniform_swap": NodeSwapProposer(
 43:                         block_data=self.block_data,
 44:                         rng=self.rng,
 45:                         use_numpy=True,
 46:                     ),
 47:             "edge_based_swap": EdgeBasedSwapProposer(
 48:                         block_data=self.block_data,
 49:                         rng=self.rng,
 50:                         use_numpy=False,
 51:                     ),
 52:             "triadic_swap": TriadicSwapProposer(
 53:                         block_data=self.block_data,
 54:                         rng=self.rng,
 55:                         use_numpy=True,
 56:                     ),
 57:             "twin_leaf": TwinLeafSwapProposer(
 58:                         block_data=self.block_data,
 59:                         rng=self.rng,
 60:                         use_numpy=True,
 61:                     ),
 62:             "cross_triangle": CrossTriangleSwapProposer(
 63:                         block_data=self.block_data,
 64:                         rng=self.rng,
 65:                         use_numpy=True,
 66:                     ),
 67:         }
 68:         self.mcmc_algorithm = MCMCAlgorithm(
 69:             block_data = self.block_data,
 70:             likelihood_calculator = self.likelihood_calculator,
 71:             change_proposer = change_proposer, # type: ignore
 72:             change_freq = change_freq, # type: ignore
 73:             rng = self.rng,
 74:             log=log
 75:         )
 76:     def fit(self,
 77:         min_block_size: int,
 78:         cooling_rate: float,
 79:         max_blocks: Optional[int] = None,
 80:         logger: Optional[CSVLogger] = None,
 81:         patience: Optional[int] = None,
 82:         return_nll: bool = False,
 83:         max_num_iterations: int=int(10**6),
 84:         initial_temperature: float=1.0,
 85:         ):
 86:         nll = self.mcmc_algorithm.fit(
 87:             max_num_iterations=max_num_iterations,
 88:             min_block_size=min_block_size,
 89:             initial_temperature=initial_temperature,
 90:             cooling_rate=cooling_rate,
 91:             max_blocks=max_blocks,
 92:             logger=logger,
 93:             patience=patience,
 94:         )
 95:         if return_nll:
 96:             return nll
 97:     def get_block_assignments(self, best:bool=True) -> Dict[int, int]:
 98:         if best:
 99:             return self.mcmc_algorithm._best_block_assignment
100:         else:
101:             return self.block_data.blocks
102:     def to_sbmfit(self, metadata: Optional[Dict] = None, best:bool=True) -> SBMFit:
103:         """ 
104:         Convert the fitted SBM model to an SBMFit object for serialization. 
105:         """
106:         if metadata is None:
107:             metadata = {}
108:         if best:
109:             blocks = self.mcmc_algorithm._best_block_assignment
110:             block_sizes = np.unique(list(blocks.values()), return_counts=True)[1].tolist()
111:             block_conn = self.mcmc_algorithm._best_block_conn
112:             nll = self.mcmc_algorithm.best_nll
113:         else:
114:             blocks = self.block_data.blocks
115:             block_sizes = list(self.block_data.block_sizes.values())
116:             block_conn = self.block_data.block_connectivity
117:             nll = self.mcmc_algorithm.current_nll
118:         return SBMFit(
119:             block_sizes=block_sizes,
120:             block_conn=csr_array(block_conn),
121:             directed_graph=self.block_data.graph_data.directed,
122:             neg_loglike=nll,
123:             metadata=metadata
124:         )

================
File: src/sbm/node_mover.py
================
 1: from typing import List, Tuple
 2: import scipy.sparse as sp
 3: import numpy as np
 4: from sbm.block_data import BlockData, _BlockDataUpdater
 5: from line_profiler import profile
 6: from sbm.block_change_proposers import (
 7:     ProposedValidChanges,
 8:     EdgeDelta,
 9: )
10: class NodeMover:
11:     """
12:     Class to move nodes between block assignment in the Stochastic Block Model (SBM).
13:     When performing a change, it updates the block sizes, connectivity matrix,
14:     block indices, and inverse block indices accordingly.
15:     All changes are performed in-place on the BlockData object by the _BlockDataUpdater.
16:     """
17:     def __init__(self, block_data: BlockData):
18:         self.block_data_updater = _BlockDataUpdater(block_data)
19:     def perform_change(self,
20:             proposed_changes: ProposedValidChanges,
21:             delta_e: EdgeDelta,
22:             ):
23:         """ 
24:         Change the block assignments of nodes according to the proposed change.
25:         Update:
26:         - block sizes
27:         - block connectivity matrix (edge counts between blocks)
28:         - block indices (node to block assignment)
29:         - inverse block indices (nodes in each block)
30:         Rely on increment_edge_count from BlockData to update edge counts.
31:         :param change: A list of tuples where each tuple contains a node and their new block.
32:         """
33:         (node_i, new_block_i), (node_j, new_block_j) = proposed_changes
34:         # update the block assignments, sizes, and memberships
35:         self.block_data_updater._move_node_to_block(node_i, new_block_i)
36:         self.block_data_updater._move_node_to_block(node_j, new_block_j)
37:         # update the edge counts between the blocks
38:         for (r, s), e_delta in delta_e.items():
39:             self.block_data_updater._increment_edge_count(r, s, e_delta)

================
File: src/tests/test_change_proposer_and_mover.py
================
  1: # src/tests/test_change_proposers_and_mover.py
  2: """
  3: Unit-tests for
  4:   â¢ sbm.block_change_proposers           (helper + NodeSwapProposer)
  5:   â¢ sbm.node_mover                      (NodeMover)
  6: All graphs are 4 undirected vertices:
  7:     0ââ1   block 0 = {0,1}
  8:     â  â
  9:     2ââ3   block 1 = {2,3}
 10: Edges: (0,1) (2,3)  plus two cross edges (0,2) (1,3).
 11: """
 12: from __future__ import annotations
 13: from collections import defaultdict
 14: from typing import Dict, Tuple
 15: import numpy as np
 16: from numpy.typing import ArrayLike
 17: import pytest
 18: from scipy.sparse import csr_array
 19: from sbm.graph_data import GraphData
 20: from sbm.block_data import BlockData
 21: from sbm.block_change_proposers import (
 22:     NodeSwapProposer,
 23:     ProposedValidChanges,
 24:     EdgeBasedSwapProposer,
 25:     TriadicSwapProposer,
 26: )
 27: from sbm.edge_delta import EdgeDelta
 28: from sbm.node_mover import NodeMover
 29: ###############################################################################
 30: # helpers
 31: ###############################################################################
 32: def _toy_graph() -> Tuple[csr_array, Dict[int, int]]:
 33:     """Return 4Ã4 adjacency and initial {node: block} mapping."""
 34:     adj = np.zeros((4, 4), dtype=int)
 35:     edges = [(0, 1), (2, 3), (0, 2), (1, 3)]
 36:     for u, v in edges:
 37:         adj[u, v] = adj[v, u] = 1
 38:     blocks = {0: 0, 1: 0, 2: 1, 3: 1}
 39:     return csr_array(adj), blocks
 40: def _brute_block_connectivity(adj: csr_array, blocks: Dict[int, int]) -> Dict[Tuple[int, int], int]:
 41:     """Return upper-triangle edge counts between blocks."""
 42:     rows, cols = adj.nonzero() # type: ignore
 43:     bc = defaultdict(int)
 44:     for u, v in zip(rows, cols, strict=False):
 45:         if u >= v:  # count each undirected edge once
 46:             continue
 47:         a, b = blocks[u], blocks[v]
 48:         r, s = (a, b) if a <= b else (b, a)
 49:         bc[(r, s)] += 1
 50:     return bc
 51: ###############################################################################
 52: # tests for _increment_delta_e
 53: ###############################################################################
 54: def test_increment_delta_e_uses_sorted_key() -> None:
 55:     e_delta = EdgeDelta(n_blocks=4)
 56:     e_delta.increment(
 57:         counts=[1],
 58:         blocks_i=[3],
 59:         blocks_j=[1],
 60:     )          # block_i > block_j â key (1,3)
 61:     assert ((1, 3), 1) in e_delta.items() and ((3, 1), 1) not in e_delta.items(), \
 62:         f"Key mismatch: delta keys = {list(e_delta.items())}"
 63: def test_increment_delta_e_overwrites_existing() -> None:
 64:     e_delta = EdgeDelta(n_blocks=4)
 65:     e_delta.increment(
 66:         counts = [1],
 67:         blocks_i = [0],
 68:         blocks_j = [2],
 69:     )          # set to 1
 70:     e_delta.increment(
 71:         counts = [3],
 72:         blocks_i = [2],
 73:         blocks_j = [0]
 74:     )          # overwrite same pair
 75:     assert e_delta[(0, 2)] == 3, \
 76:         f"Value not overwritten, got {e_delta[(0, 2)]}, expected 3"
 77: ###############################################################################
 78: # tests for NodeSwapProposer
 79: ###############################################################################
 80: @pytest.fixture(scope="module")
 81: def proposer() -> NodeSwapProposer:
 82:     adj, blocks = _toy_graph()
 83:     bd = BlockData(initial_blocks=blocks, graph_data=GraphData(adj, directed=False))
 84:     return NodeSwapProposer(block_data=bd, rng=np.random.default_rng(0))
 85: def test_compute_delta_edge_counts_matches_brute(proposer: NodeSwapProposer) -> None:
 86:     # swap vertices 0 (block 0) and 2 (block 1)
 87:     changes: ProposedValidChanges = [(0, 1), (2, 0)]
 88:     delta = proposer._compute_delta_edge_counts(changes)          # type: ignore
 89:     before = _brute_block_connectivity(
 90:         proposer.block_data.graph_data.adjacency,
 91:         proposer.block_data.blocks
 92:     )
 93:     # build new blocks mapping
 94:     new_blocks = proposer.block_data.blocks.copy()
 95:     new_blocks[0], new_blocks[2] = new_blocks[2], new_blocks[0]
 96:     after = _brute_block_connectivity(proposer.block_data.graph_data.adjacency,
 97:                                       new_blocks)
 98:     brute_delta = {k: after.get(k, 0) - before.get(k, 0) for k in set(after) | set(before)}
 99:     delta_dict = dict(delta.items())
100:     assert delta_dict == brute_delta, \
101:         f"\nexpected {brute_delta}\ngot      {delta_dict}"
102: def test_propose_change_returns_expected_structure(proposer: NodeSwapProposer) -> None:
103:     changes = [(0, 1), (2, 0)]
104:     new_changes, delta_e, delta_n = proposer.propose_change(changes=changes)
105:     assert new_changes == changes, "proposer changed explicit instruction"
106:     assert all(isinstance(k, tuple) and len(k) == 2 for k in delta_e.items()), "delta_e keys malformed"
107:     # check that all kays of delta_e are accesible in delta_n (not necessarily non-zero)
108:     for (i, j), _ in delta_e.items():
109:         try:
110:             _ = delta_n[(i, j)]
111:         except KeyError:
112:             pytest.fail(f"delta_n missing key ({i}, {j}) from delta_e: {delta_e.items()}")
113: ###############################################################################
114: # tests for NodeMover
115: ###############################################################################
116: def test_node_mover_updates_blocks_and_sizes() -> None:
117:     adj, blocks = _toy_graph()
118:     bd = BlockData(initial_blocks=blocks, graph_data=GraphData(adj, directed=False))
119:     mover = NodeMover(bd)
120:     changes = [(0, 1), (2, 0)]
121:     # reuse proposer to get correct delta_e
122:     prop = NodeSwapProposer(block_data=bd, rng=np.random.default_rng(0))
123:     delta_e = prop._compute_delta_edge_counts(changes)            # type: ignore
124:     mover.perform_change(changes, delta_e)
125:     assert bd.blocks[0] == 1 and bd.blocks[2] == 0, \
126:         f"blocks not swapped: {bd.blocks}"
127:     assert bd.block_sizes[0] == 2 and bd.block_sizes[1] == 2, \
128:         f"block_sizes wrong: {bd.block_sizes}"
129: def test_node_mover_updates_connectivity() -> None:
130:     adj, blocks = _toy_graph()
131:     bd = BlockData(initial_blocks=blocks, graph_data=GraphData(adj, directed=False))
132:     mover = NodeMover(bd)
133:     before = bd.block_connectivity.copy()
134:     changes = [(0, 1), (2, 0)]
135:     prop = NodeSwapProposer(block_data=bd, rng=np.random.default_rng(0))
136:     delta_e = prop._compute_delta_edge_counts(changes)            # type: ignore
137:     mover.perform_change(changes, delta_e)
138:     # brute recompute
139:     after_brute = _brute_block_connectivity(bd.graph_data.adjacency, bd.blocks)
140:     # connectivity matrix stores both triangles â pick upper
141:     after_matrix = {(r, s): int(bd.block_connectivity[r, s]) #type: ignore
142:                     for r, s in after_brute}
143:     msg = (f"\nexpected connectivity {after_brute}"
144:            f"\nobserved  connectivity {after_matrix}"
145:            f"\ndelta_e applied        {delta_e}")
146:     assert after_matrix == after_brute, msg
147: # ---------------------------------------------------------------------------
148: # helpers â minimal blockâedge accounting for validation
149: # ---------------------------------------------------------------------------
150: def _block_edge_matrix(adj: csr_array, blocks: np.ndarray, n_blocks: int) -> np.ndarray:
151:     """Return an n_blocksÃn_blocks symmetric matrix with edge counts."""
152:     mat = np.zeros((n_blocks, n_blocks), dtype=int)
153:     rows, cols = adj.nonzero()
154:     for u, v in zip(rows, cols):
155:         if u >= v:  # undirected â count each unordered pair once
156:             continue
157:         bu, bv = blocks[u], blocks[v]
158:         mat[bu, bv] += 1
159:         if bu != bv:
160:             mat[bv, bu] += 1
161:     return mat
162: def _apply_changes(blocks: np.ndarray, changes):
163:     new_blocks = blocks.copy()
164:     for node, tgt in changes:
165:         new_blocks[node] = tgt
166:     return new_blocks
167: def _assert_delta_matches(delta_e, before, after):
168:     """Check that EdgeDelta equals afterâbefore for every block pair."""
169:     n_blocks = before.shape[0]
170:     for r in range(n_blocks):
171:         for s in range(n_blocks):
172:             assert delta_e[r, s] == after[r, s] - before[r, s]
173: # ---------------------------------------------------------------------------
174: # fixtures
175: # ---------------------------------------------------------------------------
176: @pytest.fixture(scope="module")
177: def toy_block_data():
178:     """Simple 6ânode, 2âblock undirected graph with both intraâ and crossâedges."""
179:     edges = [
180:         (0, 1), (1, 2), (0, 2),  # block 0 internal triangle
181:         (3, 4), (4, 5), (3, 5),  # block 1 internal triangle
182:         (0, 3), (1, 4), (2, 5),  # three cross edges
183:     ]
184:     n = 6
185:     rows, cols = [], []
186:     for u, v in edges:
187:         rows += [u, v]
188:         cols += [v, u]
189:     data = np.ones(len(rows), dtype=int)
190:     adj = csr_array((data, (rows, cols)), shape=(n, n))
191:     blocks = {0: 0, 1: 0, 2: 0, 3: 1, 4: 1, 5: 1}  # type: ignore[assignment]
192:     bd = BlockData(initial_blocks=blocks, graph_data=GraphData(adj, directed=False))
193:     return bd
194: # ---------------------------------------------------------------------------
195: # tests â EdgeBasedSwapProposer
196: # ---------------------------------------------------------------------------
197: def test_edge_based_swap_valid_move(toy_block_data):
198:     rng = np.random.default_rng(42)
199:     prop = EdgeBasedSwapProposer(toy_block_data, rng=rng)
200:     changes, delta_e, _ = prop.propose_change()
201:     # exactly two tuples returned
202:     assert len(changes) == 2
203:     (i, tgt_i), (j, tgt_j) = changes
204:     blocks = toy_block_data.blocks
205:     # originally different blocks and connected by an edge
206:     assert blocks[i] != blocks[j]
207:     assert toy_block_data.graph_data.adjacency[i, j] == 1  # type: ignore[index]
208:     # swap  semantics: targets are the partner's old blocks
209:     assert tgt_i == blocks[j]
210:     assert tgt_j == blocks[i]
211:     # edgeâdelta correctness --------------------------------------------------
212:     before = _block_edge_matrix(toy_block_data.graph_data.adjacency, blocks,  # type: ignore[attr-defined]
213:                                 n_blocks=2)
214:     after_blocks = _apply_changes(blocks, changes)
215:     after = _block_edge_matrix(toy_block_data.graph_data.adjacency, after_blocks, 2)
216:     _assert_delta_matches(delta_e, before, after)
217: # ---------------------------------------------------------------------------
218: # tests â TriadicSwapProposer
219: # ---------------------------------------------------------------------------
220: def test_triadic_swap_valid_move(toy_block_data):
221:     rng = np.random.default_rng(7)
222:     prop = TriadicSwapProposer(toy_block_data, rng=rng, candidate_trials=20)
223:     changes, delta_e, _ = prop.propose_change()
224:     # two tuples returned
225:     assert len(changes) == 2
226:     (i, tgt_i), (l, tgt_l) = changes
227:     blocks = toy_block_data.blocks
228:     # i moves to l's block and viceâversa
229:     assert tgt_i == blocks[l]
230:     assert tgt_l == blocks[i]
231:     # block sizes preserved ---------------------------------------------------
232:     block_sizes = toy_block_data.block_sizes
233:     after_blocks = _apply_changes(blocks, changes)
234:     new_block_sizes = {
235:         b: sum(1 for v in after_blocks.values() if v == b)
236:         for b in set(after_blocks.values())
237:     }
238:     for block, size in new_block_sizes.items():
239:         assert size == block_sizes[block], \
240:             f"Block {block} size changed: expected {block_sizes[block]}, got {size}"
241:     # deltaâedge correctness --------------------------------------------------
242:     before = _block_edge_matrix(toy_block_data.graph_data.adjacency, blocks, 2)  # type: ignore[attr-defined]
243:     after = _block_edge_matrix(toy_block_data.graph_data.adjacency, after_blocks, 2)
244:     _assert_delta_matches(delta_e, before, after)

================
File: setup.cfg
================
 1: [metadata]
 2: name = anon-sbm
 3: version = 0.1.0
 4: author = Lasse Mohr
 5: author_email = lmmi@dtu.dk
 6: description = Package for SBM with minimum group-size constraints
 7: long_description = file: README.md
 8: long_description_content_type = text/markdown
 9: classifiers =
10:     Programming Language :: Python :: 3
11:     License :: OSI Approved :: MIT License
12:     Operating System :: OS Independent
13: 
14: [options]
15: package_dir =
16:     =src
17: packages = find:
18: python_requires = >=3.12.0
19: install_requires =
20:     numpy
21:     scipy
22:     networkx
23:     metis
24:     k-means-constrained
25:     nodevectors
26:     tqdm
27:     scikit-learn
28:     pytest
29:     line_profiler
30: 
31: [options.packages.find]
32: where = src

================
File: src/pipelines/fit_sbm.py
================
 1: # src/pipelines/fit_sbm.py
 2: import yaml
 3: import argparse
 4: from pathlib import Path
 5: from itertools import product
 6: from line_profiler import profile
 7: from time import time
 8: import numpy as np
 9: from tqdm import tqdm
10: from sbm.io import GraphLoader, SBMWriter
11: from sbm.block_assigner import AssignerConstructor
12: from sbm.model import SBMModel
13: from sbm.utils.logger import CSVLogger
14: from sbm.utils.pipeline_utils import (
15:     sbmfit_folderpath,
16:     FitConfig,
17: )
18: @profile
19: def main(fit_config: str): # type: ignore
20:     fit_config: FitConfig = yaml.safe_load(Path(fit_config).read_text())
21:     logging_config = fit_config["logging"][0] # type: ignore
22:     data_config = fit_config["datasets"] # type: ignore
23:     seed = fit_config['seed']
24:     rng = np.random.default_rng(seed)
25:     config_pairs = product(
26:         fit_config['sbm'], # type: ignore
27:         fit_config['datasets'], # type: ignore
28:     )
29:     iterator = tqdm(
30:         config_pairs,
31:         desc="Fitting SBM models",
32:         total=len(fit_config['sbm']) * len(fit_config['datasets'])
33:     )
34:     for sbm_config, ds in iterator:
35:         # prepare SBM model
36:         g = GraphLoader.load(
37:             Path(ds["path"]),
38:             force_undirected=bool(sbm_config["force_undirected"]), # type: ignore
39:             )
40:         assigner_const = AssignerConstructor(rng=rng)
41:         assigner = assigner_const.create_assigner(
42:             graph_data=g,
43:             min_block_size=int(sbm_config["min_block_size"]), # type: ignore
44:             init_method=sbm_config["init_method"], # type: ignore
45:             )
46:         block_data = assigner.compute_assignment()
47:         # check block sizes
48:         model = SBMModel(
49:             initial_blocks=block_data,
50:             rng=rng)
51:         # fit SBM model
52:         name = ds["name"] + "_".join(
53:             f"{k}_{v}" for k, v in sbm_config.items() # type: ignore
54:         )
55:         log_path = Path(logging_config['logging_folder']) / f"{name}.csv"
56:         tic = time()
57:         with CSVLogger(log_path, log_every=logging_config['log_every']) as logger:
58:             model.fit(
59:                 min_block_size=sbm_config["min_block_size"], # type: ignore
60:                 cooling_rate=sbm_config["cooling_rate"], # type: ignore
61:                 logger=logger,
62:             )
63:         # save the fitted model
64:         fit = model.to_sbmfit()
65:         toc = time()
66:         print(f"Fitting {ds['name']} took {toc - tic:.2f} seconds")
67:         tic = time()
68:         fit_configs = sbm_config.copy() # type: ignore
69:         out_dir = sbmfit_folderpath(
70:             base_dir=Path("results/sbm_fits"),
71:             sbm_config=fit_configs,
72:             data_spec=ds, 
73:         )
74:         print(f'Out directory: {out_dir}')
75:         out_dir.mkdir(parents=True, exist_ok=True)
76:         SBMWriter.save(out_dir, fit)
77:         toc = time()
78:         print(f"Saving {ds['name']} took {toc - tic:.2f} seconds, nll = {fit.neg_loglike:.2f}")
79: if __name__ == "__main__":
80:     p = argparse.ArgumentParser()
81:     p.add_argument("--fit_config", type=str, help="Path to the configuration file.")
82:     args = p.parse_args()
83:     main(fit_config=args.fit_config)

================
File: src/sbm/io.py
================
  1: from typing import Dict, Callable, Iterable, Tuple, Optional
  2: from pathlib import Path
  3: from dataclasses import dataclass
  4: import json
  5: import gzip
  6: import numpy as np
  7: from scipy.sparse import csr_array, csr_array, load_npz, coo_matrix
  8: from scipy.io import mmread
  9: import networkx as nx                                # light dep
 10: import numpy as np
 11: from scipy.sparse import load_npz, save_npz
 12: from scipy.sparse import csr_array
 13: from sbm.graph_data import GraphData
 14: # src/sbm/io.py
 15: @dataclass
 16: class SBMFit:
 17:     block_sizes: list[int]
 18:     block_conn: csr_array
 19:     directed_graph: bool # if undirected, only upper triangle is stored
 20:     neg_loglike: float
 21:     metadata: dict
 22: class SBMWriter:
 23:     @staticmethod
 24:     def save(path: Path, fit: SBMFit) -> None:
 25:         """ save SBM fit to file """
 26:         path.mkdir(parents=True, exist_ok=True)
 27:         clean_sizes  = [int(s) for s in fit.block_sizes]
 28:         (path / "block_sizes.json").write_text(json.dumps(clean_sizes))
 29:         # save sparce block connectivity matrix using scipy
 30:         with open(path / "block_connectivity.npz", 'wb') as file:
 31:             save_npz(file, fit.block_conn, compressed=True)
 32:         (path / "directed_graph.txt").write_text(str(fit.directed_graph))
 33:         (path / "neg_loglike.txt").write_text(str(fit.neg_loglike))
 34:         with open(path / "metadata.json", 'w') as f:
 35:             json.dump(fit.metadata, f)
 36:     @staticmethod
 37:     def load(path: Path, silence:bool=False) -> SBMFit:
 38:         if not silence:
 39:             print(f"Loading SBM fit from {path}")
 40:         with open(path / "block_sizes.json", 'r') as sizes_file:
 41:             block_sizes = json.load(sizes_file)
 42:         block_sizes = [int(size) for size in block_sizes]
 43:         with open(path / "block_connectivity.npz", 'rb') as conn_file:
 44:             block_conn = load_npz(conn_file)
 45:         directed_graph = path / "directed_graph.txt"
 46:         directed_graph = (path / "directed_graph.txt").read_text().strip().lower() == 'true'
 47:         neg_loglike = float((path / "neg_loglike.txt").read_text().strip())
 48:         with open(path / "metadata.json", 'r') as f:
 49:             metadata = json.load(f)
 50:         return SBMFit(
 51:             #blocks=blocks,
 52:             block_sizes=block_sizes,
 53:             block_conn=csr_array(block_conn),
 54:             directed_graph=directed_graph,
 55:             neg_loglike=neg_loglike,
 56:             metadata=metadata
 57:         )
 58: # ---------------------------------------------------------------------
 59: #  GraphLoader
 60: # ---------------------------------------------------------------------
 61: class GraphLoader:
 62:     """
 63:     Factory that maps a file *extension* to a loader function and returns
 64:     a `GraphData` object (CSR adjacency + directed flag).
 65:     Register new loaders with the `@GraphLoader.register('.ext')`
 66:     decorator.
 67:     """
 68:     # maps extension (lower-case, incl. leading dot) -> callable
 69:     registry: Dict[str, Callable[[Path], Tuple[csr_array, bool]]] = {}
 70:     # ----------------------- decorator -------------------------------
 71:     @classmethod
 72:     def register(cls, *exts: str):
 73:         """
 74:         Use as::
 75:             @GraphLoader.register('.gml', '.graphml')
 76:             def _load_graphml(path): ...
 77:         """
 78:         def decorator(fn: Callable[[Path], Tuple[csr_array, bool]]):
 79:             for ext in exts:
 80:                 cls.registry[ext.lower()] = fn
 81:             return fn
 82:         return decorator
 83:     # ----------------------- public API ------------------------------
 84:     @staticmethod
 85:     def load(
 86:         path: Path,
 87:         *,
 88:         directed: Optional[bool] = None,
 89:         force_undirected: Optional[bool] = None
 90:     ) -> GraphData:
 91:         """Load graph at *path* and return GraphData."""
 92:         ext = path.suffix.lower()
 93:         if ext not in GraphLoader.registry:
 94:             raise ValueError(
 95:                 f"GraphLoader: no loader registered for extension '{ext}'."
 96:             )
 97:         adj, is_directed = GraphLoader.registry[ext](path)
 98:         # allow caller to override detection
 99:         if directed is not None:
100:             is_directed = bool(directed)
101:         # if caller wants undirected, symmetrise the adjacency matrix
102:         if force_undirected:
103:             if is_directed:
104:                 adj = adj.maximum(adj.T)
105:             is_directed = False
106:         adj = csr_array(adj, dtype=np.int8)  # ensure type is int8
107:         return GraphData(adjacency_matrix=adj, directed=is_directed)
108:     # ---------------- default loaders -------------------------------
109: # 1. compressed / plain .npz containing a CSR adjacency ----------------
110: @GraphLoader.register(".npz")
111: def _load_npz(path: Path) -> Tuple[csr_array, bool]:
112:     adj = load_npz(path)
113:     directed = _is_directed(adj)
114:     return adj.tocsr(), directed
115: # 2. Matrix Market -----------------------------------------------------
116: @GraphLoader.register(".mtx")
117: def _load_mtx(path: Path) -> Tuple[csr_array, bool]:
118:     adj = mmread(str(path))
119:     adj = csr_array(adj, dtype=np.int8)
120:     directed = _is_directed(adj)
121:     return adj, directed
122: # 3. Plain edge list (.edges, .edgelist, .txt, optional .gz) -----------
123: @GraphLoader.register(".edges", ".edgelist", ".txt", ".gz")
124: def _load_edgelist(path: Path) -> Tuple[csr_array, bool]:
125:     opener = gzip.open if path.suffix == ".gz" else open
126:     rows, cols = [], []
127:     if not path.exists():
128:         raise FileNotFoundError(f"GraphLoader: file {path} does not exist.")
129:     with opener(path, "rt") as f:
130:         for line in f:
131:             if not line.strip() or line.startswith("#"):
132:                 continue
133:             u, v = map(int, line.split()[:2])
134:             rows.append(u)
135:             cols.append(v)
136:     n = max(rows + cols) + 1
137:     data = np.ones(len(rows), dtype=np.int8)
138:     adj = coo_matrix((data, (rows, cols)), shape=(n, n)).tocsr()
139:     directed = _is_directed(adj)
140:     if not directed:            # symmetrise if undirected
141:         adj = adj.maximum(adj.T)
142:     adj = csr_array(adj, dtype=np.int8)  # ensure type is int8
143:     return adj, directed
144: # 4. GML / GraphML via NetworkX ---------------------------------------
145: @GraphLoader.register(".gml", ".graphml")
146: def _load_graphml(path: Path) -> Tuple[csr_array, bool]:
147:     G = nx.read_gml(path) if path.suffix == ".gml" else nx.read_graphml(path)
148:     directed = G.is_directed()
149:     # new version of networkx
150:     #adj = nx.to_scipy_sparse_array(G, format="csr", dtype=np.int8)
151:     # old version of networkx
152:     adj = nx.to_scipy_sparse_matrix(G, format="csr", dtype=np.int8)
153:     if not directed:
154:         adj = adj.maximum(adj.T)
155:     return adj, directed
156: # ---------------- helper ----------------------------------------------
157: def _is_directed(adj:  csr_array, tol: int = 0) -> bool:
158:     """
159:     Quick symmetric test for an unweighted adjacency.
160:     `tol` is an integer threshold: if more than `tol` entries differ,
161:     we declare the graph directed.
162:     """
163:     diff = adj - adj.T
164:     return diff.count_nonzero() > tol

================
File: src/sbm/mcmc.py
================
  1: from typing import Optional, Tuple, Dict, Optional, List
  2: import numpy as np
  3: #from line_profiler import profile
  4: from numba import jit
  5: #from src.sbm.graph_data import GraphData
  6: from sbm.block_data import BlockData
  7: from sbm.likelihood import LikelihoodCalculator
  8: from sbm.block_change_proposers import ChangeProposer
  9: from sbm.node_mover import NodeMover
 10: from sbm.utils.logger import CSVLogger
 11: from sbm.block_change_proposers import ChangeProposer, ChangeProposerName
 12: #### Aliases
 13: ChangeProposerDict = Dict[ChangeProposerName, ChangeProposer] 
 14: ChangeFreqDict = Dict[ChangeProposerName, float]
 15: class MCMCAlgorithm:
 16:     def __init__(self,
 17:                  block_data: BlockData,
 18:                  likelihood_calculator: LikelihoodCalculator,
 19:                  change_proposer: ChangeProposerDict,
 20:                  rng: np.random.Generator,
 21:                  log: bool = True,
 22:                  change_freq: Optional[ChangeFreqDict] = None,
 23:                  ):
 24:         self.block_data = block_data
 25:         self.likelihood_calculator = likelihood_calculator
 26:         self.change_proposers = change_proposer
 27:         self.change_freq = change_freq
 28:         self.node_mover = NodeMover(block_data=block_data)
 29:         self.rng = rng
 30:         self.current_nll = self.likelihood_calculator.nll
 31:         self.log = log # True if logging is enabled, False otherwise.
 32:         # store the best block assignment and likelihood
 33:         self._best_block_assignment = block_data.blocks.copy()
 34:         self._best_block_conn = block_data.block_connectivity.copy()
 35:         self.best_nll = self.likelihood_calculator.nll
 36:     def fit(self,
 37:             max_num_iterations: int,
 38:             initial_temperature: float = 1,
 39:             cooling_rate: float = 0.99,
 40:             min_block_size: Optional[int] = None,
 41:             max_blocks: Optional[int] = None,
 42:             logger: Optional[CSVLogger] = None,
 43:             patience: Optional[int] = None,
 44:         ) -> List[float]:
 45:         """
 46:         Run the adaptive MCMC algorithm to fit the SBM to the network data.
 47:         :param max_num_iterations: max number of MCMC iterations to run.
 48:         :param min_block_size: Minimum allowed size for any block.
 49:         :param initial_temperature: Starting temperature for simulated annealing.
 50:         :param cooling_rate: Rate at which temperature decreases.
 51:         :param target_acceptance_rate: Desired acceptance rate for adaptive adjustments (default 25%).
 52:         :param max_blocks: Optional maximum number of blocks allowed.
 53:         """
 54:         temperature = initial_temperature
 55:         current_nll = self.likelihood_calculator.nll
 56:         acceptance_rate = 0 # acceptance rate of moves between logging
 57:         nll_list = [current_nll]
 58:         # if patience None, set based on the graph size
 59:         if patience is None:
 60:             n_nodes = self.block_data.graph_data.num_nodes
 61:             patience = min(int(0.1 * n_nodes*(n_nodes - 1) // 2), 10**5)
 62:         if logger:
 63:             logger.log(0, current_nll, acceptance_rate, temperature)
 64:         n_steps_declined = 0
 65:         for iteration in range(1, max_num_iterations + 1):
 66:             move_type = self._select_move_type()
 67:             delta_nll, move_accepted = self._attempt_move(
 68:                 move_type=move_type,
 69:                 min_block_size=min_block_size,
 70:                 temperature=temperature,
 71:                 max_blocks=max_blocks
 72:                 )
 73:             # update likelihood and best assignment so far
 74:             if move_accepted :
 75:                 self.current_nll += delta_nll
 76:                 n_steps_declined = 0
 77:                 if logger:
 78:                     acceptance_rate += 1
 79:                 if self.current_nll < self.best_nll:
 80:                     self.best_nll = current_nll
 81:                     self._best_block_assignment = self.block_data.blocks.copy()
 82:                     self._best_block_conn = self.block_data.block_connectivity.copy()
 83:             else:
 84:                 n_steps_declined += 1
 85:             nll_list.append(self.current_nll)
 86:             temperature = self._update_temperature(temperature, cooling_rate)
 87:             if logger and iteration % logger.log_every == 0:
 88:                 acceptance_rate = acceptance_rate / logger.log_every
 89:                 logger.log(iteration, self.current_nll, acceptance_rate, temperature)
 90:                 acceptance_rate = 0
 91:             if patience is not None and n_steps_declined >= patience:
 92:                 print(f"Stopping early after {iteration} iterations due to patience limit.")
 93:                 break
 94:         return nll_list 
 95:     def _select_move_type(self) -> ChangeProposerName:
 96:         """
 97:         Select a move type based on the current proposal probabilities.
 98:         :return: The selected move type.
 99:         """
100:         if self.change_freq is None:
101:             return "uniform_swap"
102:         else:
103:             # Select a move type based on the defined probabilities
104:             move_type = self.rng.choice(
105:                 tuple(self.change_freq.keys()),
106:                 p=tuple(self.change_freq.values())
107:             )
108:         return move_type # type: ignore
109:     def _attempt_move(self,
110:                       move_type: ChangeProposerName,
111:                       temperature: float,
112:                       max_blocks: Optional[int] = None,
113:                       min_block_size: Optional[int] = None,
114:         ) -> Tuple[float, bool]:
115:         """
116:         Attempt a move of the specified type.
117:         :param move_type: The type of move to attempt ('swap').
118:         :param min_block_size: Minimum allowed size for any block.
119:         :param temperature: Current temperature for simulated annealing.
120:         :param max_blocks: Optional maximum number of blocks allowed.
121:         :return: Tuple of (delta_nll, move_accepted)
122:         """
123:         delta_nll, move_accepted = 0.0, False
124:         proposed_change, proposed_delta_e, proposed_delta_n = \
125:             self.change_proposers[move_type].propose_change()
126:         # Compute change in log-likelihood and accept/reject move
127:         delta_nll = self.likelihood_calculator.compute_delta_nll(
128:             delta_e=proposed_delta_e,
129:             delta_n=proposed_delta_n
130:             )
131:         move_accepted = self._accept_move(delta_nll, temperature)
132:         if move_accepted:
133:             self.node_mover.perform_change(proposed_change, proposed_delta_e)
134:         return delta_nll, move_accepted
135:     def _accept_move(self, delta_nll: float, temperature: float, eps:float=1e-6) -> bool:
136:         """
137:         Determine whether to accept a proposed move based on likelihood change and temperature.
138:         :param delta_nll: Change in negative log-likelihood resulting from the proposed move.
139:         :param temperature: Current temperature for simulated annealing.
140:         :return: True if move is accepted, False otherwise.
141:         """
142:         if delta_nll < 0:
143:             return True
144:         temperature = max(temperature, eps)  # Avoid division by zero
145:         z = min(delta_nll / temperature, 700) # clip to avoid overflow in exp
146:         return self.rng.uniform() > np.exp(z)
147:     def _update_temperature(self, current_temperature: float, cooling_rate: float) -> float:
148:         """
149:         Update the temperature according to the cooling schedule.
150:         :param current_temperature: The current temperature.
151:         :param cooling_rate: The cooling rate.
152:         :return: The updated temperature.
153:         """
154:         return current_temperature * cooling_rate

================
File: src/sbm/block_assigner.py
================
  1: """ 
  2:     Functions and classes for computing initial block assignment 
  3:     used in the Stochastic Block Model (SBM). These are later updated
  4:     using the MCMC algorithm.
  5: """
  6: from __future__ import annotations
  7: from typing import List, Dict, Optional, Tuple, Iterable, TypeAlias, Set
  8: from collections import defaultdict, Counter
  9: from time import time
 10: import metis
 11: import scipy.sparse as sp
 12: from scipy.sparse import csr_array
 13: import numpy as np
 14: from k_means_constrained import KMeansConstrained
 15: from nodevectors import ProNE
 16: from sbm.block_data import BlockData
 17: from sbm.graph_data import GraphData
 18: from sbm.utils.pipeline_utils import InitMethodName
 19: from ortools.sat.python import cp_model  # type: ignore
 20: # ---------------------------------------------------------------------------
 21: #  helper ---------------------------------------------------------------
 22: # ---------------------------------------------------------------------------
 23: def _block_sizes(blocks: Dict[int, int]) -> Dict[int, int]:
 24:     sizes = defaultdict(int)
 25:     for b in blocks.values():
 26:         sizes[b] += 1
 27:     return sizes
 28: def _boundary_vertices(block: int, members: Set[int], blocks: Dict[int, int],
 29:                        indptr: np.ndarray, indices: np.ndarray) -> List[int]:
 30:     """Return vertices in *block* that touch at least one different block."""
 31:     out = []
 32:     for v in members:
 33:         row = slice(indptr[v], indptr[v + 1])
 34:         if any(blocks[u] != block for u in indices[row]):
 35:             out.append(v)
 36:     return out
 37: def _movable_vertex(src: int, dst_set: Set[int], *, rng: np.random.Generator,
 38:                     blocks: Dict[int, int], members: Dict[int, Set[int]],
 39:                     indptr: np.ndarray, indices: np.ndarray) -> Tuple[int, int] | None:
 40:     """Pick (vertex, dst) with vertex in *src* boundary and dst in dst_set."""
 41:     boundary = _boundary_vertices(src, members[src], blocks, indptr, indices)
 42:     rng.shuffle(boundary)
 43:     for v in boundary:
 44:         row = slice(indptr[v], indptr[v + 1])
 45:         neigh_blks = {blocks[u] for u in indices[row] if blocks[u] in dst_set}
 46:         if neigh_blks:
 47:             return v, rng.choice(list(neigh_blks))
 48:     return None
 49: def _move(v: int, src: int, dst: int, *, blocks: Dict[int, int],
 50:           members: Dict[int, Set[int]], sizes: Counter
 51:     ):
 52:     """Execute the move and update bookkeeping structures."""
 53:     blocks[v] = dst
 54:     members[src].remove(v)
 55:     members[dst].add(v)
 56:     sizes[src] -= 1
 57:     sizes[dst] += 1
 58:     if sizes[src] == 0:
 59:         # remove empty block
 60:         del members[src]
 61:         del sizes[src]
 62:         del blocks[v]
 63: def move_node_to_under(
 64:         under: Set[int], # blocks of size < k
 65:         over1: Set[int], # blocks of size k+1
 66:         over2: Set[int], # blocks of size > k+1
 67:         rng: np.random.Generator,
 68:         sizes: Counter[int],
 69:         k: int,
 70:         members: Dict[int, Set[int]],
 71:         blocks: Dict[int, int],
 72:         indptr: np.ndarray,
 73:         indices: np.ndarray
 74:     ) -> None:
 75:     """ 
 76:     Move a node from an oversize block to an undersize block.
 77:     """
 78:     if len(under) == 0:
 79:         # no undersize blocks available, skip
 80:         return
 81:     donors = list(over2 | over1) or list(b for b, s in sizes.items() if s > k)
 82:     rng.shuffle(donors)
 83:     moved = False
 84:     if len(under) > 0:
 85:         for b_src in donors:
 86:             mv = _movable_vertex(b_src, under, rng=rng, blocks=blocks,
 87:                                     members=members, indptr=indptr, indices=indices)
 88:             if mv is not None:
 89:                 v, b_dst = mv
 90:                 _move(v, b_src, b_dst, blocks=blocks, members=members, sizes=sizes)
 91:                 moved = True
 92:                 return
 93:     # If we reach here no boundary move could be found. Relax: pick random.
 94:     if len(donors) == 0:
 95:         # no oversize blocks available, pick random from all
 96:         donors = list(blocks.keys())
 97:     b_src = rng.choice(donors)
 98:     if len(members[b_src]) == 0:
 99:         # no members in the source block, skip
100:         return
101:     v = rng.choice(list(members[b_src]))
102:     b_dst = rng.choice(tuple(under))
103:     _move(v, b_src, b_dst, blocks=blocks, members=members, sizes=sizes)
104:     return
105: def move_node_from_over(
106:     under: Set[int], # blocks of size < k
107:     over1: Set[int], # blocks of size k+1
108:     over2: Set[int], # blocks of size > k+1
109:     rng: np.random.Generator,
110:     sizes: Counter[int],
111:     k: int,
112:     members: Dict[int, Set[int]],
113:     blocks: Dict[int, int],
114:     indptr: np.ndarray,
115:     indices: np.ndarray,
116:     r_target: int,
117: ) -> None:
118:     """ 
119:         Nodes are moved from block with size > k to block with size either
120:         < k or <=k if there are fewer than r_target blocks with size k+1.
121:     """
122:     if len(over2) == 0:
123:         # no oversize blocks available, skip
124:         return
125:     b_src = rng.choice(tuple(over2))
126:     dests = under.copy()
127:     if len(over1) > r_target:
128:         dests |= {b for b, s in sizes.items() if s == k}
129:     if not dests:
130:         # no eligible destination respecting kâlowerâbound â skip
131:         return
132:     mv = _movable_vertex(b_src, dests, rng=rng, blocks=blocks,
133:                             members=members, indptr=indptr, indices=indices)
134:     if mv is None:
135:         v = rng.choice(_boundary_vertices(b_src, members[b_src], blocks, indptr, indices))
136:         b_dst = rng.choice(tuple(dests))
137:     else:
138:         v, b_dst = mv
139:     _move(v, b_src, b_dst, blocks=blocks, members=members, sizes=sizes)
140:     return
141: def balance_k_plus_1_blocks(
142:     over1: Set[int], # blocks of size k+1
143:     over2: Set[int], # blocks of size >k+1
144:     rng: np.random.Generator,
145:     sizes: Counter[int],
146:     k: int,
147:     members: Dict[int, Set[int]],
148:     blocks: Dict[int, int],
149:     indptr: np.ndarray,
150:     indices: np.ndarray,
151:     r_target: int,
152: ) -> None:
153:     """ 
154:     Balance the number of blocks with size k+1.
155:     If there are too many blocks with size k+1, shrink one of them
156:     by moving a vertex to a block with size k or smaller.
157:     If there are too few blocks with size k+1, enlarge one of the blocks
158:     with size k by moving a vertex from a block with size larger than k+1
159:     or smaller than k+1
160:     """
161:     if len(over1) == r_target:
162:         # already balanced, nothing to do
163:         return
164:     elif len(over1) > r_target: # need fewer k+1 blocks
165:         # shrink a k+1 block
166:         b_src = rng.choice(tuple(over1))
167:         dests = {b for b, s in sizes.items() if s <= k}
168:     else:  # need more k+1 blocks
169:         # enlarge a k block
170:         #dests = set()
171:         b_src = rng.choice(tuple(over2))
172:         dests = {b for b, s in sizes.items() if s == k}
173:     if len(dests) == 0:
174:         # no eligible destination respecting kâupperâbound â skip
175:         return
176:     # shrink case
177:     mv = _movable_vertex(b_src, dests, rng=rng, blocks=blocks,
178:                             members=members, indptr=indptr, indices=indices)
179:     if mv is not None:
180:         v, b_dst = mv
181:         _move(v, b_src, b_dst, blocks=blocks, members=members, sizes=sizes)
182:         return
183:     return
184: def categorize(
185:     sizes: Dict[int, int],
186:     k: int,
187: ) -> Tuple[Set[int], Set[int], Set[int]]:
188:     """Return (oversize>k+1, oversize==k+1, undersize<k)."""
189:     over2 = {b for b, s in sizes.items() if s > k + 1}
190:     over1 = {b for b, s in sizes.items() if s == k + 1}
191:     under = {b for b, s in sizes.items() if s < k}
192:     return over2, over1, under
193: # ---------------------------------------------------------------------------
194: # Improved greedy balancer (split into helpers)
195: # ---------------------------------------------------------------------------
196: def _rebalance_to_min_size(
197:     blocks: Dict[int, int],
198:     adjacency: csr_array,
199:     k: int,
200:     rng: np.random.Generator | None = None,
201:     max_iter: int | None = None,
202: ) -> Dict[int, int]:
203:     """Greedy boundaryâonly balancing.
204:     Guarantees **no block ends smaller than *k***; tries to respect the stricter
205:     goal (sizes â {k,k+1} & exactly *r* oversized) but will *sacrifice* that goal
206:     rather than leave an undersized block.
207:     """
208:     if rng is None:
209:         rng = np.random.default_rng(1)
210:     n = adjacency.shape[0]
211:     indptr, indices = adjacency.indptr, adjacency.indices
212:     sizes: Counter[int] = Counter(blocks.values())
213:     members: Dict[int, Set[int]] = defaultdict(set)
214:     for v, b in blocks.items():
215:         members[b].add(v)
216:     B = len(sizes)
217:     r_target = n - k * B  # blocks that *should* have k+1
218:     iter_limit = max_iter or 5 * n
219:     while iter_limit:
220:         iter_limit -= 1
221:         over2, over1, under = categorize(sizes=sizes, k=k)
222:         if len(under)==0 and len(over2)==0 and len(over1)==r_target:
223:             break  # fully balanced by strict rules
224:         # 1) fix undersized first ------------------------------------------------
225:         if len(under) > 0:
226:             move_node_to_under(
227:                 under=under,
228:                 over1=over1,
229:                 over2=over2,
230:                 rng=rng,
231:                 sizes=sizes,
232:                 k=k,
233:                 members=members,
234:                 blocks=blocks,
235:                 indptr=indptr,
236:                 indices=indices
237:             )
238:             continue
239:         # 2) shrink blocks > k+1 --------------------------------------------------
240:         if len(over2) > 0 :
241:             move_node_from_over(
242:                 under=under,
243:                 over1=over1,
244:                 over2=over2,
245:                 rng=rng,
246:                 sizes=sizes,
247:                 k=k,
248:                 members=members,
249:                 blocks=blocks,
250:                 indptr=indptr,
251:                 indices=indices,
252:                 r_target=r_target
253:             )
254:             continue
255:         # 3) adjust number of k+1 blocks -----------------------------------------
256:         if len(over1) != r_target:
257:             balance_k_plus_1_blocks(
258:                 over1=over1,
259:                 over2=over2,
260:                 rng=rng,
261:                 sizes=sizes,
262:                 k=k,
263:                 members=members,
264:                 blocks=blocks,
265:                 indptr=indptr,
266:                 indices=indices,
267:                 r_target=r_target
268:             )
269:             continue
270:     # ---------------- final safety pass: remove any undersized ---------------
271:     # we first attempt to move nodes from oversize blocks to undersize blocks
272:     # if that fails, we move nodes from remaining undersized blocks to any block
273:     under_blocks = [b for b, s in sizes.items() if s < k]
274:     if len(under_blocks) == 0:
275:         return blocks
276:     rng.shuffle(under_blocks)
277:     over_blocks = [b for b, s in sizes.items() if s > k]
278:     if len(over_blocks) > 0:
279:         # attempt to move nodes from oversize blocks to undersize blocks
280:         while len(over_blocks) > 0 and len(under_blocks) > 0:
281:             b_dst = under_blocks[-1]
282:             while sizes[b_dst] < k and len(over_blocks) > 0:
283:                 b_src = over_blocks[-1]  # take from the end for efficiency
284:                 if sizes[b_src] == k: # have we taken all we can?
285:                     over_blocks.pop() # discount this block from further consideration
286:                     continue
287:                 # can we find a vertex in b_src connected to b_dst?
288:                 mv = _movable_vertex(b_src, {b_dst}, rng=rng, blocks=blocks,
289:                                       members=members, indptr=indptr, indices=indices)
290:                 if mv is None:
291:                     # if not, pick a random vertex in b_src
292:                     v = rng.choice(tuple(members[b_src]))
293:                 else:
294:                     v, _ = mv
295:                 _move(v, b_src, b_dst, blocks=blocks, members=members, sizes=sizes)
296:                 over_blocks = {b for b, s in sizes.items() if s > k}
297:             if sizes[b_dst] >= k:
298:                 # we have filled the under block, remove it from consideration
299:                 under_blocks.pop()
300:     # assign all nodes in under_block to a random block
301:     while len(under_blocks) > 0:
302:         b_src = under_blocks[-1]  # take from the end for efficiency
303:         while len(members[b_src]) > 0:
304:             non_under_blocks = {b for b, s in sizes.items() if s >= k}
305:             # check if v touches a non_under block
306:             mv = _movable_vertex(b_src, non_under_blocks, rng=rng, blocks=blocks,
307:                                     members=members, indptr=indptr, indices=indices)
308:             if mv is not None:
309:                 v, b_dst = mv
310:             else:
311:                 v = rng.choice(tuple(members[b_src]))
312:                 b_dst= rng.choice(tuple(blocks.values()))
313:             _move(v, b_src, b_dst, blocks=blocks, members=members, sizes=sizes)
314:         under_blocks.pop()
315:     # final check
316:     _, _, under = categorize(sizes=sizes, k=k)
317:     assert len(under) == 0, \
318:         f"Rebalance failed: {len(under)} blocks are still undersized (<{k})."
319:     return blocks
320: ### Base class for BlockAssigner
321: class BlockAssigner:
322:     """
323:     Base class for assigning nodes to blocks in the Stochastic Block Model (SBM).
324:     This class is intended to be subclassed for specific block assignment strategies.
325:     """
326:     def __init__(self,
327:                  graph_data: GraphData,
328:                  rng: np.random.Generator,
329:                  num_blocks: Optional[int] = None,
330:                  min_block_size: Optional[int] = None,
331:                  max_block_size: Optional[int] = None,
332:                  ):
333:         self.graph_data = graph_data
334:         # check if there exist a valid assignment
335:         # given num_blocks, min_block_size, max_block_size
336:         if num_blocks is not None and min_block_size is not None:
337:             if num_blocks * min_block_size > graph_data.num_nodes:
338:                 raise ValueError("Invalid parameters: num_blocks * min_block_size exceeds total number of nodes.")
339:         if max_block_size is not None and min_block_size is not None:
340:             if max_block_size < min_block_size:
341:                 raise ValueError("Invalid parameters: max_block_size cannot be less than min_block_size.")
342:         self.num_blocks = num_blocks
343:         self.min_block_size = min_block_size
344:         self.max_block_size = max_block_size
345:         self.rng = rng
346:     def reindex_blocks(self, blocks: Dict[int, int]) -> Dict[int, int]:
347:         """ 
348:         Reindex block IDs to be consecutive integers starting from 0.
349:         """
350:         unique_blocks = sorted(set(blocks.values()))
351:         block_mapping = {old_id: new_id for new_id, old_id in enumerate(unique_blocks)}
352:         return {node: block_mapping[block_id] for node, block_id in blocks.items()}
353:     def _compute_assignment(self) -> Dict[int, int]:
354:         raise NotImplementedError(
355:             "compute_assignment must be implemented by subclasses of BlockAssigner."
356:         )
357:     def compute_assignment(self) -> BlockData:
358:         raise NotImplementedError(
359:             "compute_assignment must be implemented by subclasses of BlockAssigner."
360:         )
361: class UniformSmallBlockAssigner(BlockAssigner):
362:     """ 
363:     Assigns nodes to blocks of size min_block_size uniformly at random. 
364:     Ignore num_blocks and max_block_size.
365:     """
366:     def _compute_assignment(self) -> Dict[int, int]:
367:         """
368:         Assign nodes to blocks uniformly at random, ensuring each block has at least min_block_size nodes.
369:         """
370:         if self.min_block_size is None:
371:             raise ValueError("min_block_size must be specified for UniformSmallBlockAssigner.")
372:         if self.min_block_size <= 0:
373:             raise ValueError("min_block_size must be a positive integer.")
374:         if self.max_block_size is not None:
375:             Warning("max_block_size is ignored in UniformSmallBlockAssigner.")
376:         if self.num_blocks is not None:
377:             Warning("num_blocks is ignored in UniformSmallBlockAssigner.")
378:         num_nodes = self.graph_data.num_nodes
379:         # create list of nodes in random order
380:         node_list = self.rng.permutation(np.arange(num_nodes))
381:         # assign nodes to blocks
382:         block_assignments = {
383:             node: node // self.min_block_size for node in node_list
384:         }
385:         return block_assignments
386:     # -----------------------------------------------------------------
387:     def compute_assignment(self) -> BlockData:
388:         """
389:         Compute a block assignment based on the proposed assignment.
390:         Currently, this method only performs a min_size balancing step.
391:         """
392:         if self.min_block_size is None:
393:             raise ValueError("min_block_size must be specified for UniformSmallBlockAssigner.")
394:         assignment = self._compute_assignment()
395:         assignment= _rebalance_to_min_size(
396:             blocks=assignment,
397:             adjacency=self.graph_data.adjacency,
398:             k=self.min_block_size,
399:             rng=self.rng,
400:             max_iter=None,  # data-driven max_iter (10*num_nodes)
401:         )
402:         reindexed_assignment = self.reindex_blocks(assignment)
403:         return BlockData(
404:             initial_blocks=reindexed_assignment,
405:             graph_data=self.graph_data
406:         )
407: class MetisBlockAssigner(BlockAssigner):
408:     """
409:     Use Metis to obtain a *balanced* `num_blocks`-way partition of the
410:     (undirected) graph.
411:     Parameters
412:     ----------
413:     graph_data : GraphData
414:         Graph wrapper holding the (sparse) adjacency matrix.
415:     num_blocks : int
416:         Desired number of blocks (â N // k where k is target block size).
417:     seed : int, optional
418:         Random seed forwarded to METIS.  If None, METIS uses its own seed.
419:     """
420:     def __init__(
421:         self,
422:         graph_data: GraphData,
423:         rng: np.random.Generator,
424:         num_blocks: Optional[int] = None,
425:         min_block_size: Optional[int] = None,
426:         max_block_size: Optional[int] = None,
427:     ) -> None:
428:         super().__init__(
429:             graph_data=graph_data,
430:             rng=rng,
431:             num_blocks=num_blocks,
432:             min_block_size=min_block_size,
433:             max_block_size=max_block_size,
434:             )
435:         if graph_data.directed:
436:             raise NotImplementedError(
437:                 "MetisBlockAssigner currently supports undirected graphs only."
438:             )
439:         if num_blocks is None and min_block_size is None:
440:             raise ValueError("Either num_blocks or min_block_size must be specified for MetisBlockAssigner.")
441:         if num_blocks is None:
442:             num_blocks = max(
443:                 1, graph_data.num_nodes // min_block_size
444:             )
445:         self.num_blocks = int(num_blocks)
446:         self.seed = rng.integers(2**32)
447:     # -----------------------------------------------------------------
448:     # Utilities
449:     # -----------------------------------------------------------------
450:     @staticmethod
451:     def _to_adj_lists(adj: sp.csr_array) -> list[list[int]]:
452:         """
453:         Convert a CSR adjacency matrix to the adjacency-list format Metis
454:         expects (no self-loops, undirected symmetry).
455:         """
456:         n = adj.shape[0] # type: ignore
457:         rows, cols = adj.nonzero() # type: ignore
458:         neigh = [[] for _ in range(n)]
459:         for u, v in zip(rows, cols):
460:             if u == v:
461:                 continue  # ignore self-loops
462:             neigh[u].append(v)
463:         return neigh
464:     # -----------------------------------------------------------------
465:     # Public API
466:     # -----------------------------------------------------------------
467:     def _compute_metis_assignment(self) -> Dict[int, int]:
468:         """
469:         Run METIS and return a BlockData with the resulting assignment.
470:         May results in blocks of size < min_block_size or > max_block_size.
471:         """
472:         n = self.graph_data.num_nodes
473:         adj_lists = self._to_adj_lists(self.graph_data.adjacency)
474:         # PyMetis returns (edgecuts, membership-array)
475:         _, parts = metis.part_graph(
476:             graph=adj_lists,
477:             nparts = self.num_blocks,
478:             ufactor = 30, # aggresively balance block
479:             tpwgts = [1/self.num_blocks]*self.num_blocks, # equal weights for each block
480:             ubvec = [1+0.05], # 5% imbalance allowed
481:             recursive=True
482:         )
483:         # PyMetis guarantees |parts| == n
484:         blocks: Dict[int, int] = {node: part for node, part in enumerate(parts)}
485:         # Wrap in BlockData so downstream code can use it directly
486:         return blocks
487:     # -----------------------------------------------------------------
488:     def compute_assignment(self) -> BlockData:
489:         """
490:         Compute a balanced block assignment based on the proposed assignment.
491:         Currently, this method only performs a min_size balancing step.
492:         """
493:         if self.min_block_size is None:
494:             raise ValueError("min_block_size must be specified for MetisBlockAssigner.")
495:         assignment = self._compute_metis_assignment()
496:         #assignment = _rebalance_to_min_size(
497:         #    blocks=assignment,
498:         #    adjacency=self.graph_data.adjacency,
499:         #    k=self.min_block_size,
500:         #    rng=self.rng,
501:         #    max_iter=None,  # data-driven max_iter (10*num_nodes)
502:         #)
503:         assignment = self.reindex_blocks(assignment)
504:         return BlockData(
505:             initial_blocks=assignment,
506:             graph_data=self.graph_data
507:         )
508: class RefinedMetisBlockAssigner(MetisBlockAssigner):
509:     """PyMETIS seed â improved greedy rebalance â optional CPâSAT polish."""
510:     def __init__(
511:         self,
512:         graph_data: GraphData,
513:         rng: np.random.Generator,
514:         num_blocks: int | None = None,
515:         min_block_size: int | None = None,
516:         max_block_size: int | None = None,
517:         cpsat_time_limit: int | None = 5,
518:     ) -> None:
519:         super().__init__(
520:             graph_data=graph_data,
521:             rng=rng,
522:             num_blocks=num_blocks,
523:             min_block_size=min_block_size,
524:             max_block_size=max_block_size,
525:         )
526:         self._rng = rng
527:         self._cpsat_limit = cpsat_time_limit
528:     # -----------------------------------------------------------------
529:     def compute_assignment(self) -> BlockData:  # noqa: D401 â keep signature
530:         # unbalanced
531:         if self.min_block_size is None:
532:             raise ValueError("min_block_size must be specified for RefinedMetisBlockAssigner.")
533:         blocks = super()._compute_metis_assignment()
534:         blocks = _rebalance_to_min_size(
535:             blocks,
536:             self.graph_data.adjacency,
537:             self.min_block_size,
538:             rng=self._rng,
539:         )
540:         # polish with CPâSAT
541:         blocks = self._cpsat_polish(blocks)
542:         return BlockData(initial_blocks=self.reindex_blocks(blocks),
543:                          graph_data=self.graph_data)
544:     # -----------------------------------------------------------------
545:     def _compute_metis_assignment(self) -> Dict[int, int]:  # noqa:Â D401  â keep name
546:         return super()._compute_metis_assignment()
547:     # -----------------------------------------------------------------
548:     def _block_members(self, blk: int, blocks: Dict[int, int]) -> List[int]:
549:         return [v for v, b in blocks.items() if b == blk]
550:     # -----------------------------------------------------------------
551:     def _cpsat_polish(self, blocks: Dict[int, int]) -> Dict[int, int]:
552:         """ 
553:         Polish the block assignment to decrease the edge cut while ensuring
554:         block sizes are within min_block_size and min_block_size + 1.
555:         """
556:         if self.min_block_size is None:
557:             return blocks
558:         k = self.min_block_size
559:         sizes = _block_sizes(blocks)
560:         wrong = {b for b, s in sizes.items() if not (k <= s <= k + 1)}
561:         if not wrong:
562:             return blocks  # already good
563:         # collect *boundary* nodes of wrong blocks + their neighbours
564:         boundary: Set[int] = set()
565:         adj = self.graph_data.adjacency
566:         indptr, indices = adj.indptr, adj.indices
567:         for b in wrong:
568:             for v in self._block_members(b, blocks):
569:                 row = slice(indptr[v], indptr[v + 1])
570:                 if any(blocks[u] != b for u in indices[row]):
571:                     boundary.add(v)
572:                     boundary.update(indices[row])
573:         sub_nodes = sorted(boundary)
574:         sub_adj = adj[sub_nodes][:, sub_nodes]  # type: ignore[index]
575:         # blocks involved
576:         blks_sub = {blocks[v] for v in sub_nodes}
577:         # ------- build CPâSAT model ----------------------------------
578:         model = cp_model.CpModel()
579:         x = {}
580:         for v in sub_nodes:
581:             for b in blks_sub:
582:                 x[v, b] = model.NewBoolVar(f"x_{v}_{b}")
583:             # each vertex exactly one block (in subâproblem)
584:             model.Add(sum(x[v, b] for b in blks_sub) == 1)
585:         # blockâsize constraints & t_b variables
586:         t = {}
587:         r_target = (len(sub_nodes) + sum(sizes[b] for b in blks_sub) - k * len(blks_sub))  # local oversize quota
588:         for b in blks_sub:
589:             t[b] = model.NewBoolVar(f"t_{b}")
590:             size_expr = sum(x[v, b] for v in sub_nodes) + (sizes[b] - sum(blocks[v] == b for v in sub_nodes))
591:             model.Add(size_expr == k + t[b])
592:         model.Add(sum(t[b] for b in blks_sub) == r_target)
593:         # edgeâcut objective (linearised y/z eliminated â constant perimeter suffices in subgraph)
594:         rows, cols = sub_adj.nonzero()
595:         z = {}
596:         for v, u in zip(rows, cols):
597:             if v >= u:
598:                 continue  # undirected upper triangle
599:             i, j = sub_nodes[v], sub_nodes[u]
600:             z[(i, j)] = model.NewBoolVar(f"z_{i}_{j}")
601:             # z = 1 if endpoints differ
602:             for b in blks_sub:
603:                 model.AddBoolAnd([x[i, b], x[j, b]]).OnlyEnforceIf(z[(i, j)].Not())
604:             # if all sameâblock conjunctions false â z=1
605:         model.Minimize(sum(z.values()))
606:         # solve
607:         solver = cp_model.CpSolver()
608:         if self._cpsat_limit:
609:             solver.parameters.max_time_in_seconds = float(self._cpsat_limit)
610:         status = solver.Solve(model)
611:         if status in (cp_model.OPTIMAL, cp_model.FEASIBLE):
612:             for v in sub_nodes:
613:                 for b in blks_sub:
614:                     if solver.BooleanValue(x[v, b]):
615:                         blocks[v] = b
616:                         break
617:         return blocks
618: class EmbedAndConstrKMeansAssigner(BlockAssigner):
619:     """
620:     Assign nodes to blocks using a two-step process:
621:     1. use embed nodes into a low-dimensional space,
622:     2. use constrained KMeans to assign nodes to blocks of prespecified sizes.
623:     """ 
624:     def __init__(
625:         self,
626:         graph_data: GraphData,
627:         rng: np.random.Generator,
628:         num_blocks: Optional[int] = None,
629:         min_block_size: Optional[int] = None,
630:         max_block_size: Optional[int] = None,
631:     ) -> None:
632:         super().__init__(
633:             graph_data=graph_data,
634:             rng=rng,
635:             num_blocks=num_blocks,
636:             min_block_size=min_block_size,
637:             max_block_size=max_block_size,
638:         )
639:         if min_block_size is None:
640:             raise ValueError("num_blocks and min_block_size must be specified for ProneAndConstrKMeansAssigner.")
641:         if num_blocks is not None:
642:             Warning("num_blocks is ignored in ProneAndConstrKMeansAssigner. Only min_block_size is used.")
643:         if max_block_size is not None:
644:             Warning("max_block_size is ignored in ProneAndConstrKMeansAssigner. Only min_block_size is used.")
645:     def embed_nodes(self, adjacency:sp.csr_array, n_dimensions:int=128)->np.ndarray:
646:         """ 
647:         Method to perform node embedding. Subclasses should implement this method
648:         """
649:         raise NotImplementedError("This method should be overwritten by subclasses to provide specific embedding logic.")
650:     def _compute_assignment(self) -> Dict[int, int]:
651:         """
652:         Compute block assignments using constrained KMeans after embedding with Prone.
653:         """
654:         if self.graph_data.num_nodes < self.min_block_size:
655:             raise ValueError("Number of nodes in the graph is less than min_block_size.")
656:         if self.min_block_size is None:
657:             raise ValueError("min_block_size must be specified for ProneAndConstrKMeansAssigner.")
658:         # Step 1: Embed nodes using Prone
659:         embeddings = self.embed_nodes(
660:             adjacency=self.graph_data.adjacency,
661:             n_dimensions=128  # default embedding dimension
662:         )
663:         # compute how many blocks we need to only have blocks of
664:         #   size min_block_size and min_block_size+1
665:         number_of_clusters = self.graph_data.num_nodes // self.min_block_size
666:         # Step 2: Use constrained KMeans to assign nodes to blocks
667:         kmeans = KMeansConstrained(
668:                     n_clusters=number_of_clusters,
669:                     size_min=self.min_block_size,
670:                     size_max=self.min_block_size+1, # 
671:                     init='k-means++',
672:                     n_init=1,
673:                     max_iter=10,
674:                     tol=1e-3,
675:                     verbose=False,
676:                     random_state=self.rng.choice(2**32), 
677:                     copy_x=False, # perform centering
678:                     # use all available CPU cores
679:                     n_jobs=-1
680:                 )
681:         tic = time()
682:         labels = kmeans.fit_predict(embeddings)
683:         toc = time()
684:         print(f"KMeans with constraints took {toc - tic:.2f} seconds for {self.graph_data.num_nodes} nodes.")
685:         # Create a mapping from node index to block ID
686:         blocks = {node: label for node, label in enumerate(labels)} # type: ignore
687:         return blocks
688:     def compute_assignment(self) -> BlockData:
689:         """
690:         Compute a block assignment based on the proposed assignment.
691:         Currently, this method only performs a min_size balancing step.
692:         """
693:         balanced_assignment = self._compute_assignment() # balanced from k-means w. size constraints
694:         reindexed_assignment = self.reindex_blocks(balanced_assignment)
695:         return BlockData(
696:             initial_blocks=reindexed_assignment,
697:             graph_data=self.graph_data
698:         )
699: class ProNEAndConstrKMeansAssigner(EmbedAndConstrKMeansAssigner):
700:     """
701:     Assign nodes to blocks using ProNE embedding followed by constrained KMeans.
702:     """
703:     def embed_nodes(self, adjacency: sp.csr_array, n_dimensions: int = 128) -> np.ndarray:
704:         """
705:         Embed nodes using ProNE.
706:         """
707:         if n_dimensions <= 0:
708:             raise ValueError("n_dimensions must be a positive integer.")
709:         # Create a ProNE instance and fit it to the adjacency matrix
710:         model = ProNE(
711:                     n_components=n_dimensions,
712:                     step=10,
713:                     mu=0.2,
714:                     theta=0.5, 
715:                     exponent=0.75,
716:                     verbose=False
717:                 )
718:         tic = time()
719:         embeddings = model.fit_transform(
720:             sp.csr_matrix(adjacency) # nodevectors expect a CSR matrix, and not array
721:             )
722:         toc = time()
723:         print(f"ProNE embedding took {toc - tic:.2f} seconds for {adjacency.shape[0]} nodes.") # type: ignore
724:         return embeddings
725: class AssignerConstructor:
726:     """ 
727:     Factory class to construct block assigners based on configuration parameters. 
728:     """
729:     def __init__(self, rng: np.random.Generator):
730:         self.rng = rng
731:     def create_assigner(self,
732:                         graph_data: GraphData,
733:                         init_method: InitMethodName = "metis", 
734:                         min_block_size: Optional[int] = None,
735:                         max_block_size: Optional[int] = None,
736:                         num_blocks: Optional[int] = None,
737:                     ) -> BlockAssigner:
738:         if init_method == "uniform":
739:             return UniformSmallBlockAssigner(
740:                 graph_data=graph_data,
741:                 rng=self.rng,
742:                 min_block_size=min_block_size,
743:                 max_block_size=max_block_size,
744:                 num_blocks=num_blocks,
745:             )
746:         elif init_method == "prone_and_kmeans":
747:             return ProNEAndConstrKMeansAssigner(
748:                 graph_data=graph_data,
749:                 rng=self.rng,
750:                 min_block_size=min_block_size,
751:                 max_block_size=max_block_size,
752:                 num_blocks=num_blocks,
753:             )
754:         elif init_method == "metis":
755:             return MetisBlockAssigner(
756:                 graph_data=graph_data,
757:                 rng=self.rng,
758:                 num_blocks=num_blocks,
759:                 min_block_size=min_block_size,
760:                 max_block_size=max_block_size,
761:             )
762:         elif init_method == "metis_refine":
763:             return RefinedMetisBlockAssigner(
764:                 graph_data=graph_data,
765:                 rng=self.rng,
766:                 min_block_size=min_block_size,
767:                 max_block_size=max_block_size,
768:                 num_blocks=num_blocks,
769:                 cpsat_time_limit=10
770:             )
771:         else:
772:             raise ValueError(f"Unknown initialization method: {init_method}. "
773:                 "Available methods: 'metis', 'uniform', 'prone_and_kmeans', 'metis_refine'."
774:                 )

================
File: src/sbm/block_data.py
================
  1: from typing import Dict, Set, Optional
  2: from dataclasses import dataclass
  3: import numpy as np
  4: import scipy.sparse as sp
  5: from sbm.graph_data import GraphData
  6: from sbm.sampling import sample_sbm_graph
  7: BlockConn = sp.dok_array
  8: BlockMembership = Dict[int, Set[int]]  # Block ID to set of node indices
  9: class _BlockDataUpdater:
 10:     """
 11:     Helper class to update edge counts and possible pairs in the block data.
 12:     This class is used to hide bookkeeping of handling directed vs undirected graphs.
 13:     Parameters
 14:     ----------
 15:     bd : BlockData
 16:     """
 17:     def __init__(self, block_data: "BlockData"):
 18:         self.block_data = block_data # B Ã B integer matrix
 19:     # block memberships
 20:     def _move_node_to_block(self, node: int, block_id: int, update_sizes=True) -> None:
 21:         # update block assignment
 22:         old_block = self.block_data.blocks[node] # type: ignore
 23:         if update_sizes: 
 24:             # update block sizes
 25:             self.block_data.block_sizes[block_id] += 1
 26:             self.block_data.block_sizes[old_block] -= 1
 27:         self.block_data.blocks[node] = block_id # type: ignore
 28:         # update block membersets
 29:         if block_id not in self.block_data.block_members:
 30:             self.block_data.block_members[block_id] = set()
 31:         self.block_data.block_members[block_id].add(node)
 32:         self.block_data.block_members[old_block].remove(node)
 33:     # ----- edge counts --------------------------------------------------
 34:     def _increment_edge_count(self, idx_a: int, idx_b: int, e_delta: int) -> None:
 35:         """ 
 36:         Increment the edge count between two blocks.
 37:         If the graph is undirected, increment both directions.
 38:         e_delta can be negative to decrement the edge count.
 39:         idx_a and idx_b are indices in the block_connectivity matrix.
 40:         """
 41:         self.block_data.block_connectivity[idx_a, idx_b] += e_delta
 42:         if not self.block_data.directed and idx_a != idx_b:
 43:             self.block_data.block_connectivity[idx_b, idx_a] += e_delta
 44: class BlockData:
 45:     """ 
 46:     Class to store block data for the SBM.
 47:     There are two ways to initialize this class:
 48:     Attributes:
 49:         graph_data: The graph data object.
 50:         blocks: A dictionary mapping node indices to block indices.
 51:         block_members: A dictionary mapping block indices to lists of node indices.
 52:         block_sizes: A dictionary mapping block indices to the number of nodes in each block.
 53:         directed: A boolean indicating whether the graph is directed or not.
 54:         block_indices: A dictionary mapping block IDs to indices used in matrices.
 55:         inverse_block_indices: A dictionary mapping indices used in matrices to block IDs.
 56:         block_connectivity: A sparse matrix representing the block connectivity matrix.
 57:     """
 58:     def __init__(self,
 59:                  initial_blocks: Dict[int, int],
 60:                  graph_data: GraphData,
 61:         ):
 62:         self.blocks: Dict[int, int] = initial_blocks # Node to block mapping
 63:         self.block_updater = _BlockDataUpdater(self)
 64:         self.graph_data = graph_data
 65:         self.directed = graph_data.directed
 66:         self.block_members = self._initialize_block_members()
 67:         self.block_sizes = {block: len(nodes) for block, nodes in self.block_members.items()}
 68:         self._update_block_indices()
 69:         self.block_connectivity: BlockConn = self._compute_block_connectivity()
 70:         # Recompute block connectivity based on the new graph data
 71:         self.block_connectivity = self._compute_block_connectivity()
 72:     def increment_edge_count(self, block_a: int, block_b: int, e_delta: int) -> None:
 73:         """ 
 74:         Increment the edge count between two blocks.
 75:         If the graph is undirected, increment both directions.
 76:         e_delta can be negative to decrement the edge count.
 77:         """
 78:         idx_a = self.block_indices[block_a]
 79:         idx_b = self.block_indices[block_b]
 80:         self.block_updater._increment_edge_count(idx_a, idx_b, e_delta)
 81:     def get_possible_pairs(self, block_a: int, block_b:int ) -> int:
 82:         """ 
 83:         Compute the possible number of edges between two blocks.
 84:         """
 85:         if block_a == block_b:
 86:             # If the same block, return the number of pairs within the block
 87:             return self.block_sizes[block_a] * (self.block_sizes[block_a] - 1) // 2
 88:         # If different blocks, return the product of their sizes
 89:         return self.block_sizes[block_a] * self.block_sizes[block_b]
 90:     def _initialize_block_members(self) -> BlockMembership:
 91:         """
 92:         Initialize block members from the blocks mapping.
 93:         :return: A dictionary mapping block indices to lists of node indices.
 94:         """
 95:         if self.blocks is None:
 96:             raise ValueError("Blocks mapping is not provided to initialize block members.")
 97:         block_members: BlockMembership = {}
 98:         for node, block in self.blocks.items():
 99:             if block not in block_members:
100:                 block_members[block] = set()
101:             # Add node to the corresponding block
102:             block_members[block].add(node)
103:         return block_members
104:     def _update_block_indices(self):
105:         """
106:         Update mappings between block IDs and indices used in matrices.
107:         """
108:         # Sort block IDs to ensure consistent ordering
109:         sorted_block_ids = sorted(self.block_members.keys())
110:         self.block_indices = {
111:             block_id: idx for idx, block_id in enumerate(sorted_block_ids)
112:             }
113:         self.inverse_block_indices = {
114:             idx: block_id for block_id, idx in self.block_indices.items()
115:             }
116:     def _compute_block_connectivity(self) -> BlockConn:
117:         """
118:         Compute the block connectivity matrix.
119:         This matrix is a sparse matrix where the entry at (i, j) is number of edges 
120:         between block i and block j. If the graph is undirected, the matrix is symmetric.
121:         """
122:         if self.graph_data is None:
123:             raise ValueError("Graph data is not set. Cannot compute block connectivity.")
124:         if self.block_members is None:
125:             raise ValueError("Block members are not initialized. Cannot compute block connectivity.")
126:         num_blocks = len(self.block_members)
127:         self._update_block_indices()
128:         block_connectivity_dok = sp.dok_array((num_blocks, num_blocks), dtype=np.int64)
129:         if self.directed:
130:             raise ValueError("Block connectivity computation is not implemented for directed graphs.")
131:         else:
132:             for i_block_id, nodes_i in self.block_members.items():
133:                 idx_i = self.block_indices[i_block_id]
134:                 nodes_i = list(nodes_i)
135:                 sub_adj_i = self.graph_data.adjacency[nodes_i]  # type: ignore
136:                 for j_block_id, nodes_j in self.block_members.items():
137:                     idx_j = self.block_indices[j_block_id]
138:                     nodes_j = list(nodes_j)
139:                     # Sum of weights between block i and block j
140:                     weight = sub_adj_i[:, nodes_j].sum() # type: ignore
141:                     # If the blocks are the same, we only count pairs
142:                     if i_block_id == j_block_id:
143:                         weight = weight // 2
144:                     block_connectivity_dok[idx_i, idx_j] = weight
145:             return block_connectivity_dok
146:     def _remove_block_index(self, block_id: int):
147:         """
148:         Remove a block from block_indices and inverse_block_indices.
149:         Do not use directly, call remove_block instead.
150:         :param block_id: The block ID to remove.
151:         """
152:         idx = self.block_indices.pop(block_id)
153:         self.inverse_block_indices.pop(idx)
154:         # Adjust indices of remaining blocks
155:         for b_id, index in self.block_indices.items():
156:             if index > idx:
157:                 self.block_indices[b_id] -= 1
158:                 self.inverse_block_indices[self.block_indices[b_id]] = b_id
159:     def _remove_block_from_connectivity(self, block_id: int):
160:         """
161:         Remove the block's row and column from the block connectivity matrix.
162:         Do not use directly, call remove_block instead.
163:         :param block_id: The block ID to remove.
164:         """
165:         idx = self.block_indices[block_id]
166:         # Remove the row and column corresponding to idx
167:         slicable_array = self.block_connectivity.tocsr()
168:         non_slice_idx = np.arange(self.block_connectivity.shape[1]) != idx # type: ignore
169:         self.block_connectivity = slicable_array[:, non_slice_idx][non_slice_idx, :].todok()
170:     def remove_block(self, block_id: int):
171:         """
172:         Remove a block from the block data.
173:         Do not use directly, call remove_block instead.
174:         :param block_id: The block ID to remove.
175:         """
176:         del self.block_sizes[block_id]
177:         del self.block_members[block_id]
178:         self._remove_block_from_connectivity(block_id)
179:         self._remove_block_index(block_id)
180:     def _add_block_index(self, block_id: int):
181:         """
182:         Add a new block index for a new block.
183:         Do not use directly, call add_block instead.
184:         :param block_id: The block ID to add.
185:         """
186:         new_idx = len(self.block_indices)
187:         self.block_indices[block_id] = new_idx
188:         self.inverse_block_indices[new_idx] = block_id
189:     def _add_block_to_connectivity(self):
190:         """
191:         Add a new block to the block connectivity matrix.
192:         Do not use directly, call add_block instead.
193:         :param block_id: The block ID to add.
194:         """
195:         num_blocks = len(self.block_indices)
196:         connectivity_lil = sp.lil_matrix(self.block_connectivity)
197:         connectivity_lil.resize((num_blocks, num_blocks))
198:         self.block_connectivity = connectivity_lil.todok()
199:     def add_block(self, block_id: int, nodes=[]):
200:         """
201:         Add a new block to the block data.
202:         :param block_id: The block ID to add.
203:         """
204:         if self.blocks is None:
205:             raise ValueError("Blocks mapping is not initialized. Cannot add a block.")
206:         self.block_sizes[block_id] = len(nodes)
207:         self.block_members[block_id] = nodes
208:         for node in nodes:
209:             self.blocks[node] = block_id
210:         self._add_block_index(block_id)
211:         self._add_block_to_connectivity()

================
File: src/sbm/likelihood.py
================
  1: from typing import (
  2:     Dict,
  3:     Tuple,
  4:     Literal,
  5: )
  6: from numba import jit
  7: from scipy.sparse import coo_array
  8: import numpy as np
  9: from sbm.block_data import BlockData
 10: from sbm.block_change_proposers import (
 11:     EdgeDelta,
 12:     CombinationDelta,
 13: )
 14: #### aliases ######
 15: LikelihoodType = Literal['bernoulli']
 16: # Bernoulli functions
 17: @jit(nopython=True, cache=True, fastmath=True)
 18: def _bernoulli_ll_block_pair(e: int, n: int, eps:float= 1e-6) -> float:
 19:     """
 20:     Profile log-likelihood for one block pair (constants dropped).
 21:     e: number of edges between block pair.
 22:     n: number of possible pairs between block pair.
 23:     """
 24:     if e == 0: # 0 Â· log 0 := 0   (limit)
 25:         return 0.0
 26:     elif n <= 0:
 27:         raise ValueError("Number of possible pairs (n) must be greater than 0.")
 28:     # clip to avoid overflow in lo
 29:     pos = max(e/n, eps)
 30:     neg = max(1 - e/n, eps)
 31:     return e * np.log(pos) - (n-e) * np.log(neg)
 32: @jit(fastmath=True, cache=True)
 33: def _delta_ll_bernoulli_block_pair(
 34:         e_old: int, e_new: int,
 35:         n_old: int, n_new: int,
 36:         eps: float = 1e-6
 37:         ) -> float:
 38:     """Îâ for a single block pair.
 39:     e_new: new number of edges between block pair.
 40:     e_old: old number of edges between block pair.
 41:     n_new: new number of possible pairs between block pair.
 42:     n_old: old number of possible pairs between block pair.
 43:     """
 44:     new_ll = _bernoulli_ll_block_pair(e=e_new, n=n_new, eps=eps)
 45:     old_ll = _bernoulli_ll_block_pair(e=e_old, n=n_old, eps=eps)
 46:     return new_ll - old_ll
 47: def compute_delta_ll_from_change_bernoulli(
 48:         delta_e: EdgeDelta,
 49:         delta_n: CombinationDelta,
 50:         block_data: BlockData) -> float:
 51:     """
 52:     Incremental change in Bernoulli log-likelihood after a node-swap or move.
 53:     Only the pairs present in `delta_e` or `delta_n` need to be visited.
 54:     delta_e: changes in edge counts between affected blocks.
 55:     delta_n: changes in possible pairs between affected blocks.
 56:     block_data: BlockData object containing edge counts and possible pairs.
 57:     :return: Tuple of (change in log-likelihood, edge counts changes of move delta).
 58:     """
 59:     upper_triangle_only = not block_data.directed
 60:     delta_ll = 0.0
 61:     for (r, s), delta in delta_e.items():
 62:         if upper_triangle_only and s < r:
 63:             continue
 64:         e_old = int(block_data.block_connectivity[r, s]) # type: ignore
 65:         n_old = block_data.get_possible_pairs(r, s)
 66:         e_new = e_old + delta
 67:         n_new = n_old + delta_n[r, s]
 68:         delta_ll += _delta_ll_bernoulli_block_pair(
 69:             e_old=e_old,
 70:             e_new=e_new,
 71:             n_old=n_old,
 72:             n_new=n_new
 73:         )
 74:     return delta_ll
 75: # ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
 76: ### Helpter function to vectorise the LL global computation
 77: # ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
 78: @jit(nopython=True, cache=True, fastmath=True)   # remove decorator if you dislike Numba
 79: def _ll_vec(edges: np.ndarray, pairs: np.ndarray, eps: float = 1e-6) -> np.ndarray:
 80:     """
 81:     edges  : e_rs   (int â¥ 0)
 82:     pairs  : n_rs   (int â¥ 1)
 83:     returns: â_rs   (float)
 84:     """
 85:     p = edges / pairs
 86:     p = np.where(p < eps, eps, p)
 87:     p = np.where(p > 1.0 - eps, 1.0 - eps, p)
 88:     return edges * np.log(p) - (pairs - edges) * np.log1p(-p)
 89: def compute_global_bernoulli_ll_fast(block_data:BlockData) -> float:
 90:     """
 91:     Computes the global log-likelihood of the SBM using Bernoulli likelihood.
 92:     Same semantics as the original `compute_global_bernoulli_ll`, but
 93:     **O(nnz)** instead of O(BÂ²).
 94:     The trick: only block pairs with at least one edge (e_rs > 0) can
 95:     change the profiled Bernoulli LL once the constants are dropped.
 96:     """
 97:     conn: coo_array = coo_array(block_data.block_connectivity)
 98:     rows, cols, e = conn.row, conn.col, conn.data.astype(np.int64)
 99:     # Undirected graphs: keep only upper-triangle to avoid double count
100:     if not block_data.directed:
101:         keep = rows <= cols
102:         rows, cols, e = rows[keep], cols[keep], e[keep]
103:     # Block sizes in matrix-index order
104:     sizes = np.fromiter(
105:         (block_data.block_sizes[block_data.inverse_block_indices[i]]
106:          for i in range(len(block_data.block_sizes))),
107:         dtype=np.int64,
108:         count=len(block_data.block_sizes)
109:     )
110:     # Possible pair counts n_rs (vectorised)
111:     n = np.where(
112:         rows == cols,
113:         sizes[rows] * (sizes[rows] - 1) // 2,   # diagonal blocks
114:         sizes[rows] * sizes[cols]               # off-diagonal
115:     )
116:     # Safety: skip singleton blocks (n = 0) to avoid /0 in n==1 corner
117:     valid = n > 0
118:     if not valid.all():
119:         rows, cols, e, n = rows[valid], cols[valid], e[valid], n[valid]
120:     # Vectorised LL and reduction
121:     return float(_ll_vec(e, n).sum())
122: def compute_global_bernoulli_ll(
123:         block_data: BlockData,
124: ) -> float:
125:     """
126:     Compute the global log-likelihood of the SBM using Bernoulli likelihood.
127:     :param block_data: The BlockData object containing block connectivity and sizes.
128:     :param upper_triangle_only: If True, only compute for upper triangle of the connectivity matrix.
129:     :return: The global log-likelihood.
130:     """
131:     upper_triangle_only = not block_data.directed
132:     ll = 0.0
133:     for r in range(len(block_data.block_sizes)):
134:         # if block has less than 2 nodes, skip it: no possible pairs
135:         size_r = block_data.block_sizes[ block_data.inverse_block_indices[r] ]
136:         if size_r <= 1:
137:             continue 
138:         for s in range(r if upper_triangle_only else 0, len(block_data.block_sizes)):
139:             e = block_data.block_connectivity[r, s]
140:             #n = block_data.get_possible_pairs(r, s)
141:             if r == s:
142:                 # If the same block, return the number of pairs within the block
143:                 n = block_data.block_sizes[r] * (block_data.block_sizes[r] - 1) // 2
144:             # If different blocks, return the product of their sizes
145:             else:
146:                 n = block_data.block_sizes[r] * block_data.block_sizes[s]
147:             if e < 0 or n < 0:
148:                 raise ValueError(f"Invalid edge count {e} or possible pairs {n} for block pair ({r}, {s}).")
149:             if e > n:
150:                 raise ValueError(f"Edge count {e} cannot be greater than possible pairs {n} for block pair ({r}, {s}).")
151:             ll += _bernoulli_ll_block_pair(e, n) # type: ignore
152:     return ll
153: #### LikelihoodCalculator class ######
154: class LikelihoodCalculator:
155:     def __init__(self,
156:                  block_data: BlockData,
157:                  likelihood_type: LikelihoodType = 'bernoulli',
158:                  ):
159:         self.block_data = block_data
160:         self.likelihood_type: LikelihoodType = 'bernoulli'
161:         self.nll = self.compute_nll()
162:     def compute_nll(self) -> float:
163:         """
164:         Compute the negative likelihood of the network given the current partition.
165:         :return: The negative log-likelihood of the SBM.
166:         """
167:         if self.likelihood_type.lower() == 'bernoulli':
168:             return -compute_global_bernoulli_ll_fast(block_data=self.block_data)
169:         else:
170:             raise NotImplementedError("Only Bernoulli likelihood is implemented.")
171:     def _compute_delta_nll_from_changes(self,
172:                                        delta_e: EdgeDelta,
173:                                        delta_n: CombinationDelta,
174:     ) ->float:
175:         """
176:         efficeintly compute the change in log-likelihood from changes in edge counts and possible pairs.
177:         :param delta_e: Changes in edge counts between blocks.
178:         :param delta_n: Changes in possible pairs between blocks.
179:         :param total_edges: Total number of edges in the graph.
180:         :return: The change in log-likelihood.
181:         """
182:         if self.likelihood_type.lower() == 'bernoulli':
183:             return -compute_delta_ll_from_change_bernoulli(
184:                 delta_e=delta_e,
185:                 delta_n=delta_n,
186:                 block_data=self.block_data
187:             )
188:         else:
189:             raise NotImplementedError("Only Bernoulli likelihood is implemented.")
190:     def compute_delta_nll(self,
191:                         delta_e: EdgeDelta,
192:                         delta_n: CombinationDelta,
193:         ) -> float:
194:         """
195:         Compute the change in log-likelihood for a proposed swap of two nodes.
196:         :param proposed_moves: A list of tuples (node_i, node_j) representing the nodes to swap.
197:         :return: The change in log-likelihood.
198:         """
199:         return self._compute_delta_nll_from_changes(
200:             delta_e=delta_e,
201:             delta_n=delta_n
202:             )




================================================================
End of Codebase
================================================================
