This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed, line numbers have been added.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: data/
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Line numbers have been added to the beginning of each line
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
.repomix/
  bundles.json
configs/
  sbm_fit_block_size_experiments.yml
  surrogate_eval.yml
notebooks/
  block_assigner_comparison_01-07-2025.ipynb
  convergence_figures_25-06-2025.ipynb
  likelihood_test.ipynb
  move_type_comparisons_30-06-2025.ipynb
  sbm_block_sizes_26-06-2025.ipynb
  sbm_visualize.ipynb
  surrogate_accuracy_26-06-2025.ipynb
planted_partitions/
  undirected_planted_partitions.py
slurm_scripts/
  fit_sbm.sh
src/
  data_processing/
    process_all.py
    process_caltech.py
    process_congress_twitter.py
    process_email_eu.py
    process_enron_email.py
    process_lastfm_asia.py
    process_wiki_vote.py
  metrics/
    __init__.py
    clustering.py
    degree.py
    shortest_path.py
  pipelines/
    evaluate_surrogates.py
    fit_sbm.py
    generate_and_evaluate_surrogates.py
    run_all.py
  sbm/
    utils/
      logger.py
      pipeline_utils.py
      util.py
    block_assigner.py
    block_change_proposers.py
    block_data.py
    edge_delta.py
    graph_data.py
    initial_partition.py
    io.py
    likelihood.py
    mcmc.py
    model.py
    node_mover.py
    sampling.py
    stopping_criteria.py
  tests/
    likelihood_test.py
    planted_partition_tests.py
    test_block_assigner.py
    test_change_proposer_and_mover.py
    test_edge_delta.py
    test_global_ll.py
    test_greedy_assign_helpers.py
    test_io.py
    test_metrics.py
    test_sampling.py
    test_swaps.py
.gitignore
env_backup.yml
pyproject.toml
README.md
requirements.txt
setup.cfg
tmp_test.py

================================================================
Files
================================================================

================
File: notebooks/block_assigner_comparison_01-07-2025.ipynb
================
  1: {
  2:  "cells": [
  3:   {
  4:    "cell_type": "markdown",
  5:    "id": "03332c1a",
  6:    "metadata": {},
  7:    "source": [
  8:     "# Notebook for comparing the quality of block-assignment strategies"
  9:    ]
 10:   },
 11:   {
 12:    "cell_type": "code",
 13:    "execution_count": 1,
 14:    "id": "ca236c42",
 15:    "metadata": {},
 16:    "outputs": [],
 17:    "source": [
 18:     "from pathlib import Path\n",
 19:     "\n",
 20:     "import numpy as np\n",
 21:     "import pandas as pd\n",
 22:     "import scipy.sparse as sp\n",
 23:     "\n",
 24:     "from sbm.io import GraphLoader\n",
 25:     "from sbm.block_assigner import AssignerConstructor"
 26:    ]
 27:   },
 28:   {
 29:    "cell_type": "code",
 30:    "execution_count": 2,
 31:    "id": "75c16b11",
 32:    "metadata": {},
 33:    "outputs": [],
 34:    "source": [
 35:     "#g = GraphLoader.load(\n",
 36:     "#    Path(\"/Users/lmmi/anon_sbm/data/processed/congress_twitter.edgelist\"),\n",
 37:     "#    force_undirected=True, # type: ignore\n",
 38:     "#    )\n",
 39:     "g = GraphLoader.load(\n",
 40:     "    Path(\"/Users/lmmi/anon_sbm/data/processed/lastfm_asia.edgelist\"),\n",
 41:     "    force_undirected=True, # type: ignore\n",
 42:     "    )"
 43:    ]
 44:   },
 45:   {
 46:    "cell_type": "code",
 47:    "execution_count": null,
 48:    "id": "e54ed4ac",
 49:    "metadata": {},
 50:    "outputs": [],
 51:    "source": [
 52:     "rng = np.random.default_rng(1) # type: ignore\n",
 53:     "k = 10"
 54:    ]
 55:   },
 56:   {
 57:    "cell_type": "code",
 58:    "execution_count": 4,
 59:    "id": "e8d0bf40",
 60:    "metadata": {},
 61:    "outputs": [],
 62:    "source": [
 63:     "assigner_const = AssignerConstructor(rng=rng)\n",
 64:     "uniform_assigner = assigner_const.create_assigner(\n",
 65:     "    graph_data=g,\n",
 66:     "    min_block_size=k, # type: ignore\n",
 67:     "    init_method=\"uniform\", # type: ignore\n",
 68:     "    )\n",
 69:     "prone_assigner = assigner_const.create_assigner(\n",
 70:     "    graph_data=g,\n",
 71:     "    min_block_size=k, # type: ignore\n",
 72:     "    init_method=\"prone_and_kmeans\", # type: ignore\n",
 73:     "    )\n",
 74:     "metis_assigner = assigner_const.create_assigner(\n",
 75:     "    graph_data=g,\n",
 76:     "    min_block_size=k, # type: ignore\n",
 77:     "    init_method=\"metis\", # type: ignore\n",
 78:     "    )\n",
 79:     "metis_ref_assigner = assigner_const.create_assigner(\n",
 80:     "    graph_data=g,\n",
 81:     "    min_block_size=k, # type: ignore\n",
 82:     "    init_method=\"metis_refine\", # type: ignore\n",
 83:     "    )"
 84:    ]
 85:   },
 86:   {
 87:    "cell_type": "code",
 88:    "execution_count": 5,
 89:    "id": "6030cfba",
 90:    "metadata": {},
 91:    "outputs": [],
 92:    "source": [
 93:     "uniform_blocks = uniform_assigner.compute_assignment()\n",
 94:     "#prone_blocks = prone_assigner.compute_assignment()\n",
 95:     "metis_blocks = metis_assigner.compute_assignment()\n",
 96:     "metis_ref_blocks = metis_ref_assigner.compute_assignment()"
 97:    ]
 98:   },
 99:   {
100:    "cell_type": "code",
101:    "execution_count": 6,
102:    "id": "8b91f480",
103:    "metadata": {},
104:    "outputs": [
105:     {
106:      "name": "stdout",
107:      "output_type": "stream",
108:      "text": [
109:       "{10, 11}\n",
110:       "{10, 11}\n",
111:       "{10, 11}\n"
112:      ]
113:     }
114:    ],
115:    "source": [
116:     "print(set(uniform_blocks.block_sizes.values()))\n",
117:     "#print(set(prone_blocks.block_sizes.values()))\n",
118:     "print(set(metis_blocks.block_sizes.values()))\n",
119:     "print(set(metis_ref_blocks.block_sizes.values()))"
120:    ]
121:   },
122:   {
123:    "cell_type": "code",
124:    "execution_count": 7,
125:    "id": "399008f8",
126:    "metadata": {},
127:    "outputs": [
128:     {
129:      "name": "stdout",
130:      "output_type": "stream",
131:      "text": [
132:       "\n",
133:       "Small graph likelihood comparison:\n",
134:       "    Uniform assignment likelihood: -98355.50266169311\n",
135:       "    Metis assignment likelihood: -49418.540600798835\n",
136:       "    Metis-refine assignment likelihood: -49862.94430540358\n",
137:       "\n"
138:      ]
139:     }
140:    ],
141:    "source": [
142:     "# compute likelihood of the assignments\n",
143:     "from sbm.likelihood import compute_global_bernoulli_ll_fast\n",
144:     "\n",
145:     "uniform_ll = compute_global_bernoulli_ll_fast(uniform_blocks)\n",
146:     "#prone_ll = compute_global_bernoulli_ll_fast(prone_blocks)\n",
147:     "metis_ll = compute_global_bernoulli_ll_fast(metis_blocks)\n",
148:     "metis_ref_ll = compute_global_bernoulli_ll_fast(metis_ref_blocks)\n",
149:     "\n",
150:     "print(f\"\"\"\n",
151:     "Small graph likelihood comparison:\n",
152:     "    Uniform assignment likelihood: {uniform_ll}\n",
153:     "    Metis assignment likelihood: {metis_ll}\n",
154:     "    Metis-refine assignment likelihood: {metis_ref_ll}\n",
155:     "\"\"\")"
156:    ]
157:   },
158:   {
159:    "cell_type": "code",
160:    "execution_count": null,
161:    "id": "f3633444",
162:    "metadata": {},
163:    "outputs": [],
164:    "source": []
165:   },
166:   {
167:    "cell_type": "code",
168:    "execution_count": null,
169:    "id": "f2c3d8e0",
170:    "metadata": {},
171:    "outputs": [],
172:    "source": []
173:   }
174:  ],
175:  "metadata": {
176:   "kernelspec": {
177:    "display_name": "Python 3",
178:    "language": "python",
179:    "name": "python3"
180:   },
181:   "language_info": {
182:    "codemirror_mode": {
183:     "name": "ipython",
184:     "version": 3
185:    },
186:    "file_extension": ".py",
187:    "mimetype": "text/x-python",
188:    "name": "python",
189:    "nbconvert_exporter": "python",
190:    "pygments_lexer": "ipython3",
191:    "version": "3.12.11"
192:   }
193:  },
194:  "nbformat": 4,
195:  "nbformat_minor": 5
196: }

================
File: notebooks/move_type_comparisons_30-06-2025.ipynb
================
  1: {
  2:  "cells": [
  3:   {
  4:    "cell_type": "code",
  5:    "execution_count": 1,
  6:    "id": "0c56f619",
  7:    "metadata": {},
  8:    "outputs": [],
  9:    "source": [
 10:     "# Notebook for comparing move-types and their resulting likelihood trajectories"
 11:    ]
 12:   },
 13:   {
 14:    "cell_type": "code",
 15:    "execution_count": 2,
 16:    "id": "ca236c42",
 17:    "metadata": {},
 18:    "outputs": [],
 19:    "source": [
 20:     "from pathlib import Path\n",
 21:     "\n",
 22:     "import numpy as np\n",
 23:     "import pandas as pd\n",
 24:     "import scipy.sparse as sp\n",
 25:     "\n",
 26:     "from sbm.io import GraphLoader\n",
 27:     "from sbm.block_assigner import AssignerConstructor\n",
 28:     "from sbm.model import SBMModel\n",
 29:     "\n",
 30:     "from sbm.utils.pipeline_utils import (\n",
 31:     "    sbmfit_folderpath,\n",
 32:     "    FitConfig,\n",
 33:     ")"
 34:    ]
 35:   },
 36:   {
 37:    "cell_type": "code",
 38:    "execution_count": 3,
 39:    "id": "75c16b11",
 40:    "metadata": {},
 41:    "outputs": [],
 42:    "source": [
 43:     "g = GraphLoader.load(\n",
 44:     "    Path(\"/Users/lmmi/anon_sbm/data/processed/congress_twitter.edgelist\"),\n",
 45:     "    force_undirected=True, # type: ignore\n",
 46:     "    )"
 47:    ]
 48:   },
 49:   {
 50:    "cell_type": "code",
 51:    "execution_count": 4,
 52:    "id": "e54ed4ac",
 53:    "metadata": {},
 54:    "outputs": [],
 55:    "source": [
 56:     "rng = np.random.default_rng(1) # type: ignore"
 57:    ]
 58:   },
 59:   {
 60:    "cell_type": "code",
 61:    "execution_count": null,
 62:    "id": "e8d0bf40",
 63:    "metadata": {},
 64:    "outputs": [
 65:     {
 66:      "name": "stdout",
 67:      "output_type": "stream",
 68:      "text": [
 69:       "ProNE embedding took 0.14 seconds for 475 nodes.\n",
 70:       "KMeans with constraints took 0.60 seconds for 475 nodes.\n"
 71:      ]
 72:     }
 73:    ],
 74:    "source": [
 75:     "assigner_const = AssignerConstructor(rng=rng)\n",
 76:     "assigner = assigner_const.create_assigner(\n",
 77:     "    graph_data=g,\n",
 78:     "    min_block_size=5, # type: ignore\n",
 79:     "    init_method=\"uniform\", # type: ignore\n",
 80:     "    )\n",
 81:     "\n",
 82:     "block_data = assigner.compute_assignment()"
 83:    ]
 84:   },
 85:   {
 86:    "cell_type": "code",
 87:    "execution_count": 6,
 88:    "id": "51e49a44",
 89:    "metadata": {},
 90:    "outputs": [],
 91:    "source": [
 92:     "uniform_swap_model = SBMModel(\n",
 93:     "    initial_blocks=block_data,\n",
 94:     "    rng=rng,\n",
 95:     "    change_freq = { # probabilities of trying each move type\n",
 96:     "        \"uniform_swap\": 1,\n",
 97:     "    },\n",
 98:     ")\n",
 99:     "\n",
100:     "edge_swap_model = SBMModel(\n",
101:     "    initial_blocks=block_data,\n",
102:     "    rng=rng,\n",
103:     "    change_freq = { # probabilities of trying each move type\n",
104:     "    \"uniform_swap\": 0.8,\n",
105:     "    \"edge_based_swap\": 0.1,\n",
106:     "    \"triadic_swap\": 0.1,\n",
107:     "    },\n",
108:     ")\n",
109:     "triad_swap_model = SBMModel(\n",
110:     "    initial_blocks=block_data,\n",
111:     "    rng=rng,\n",
112:     "    change_freq = { # probabilities of trying each move type\n",
113:     "    \"triadic_swap\": 1.0,\n",
114:     "    },\n",
115:     ")"
116:    ]
117:   },
118:   {
119:    "cell_type": "code",
120:    "execution_count": 7,
121:    "id": "73af6cbf",
122:    "metadata": {},
123:    "outputs": [],
124:    "source": [
125:     "max_num_iterations = int(1e5)\n",
126:     "min_block_size = 5\n",
127:     "initial_temperature = 1.0\n",
128:     "cooling_rate = 0.999\n",
129:     "max_blocks = None\n",
130:     "patience  = int(1e3)\n",
131:     "return_ll = True"
132:    ]
133:   },
134:   {
135:    "cell_type": "code",
136:    "execution_count": 8,
137:    "id": "bced68cd",
138:    "metadata": {},
139:    "outputs": [
140:     {
141:      "name": "stdout",
142:      "output_type": "stream",
143:      "text": [
144:       "Stopping early after 27012 iterations due to patience limit.\n"
145:      ]
146:     }
147:    ],
148:    "source": [
149:     "uniform_ll = uniform_swap_model.fit(\n",
150:     "    max_num_iterations=max_num_iterations,\n",
151:     "    min_block_size=min_block_size,\n",
152:     "    initial_temperature=initial_temperature,\n",
153:     "    cooling_rate=cooling_rate,\n",
154:     "    max_blocks=max_blocks,\n",
155:     "    patience=patience,\n",
156:     "    return_ll=return_ll,\n",
157:     ")"
158:    ]
159:   },
160:   {
161:    "cell_type": "code",
162:    "execution_count": 9,
163:    "id": "76f33e97",
164:    "metadata": {},
165:    "outputs": [
166:     {
167:      "name": "stdout",
168:      "output_type": "stream",
169:      "text": [
170:       "Stopping early after 2345 iterations due to patience limit.\n"
171:      ]
172:     }
173:    ],
174:    "source": [
175:     "edge_ll = edge_swap_model.fit(\n",
176:     "    max_num_iterations=max_num_iterations,\n",
177:     "    min_block_size=min_block_size,\n",
178:     "    initial_temperature=initial_temperature,\n",
179:     "    cooling_rate=cooling_rate,\n",
180:     "    max_blocks=max_blocks,\n",
181:     "    patience=patience,\n",
182:     "    return_ll=return_ll,\n",
183:     ")"
184:    ]
185:   },
186:   {
187:    "cell_type": "code",
188:    "execution_count": 10,
189:    "id": "96b956a2",
190:    "metadata": {},
191:    "outputs": [
192:     {
193:      "name": "stdout",
194:      "output_type": "stream",
195:      "text": [
196:       "Stopping early after 3040 iterations due to patience limit.\n"
197:      ]
198:     }
199:    ],
200:    "source": [
201:     "triad_ll = triad_swap_model.fit(\n",
202:     "    max_num_iterations=max_num_iterations,\n",
203:     "    min_block_size=min_block_size,\n",
204:     "    initial_temperature=initial_temperature,\n",
205:     "    cooling_rate=cooling_rate,\n",
206:     "    max_blocks=max_blocks,\n",
207:     "    patience=patience,\n",
208:     "    return_ll=return_ll,\n",
209:     ")"
210:    ]
211:   },
212:   {
213:    "cell_type": "code",
214:    "execution_count": 11,
215:    "id": "6dc70577",
216:    "metadata": {},
217:    "outputs": [
218:     {
219:      "name": "stderr",
220:      "output_type": "stream",
221:      "text": [
222:       "/var/folders/y6/j9fbqcvx6lb5l99614n30y4c0000gn/T/ipykernel_29400/3143086871.py:12: UserWarning: FigureCanvasAgg is non-interactive, and thus cannot be shown\n",
223:       "  fig.show()\n"
224:      ]
225:     },
226:     {
227:      "data": {
228:       "image/png": "iVBORw0KGgoAAAANSUhEUgAAAtQAAAINCAYAAAAeHOgXAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjMsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvZiW1igAAAAlwSFlzAAAPYQAAD2EBqD+naQAAbxJJREFUeJzt3Xd8VFX+//H3nUknJKEEEiBSpCOCgmJQihqNioWFVSw/BARdEHQpSlkVsCCWVUSBtQvu6op+d9VVEBYDQYVIB6WKiAYXQk9CCSkz5/fHkGuGBEzIhEkyr+fjMY/M3Hvm3s+dS3nPybnnWsYYIwAAAABnxeHvAgAAAICqjEANAAAAlAOBGgAAACgHAjUAAABQDgRqAAAAoBwI1AAAAEA5EKgBAACAciBQAwAAAOUQ5O8CApXb7dbu3btVs2ZNWZbl73IAAABwCmOMjhw5ogYNGsjhOH0/NIHaT3bv3q2EhAR/lwEAAIDfsWvXLjVq1Oi06wnUflKzZk1JnhMUFRXl52oAAABwquzsbCUkJNi57XQI1H5SOMwjKiqKQA0AAFCJ/d7wXC5KBAAAAMqBQA0AAACUA4EaAAAAKAfGUAMAgCrL5XIpPz/f32WginI6nQoKCir3FMYEagAAUCUdPXpUv/76q4wx/i4FVVhERITi4+MVEhJy1tsgUAMAgCrH5XLp119/VUREhGJjY7lJGsrMGKO8vDzt379fO3fuVIsWLc5485YzIVADAIAqJz8/X8YYxcbGKjw83N/loIoKDw9XcHCwfvnlF+Xl5SksLOystsNFiQAAoMqiZxrldba90l7b8EEdAAAAQMAiUAMAAFRBTZo00UsvvWS/zsjI0DXXXKMaNWooJibGb3UFomoTqFNTU2VZVomPVatW2e2+++47devWTWFhYUpISNBzzz1XbFsfffSRWrdurbCwMLVv317z58/3Wm+M0cSJExUfH6/w8HAlJSVp+/btFX6MAACgauvZs6dGjhxZbPns2bPLHIJXrVql++67z349bdo07dmzR+vXr9cPP/xQzkp9Y+nSpbrqqqtUu3ZtRUREqEWLFhowYIDy8vL8XZpPVZtA3bVrV+3Zs8frMWTIEDVt2lSdO3eWJGVnZ+vaa69V48aNtWbNGj3//POaPHmyXn/9dXs7y5cv1x133KHBgwdr3bp16t27t3r37q2NGzfabZ577jm9/PLLevXVV7VixQrVqFFDycnJOnHixDk/bgAAEJhiY2MVERFhv96xY4c6deqkFi1aqF69eme1TV8G3c2bN+u6665T586d9dVXX+n777/XK6+8opCQELlcLp/tp1Iw1VReXp6JjY01TzzxhL1s1qxZplatWiY3N9deNm7cONOqVSv79W233WZ69erlta0uXbqYP/3pT8YYY9xut4mLizPPP/+8vT4zM9OEhoaaf/7zn6WuLysry0gyWVlZZT42AAACXU5Ojtm8ebPJycnxdyll0qNHD/PnP/+52PJ33nnHREdH268HDBhgbrnlFvP888+buLg4U7t2bXP//febvLw8u03jxo3NtGnT7OeS7MeAAQOMMcb88ssv5uabbzY1atQwNWvWNLfeeqvJyMiwtzFp0iTToUMH88Ybb5gmTZoYy7KMMcZIMq+++qrp1auXCQ8PN61btzbLly8327dvNz169DAREREmMTHR/Pjjj6c91mnTppkmTZqcdr3b7TZ169Y1H330kb2sQ4cOJi4uzn799ddfm5CQEHPs2DFjjDEvvPCCueCCC0xERIRp1KiRGTZsmDly5Eixz/Hjjz82zZs3N6Ghoebaa6816enpp63jTH+WSpvXqk0P9an+85//6ODBgxo0aJC9LC0tTd27d/eauDs5OVnbtm3T4cOH7TZJSUle20pOTlZaWpokaefOncrIyPBqEx0drS5duthtSpKbm6vs7GyvBwAA8A1jjExern8eFXRjmSVLlmjHjh1asmSJ5syZo9mzZ2v27Nkltl21apWuu+463XbbbdqzZ4+mT58ut9utW265RYcOHdLSpUu1aNEi/fTTT+rXr5/Xe3/88Uf961//0r///W+tX7/eXv7kk0/q7rvv1vr169W6dWvdeeed+tOf/qQJEyZo9erVMsZoxIgRp60/Li5Oe/bs0VdffVXiesuy1L17d6WmpkqSDh8+rC1btignJ0dbt26V5Bkycskll9g98Q6HQy+//LI2bdqkOXPmaPHixRo7dqzXdo8fP64pU6bo3Xff1bJly5SZmanbb7/9TB91uVXbeajfeustJScnq1GjRvayjIwMNW3a1Ktd/fr17XW1atVSRkaGvaxom4yMDLtd0feV1KYkU6dO1eOPP372BwQAAE4vP08FU//il10HTXhaCgn1+XZr1aqlGTNmyOl0qnXr1urVq5dSUlJ07733FmsbGxur0NBQhYeHKy4uTpK0aNEiff/999q5c6cSEhIkSe+++67atWunVatW6ZJLLpHkGebx7rvvKjY21mubgwYN0m233SZJGjdunBITE/XYY48pOTlZkvTnP//Zq+PyVLfeeqsWLlyoHj16KC4uTpdddpmuvvpq3X333YqKipLkGVP+2muvSZK++uorXXTRRYqLi1Nqaqpat26t1NRU9ejRw95m0fHnTZo00VNPPaWhQ4dq1qxZ9vL8/HzNmDFDXbp0kSTNmTNHbdq00cqVK3XppZeW4pMvu0rfQz1+/PjTXmxY+Cj8FlPo119/1cKFCzV48GA/VV3chAkTlJWVZT927drl75IAAEAl1q5dOzmdTvt1fHy89u3bV+r3b9myRQkJCXaYlqS2bdsqJiZGW7ZssZc1bty4WJiWpAsvvNB+XtiR2L59e69lJ06cOO1v3Z1Op9555x39+uuveu6559SwYUM9/fTTateunfbs2SNJ6tGjhzZv3qz9+/dr6dKl6tmzp3r27KnU1FTl5+dr+fLl6tmzp73NL7/8UldffbUaNmyomjVrqn///jp48KCOHz9utwkKCrK/LEhS69atix2zr1X6HuoxY8Zo4MCBZ2zTrFkzr9fvvPOO6tSpo5tvvtlreVxcnPbu3eu1rPB14be507Upur5wWXx8vFebjh07nrbG0NBQhYb6/ttraU14YrIKCgqkWnVkOZ1eE+GfOiV+4bogp1PRYWGe9SeXOYq0KWxX7Gfh+t826PXaOjmBuiUpplYthYWF2dtzOBy/fVkqsh+HZUkn1ydER8t5sl3RWkp6FF0fERGhmjVrlvejBABURsEhnp5iP+27tKKiopSVlVVseWZmpqKjo703Gxzs9dqyLLnd7rOr8Qxq1KhR4vKi+y/8P7WkZb9XU8OGDdW/f3/1799fTz75pFq2bKlXX31Vjz/+uNq3b6/atWtr6dKlWrp0qaZMmaK4uDg9++yzWrVqlfLz89W1a1dJ0s8//6wbb7xRw4YN05QpU1S7dm198803Gjx4sPLy8rwu0DzXKn2gjo2NLfFb0+kYY/TOO+/o7rvvLvYHMTExUY888ojy8/PtdYsWLVKrVq1Uq1Ytu01KSorXrxQWLVqkxMRESVLTpk0VFxenlJQUO0BnZ2drxYoVGjZsWDmOtGI989TTUn6+v8vwq5EjR2ratGn+LgMAUAEsy6qQYRe+1qpVK/33v/8ttnzt2rVq2bKlT/fVpk0b7dq1S7t27bJ7qTdv3qzMzEy1bdvWp/sqrVq1aik+Pl7Hjh2T5Dlv3bp106effqpNmzbpiiuuUEREhHJzc/Xaa6+pc+fOduBfs2aN3G63XnjhBfvuhh9++GGxfRQUFGj16tX28I5t27YpMzNTbdq0qbDjqvSBuqwWL16snTt3asiQIcXW3XnnnXr88cc1ePBgjRs3Ths3btT06dO9Qtaf//xn9ejRQy+88IJ69eqlDz74QKtXr7an1rMsSyNHjtRTTz2lFi1aqGnTpnrsscfUoEED9e7d+1wdZpnVTmjk6aE+5R8br8soilxU4TZGBW6394UWxqjYZRdF1p/2ooyTy82p7fPyZE6c+G2ZMSW3PaWGGsHBnotPijwK93+m5dyeFgDgb8OGDdOMGTP04IMPasiQIQoNDdW8efP0z3/+U5999plP95WUlKT27dvrrrvu0ksvvaSCggLdf//96tGjhz2lcEV67bXXtH79ev3hD3/Q+eefrxMnTujdd9/Vpk2b9Morr9jtevbsqTFjxqhz586KjIyUJHXv3l3vvfeeHn74Ybtd8+bNlZ+fr1deeUU33XSTli1bpldffbXYfoODg/XAAw/o5ZdfVlBQkEaMGKHLLruswsZPS9UwUL/11lvq2rWrWrduXWxddHS0/vvf/2r48OHq1KmT6tatq4kTJ3pNit61a1e9//77evTRR/WXv/xFLVq00CeffKILLrjAbjN27FgdO3ZM9913nzIzM3XFFVdowYIFCgsLOyfHeDYyhtwu5eUq6IEJsmrX9Xc5AAAEpGbNmumrr77SI488oqSkJOXl5al169b66KOPdN111/l0X5Zl6dNPP9UDDzyg7t27y+Fw6LrrrvMKsxXp0ksv1TfffKOhQ4dq9+7dioyMVLt27fTJJ594XWjYo0cPuVwur7HSPXv21Keffuq1rEOHDnrxxRf17LPPasKECerevbumTp2qu+++22u/ERERGjdunO68807973//U7du3fTWW29V6LFapqLmesEZZWdnKzo6WllZWfaVrhUp/5lHpNwTChoxXlad0g+hAQCgMjpx4oR27typpk2bVuoOLZxbs2fP1siRI5WZmVnq95zpz1Jp81qln+UDPlI43IHvTwAAAD5FoA4UBGoAAIAKQaAOFNbJU02gBgAA1dTAgQPLNNzDVwjUgYIeagAAgApBoA4UBGoAAIAKQaAOFHag9v0dlgAAAAIZgTpQnAzUzJIIAADgWwTqQMGQDwAAgApBoA4UBGoAAIAKQaAOFIyhBgCgyrIsS5988om/y8BpEKgDBT3UAAD43cCBA2VZVrHHdddd5+/SJElvvPGGOnTooMjISMXExOiiiy7S1KlT/V1WpRfk7wJwjhCoAQCoFK677jq98847XstCQ0P9VM1v3n77bY0cOVIvv/yyevToodzcXH333XfauHGjv0ur9OihDhTcKREAgEohNDRUcXFxXo9atWrZ67dv367u3bsrLCxMbdu21aJFi4ptY/ny5erYsaPCwsLUuXNnffLJJ7IsS+vXr7fbbNy4Uddff70iIyNVv3599e/fXwcOHDhtXf/5z3902223afDgwWrevLnatWunO+64Q1OmTLG353A4tH//fknSoUOH5HA4dPvtt9vbeOqpp3TFFVdIklwulwYPHqymTZsqPDxcrVq10vTp0732OXDgQPXu3VuPP/64YmNjFRUVpaFDhyovL6/sH6wf0UMdKOihBgBUY8YYHc/P98u+I4KDZRX+P1tObrdbffr0Uf369bVixQplZWVp5MiRXm2ys7N100036YYbbtD777+vX375pVibzMxMXXXVVRoyZIimTZumnJwcjRs3TrfddpsWL15c4r7j4uK0dOlS/fLLL2rcuHGx9e3atVOdOnW0dOlS/fGPf9TXX39tvy60dOlS9ezZ0z6WRo0a6aOPPlKdOnW0fPly3XfffYqPj9dtt91mvyclJUVhYWFKTU3Vzz//rEGDBqlOnTp2kK8KCNSBgkANAKjGjufnK9JPY32PTpigGiEhpW7/+eefKzIy0mvZX/7yF/3lL3/Rl19+qa1bt2rhwoVq0KCBJOnpp5/W9ddfb7d9//33ZVmW3njjDbsX+3//+5/uvfdeu82MGTN00UUX6emnn7aXvf3220pISNAPP/ygli1bFqtr0qRJ6tOnj5o0aaKWLVsqMTFRN9xwg/74xz/K4XDIsix1795dqamp+uMf/6jU1FQNGjRIb775prZu3arzzz9fy5cv19ixYyVJwcHBevzxx+3tN23aVGlpafrwww+9AnVISIjefvttRUREqF27dnriiSf08MMP68knn5TDUTUGUxCoAwWBGgCASuHKK6/U3/72N69ltWvXliRt2bJFCQkJdpiWpMTERK+227Zt04UXXqiwsDB72aWXXurVZsOGDVqyZEmx4C5JO3bsKDFQx8fHKy0tTRs3btRXX32l5cuXa8CAAXrzzTe1YMECORwO9ejRQ6+//rokT2/0008/rR9++EGpqak6dOiQ8vPzdfnll9vbnDlzpt5++22lp6crJydHeXl56tixo9d+O3TooIiICK/jPXr0qHbt2lViT3llRKAOFARqAEA1FhEcrKMTJvht32VRo0YNNW/evIKq8Th69KhuuukmPfvss8XWxcfHn/G9F1xwgS644ALdf//9Gjp0qLp166alS5fqyiuvVM+ePTVy5Eht375dmzdv1hVXXKGtW7cqNTVVhw8fVufOne1w/MEHH+ihhx7SCy+8oMTERNWsWVPPP/+8VqxYUSHH7E8E6gBhWZaMRKAGAFRLlmWVadhFZdWmTRvt2rVLe/bssYPvt99+69WmVatW+sc//qHc3Fx7dpBVq1Z5tbn44ov1r3/9S02aNFFQ0NnHvbZt20qSjh07Jklq3769atWqpaeeekodO3ZUZGSkevbsqWeffVaHDx+2x09L0rJly9S1a1fdf//99rIdO3YU28eGDRuUk5Oj8PBw+3gjIyOVkJBw1nWfa1VjYArKjx5qAAAqhdzcXGVkZHg9CmffSEpKUsuWLTVgwABt2LBBX3/9tR555BGv9995551yu9267777tGXLFi1cuFB//etfJcm+OHL48OE6dOiQ7rjjDq1atUo7duzQwoULNWjQILlcrhLrGjZsmJ588kktW7ZMv/zyi7799lvdfffdio2NtYedFI6jfu+99+zwfOGFFyo3N1cpKSnq0aOHvb0WLVpo9erVWrhwoX744Qc99thjxYK/JOXl5Wnw4MHavHmz5s+fr0mTJmnEiBFVZvy0RKAOHNwpEQCASmHBggWKj4/3ehRONedwOPTxxx8rJydHl156qYYMGVJstouoqCh99tlnWr9+vTp27KhHHnlEEydOlCR7XHWDBg20bNkyuVwuXXvttWrfvr1GjhypmJiY0wbVpKQkffvtt7r11lvVsmVL9e3bV2FhYUpJSVGdOnXsdj169JDL5bIDtcPhUPfu3WVZltf46T/96U/q06eP+vXrpy5duujgwYNevdWFrr76arVo0ULdu3dXv379dPPNN2vy5Mln/fn6g2UMXZb+kJ2drejoaGVlZSkqKqrC91fw1ssyv/4iZ7+BcrRuX+H7AwCgIp04cUI7d+5U06ZNvS7OC1TvvfeeBg0apKysLHvoRFUwcOBAZWZm+vW26mf6s1TavMYY6kDBkA8AAKqNd999V82aNVPDhg21YcMGe47pqhSmqxMCdaDgTokAAFQbGRkZmjhxojIyMhQfH69bb721St0IpbohUAcKeqgBAKg2xo4da99ApSqbPXu2v0vwCS5KDBQEagAAgApBoA4UBGoAAIAKQaAOFARqAACACkGgDhQEagAAgApBoA4U3NgFAACgQhCoAwU91AAAABWCQB0oCNQAAFQ5kydPVseOHcu9Hcuy7LsR/vzzz7IsS+vXry/3duFBoA4UJwO1cROoAQDwB8uyzviYPHlysfc89NBDSklJ8WkdCQkJ2rNnjy644IKz3sbHH3+syy67TNHR0apZs6batWunkSNH+q7IKoYbuwQKR+GdEhlDDQCAP+zZs8d+PnfuXE2cOFHbtm2zl0VGRtrPjTFyuVyKjIz0Wu4LTqdTcXFxZ/3+lJQU9evXT1OmTNHNN98sy7K0efNmLVq0yIdVVi30UAeKwkDtJlADAOAPcXFx9iM6OlqWZdmvt27dqpo1a+qLL75Qp06dFBoaqm+++abYkI9Vq1bpmmuuUd26dRUdHa0ePXpo7dq1XvvZvn27unfvrrCwMLVt27ZY0C1pyMemTZt04403KioqSjVr1lS3bt20Y8eOEo/js88+0+WXX66HH35YrVq1UsuWLdW7d2/NnDlTkpSVlSWn06nVq1dLktxut2rXrq3LLrvM3sY//vEPJSQk2K/HjRunli1bKiIiQs2aNdNjjz2m/Px8e33h5/Daa68pISFBERERuu2225SVlVW2k1BB6KEOFFZhDzVDPgAA1Y8xRsePH/fLviMiImQVXqtUTuPHj9df//pXNWvWTLVq1VJqaqrX+iNHjmjAgAF65ZVXZIzRCy+8oBtuuEHbt29XzZo15Xa71adPH9WvX18rVqxQVlbW7w7F+N///qfu3burZ8+eWrx4saKiorRs2TIVFBSU2D4uLk7vv/++Nm7cWOKwkejoaHXs2FGpqanq3Lmzvv/+e1mWpXXr1uno0aOKjIzU0qVL1aNHD/s9NWvW1OzZs9WgQQN9//33uvfee1WzZk2v26v/+OOP+vDDD/XZZ58pOztbgwcP1v3336/33nuv9B9wBSFQBwq7h9rl3zoAAKgAx48f9/nQiNI6evSoatSo4ZNtPfHEE7rmmmtOu/6qq67yev36668rJiZGS5cu1Y033qgvv/xSW7du1cKFC9WgQQNJ0tNPP63rr7/+tNucOXOmoqOj9cEHHyg4OFiS1LJly9O2f+CBB/T111+rffv2aty4sS677DJde+21uuuuuxQaGipJ6tmzp1JTU/XQQw8pNTVV11xzjbZu3apvvvlG1113nVJTU73C8qOPPmo/b9KkiR566CF98MEHXm1OnDihd999Vw0bNpQkvfLKK+rVq5deeOGFcg1h8QWGfASKwm/OXJQIAECl1blz5zOu37t3r+699161aNFC0dHRioqK0tGjR5Weni5J2rJlixISEuwwLUmJiYln3Ob69evVrVs3O0z/nho1amjevHn68ccf9eijjyoyMlJjxozRpZdeav+WoEePHvrmm2/kcrm0dOlS9ezZ0w7Zu3fv1o8//qiePXva25w7d64uv/xyxcXFKTIyUo8++qh9TIXOO+88O0wXHpfb7fYah+4v9FAHCi5KBABUYxERETp69Kjf9u0rv9fTPWDAAB08eFDTp09X48aNFRoaqsTEROXl5Z31PsPDw8/qfeeff77OP/98DRkyRI888ohatmypuXPnatCgQerevbuOHDmitWvX6quvvtLTTz+tuLg4PfPMM+rQoYMaNGigFi1aSJLS0tJ011136fHHH1dycrLdW/7CCy+c9TGdawTqAGFZDhmJHmoAQLVkWZbPhl1UZsuWLdOsWbN0ww03SJJ27dqlAwcO2OvbtGmjXbt2ac+ePYqPj5ckffvtt2fc5oUXXqg5c+YoPz+/1L3Up2rSpIkiIiJ07NgxSVJMTIwuvPBCzZgxQ8HBwWrdurXq1aunfv366fPPP/caP718+XI1btxYjzzyiL3sl19+KbaP9PR07d692+59//bbb+VwONSqVauzqtmXGPIRKOihBgCgymvRooX+/ve/a8uWLVqxYoXuuusurx7mpKQktWzZUgMGDNCGDRv09ddfewXVkowYMULZ2dm6/fbbtXr1am3fvl1///vfTzuUYvLkyRo7dqxSU1O1c+dOrVu3Tvfcc4/y8/O9xn/37NlT7733nh2ea9eurTZt2mju3LlegbpFixZKT0/X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+eaRRx4x//73v40k8/HHH3utf+aZZ0x0dLT55JNPzIYNG8zNN99smjZtanJycuw21113nenQoYP59ttvzddff22aN29u7rjjDnt9VlaWqV+/vrnrrrvMxo0bzT//+U8THh5uXnvtNbvNsmXLjNPpNM8995zZvHmzefTRR01wcLD5/vvvK/wzqOx+7xwNGDDAXHfddV5/pw4dOuTVhnNUcZKTk80777xjNm7caNavX29uuOEGc95555mjR4/abc7Vv2v8P1Zcac5Pjx49zL333uv1dygrK8tez/nxHQJ1ALj00kvN8OHD7dcul8s0aNDATJ061Y9VVT+TJk0yHTp0KHFdZmamCQ4ONh999JG9bMuWLUaSSUtLM8Z4woXD4TAZGRl2m7/97W8mKirK5ObmGmOMGTt2rGnXrp3Xtvv162eSk5N9fDTVy6lhze12m7i4OPP888/byzIzM01oaKj55z//aYwxZvPmzUaSWbVqld3miy++MJZlmf/973/GGGNmzZplatWqZZ8fY4wZN26cadWqlf36tttuM7169fKqp0uXLuZPf/qTT4+xqjtdoL7llltO+x7O0bm1b98+I8ksXbrUGHNu/13j/7Hfd+r5McYTqP/85z+f9j2cH99hyEc1l5eXpzVr1igpKcle5nA4lJSUpLS0ND9WVj1t375dDRo0ULNmzXTXXXcpPT1dkrRmzRrl5+d7nYfWrVvrvPPOs89DWlqa2rdvr/r169ttkpOTlZ2drU2bNtltim6jsA3nsmx27typjIwMr88yOjpaXbp08TofMTEx6ty5s90mKSlJDodDK1assNt0795dISEhdpvk5GRt27ZNhw8ftttwzs5eamqq6tWrp1atWmnYsGE6ePCgvY5zdG5lZWVJkmrXri3p3P27xv9jpXPq+Sn03nvvqW7durrgggs0YcIEHT9+3F7H+fGdIH8XgIp14MABuVwur78sklS/fn1t3brVT1VVT126dNHs2bPVqlUr7dmzR48//ri6deumjRs3KiMjQyEhIYqJifF6T/369ZWRkSFJysjIKPE8Fa47U5vs7Gzl5OQoPDy8go6uein8PEv6LIt+1vXq1fNaHxQUpNq1a3u1adq0abFtFK6rVavWac9Z4TZwetddd5369Omjpk2baseOHfrLX/6i66+/XmlpaXI6nZyjc8jtdmvkyJG6/PLLdcEFF0jSOft37fDhw/w/9jtKOj+SdOedd6px48Zq0KCBvvvuO40bN07btm3Tv//9b0mcH18iUAM+cv3119vPL7zwQnXp0kWNGzfWhx9+SNAFzsLtt99uP2/fvr0uvPBCnX/++UpNTdXVV1/tx8oCz/Dhw7Vx40Z98803/i4FJTjd+bnvvvvs5+3bt1d8fLyuvvpq7dixQ+eff/65LrNaY8hHNVe3bl05nc5iV13v3btXcXFxfqoqMMTExKhly5b68ccfFRcXp7y8PGVmZnq1KXoe4uLiSjxPhevO1CYqKorQXgaFn+eZ/l7ExcVp3759XusLCgp06NAhn5wz/v6VXbNmzVS3bl39+OOPkjhH58qIESP0+eefa8mSJWrUqJG9/Fz9u8b/Y2d2uvNTki5dukiS198hzo9vEKiruZCQEHXq1EkpKSn2MrfbrZSUFCUmJvqxsurv6NGj2rFjh+Lj49WpUycFBwd7nYdt27YpPT3dPg+JiYn6/vvvvQLCokWLFBUVpbZt29ptim6jsA3nsmyaNm2quLg4r88yOztbK1as8DofmZmZWrNmjd1m8eLFcrvd9n9KiYmJ+uqrr5Sfn2+3WbRokVq1aqVatWrZbThnvvHrr7/q4MGDio+Pl8Q5qmjGGI0YMUIff/yxFi9eXGzozLn6d43/x0r2e+enJOvXr5ckr79DnB8f8fdVkah4H3zwgQkNDTWzZ882mzdvNvfdd5+JiYnxuqoX5TdmzBiTmppqdu7caZYtW2aSkpJM3bp1zb59+4wxnumlzjvvPLN48WKzevVqk5iYaBITE+33F05fdO2115r169ebBQsWmNjY2BKnL3r44YfNli1bzMyZM5k27zSOHDli1q1bZ9atW2ckmRdffNGsW7fO/PLLL8YYz7R5MTEx5tNPPzXfffedueWWW0qcNu+iiy4yK1asMN98841p0aKF15RsmZmZpn79+qZ///5m48aN5oMPPjARERHFpmQLCgoyf/3rX82WLVvMpEmTmJLtpDOdoyNHjpiHHnrIpKWlmZ07d5ovv/zSXHzxxaZFixbmxIkT9jY4RxVn2LBhJjo62qSmpnpNu3b8+HG7zbn6d43/x4r7vfPz448/mieeeMKsXr3a7Ny503z66aemWbNmpnv37vY2OD++Q6AOEK+88oo577zzTEhIiLn00kvNt99+6++Sqp1+/fqZ+Ph4ExISYho2bGj69etnfvzxR3t9Tk6Ouf/++02tWrVMRESE+cMf/mD27NnjtY2ff/7ZXH/99SY8PNzUrVvXjBkzxuTn53u1WbJkienYsaMJCQkxzZo1M++88865OLwqZ8mSJUZSsceAAQOMMZ6p8x577DFTv359Exoaaq6++mqzbds2r20cPHjQ3HHHHSYyMtJERUWZQYMGmSNHjni12bBhg7niiitMaGioadiwoXnmmWeK1fLhhx+ali1bmpCQENOuXTszb968CjvuquRM5+j48ePm2muvNbGxsSY4ONg0btzY3HvvvcX+g+YcVZySzo0kr39zzuW/a/w/5u33zk96errp3r27qV27tgkNDTXNmzc3Dz/8sNc81MZwfnzFMsaYc9cfDgAAAFQvjKEGAAAAyoFADQAAAJQDgRoAAAAoBwI1AAAAUA4EagAAAKAcCNQAAABAORCoAQAAgHIgUAMAzqkmTZropZde8ncZAOAzBGoAqMYGDhyo3r17S5J69uypkSNHnrN9z549WzExMcWWr1q1Svfdd985qwMAKlqQvwsAAFQteXl5CgkJOev3x8bG+rAaAPA/eqgBIAAMHDhQS5cu1fTp02VZlizL0s8//yxJ2rhxo66//npFRkaqfv366t+/vw4cOGC/t2fPnhoxYoRGjhypunXrKjk5WZL04osvqn379qpRo4YSEhJ0//336+jRo5Kk1NRUDRo0SFlZWfb+Jk+eLKn4kI/09HTdcsstioyMVFRUlG677Tbt3bvXXj958mR17NhRf//739WkSRNFR0fr9ttv15EjRyr2QwOAUiJQA0AAmD59uhITE3Xvvfdqz5492rNnjxISEpSZmamrrrpKF110kVavXq0FCxZo7969uu2227zeP2fOHIWEhGjZsmV69dVXJUkOh0Mvv/yyNm3apDlz5mjx4sUaO3asJKlr16566aWXFBUVZe/voYceKlaX2+3WLbfcokOHDmnp0qVatGiRfvrpJ/Xr18+r3Y4dO/TJJ5/o888/1+eff66lS5fqmWeeqaBPCwDKhiEfABAAoqOjFRISooiICMXFxdnLZ8yYoYsuukhPP/20veztt99WQkKCfvjhB7Vs2VKS1KJFCz333HNe2yw6HrtJkyZ66qmnNHToUM2aNUshISGKjo6WZVle+ztVSkqKvv/+e+3cuVMJCQmSpHfffVft2rXTqlWrdMkll0jyBO/Zs2erZs2akqT+/fsrJSVFU6ZMKd8HAwA+QA81AASwDRs2aMmSJYqMjLQfrVu3luTpFS7UqVOnYu/98ssvdfXVV6thw4aqWbOm+vfvr4MHD+r48eOl3v+WLVuUkJBgh2lJatu2rWJiYrRlyxZ7WZMmTewwLUnx8fHat29fmY4VACoKPdQAEMCOHj2qm266Sc8++2yxdfHx8fbzGjVqeK37+eefdeONN2rYsGGaMmWKateurW+++UaDBw9WXl6eIiIifFpncHCw12vLsuR2u326DwA4WwRqAAgQISEhcrlcXssuvvhi/etf/1KTJk0UFFT6/xLWrFkjt9utF154QQ6H55edH3744e/u71Rt2rTRrl27tGvXLruXevPmzcrMzFTbtm1LXQ8A+BNDPgAgQDRp0kQrVqzQzz//rAMHDsjtdmv48OE6dOiQ7rjjDq1atUo7duzQwoULNWjQoDOG4ebNmys/P1+vvPKKfvrpJ/3973+3L1Ysur+jR48qJSVFBw4cKHEoSFJSktq3b6+77rpLa9eu1cqVK3X33XerR48e6ty5s88/AwCoCARqAAgQDz30kJxOp9q2bavY2Filp6erQYMGWrZsmVwul6699lq1b99eI0eOVExMjN3zXJIOHTroxRdf1LPPPqsLLrhA7733nqZOnerVpmvXrho6dKj69eun2NjYYhc1Sp6hG59++qlq1aql7t27KykpSc2aNdPcuXN9fvwAUFEsY4zxdxEAAABAVUUPNQAAAFAOBGoAAACgHAjUAAAAQDkQqAEAAIByIFADAAAA5UCgBgAAAMqBQA0AAACUA4EaAAAAKAcCNQAAAFAOBGoAAACgHAjUAAAAQDkQqAEAAIBy+P/CS/CyD6E2yAAAAABJRU5ErkJggg==",
229:       "text/plain": [
230:        "<Figure size 800x600 with 1 Axes>"
231:       ]
232:      },
233:      "metadata": {},
234:      "output_type": "display_data"
235:     }
236:    ],
237:    "source": [
238:     "import matplotlib.pyplot as plt\n",
239:     "fig, ax = plt.subplots(figsize=(8,6))\n",
240:     "\n",
241:     "ax.plot(uniform_ll, label=\"Uniform Swap\", color=\"salmon\")\n",
242:     "ax.plot(edge_ll, label=\"Edge Swap\", color=\"teal\")\n",
243:     "ax.plot(triad_ll, label=\"Triadic Swap\", color=\"black\")\n",
244:     "\n",
245:     "ax.set_xlabel(\"Iteration\")\n",
246:     "ax.set_ylabel(\"Log Likelihood\")\n",
247:     "\n",
248:     "ax.legend()\n",
249:     "fig.show()"
250:    ]
251:   },
252:   {
253:    "cell_type": "code",
254:    "execution_count": null,
255:    "id": "6030cfba",
256:    "metadata": {},
257:    "outputs": [],
258:    "source": []
259:   }
260:  ],
261:  "metadata": {
262:   "kernelspec": {
263:    "display_name": "anon_sbm_notebook",
264:    "language": "python",
265:    "name": "python3"
266:   },
267:   "language_info": {
268:    "codemirror_mode": {
269:     "name": "ipython",
270:     "version": 3
271:    },
272:    "file_extension": ".py",
273:    "mimetype": "text/x-python",
274:    "name": "python",
275:    "nbconvert_exporter": "python",
276:    "pygments_lexer": "ipython3",
277:    "version": "3.12.11"
278:   }
279:  },
280:  "nbformat": 4,
281:  "nbformat_minor": 5
282: }

================
File: src/tests/test_global_ll.py
================
  1: """Tests that the *slow* and *fast* global Bernoulli loglikelihood
  2: implementations are numerically identical on a variety of synthetic block
  3: partitions.
  4: We build *real* ``BlockData`` instances by constructing a synthetic graph
  5: (adjacency matrix) whose edge counts per block pair match a prescribed
  6: connectivity matrix.  This avoids touching the rest of the SBM pipeline
  7: while exercising exactly the code paths used by the likelihood routines.
  8: """
  9: from __future__ import annotations
 10: import random
 11: from typing import List, Sequence, Tuple
 12: import numpy as np
 13: import pytest
 14: import scipy.sparse as sp
 15: # ---------------------------------------------------------------------------
 16: # Functions under test
 17: # ---------------------------------------------------------------------------
 18: from sbm.likelihood import (
 19:     compute_global_bernoulli_ll,
 20:     compute_global_bernoulli_ll_fast,
 21: )
 22: from sbm.graph_data import GraphData
 23: # ---------------------------------------------------------------------------
 24: # Utility to create a BlockData instance whose *block_connectivity* matches a
 25: # given integer matrix ``conn`` (undirected only, because BlockData does not
 26: # implement the directed path).
 27: # ---------------------------------------------------------------------------
 28: try:
 29:     from sbm.block_data import BlockData  # type: ignore
 30: except ModuleNotFoundError:  # local fallback
 31:     from block_data import BlockData  # type: ignore
 32: def _node_ranges(sizes: Sequence[int]) -> List[Tuple[int, int]]:
 33:     """Return (start, stop) index for each block (Python halfopen)."""
 34:     ranges = []
 35:     start = 0
 36:     for sz in sizes:
 37:         ranges.append((start, start + sz))
 38:         start += sz
 39:     return ranges
 40: def build_block_data(
 41:     block_sizes: Sequence[int],
 42:     conn: np.ndarray,
 43:     rng: random.Random,
 44: ) -> BlockData:
 45:     """Construct a *consistent* BlockData (undirected) for testing."""
 46:     B = len(block_sizes)
 47:     assert conn.shape == (B, B)
 48:     assert (conn == conn.T).all(), "Connectivity must be symmetric for undirected graphs."  # noqa: E501
 49:     # Total number of nodes & adjacency matrix
 50:     N = int(sum(block_sizes))
 51:     adj = sp.dok_array((N, N), dtype=np.int64)
 52:     ranges = _node_ranges(block_sizes)
 53:     for r in range(B):
 54:         nodes_r = list(range(*ranges[r]))
 55:         # Diagonal block r==r
 56:         e_rr = int(conn[r, r])
 57:         if e_rr:
 58:             # all unordered pairs inside block
 59:             possible = [(u, v) for i, u in enumerate(nodes_r) for v in nodes_r[i + 1 :]]
 60:             assert e_rr <= len(possible)
 61:             chosen = rng.sample(possible, e_rr)
 62:             for u, v in chosen:
 63:                 adj[u, v] = 1
 64:                 adj[v, u] = 1
 65:         for s in range(r + 1, B):
 66:             e_rs = int(conn[r, s])
 67:             if not e_rs:
 68:                 continue
 69:             nodes_s = list(range(*ranges[s]))
 70:             possible = [(u, v) for u in nodes_r for v in nodes_s]
 71:             assert e_rs <= len(possible)
 72:             chosen = rng.sample(possible, e_rs)
 73:             for u, v in chosen:
 74:                 adj[u, v] = 1
 75:                 adj[v, u] = 1
 76:     adj = adj.tocsr()
 77:     # Blocks mapping: node -> block_id (block IDs are 0..B-1)
 78:     blocks = {node: b for b, (start, stop) in enumerate(ranges) for node in range(start, stop)}
 79:     dummy_graph = GraphData(adj, directed=False)
 80:     return BlockData(initial_blocks=blocks, graph_data=dummy_graph)
 81: # ---------------------------------------------------------------------------
 82: # Sanity helper
 83: # ---------------------------------------------------------------------------
 84: def assert_ll_equal(bd: BlockData):
 85:     ll_slow = compute_global_bernoulli_ll(bd)
 86:     ll_fast = compute_global_bernoulli_ll_fast(bd)
 87:     assert np.isclose(ll_slow, ll_fast, rtol=1e-4, atol=1e-6), f"{ll_slow} != {ll_fast}"
 88: # ==========================================================================
 89: # TEST CASES
 90: # ==========================================================================
 91: # 1) Tiny hand-crafted graph -------------------------------------------------
 92: def test_tiny_example():
 93:     sizes = [3, 4]
 94:     conn = np.array([[2, 5],
 95:                      [5, 1]], dtype=np.int64)
 96:     bd = build_block_data(sizes, conn, rng=random.Random(0))
 97:     assert_ll_equal(bd)
 98: # 2) Singleton block present -------------------------------------------------
 99: def test_singleton_block():
100:     sizes = [1, 5, 2]
101:     conn = np.array([[0, 0, 0],
102:                      [0, 4, 3],
103:                      [0, 3, 1]], dtype=np.int64)
104:     # ensure symmetry
105:     conn = conn + conn.T - np.diag(conn.diagonal())
106:     bd = build_block_data(sizes, conn, rng=random.Random(1))
107:     assert_ll_equal(bd)
108: # 3) Random dense undirected graphs -----------------------------------------
109: @pytest.mark.parametrize("seed,B", [(2, 4), (3, 6)])
110: def test_random_dense(seed: int, B: int):
111:     rng = random.Random(seed)
112:     sizes = [rng.randint(2, 6) for _ in range(B)]
113:     conn = np.zeros((B, B), dtype=np.int64)
114:     for r in range(B):
115:         n_rr = sizes[r] * (sizes[r] - 1) // 2
116:         conn[r, r] = rng.randrange(n_rr + 1)
117:         for s in range(r + 1, B):
118:             n_rs = sizes[r] * sizes[s]
119:             val = rng.randrange(n_rs + 1)
120:             conn[r, s] = conn[s, r] = val
121:     bd = build_block_data(sizes, conn, rng)
122:     assert_ll_equal(bd)

================
File: src/tests/test_greedy_assign_helpers.py
================
  1: import numpy as np
  2: import scipy.sparse as sp
  3: from scipy.sparse import csr_array
  4: import pytest
  5: from collections import Counter, defaultdict
  6: from sbm.block_assigner import (
  7:     _boundary_vertices,
  8:     _movable_vertex,
  9:     _move,
 10:     categorize,
 11:     move_node_to_under,
 12:     move_node_from_over,
 13:     balance_k_plus_1_blocks,
 14:     _rebalance_to_min_size,
 15: )
 16: # ---------------------------------------------------------------------------
 17: # Minimal helper to build a fully connected small graph ---------------------
 18: # ---------------------------------------------------------------------------
 19: def full_graph_csr(n: int) -> csr_array:
 20:     rows, cols = np.triu_indices(n, 1)
 21:     data = np.ones_like(rows)
 22:     A = csr_array((data, (rows, cols)), shape=(n, n))
 23:     A = A + A.T  # undirected
 24:     return A
 25: # ---------------------------------------------------------------------------
 26: # Tests for categorize ------------------------------------------------------
 27: # ---------------------------------------------------------------------------
 28: def test_categorize_basic():
 29:     k = 3
 30:     sizes = {0: 2, 1: 3, 2: 4, 3: 5}
 31:     over2, over1, under = categorize(sizes, k)
 32:     assert over2 == {3}
 33:     assert over1 == {2}
 34:     assert under == {0}
 35: # ---------------------------------------------------------------------------
 36: # Tests for move_node_to_under -------------------------------------------
 37: # ---------------------------------------------------------------------------
 38: def test_move_node_to_under_correct():
 39:     k = 2
 40:     A = full_graph_csr(4)
 41:     # block 0 undersize (1), block 1 oversize (3)
 42:     blocks = {0: 0, 1: 1, 2: 1, 3: 1}
 43:     sizes = Counter(blocks.values())
 44:     members = defaultdict(set)
 45:     for v, b in blocks.items():
 46:         members[b].add(v)
 47:     rng = np.random.default_rng(0)
 48:     over2, over1, under = categorize(sizes, k)
 49:     move_node_to_under(
 50:         under=under,
 51:         over1=over1,
 52:         over2=over2,
 53:         rng=rng,
 54:         sizes=sizes,
 55:         k=k,
 56:         members=members,
 57:         blocks=blocks,
 58:         indptr=A.indptr,
 59:         indices=A.indices,
 60:     )
 61:     # After move, block 0 should have size 2, block 1 size 2
 62:     assert sizes[0] == k
 63:     assert sizes[1] == k
 64:     # No undersized blocks remain
 65:     _, _, under_new = categorize(sizes, k)
 66:     assert not under_new
 67: # ---------------------------------------------------------------------------
 68: # Tests for move_node_from_over --------------------------------------------
 69: # ---------------------------------------------------------------------------
 70: def test_move_node_from_over_shrink():
 71:     k = 3
 72:     A = full_graph_csr(8)
 73:     # block 0 size 2 (<k), block 1 size 6 (>k+1), others size 0
 74:     blocks = {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1}
 75:     sizes = Counter(blocks.values())
 76:     members = defaultdict(set)
 77:     for v, b in blocks.items():
 78:         members[b].add(v)
 79:     rng = np.random.default_rng(1)
 80:     over2, over1, under = categorize(sizes, k)
 81:     move_node_from_over(
 82:         under=under,
 83:         over1=over1,
 84:         over2=over2,
 85:         rng=rng,
 86:         sizes=sizes,
 87:         k=k,
 88:         members=members,
 89:         blocks=blocks,
 90:         indptr=A.indptr,
 91:         indices=A.indices,
 92:         r_target=0,
 93:     )
 94:     # block 0 size should have increased by 1, block1 decreased by1
 95:     assert sizes[0] == 2  # reached k
 96:     assert sizes[1] == 6
 97: # ---------------------------------------------------------------------------
 98: # Tests for balance_k_plus_1_blocks ----------------------------------------
 99: # ---------------------------------------------------------------------------
100: def test_balance_k_plus_1_blocks_shrink_and_enlarge():
101:     k = 2
102:     A = full_graph_csr(6)
103:     # create three blocks: 0 size 3 (k+1), 1 size 3 (k+1), 2 size 0 (empty)
104:     blocks = {0: 0, 1: 0, 2: 0, 3: 1, 4: 1, 5: 1}
105:     sizes = Counter(blocks.values())
106:     members = defaultdict(set)
107:     for v, b in blocks.items():
108:         members[b].add(v)
109:     rng = np.random.default_rng(3)
110:     r_target = 1  # we want exactly one k+1
111:     over2, over1, under = categorize(sizes, k)
112:     assert len(over1) == 2  # precondition
113:     # no possible balance to achieve
114:     balance_k_plus_1_blocks(
115:         over1=over1,
116:         over2=over2,
117:         rng=rng,
118:         sizes=sizes,
119:         k=k,
120:         members=members,
121:         blocks=blocks,
122:         indptr=A.indptr,
123:         indices=A.indices,
124:         r_target=r_target,
125:     )
126:     # After balancing, over1 should be 1
127:     over2_after, over1_after, under_after = categorize(sizes, k)
128:     assert len(over1_after) == len(over1) # no change made
129:     assert len(over2_after) == len(over2) # no change made
130:     assert not under_after and not under # no undersized introduced
131: # ---------------------------------------------------------------------------
132: # Test safety with empty sets ----------------------------------------------
133: # ---------------------------------------------------------------------------
134: def test_empty_sets_no_crash():
135:     k = 2
136:     A = full_graph_csr(3)
137:     blocks = {0: 0, 1: 0, 2: 0}
138:     sizes = Counter(blocks.values())
139:     members = defaultdict(set)
140:     for v, b in blocks.items():
141:         members[b].add(v)
142:     rng = np.random.default_rng(4)
143:     # empty over/under sets
144:     over2, over1, under = categorize(sizes, k)
145:     # should do nothing and not raise
146:     move_node_to_under(under, over1, over2, rng, sizes, k, members, blocks, A.indptr, A.indices)
147:     move_node_from_over(under, over1, over2, rng, sizes, k, members, blocks, A.indptr, A.indices, r_target=0)
148:     balance_k_plus_1_blocks(over1, over2, rng, sizes, k, members, blocks, A.indptr, A.indices, r_target=0)
149: # ---------------------------------------------------------------------------
150: # Integration test for _rebalance_to_min_size ------------------------------
151: # ---------------------------------------------------------------------------
152: def test_rebalance_removes_all_undersize():
153:     n = 25
154:     k = 3
155:     A = full_graph_csr(n)
156:     rng = np.random.default_rng(10)
157:     # start with random over/under assignment
158:     blocks = {i: rng.integers(0, 8) for i in range(n)}
159:     print(set(Counter(blocks.values()).values()))
160:     balanced = _rebalance_to_min_size(blocks.copy(), A, k, rng)
161:     sizes = Counter(balanced.values())
162:     print(set(sizes.values()))
163:     # No block smaller than k
164:     assert min(sizes.values()) >= k

================
File: .repomix/bundles.json
================
1: {
2:   "bundles": {}
3: }

================
File: notebooks/convergence_figures_25-06-2025.ipynb
================
  1: {
  2:  "cells": [
  3:   {
  4:    "cell_type": "markdown",
  5:    "id": "af425169",
  6:    "metadata": {},
  7:    "source": [
  8:     "# Notebook for visualizing the convergence of the MCMC algorithm"
  9:    ]
 10:   },
 11:   {
 12:    "cell_type": "code",
 13:    "execution_count": null,
 14:    "id": "828ee0d9",
 15:    "metadata": {},
 16:    "outputs": [],
 17:    "source": [
 18:     "import numpy as np\n",
 19:     "import pandas as pd\n",
 20:     "import matplotlib.pyplot as plt"
 21:    ]
 22:   },
 23:   {
 24:    "cell_type": "code",
 25:    "execution_count": 69,
 26:    "id": "9f091b92",
 27:    "metadata": {},
 28:    "outputs": [],
 29:    "source": [
 30:     "import sys\n",
 31:     "from pathlib import Path\n",
 32:     "logs_path = Path(\"/Users/lmmi/anon_sbm/logs\")\n",
 33:     "\n",
 34:     "# find all log files in the logs directory\n",
 35:     "log_files = list(logs_path.glob(\"*.csv\"))"
 36:    ]
 37:   },
 38:   {
 39:    "cell_type": "code",
 40:    "execution_count": 70,
 41:    "id": "e8adb1d1",
 42:    "metadata": {},
 43:    "outputs": [],
 44:    "source": [
 45:     "def determine_name(file_name, dataset_names):\n",
 46:     "    \"\"\"\n",
 47:     "    Determine the name of the dataset based on the file name.\n",
 48:     "    \"\"\"\n",
 49:     "    for name in dataset_names:\n",
 50:     "        if name in file_name:\n",
 51:     "            return name\n",
 52:     "    return \"unknown\"\n",
 53:     "dataset_names = [ \"congress_twitter\", \"caltech_fb\", \"eu_email\", ]"
 54:    ]
 55:   },
 56:   {
 57:    "cell_type": "code",
 58:    "execution_count": 71,
 59:    "id": "23eabf12",
 60:    "metadata": {},
 61:    "outputs": [],
 62:    "source": [
 63:     "df_list = []\n",
 64:     "\n",
 65:     "for log_file in log_files:\n",
 66:     "    df = pd.read_csv(log_file)\n",
 67:     "    df[\"name\"] = determine_name(log_file.name, dataset_names)\n",
 68:     "\n",
 69:     "    df_list.append(df)\n",
 70:     "\n",
 71:     "df = pd.concat(df_list, ignore_index=True)"
 72:    ]
 73:   },
 74:   {
 75:    "cell_type": "code",
 76:    "execution_count": 72,
 77:    "id": "afc3941c",
 78:    "metadata": {},
 79:    "outputs": [
 80:     {
 81:      "name": "stderr",
 82:      "output_type": "stream",
 83:      "text": [
 84:       "/var/folders/y6/j9fbqcvx6lb5l99614n30y4c0000gn/T/ipykernel_88748/2982452800.py:32: UserWarning: FigureCanvasAgg is non-interactive, and thus cannot be shown\n",
 85:       "  fig.show()\n"
 86:      ]
 87:     },
 88:     {
 89:      "data": {
 90:       "image/png": "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5IGuqKgISUlJGDduHACgadOmcHJyQlJSEvr06QMAuHLlCm7duqXQq0dERERERGRMogt0urh16xYyMzNx69YtFBYWIiUlBQBQq1YtuLu7Y8eOHUhPT0fLli3h6uqKxMRELFiwAFOmTJFfY/To0fjyyy8xdepUDB8+HPv378fmzZuxa9cueZ1JkyZhyJAhaNasGVq0aIHPP/8cubm5GDZsGADA09MT0dHRmDRpEipWrAgPDw+MHz8erVq1UrvCJRERERERkaGsOtDNnj0ba9eulT9+6aWXAAAHDhxA+/bt4eTkhBUrVuDdd9+FIAioVasW/u///g8jRoyQnxMSEoJdu3bh3XffxbJly1ClShV88803iIqKktd54403cO/ePcyePRtpaWkICwvDnj17FBZK+eyzzyCVStGnTx/k5eUhKioKsbGxZngViIiIiIjIXoluDp094xw6IiIiIiLShc1vW0BERERERGSrGOiIiIiIiIisFAMdERERERGRlWKgIyIiIiIislIMdERERERERFaKgY6IiIiIiMhKMdARERERERFZKQY6IiIiIiIiK8VAR0REREREZKUY6IiIiIiIiKwUAx0REREREZGVYqAjIiIiIiKyUgx0REREREREVoqBjoiIiIiIyEox0BEREREREVkpBjoiIiIiIiIrxUBHRERERERkpRjoiIiIiIiIrBQDHRERERERkZVioCMiIiIiIrJSDHRERERERERWioGOiIiIiIjISjHQERERERERWSkGOiIiIiIiIivFQEdERERERGSlGOiIiIiIiIisFAMdERERERGRlWKgIyIiIiIislIMdERERERERFaKgY6IiIiIiMhKMdARERERERFZKUdtKn344Yd6XVwikWDWrFl6nUtERERERESaSQRBEMqqJJUqd+RJJBL5n0teQnZcEARIJBIUFhYao512IScnB56ensjOzoaHh4elm0NERERERCKnVQ/dgQMHlI59+umn2LdvHwYNGoQ2bdrA398f6enpOHToEL7//ntERUVh0qRJRm8wERERERERFdOqh660b775BpMmTUJycjIaNGigVH7u3Dm0bt0ay5Ytw/Dhw43SUHvAHjoiIiIiItKFXoGuUaNGaNWqFb766iu1dUaMGIE///wT586dM6iB9oSBjoiIiIiIdKHXKpdXr15FpUqVNNapVKkS/vnnH70aRURERERERGXTK9D5+vril19+gbrOvaKiIvzyyy/w8fExqHFERERERESknl6B7s0338TZs2fx2muv4cyZMwplKSkpeO2113D+/HkMHDjQKI0kIiIiIiIiZXrNoXv27Blee+01JCUlQSKRoHz58vD19cW9e/eQm5sLQRAQGRmJ7du3w9XV1RTttkmcQ0dERERERLrQq4fO1dUV+/btw7fffot27drB2dkZt27dgrOzM9q3b49vv/0We/fuZZgjIiIiIiIyIb166Mg02ENHRERERES60KuHjoiIiIiIiCzP0ZCTb9y4gfXr1yMlJQU5OTnw8PBAWFgYBg4ciOrVqxupiURERERERKSK3kMuly1bhqlTp6KgoEBp+wInJycsWbIE77zzjlEaaS845JKIiIiIiHSh15DLnTt34t1334Wnpyfmz5+PI0eO4Pr160hOTsaCBQvg6emJSZMmYdeuXcZuLxEREREREf1Lrx66jh074uzZs0hJSUGVKlWUym/fvo2XXnoJTZo0QVJSklEaag/YQ0dERERERLrQq4fu1KlTeOONN1SGOQAIDg5Gv379cPLkSYMaR0REREREROrpFejy8/NRvnx5jXXc3d2Rn5+vV6OIiIiIiIiobHoFujp16mDHjh0oKChQWV5QUICdO3eiTp06BjWOiIiIiIiI1NMr0A0ePBhXrlxBVFSU0rDKEydOoFu3brhy5QqGDBlilEYSERERERGRMr0WRSksLESfPn2wfft2SCQSlCtXDn5+fsjIyMCTJ08gCAL+85//4Mcff4RUyr3LtcVFUYiIiIiISBd6pS0HBwds27YN8fHxaN++PZydnXHr1i04OzujQ4cOWLt2LX766SeGOSIiIiIiIhPSe2NxMj720BERERERkS7YhUZERERERGSlHA05+caNG1i/fj1SUlKQk5MDDw8PhIWFYeDAgahevbqRmkhERERERESq6D3kctmyZZg6dSoKCgpQ+hJOTk5YsmQJ3nnnHaM00l5wyCUREREREelCryGXO3fuxLvvvgtPT0/Mnz8fR44cwfXr15GcnIwFCxbA09MTkyZNwq5du4zdXiIiIiIiIvqXXj10HTt2xNmzZ5GSkoIqVaoold++fRsvvfQSmjRpgqSkJKM01B6wh46IiIiIiHShVw/dqVOn8MYbb6gMcwAQHByMfv36KW06TkRERERERMaj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",
 91:       "text/plain": [
 92:        "<Figure size 1000x600 with 1 Axes>"
 93:       ]
 94:      },
 95:      "metadata": {},
 96:      "output_type": "display_data"
 97:     }
 98:    ],
 99:    "source": [
100:     "marker_styles = {\n",
101:     "    \"congress_twitter\": \"o\",\n",
102:     "    \"caltech_fb\": \"s\",\n",
103:     "    \"eu_email\": \"D\",\n",
104:     "}\n",
105:     "colors = {\n",
106:     "    \"congress_twitter\": \"teal\",\n",
107:     "    \"caltech_fb\": \"salmon\",\n",
108:     "    \"eu_email\": \"black\",\n",
109:     "}\n",
110:     "\n",
111:     "\n",
112:     "fig, ax = plt.subplots(figsize=(10, 6))\n",
113:     "\n",
114:     "for name, group in df.groupby(\"name\"):\n",
115:     "    group = group.sort_values(\"iteration\")\n",
116:     "    ax.plot(\n",
117:     "        group[\"iteration\"],\n",
118:     "        group[\"neg_log_likelihood\"],\n",
119:     "        label=name,\n",
120:     "        linewidth=0,\n",
121:     "        marker=marker_styles[name], # type: ignore\n",
122:     "        )\n",
123:     "\n",
124:     "plt.legend(fontsize=12)\n",
125:     "\n",
126:     "ax.set_ylabel(\"Negative Log Likelihood\", fontsize=14)\n",
127:     "ax.set_xlabel(\"MCMC Iteration\", fontsize=14)\n",
128:     "\n",
129:     "\n",
130:     "ax.spines[['top', 'right']].set_visible(False)\n",
131:     "fig.show()"
132:    ]
133:   },
134:   {
135:    "cell_type": "code",
136:    "execution_count": null,
137:    "id": "666c6cc1",
138:    "metadata": {},
139:    "outputs": [],
140:    "source": []
141:   }
142:  ],
143:  "metadata": {
144:   "kernelspec": {
145:    "display_name": "anon_sbm_notebook",
146:    "language": "python",
147:    "name": "python3"
148:   },
149:   "language_info": {
150:    "codemirror_mode": {
151:     "name": "ipython",
152:     "version": 3
153:    },
154:    "file_extension": ".py",
155:    "mimetype": "text/x-python",
156:    "name": "python",
157:    "nbconvert_exporter": "python",
158:    "pygments_lexer": "ipython3",
159:    "version": "3.13.5"
160:   }
161:  },
162:  "nbformat": 4,
163:  "nbformat_minor": 5
164: }

================
File: notebooks/likelihood_test.ipynb
================
   1: {
   2:  "cells": [
   3:   {
   4:    "cell_type": "code",
   5:    "execution_count": 2,
   6:    "metadata": {},
   7:    "outputs": [],
   8:    "source": [
   9:     "import numpy as np\n",
  10:     "import scipy.sparse as sp\n",
  11:     "from sbm.sbm import StochasticBlockModel"
  12:    ]
  13:   },
  14:   {
  15:    "cell_type": "code",
  16:    "execution_count": 32,
  17:    "metadata": {},
  18:    "outputs": [],
  19:    "source": [
  20:     "num_nodes = 1000\n",
  21:     "block_size = 50\n",
  22:     "# Generate a random sparse adjacency matrix\n",
  23:     "adjacency = sp.random(num_nodes, num_nodes, density=0.01, format='csr')\n",
  24:     "adjacency = adjacency + adjacency.T  # Make it symmetric\n",
  25:     "adjacency.data = np.ones_like(adjacency.data)  # Unweighted graph\n",
  26:     "\n",
  27:     "# Create an initial uniform random partition\n",
  28:     "initial_blocks = StochasticBlockModel.create_uniform_partition(num_nodes, block_size)\n",
  29:     "\n",
  30:     "# Initialize the SBM\n",
  31:     "sbm = StochasticBlockModel(adjacency, initial_blocks)"
  32:    ]
  33:   },
  34:   {
  35:    "cell_type": "code",
  36:    "execution_count": 33,
  37:    "metadata": {},
  38:    "outputs": [
  39:     {
  40:      "name": "stdout",
  41:      "output_type": "stream",
  42:      "text": [
  43:       "Initial Likelihood: -110207.47925966672\n"
  44:      ]
  45:     }
  46:    ],
  47:    "source": [
  48:     "# Compute the initial likelihood\n",
  49:     "initial_likelihood = sbm.compute_likelihood()\n",
  50:     "print(f\"Initial Likelihood: {initial_likelihood}\")"
  51:    ]
  52:   },
  53:   {
  54:    "cell_type": "code",
  55:    "execution_count": 34,
  56:    "metadata": {},
  57:    "outputs": [
  58:     {
  59:      "name": "stdout",
  60:      "output_type": "stream",
  61:      "text": [
  62:       "[True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True]\n"
  63:      ]
  64:     }
  65:    ],
  66:    "source": [
  67:     "block_0 = sbm.block_members[0]\n",
  68:     "sbm.split_block(0)\n",
  69:     "\n",
  70:     "test = [elem in block_0 for elem in sbm.block_members[0]]\n",
  71:     "print(test)"
  72:    ]
  73:   },
  74:   {
  75:    "cell_type": "code",
  76:    "execution_count": 35,
  77:    "metadata": {},
  78:    "outputs": [
  79:     {
  80:      "name": "stdout",
  81:      "output_type": "stream",
  82:      "text": [
  83:       "[True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True]\n"
  84:      ]
  85:     }
  86:    ],
  87:    "source": [
  88:     "block_1, block_2 = sbm.block_members[1], sbm.block_members[2]\n",
  89:     "\n",
  90:     "sbm.merge_blocks(1, 2)\n",
  91:     "\n",
  92:     "test = [elem in sbm.block_members[1] for elem in block_1] + [elem in sbm.block_members[1] for elem in block_2]\n",
  93:     "print(test)"
  94:    ]
  95:   },
  96:   {
  97:    "cell_type": "code",
  98:    "execution_count": 62,
  99:    "metadata": {},
 100:    "outputs": [],
 101:    "source": [
 102:     "sbm.split_block(0)"
 103:    ]
 104:   },
 105:   {
 106:    "cell_type": "code",
 107:    "execution_count": 63,
 108:    "metadata": {},
 109:    "outputs": [
 110:     {
 111:      "data": {
 112:       "text/plain": [
 113:        "dict_keys([3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 26])"
 114:       ]
 115:      },
 116:      "execution_count": 63,
 117:      "metadata": {},
 118:      "output_type": "execute_result"
 119:     }
 120:    ],
 121:    "source": [
 122:     "sbm.block_members.keys()"
 123:    ]
 124:   },
 125:   {
 126:    "cell_type": "code",
 127:    "execution_count": 64,
 128:    "metadata": {},
 129:    "outputs": [
 130:     {
 131:      "data": {
 132:       "text/plain": [
 133:        "{3: [361,\n",
 134:        "  569,\n",
 135:        "  298,\n",
 136:        "  110,\n",
 137:        "  288,\n",
 138:        "  972,\n",
 139:        "  595,\n",
 140:        "  10,\n",
 141:        "  67,\n",
 142:        "  436,\n",
 143:        "  281,\n",
 144:        "  52,\n",
 145:        "  476,\n",
 146:        "  791,\n",
 147:        "  760,\n",
 148:        "  388,\n",
 149:        "  926,\n",
 150:        "  928,\n",
 151:        "  45,\n",
 152:        "  40,\n",
 153:        "  393,\n",
 154:        "  474,\n",
 155:        "  237,\n",
 156:        "  226,\n",
 157:        "  814,\n",
 158:        "  447,\n",
 159:        "  884,\n",
 160:        "  833,\n",
 161:        "  62,\n",
 162:        "  834,\n",
 163:        "  387,\n",
 164:        "  448,\n",
 165:        "  788,\n",
 166:        "  179,\n",
 167:        "  801,\n",
 168:        "  318,\n",
 169:        "  64,\n",
 170:        "  629,\n",
 171:        "  968,\n",
 172:        "  911,\n",
 173:        "  568,\n",
 174:        "  450,\n",
 175:        "  735,\n",
 176:        "  1,\n",
 177:        "  410,\n",
 178:        "  30,\n",
 179:        "  389,\n",
 180:        "  215,\n",
 181:        "  478,\n",
 182:        "  319],\n",
 183:        " 4: [202,\n",
 184:        "  787,\n",
 185:        "  255,\n",
 186:        "  502,\n",
 187:        "  242,\n",
 188:        "  827,\n",
 189:        "  402,\n",
 190:        "  256,\n",
 191:        "  584,\n",
 192:        "  547,\n",
 193:        "  579,\n",
 194:        "  739,\n",
 195:        "  282,\n",
 196:        "  697,\n",
 197:        "  135,\n",
 198:        "  342,\n",
 199:        "  636,\n",
 200:        "  377,\n",
 201:        "  118,\n",
 202:        "  722,\n",
 203:        "  915,\n",
 204:        "  685,\n",
 205:        "  397,\n",
 206:        "  341,\n",
 207:        "  416,\n",
 208:        "  612,\n",
 209:        "  491,\n",
 210:        "  392,\n",
 211:        "  941,\n",
 212:        "  668,\n",
 213:        "  148,\n",
 214:        "  370,\n",
 215:        "  247,\n",
 216:        "  734,\n",
 217:        "  991,\n",
 218:        "  619,\n",
 219:        "  262,\n",
 220:        "  351,\n",
 221:        "  628,\n",
 222:        "  864,\n",
 223:        "  337,\n",
 224:        "  845,\n",
 225:        "  752,\n",
 226:        "  244,\n",
 227:        "  903,\n",
 228:        "  606,\n",
 229:        "  269,\n",
 230:        "  898,\n",
 231:        "  780,\n",
 232:        "  716],\n",
 233:        " 5: [352,\n",
 234:        "  210,\n",
 235:        "  473,\n",
 236:        "  807,\n",
 237:        "  676,\n",
 238:        "  353,\n",
 239:        "  534,\n",
 240:        "  813,\n",
 241:        "  88,\n",
 242:        "  58,\n",
 243:        "  198,\n",
 244:        "  715,\n",
 245:        "  519,\n",
 246:        "  945,\n",
 247:        "  264,\n",
 248:        "  357,\n",
 249:        "  53,\n",
 250:        "  934,\n",
 251:        "  877,\n",
 252:        "  217,\n",
 253:        "  437,\n",
 254:        "  653,\n",
 255:        "  746,\n",
 256:        "  737,\n",
 257:        "  461,\n",
 258:        "  953,\n",
 259:        "  458,\n",
 260:        "  346,\n",
 261:        "  414,\n",
 262:        "  329,\n",
 263:        "  902,\n",
 264:        "  106,\n",
 265:        "  295,\n",
 266:        "  695,\n",
 267:        "  480,\n",
 268:        "  994,\n",
 269:        "  206,\n",
 270:        "  592,\n",
 271:        "  44,\n",
 272:        "  171,\n",
 273:        "  876,\n",
 274:        "  105,\n",
 275:        "  758,\n",
 276:        "  57,\n",
 277:        "  128,\n",
 278:        "  7,\n",
 279:        "  811,\n",
 280:        "  145,\n",
 281:        "  985,\n",
 282:        "  977],\n",
 283:        " 6: [229,\n",
 284:        "  394,\n",
 285:        "  656,\n",
 286:        "  744,\n",
 287:        "  935,\n",
 288:        "  333,\n",
 289:        "  407,\n",
 290:        "  736,\n",
 291:        "  546,\n",
 292:        "  553,\n",
 293:        "  221,\n",
 294:        "  982,\n",
 295:        "  914,\n",
 296:        "  101,\n",
 297:        "  230,\n",
 298:        "  406,\n",
 299:        "  872,\n",
 300:        "  266,\n",
 301:        "  285,\n",
 302:        "  325,\n",
 303:        "  582,\n",
 304:        "  562,\n",
 305:        "  222,\n",
 306:        "  924,\n",
 307:        "  78,\n",
 308:        "  970,\n",
 309:        "  899,\n",
 310:        "  729,\n",
 311:        "  869,\n",
 312:        "  77,\n",
 313:        "  908,\n",
 314:        "  510,\n",
 315:        "  713,\n",
 316:        "  9,\n",
 317:        "  593,\n",
 318:        "  279,\n",
 319:        "  429,\n",
 320:        "  721,\n",
 321:        "  933,\n",
 322:        "  860,\n",
 323:        "  375,\n",
 324:        "  334,\n",
 325:        "  750,\n",
 326:        "  849,\n",
 327:        "  524,\n",
 328:        "  225,\n",
 329:        "  241,\n",
 330:        "  803,\n",
 331:        "  759,\n",
 332:        "  669],\n",
 333:        " 7: [92,\n",
 334:        "  196,\n",
 335:        "  770,\n",
 336:        "  530,\n",
 337:        "  740,\n",
 338:        "  189,\n",
 339:        "  777,\n",
 340:        "  699,\n",
 341:        "  144,\n",
 342:        "  463,\n",
 343:        "  404,\n",
 344:        "  270,\n",
 345:        "  890,\n",
 346:        "  320,\n",
 347:        "  315,\n",
 348:        "  403,\n",
 349:        "  310,\n",
 350:        "  350,\n",
 351:        "  802,\n",
 352:        "  293,\n",
 353:        "  29,\n",
 354:        "  587,\n",
 355:        "  846,\n",
 356:        "  852,\n",
 357:        "  86,\n",
 358:        "  453,\n",
 359:        "  523,\n",
 360:        "  249,\n",
 361:        "  939,\n",
 362:        "  34,\n",
 363:        "  912,\n",
 364:        "  0,\n",
 365:        "  776,\n",
 366:        "  812,\n",
 367:        "  340,\n",
 368:        "  512,\n",
 369:        "  187,\n",
 370:        "  672,\n",
 371:        "  677,\n",
 372:        "  190,\n",
 373:        "  878,\n",
 374:        "  893,\n",
 375:        "  605,\n",
 376:        "  411,\n",
 377:        "  228,\n",
 378:        "  665,\n",
 379:        "  751,\n",
 380:        "  439,\n",
 381:        "  5,\n",
 382:        "  844],\n",
 383:        " 8: [795,\n",
 384:        "  943,\n",
 385:        "  212,\n",
 386:        "  978,\n",
 387:        "  347,\n",
 388:        "  71,\n",
 389:        "  48,\n",
 390:        "  292,\n",
 391:        "  155,\n",
 392:        "  608,\n",
 393:        "  997,\n",
 394:        "  576,\n",
 395:        "  449,\n",
 396:        "  990,\n",
 397:        "  36,\n",
 398:        "  895,\n",
 399:        "  979,\n",
 400:        "  778,\n",
 401:        "  154,\n",
 402:        "  494,\n",
 403:        "  529,\n",
 404:        "  542,\n",
 405:        "  303,\n",
 406:        "  560,\n",
 407:        "  471,\n",
 408:        "  385,\n",
 409:        "  901,\n",
 410:        "  124,\n",
 411:        "  180,\n",
 412:        "  850,\n",
 413:        "  631,\n",
 414:        "  769,\n",
 415:        "  137,\n",
 416:        "  462,\n",
 417:        "  307,\n",
 418:        "  263,\n",
 419:        "  89,\n",
 420:        "  805,\n",
 421:        "  428,\n",
 422:        "  424,\n",
 423:        "  892,\n",
 424:        "  390,\n",
 425:        "  63,\n",
 426:        "  19,\n",
 427:        "  782,\n",
 428:        "  267,\n",
 429:        "  917,\n",
 430:        "  773,\n",
 431:        "  465,\n",
 432:        "  842],\n",
 433:        " 9: [76,\n",
 434:        "  733,\n",
 435:        "  49,\n",
 436:        "  43,\n",
 437:        "  614,\n",
 438:        "  885,\n",
 439:        "  618,\n",
 440:        "  164,\n",
 441:        "  423,\n",
 442:        "  117,\n",
 443:        "  516,\n",
 444:        "  565,\n",
 445:        "  166,\n",
 446:        "  771,\n",
 447:        "  717,\n",
 448:        "  859,\n",
 449:        "  691,\n",
 450:        "  159,\n",
 451:        "  495,\n",
 452:        "  153,\n",
 453:        "  678,\n",
 454:        "  227,\n",
 455:        "  692,\n",
 456:        "  981,\n",
 457:        "  181,\n",
 458:        "  857,\n",
 459:        "  126,\n",
 460:        "  950,\n",
 461:        "  55,\n",
 462:        "  622,\n",
 463:        "  129,\n",
 464:        "  731,\n",
 465:        "  554,\n",
 466:        "  556,\n",
 467:        "  220,\n",
 468:        "  162,\n",
 469:        "  238,\n",
 470:        "  925,\n",
 471:        "  309,\n",
 472:        "  662,\n",
 473:        "  673,\n",
 474:        "  831,\n",
 475:        "  72,\n",
 476:        "  107,\n",
 477:        "  815,\n",
 478:        "  514,\n",
 479:        "  706,\n",
 480:        "  847,\n",
 481:        "  233,\n",
 482:        "  467],\n",
 483:        " 10: [308,\n",
 484:        "  186,\n",
 485:        "  489,\n",
 486:        "  959,\n",
 487:        "  658,\n",
 488:        "  362,\n",
 489:        "  223,\n",
 490:        "  862,\n",
 491:        "  659,\n",
 492:        "  484,\n",
 493:        "  536,\n",
 494:        "  757,\n",
 495:        "  969,\n",
 496:        "  18,\n",
 497:        "  825,\n",
 498:        "  332,\n",
 499:        "  306,\n",
 500:        "  840,\n",
 501:        "  660,\n",
 502:        "  602,\n",
 503:        "  684,\n",
 504:        "  188,\n",
 505:        "  613,\n",
 506:        "  590,\n",
 507:        "  820,\n",
 508:        "  324,\n",
 509:        "  443,\n",
 510:        "  627,\n",
 511:        "  586,\n",
 512:        "  766,\n",
 513:        "  69,\n",
 514:        "  830,\n",
 515:        "  942,\n",
 516:        "  419,\n",
 517:        "  798,\n",
 518:        "  946,\n",
 519:        "  65,\n",
 520:        "  644,\n",
 521:        "  79,\n",
 522:        "  604,\n",
 523:        "  121,\n",
 524:        "  74,\n",
 525:        "  971,\n",
 526:        "  381,\n",
 527:        "  81,\n",
 528:        "  100,\n",
 529:        "  932,\n",
 530:        "  531,\n",
 531:        "  232,\n",
 532:        "  466],\n",
 533:        " 11: [762,\n",
 534:        "  355,\n",
 535:        "  955,\n",
 536:        "  451,\n",
 537:        "  904,\n",
 538:        "  109,\n",
 539:        "  749,\n",
 540:        "  621,\n",
 541:        "  689,\n",
 542:        "  231,\n",
 543:        "  626,\n",
 544:        "  305,\n",
 545:        "  167,\n",
 546:        "  98,\n",
 547:        "  938,\n",
 548:        "  37,\n",
 549:        "  427,\n",
 550:        "  284,\n",
 551:        "  793,\n",
 552:        "  958,\n",
 553:        "  724,\n",
 554:        "  312,\n",
 555:        "  848,\n",
 556:        "  415,\n",
 557:        "  528,\n",
 558:        "  867,\n",
 559:        "  645,\n",
 560:        "  158,\n",
 561:        "  661,\n",
 562:        "  954,\n",
 563:        "  920,\n",
 564:        "  354,\n",
 565:        "  910,\n",
 566:        "  59,\n",
 567:        "  965,\n",
 568:        "  208,\n",
 569:        "  441,\n",
 570:        "  358,\n",
 571:        "  623,\n",
 572:        "  54,\n",
 573:        "  497,\n",
 574:        "  966,\n",
 575:        "  112,\n",
 576:        "  125,\n",
 577:        "  532,\n",
 578:        "  379,\n",
 579:        "  365,\n",
 580:        "  138,\n",
 581:        "  634,\n",
 582:        "  214],\n",
 583:        " 12: [797,\n",
 584:        "  719,\n",
 585:        "  975,\n",
 586:        "  603,\n",
 587:        "  540,\n",
 588:        "  507,\n",
 589:        "  610,\n",
 590:        "  879,\n",
 591:        "  870,\n",
 592:        "  302,\n",
 593:        "  594,\n",
 594:        "  609,\n",
 595:        "  574,\n",
 596:        "  199,\n",
 597:        "  693,\n",
 598:        "  703,\n",
 599:        "  666,\n",
 600:        "  422,\n",
 601:        "  278,\n",
 602:        "  775,\n",
 603:        "  219,\n",
 604:        "  84,\n",
 605:        "  654,\n",
 606:        "  317,\n",
 607:        "  321,\n",
 608:        "  420,\n",
 609:        "  17,\n",
 610:        "  573,\n",
 611:        "  843,\n",
 612:        "  201,\n",
 613:        "  525,\n",
 614:        "  224,\n",
 615:        "  816,\n",
 616:        "  207,\n",
 617:        "  783,\n",
 618:        "  435,\n",
 619:        "  725,\n",
 620:        "  360,\n",
 621:        "  518,\n",
 622:        "  80,\n",
 623:        "  561,\n",
 624:        "  11,\n",
 625:        "  948,\n",
 626:        "  694,\n",
 627:        "  493,\n",
 628:        "  103,\n",
 629:        "  923,\n",
 630:        "  70,\n",
 631:        "  268,\n",
 632:        "  290],\n",
 633:        " 13: [13,\n",
 634:        "  989,\n",
 635:        "  929,\n",
 636:        "  374,\n",
 637:        "  195,\n",
 638:        "  236,\n",
 639:        "  446,\n",
 640:        "  39,\n",
 641:        "  973,\n",
 642:        "  625,\n",
 643:        "  161,\n",
 644:        "  630,\n",
 645:        "  464,\n",
 646:        "  682,\n",
 647:        "  345,\n",
 648:        "  768,\n",
 649:        "  680,\n",
 650:        "  549,\n",
 651:        "  455,\n",
 652:        "  192,\n",
 653:        "  633,\n",
 654:        "  23,\n",
 655:        "  20,\n",
 656:        "  883,\n",
 657:        "  589,\n",
 658:        "  533,\n",
 659:        "  87,\n",
 660:        "  475,\n",
 661:        "  996,\n",
 662:        "  947,\n",
 663:        "  686,\n",
 664:        "  283,\n",
 665:        "  384,\n",
 666:        "  376,\n",
 667:        "  259,\n",
 668:        "  323,\n",
 669:        "  326,\n",
 670:        "  274,\n",
 671:        "  165,\n",
 672:        "  398,\n",
 673:        "  781,\n",
 674:        "  747,\n",
 675:        "  149,\n",
 676:        "  838,\n",
 677:        "  240,\n",
 678:        "  598,\n",
 679:        "  741,\n",
 680:        "  204,\n",
 681:        "  700,\n",
 682:        "  457],\n",
 683:        " 14: [301,\n",
 684:        "  804,\n",
 685:        "  964,\n",
 686:        "  504,\n",
 687:        "  616,\n",
 688:        "  921,\n",
 689:        "  409,\n",
 690:        "  600,\n",
 691:        "  413,\n",
 692:        "  949,\n",
 693:        "  819,\n",
 694:        "  861,\n",
 695:        "  291,\n",
 696:        "  211,\n",
 697:        "  75,\n",
 698:        "  432,\n",
 699:        "  425,\n",
 700:        "  753,\n",
 701:        "  772,\n",
 702:        "  742,\n",
 703:        "  82,\n",
 704:        "  674,\n",
 705:        "  643,\n",
 706:        "  607,\n",
 707:        "  765,\n",
 708:        "  460,\n",
 709:        "  500,\n",
 710:        "  400,\n",
 711:        "  889,\n",
 712:        "  683,\n",
 713:        "  940,\n",
 714:        "  839,\n",
 715:        "  513,\n",
 716:        "  177,\n",
 717:        "  408,\n",
 718:        "  248,\n",
 719:        "  790,\n",
 720:        "  97,\n",
 721:        "  131,\n",
 722:        "  544,\n",
 723:        "  234,\n",
 724:        "  578,\n",
 725:        "  250,\n",
 726:        "  980,\n",
 727:        "  873,\n",
 728:        "  687,\n",
 729:        "  42,\n",
 730:        "  541,\n",
 731:        "  710,\n",
 732:        "  663],\n",
 733:        " 15: [197,\n",
 734:        "  380,\n",
 735:        "  28,\n",
 736:        "  728,\n",
 737:        "  134,\n",
 738:        "  254,\n",
 739:        "  8,\n",
 740:        "  566,\n",
 741:        "  216,\n",
 742:        "  962,\n",
 743:        "  314,\n",
 744:        "  277,\n",
 745:        "  6,\n",
 746:        "  708,\n",
 747:        "  829,\n",
 748:        "  796,\n",
 749:        "  701,\n",
 750:        "  515,\n",
 751:        "  779,\n",
 752:        "  114,\n",
 753:        "  2,\n",
 754:        "  368,\n",
 755:        "  832,\n",
 756:        "  287,\n",
 757:        "  823,\n",
 758:        "  763,\n",
 759:        "  642,\n",
 760:        "  243,\n",
 761:        "  66,\n",
 762:        "  15,\n",
 763:        "  535,\n",
 764:        "  272,\n",
 765:        "  391,\n",
 766:        "  548,\n",
 767:        "  205,\n",
 768:        "  983,\n",
 769:        "  858,\n",
 770:        "  808,\n",
 771:        "  265,\n",
 772:        "  720,\n",
 773:        "  26,\n",
 774:        "  327,\n",
 775:        "  570,\n",
 776:        "  709,\n",
 777:        "  527,\n",
 778:        "  789,\n",
 779:        "  868,\n",
 780:        "  581,\n",
 781:        "  151,\n",
 782:        "  421],\n",
 783:        " 16: [647,\n",
 784:        "  956,\n",
 785:        "  111,\n",
 786:        "  47,\n",
 787:        "  418,\n",
 788:        "  469,\n",
 789:        "  937,\n",
 790:        "  688,\n",
 791:        "  356,\n",
 792:        "  289,\n",
 793:        "  615,\n",
 794:        "  286,\n",
 795:        "  170,\n",
 796:        "  617,\n",
 797:        "  511,\n",
 798:        "  986,\n",
 799:        "  313,\n",
 800:        "  364,\n",
 801:        "  896,\n",
 802:        "  974,\n",
 803:        "  119,\n",
 804:        "  22,\n",
 805:        "  133,\n",
 806:        "  987,\n",
 807:        "  163,\n",
 808:        "  679,\n",
 809:        "  431,\n",
 810:        "  483,\n",
 811:        "  550,\n",
 812:        "  738,\n",
 813:        "  517,\n",
 814:        "  712,\n",
 815:        "  818,\n",
 816:        "  963,\n",
 817:        "  897,\n",
 818:        "  261,\n",
 819:        "  564,\n",
 820:        "  96,\n",
 821:        "  539,\n",
 822:        "  828,\n",
 823:        "  863,\n",
 824:        "  916,\n",
 825:        "  41,\n",
 826:        "  294,\n",
 827:        "  132,\n",
 828:        "  299,\n",
 829:        "  652,\n",
 830:        "  336,\n",
 831:        "  718,\n",
 832:        "  168],\n",
 833:        " 17: [675,\n",
 834:        "  73,\n",
 835:        "  25,\n",
 836:        "  276,\n",
 837:        "  809,\n",
 838:        "  386,\n",
 839:        "  127,\n",
 840:        "  257,\n",
 841:        "  442,\n",
 842:        "  331,\n",
 843:        "  245,\n",
 844:        "  417,\n",
 845:        "  786,\n",
 846:        "  572,\n",
 847:        "  891,\n",
 848:        "  995,\n",
 849:        "  485,\n",
 850:        "  113,\n",
 851:        "  456,\n",
 852:        "  841,\n",
 853:        "  412,\n",
 854:        "  152,\n",
 855:        "  235,\n",
 856:        "  481,\n",
 857:        "  599,\n",
 858:        "  338,\n",
 859:        "  596,\n",
 860:        "  646,\n",
 861:        "  650,\n",
 862:        "  824,\n",
 863:        "  396,\n",
 864:        "  330,\n",
 865:        "  316,\n",
 866:        "  24,\n",
 867:        "  745,\n",
 868:        "  454,\n",
 869:        "  115,\n",
 870:        "  707,\n",
 871:        "  784,\n",
 872:        "  61,\n",
 873:        "  952,\n",
 874:        "  508,\n",
 875:        "  498,\n",
 876:        "  184,\n",
 877:        "  866,\n",
 878:        "  213,\n",
 879:        "  927,\n",
 880:        "  150,\n",
 881:        "  900,\n",
 882:        "  558],\n",
 883:        " 18: [648,\n",
 884:        "  999,\n",
 885:        "  624,\n",
 886:        "  203,\n",
 887:        "  146,\n",
 888:        "  182,\n",
 889:        "  585,\n",
 890:        "  704,\n",
 891:        "  906,\n",
 892:        "  670,\n",
 893:        "  482,\n",
 894:        "  984,\n",
 895:        "  785,\n",
 896:        "  503,\n",
 897:        "  486,\n",
 898:        "  296,\n",
 899:        "  239,\n",
 900:        "  875,\n",
 901:        "  252,\n",
 902:        "  492,\n",
 903:        "  537,\n",
 904:        "  99,\n",
 905:        "  335,\n",
 906:        "  957,\n",
 907:        "  200,\n",
 908:        "  506,\n",
 909:        "  108,\n",
 910:        "  193,\n",
 911:        "  588,\n",
 912:        "  359,\n",
 913:        "  657,\n",
 914:        "  373,\n",
 915:        "  94,\n",
 916:        "  60,\n",
 917:        "  960,\n",
 918:        "  366,\n",
 919:        "  14,\n",
 920:        "  3,\n",
 921:        "  810,\n",
 922:        "  951,\n",
 923:        "  583,\n",
 924:        "  142,\n",
 925:        "  761,\n",
 926:        "  637,\n",
 927:        "  505,\n",
 928:        "  711,\n",
 929:        "  339,\n",
 930:        "  35,\n",
 931:        "  851,\n",
 932:        "  743],\n",
 933:        " 19: [50,\n",
 934:        "  349,\n",
 935:        "  156,\n",
 936:        "  853,\n",
 937:        "  251,\n",
 938:        "  620,\n",
 939:        "  160,\n",
 940:        "  822,\n",
 941:        "  275,\n",
 942:        "  4,\n",
 943:        "  792,\n",
 944:        "  767,\n",
 945:        "  472,\n",
 946:        "  577,\n",
 947:        "  907,\n",
 948:        "  580,\n",
 949:        "  723,\n",
 950:        "  611,\n",
 951:        "  147,\n",
 952:        "  992,\n",
 953:        "  172,\n",
 954:        "  998,\n",
 955:        "  348,\n",
 956:        "  521,\n",
 957:        "  575,\n",
 958:        "  21,\n",
 959:        "  651,\n",
 960:        "  854,\n",
 961:        "  591,\n",
 962:        "  176,\n",
 963:        "  837,\n",
 964:        "  918,\n",
 965:        "  635,\n",
 966:        "  571,\n",
 967:        "  976,\n",
 968:        "  56,\n",
 969:        "  826,\n",
 970:        "  174,\n",
 971:        "  311,\n",
 972:        "  271,\n",
 973:        "  496,\n",
 974:        "  913,\n",
 975:        "  855,\n",
 976:        "  557,\n",
 977:        "  139,\n",
 978:        "  209,\n",
 979:        "  552,\n",
 980:        "  369,\n",
 981:        "  638,\n",
 982:        "  218],\n",
 983:        " 20: [748,\n",
 984:        "  690,\n",
 985:        "  545,\n",
 986:        "  756,\n",
 987:        "  95,\n",
 988:        "  730,\n",
 989:        "  649,\n",
 990:        "  405,\n",
 991:        "  526,\n",
 992:        "  993,\n",
 993:        "  130,\n",
 994:        "  399,\n",
 995:        "  426,\n",
 996:        "  764,\n",
 997:        "  300,\n",
 998:        "  440,\n",
 999:        "  477,\n",
1000:        "  655,\n",
1001:        "  85,\n",
1002:        "  322,\n",
1003:        "  452,\n",
1004:        "  395,\n",
1005:        "  304,\n",
1006:        "  91,\n",
1007:        "  490,\n",
1008:        "  175,\n",
1009:        "  83,\n",
1010:        "  445,\n",
1011:        "  835,\n",
1012:        "  702,\n",
1013:        "  931,\n",
1014:        "  104,\n",
1015:        "  726,\n",
1016:        "  865,\n",
1017:        "  178,\n",
1018:        "  794,\n",
1019:        "  522,\n",
1020:        "  727,\n",
1021:        "  640,\n",
1022:        "  501,\n",
1023:        "  698,\n",
1024:        "  967,\n",
1025:        "  988,\n",
1026:        "  120,\n",
1027:        "  434,\n",
1028:        "  664,\n",
1029:        "  641,\n",
1030:        "  51,\n",
1031:        "  886,\n",
1032:        "  12,\n",
1033:        "  433,\n",
1034:        "  102,\n",
1035:        "  122,\n",
1036:        "  714,\n",
1037:        "  32,\n",
1038:        "  31,\n",
1039:        "  371,\n",
1040:        "  344,\n",
1041:        "  157,\n",
1042:        "  38,\n",
1043:        "  922,\n",
1044:        "  880,\n",
1045:        "  16,\n",
1046:        "  961,\n",
1047:        "  930,\n",
1048:        "  363,\n",
1049:        "  136,\n",
1050:        "  555,\n",
1051:        "  909,\n",
1052:        "  696,\n",
1053:        "  559,\n",
1054:        "  543,\n",
1055:        "  667,\n",
1056:        "  382,\n",
1057:        "  191],\n",
1058:        " 21: [567,\n",
1059:        "  817,\n",
1060:        "  383,\n",
1061:        "  116,\n",
1062:        "  68,\n",
1063:        "  888,\n",
1064:        "  944,\n",
1065:        "  33,\n",
1066:        "  401,\n",
1067:        "  430,\n",
1068:        "  881,\n",
1069:        "  499,\n",
1070:        "  260,\n",
1071:        "  754,\n",
1072:        "  372,\n",
1073:        "  919,\n",
1074:        "  185,\n",
1075:        "  821,\n",
1076:        "  905,\n",
1077:        "  123,\n",
1078:        "  732,\n",
1079:        "  90,\n",
1080:        "  273,\n",
1081:        "  705,\n",
1082:        "  871,\n",
1083:        "  141,\n",
1084:        "  551,\n",
1085:        "  836,\n",
1086:        "  671,\n",
1087:        "  27,\n",
1088:        "  93,\n",
1089:        "  563,\n",
1090:        "  936,\n",
1091:        "  639,\n",
1092:        "  488,\n",
1093:        "  487,\n",
1094:        "  328,\n",
1095:        "  774],\n",
1096:        " 22: [470,\n",
1097:        "  258,\n",
1098:        "  378,\n",
1099:        "  509,\n",
1100:        "  459,\n",
1101:        "  887,\n",
1102:        "  246,\n",
1103:        "  520,\n",
1104:        "  438,\n",
1105:        "  601,\n",
1106:        "  856,\n",
1107:        "  343,\n",
1108:        "  143,\n",
1109:        "  280,\n",
1110:        "  597,\n",
1111:        "  140,\n",
1112:        "  183,\n",
1113:        "  444,\n",
1114:        "  681],\n",
1115:        " 23: [894, 538, 253, 468, 194, 367, 173, 632, 479],\n",
1116:        " 24: [800, 46, 882, 799, 874],\n",
1117:        " 25: [169, 806],\n",
1118:        " 0: [297],\n",
1119:        " 26: [755]}"
1120:       ]
1121:      },
1122:      "execution_count": 64,
1123:      "metadata": {},
1124:      "output_type": "execute_result"
1125:     }
1126:    ],
1127:    "source": [
1128:     "sbm.block_members"
1129:    ]
1130:   },
1131:   {
1132:    "cell_type": "code",
1133:    "execution_count": 36,
1134:    "metadata": {},
1135:    "outputs": [
1136:     {
1137:      "ename": "KeyError",
1138:      "evalue": "2",
1139:      "output_type": "error",
1140:      "traceback": [
1141:       "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
1142:       "\u001b[0;31mKeyError\u001b[0m                                  Traceback (most recent call last)",
1143:       "Cell \u001b[0;32mIn[36], line 2\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[38;5;66;03m# Perform some partition manipulations\u001b[39;00m\n\u001b[0;32m----> 2\u001b[0m \u001b[43msbm\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mmerge_blocks\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;241;43m1\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m2\u001b[39;49m\u001b[43m)\u001b[49m\n\u001b[1;32m      3\u001b[0m sbm\u001b[38;5;241m.\u001b[39mmove_node(\u001b[38;5;241m10\u001b[39m, \u001b[38;5;241m3\u001b[39m)\n\u001b[1;32m      5\u001b[0m \u001b[38;5;66;03m# Compute the new likelihood\u001b[39;00m\n",
1144:       "File \u001b[0;32m~/anon_sbm/src/sbm/sbm.py:159\u001b[0m, in \u001b[0;36mStochasticBlockModel.merge_blocks\u001b[0;34m(self, block_a, block_b)\u001b[0m\n\u001b[1;32m    157\u001b[0m new_block_idx \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mmin\u001b[39m(block_a, block_b)\n\u001b[1;32m    158\u001b[0m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mblock_members[new_block_idx] \u001b[38;5;241m=\u001b[39m merged_nodes\n\u001b[0;32m--> 159\u001b[0m \u001b[38;5;28;01mdel\u001b[39;00m \u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mblock_members\u001b[49m\u001b[43m[\u001b[49m\u001b[38;5;28;43mmax\u001b[39;49m\u001b[43m(\u001b[49m\u001b[43mblock_a\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mblock_b\u001b[49m\u001b[43m)\u001b[49m\u001b[43m]\u001b[49m\n\u001b[1;32m    161\u001b[0m \u001b[38;5;66;03m# Update blocks mapping\u001b[39;00m\n\u001b[1;32m    162\u001b[0m \u001b[38;5;28;01mfor\u001b[39;00m node \u001b[38;5;129;01min\u001b[39;00m merged_nodes:\n",
1145:       "\u001b[0;31mKeyError\u001b[0m: 2"
1146:      ]
1147:     }
1148:    ],
1149:    "source": [
1150:     "# Perform some partition manipulations\n",
1151:     "sbm.merge_blocks(1, 2)\n",
1152:     "sbm.move_node(10, 3)\n",
1153:     "\n",
1154:     "# Compute the new likelihood\n",
1155:     "new_likelihood = sbm.compute_likelihood()\n",
1156:     "print(f\"New Likelihood: {new_likelihood}\")\n",
1157:     "\n",
1158:     "# Check minimum block size\n",
1159:     "min_size = sbm.min_block_size()\n",
1160:     "print(f\"Minimum Block Size: {min_size}\")"
1161:    ]
1162:   },
1163:   {
1164:    "cell_type": "code",
1165:    "execution_count": null,
1166:    "metadata": {},
1167:    "outputs": [],
1168:    "source": []
1169:   }
1170:  ],
1171:  "metadata": {
1172:   "kernelspec": {
1173:    "display_name": "anon_sbm",
1174:    "language": "python",
1175:    "name": "python3"
1176:   },
1177:   "language_info": {
1178:    "codemirror_mode": {
1179:     "name": "ipython",
1180:     "version": 3
1181:    },
1182:    "file_extension": ".py",
1183:    "mimetype": "text/x-python",
1184:    "name": "python",
1185:    "nbconvert_exporter": "python",
1186:    "pygments_lexer": "ipython3",
1187:    "version": "3.13.0"
1188:   }
1189:  },
1190:  "nbformat": 4,
1191:  "nbformat_minor": 2
1192: }

================
File: notebooks/sbm_visualize.ipynb
================
  1: {
  2:  "cells": [
  3:   {
  4:    "cell_type": "code",
  5:    "execution_count": 2,
  6:    "metadata": {},
  7:    "outputs": [
  8:     {
  9:      "name": "stdout",
 10:      "output_type": "stream",
 11:      "text": [
 12:       "Collecting networkx\n",
 13:       "  Using cached networkx-3.4.2-py3-none-any.whl.metadata (6.3 kB)\n",
 14:       "Using cached networkx-3.4.2-py3-none-any.whl (1.7 MB)\n",
 15:       "Installing collected packages: networkx\n",
 16:       "Successfully installed networkx-3.4.2\n"
 17:      ]
 18:     }
 19:    ],
 20:    "source": [
 21:     "!pip install networkx\n",
 22:     "!pip install matplotlib\n",
 23:     "!pip install numpy"
 24:    ]
 25:   },
 26:   {
 27:    "cell_type": "code",
 28:    "execution_count": 5,
 29:    "metadata": {},
 30:    "outputs": [
 31:     {
 32:      "data": {
 33:       "image/png": "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f/9qwwGzsrLYs2cP8+bNq/e9koWFBTNnzjTcX6xZswZPT0/D/eCPPXhPWFxcTEZGBgMGDACoduweZfjw4TXuNeryxhtvEBAQwKJFi3j++ecZPnw4v/rVr+q9LSGE+ZCEknii9e3bl61bt5KdnU10dDR//OMfycvLY/r06YYkRV3S09MpLCykW7duNV7r3r07er3eMFb/1q1bDx1W9yAvL69q37dp0wagWlLo7t27LF68GCcnJ+zs7HB2dmb48OEA5ObmAqDRaPjnP//Jnj17cHV1ZdiwYbz99tu1PjmkPqp6ENV3P2oTGBhIaGgooaGhzJw5k9WrVzNhwgReeeUV0tPT61zuzp07dR7nqterYuzWrVu9ejK99dZbfPPNN2zevLlaH4eGmDt3rmEI4TfffMPcuXPrjB+odR/8/PwMr1f926VLlxrz/XjZGzdukJubi4uLC87OztW+8vPzSUtLa9Q+CSGEEFUqKipYv349I0eOJD4+nps3b3Lz5k369+9PamoqkZGRhnnv3LlTr+tXXVatWkVQUBBarZa2bdvi7OzMrl27DPc1UHmd79ChQ7UhZT9248YNFEWhS5cuNa6PV65cqXF99PDwqJHsadOmTbX7rvreXyxcuJDjx48bruebNm2irKyMBQsW1OsYVJk7dy5xcXFcvHiRtWvXMnv27DoTUllZWbz44ou4urpiY2ODs7Mzvr6+ANWO3aNULVMf1tbWfPnll8THx5OXl8eKFSvqnTATQpgX6aEkBJUXxr59+9K3b1+6du3KkiVL2LRpU62fgDW3usaeK4oCVN7cjR49mqysLP7whz/g5+eHra0tSUlJLF68uFrzy1//+tdMnDiRb775hn379vHnP/+Zt956i4MHD9KrV6/Hsj+PMmrUKHbu3El0dPRjfTpaWFgYe/fu5e2332bEiBGNehTv008/jUajYdGiRZSUlDBz5sxmiLR2er0eFxeXOhujPtgXQQghhGiMgwcPkpyczPr161m/fn2N19esWdPgCt/arF69msWLFzN58mR+97vf4eLigoWFBW+99dZDH6pRG71ej0qlYs+ePbXeU9nZ2VX7/lH3XQ0xe/ZsXnrpJdasWcP//M//sHr1avr06VPvpFqV/v3706lTJ379618THx9f5wdWADNnzuTEiRP87ne/o2fPntjZ2aHX6xk7dmytDdHrUp9eVw/at28fUFkVdePGjQYlpIQQ5kMSSkL8SFVDx+TkZMO02j51cXZ2plWrVly7dq3Ga1evXkWtVuPp6QlUNvGOjY01SnyXLl3i+vXrrFq1ioULFxqmR0RE1Dp/p06d+M1vfsNvfvMbbty4Qc+ePfn3v//N6tWrgfoPV6tqDBkbG0toaGgT9+IH5eXlQGXj8rp4e3vXeZyrXq+K8dSpU5SVlT2yIfWAAQP42c9+xoQJE5gxYwbbtm1r8GNxbWxsmDx5MqtXryY8PLxac/Ufxw9w7do1nnrqqWqvXbt2zfB61b83btyosY4f73+nTp04cOAAgwcPbvBNoBBCCFEfa9aswcXFhQ8++KDGa1u3bmXbtm18/PHH2NjY4O3tXa/rV202b95Mx44d2bp1a7X7kh9/sNepUyf27dtXo/H1j+dRFAVfX1+6du36yG3XR33vL5ycnBg/fjxr1qxh3rx5HD9+nHfffbdR25wzZw5//etf6d69e7Wm5A/Kzs4mMjKSN998k9dee80wvbafgzEriGJiYvjf//1flixZwoULF1i2bBmXLl2qNlxfCPFkkCFv4ol16NChWj992r17N1C9RNvW1pacnJxq81lYWDBmzBi2b99ueOwqVD6RbO3atQwZMgQHBweg8mlrFy9erPXx7w39BKzqk7QHl1MUpUYfosLCwhpPG+vUqRP29vaUlJQ8dN9q07t3b3x9fXn33XdrzN+YT/Gq7Ny5E4Dg4OA65xk3bhzR0dGcPHnSMK2goIBPP/0UHx8fw5j/adOmkZGRwX//+98a66gtxtDQUNavX8/evXtZsGBBgz7Jq/Lb3/6W119/nT//+c91ztOnTx9cXFz4+OOPqx37PXv2cOXKFUNllpubGz179mTVqlXVytQjIiJqDMGcOXMmFRUV/OUvf6mxvfLy8nr9TIUQQoi6FBUVsXXrViZMmMD06dNrfL3wwgvk5eUZ+k6OGzeOqKgooqOjDetIT0+vs5L2QbXd25w6daradR8qr/OKovDmm2/WWEfVslOnTsXCwoI333yzxrVfURQyMzPreQSqb7e+9xcLFiwgLi6O3/3ud1hYWDB79uwGbw9g2bJlvP766/z73/+uc57ajhtQaxLL1tYWoMn3B2VlZSxevJgOHTrw3nvvsXLlSlJTU3nppZeatF4hxE+TVCiJJ9Yvf/lLCgsLmTJlCn5+fpSWlnLixAk2bNiAj48PS5YsMcwbEhLCgQMHeOedd+jQoQO+vr7079+fv/71r0RERDBkyBCef/55LC0t+eSTTygpKeHtt982LP+73/2OzZs3M2PGDJYuXUpISAhZWVns2LGDjz/++KHJlB/z8/OjU6dO/Pa3vyUpKQkHBwe2bNlSo/H29evXGTVqFDNnzsTf3x9LS0u2bdtGampqtZubkJAQPvroI/7617/SuXNnXFxcalTRAKjVaj766CMmTpxIz549WbJkCW5ubly9epXLly8bSp8f5tixY4YkV9X+HzlyhNmzZ+Pn51fncq+88grr1q0jPDycX/3qVzg5ObFq1Sri4+PZsmULanVlbnzhwoV89dVXvPzyy0RHRzN06FAKCgo4cOAAzz//PJMmTaqx7smTJ7NixQoWLlyIg4MDn3zyySP340HBwcGP/PlZWVnxz3/+kyVLljB8+HDmzJlDamoq7733Hj4+PtVuwt566y3Gjx/PkCFDWLp0KVlZWbz//vsEBARUq+IaPnw4zz33HG+99RYXLlxgzJgxWFlZcePGDTZt2sR7773H9OnTG7QvQgghRJUdO3aQl5fH008/XevrAwYMwNnZmTVr1jBr1ix+//vf8/XXXzN27FhefPFFbG1t+fTTT/H29iYmJuah25owYQJbt25lypQpjB8/nvj4eD7++GP8/f2rXftGjhzJggUL+L//+z9u3LhhGNZ17NgxRo4cyQsvvECnTp3461//yh//+EcSEhKYPHky9vb2xMfHs23bNp599ll++9vfNuhYNOT+Yvz48bRt25ZNmzYRHh6Oi4tLg7ZVxdvbmzfeeOOh8zg4OBh6ZJaVleHu7s7+/fuJj4+vMW9ISAgAr776KrNnz8bKyoqJEycaEk319de//pULFy4QGRmJvb09QUFBvPbaa/zpT39i+vTpjBs3rkHrE0L8xD3ux8oJ0VLs2bNHWbp0qeLn56fY2dkp1tbWSufOnZVf/vKXSmpqarV5r169qgwbNkyxsbFRgGqPtD937pwSFham2NnZKa1atVJGjhypnDhxosb2MjMzlRdeeEFxd3dXrK2tFQ8PD2XRokVKRkaGoiiKcujQIQVQNm3aVG25qsfcr1ixwjAtLi5OCQ0NVezs7JR27dopy5cvVy5evFhtvoyMDOUXv/iF4ufnp9ja2iqOjo5K//79lY0bN1Zbf0pKijJ+/HjF3t5eAQyP8a2K59ChQ9Xm/+6775TRo0cr9vb2iq2trRIUFKS8//77Dz3WVet68Mva2lrx8/NT/va3vymlpaXV5vf29q52jBVFUW7duqVMnz5dad26taLVapV+/fopO3furLGtwsJC5dVXX1V8fX0VKysrpX379sr06dOVW7duVTue//rXv6ot9+GHHyqA8tvf/vah+wIov/jFLx46z+uvv64ASnp6erXpGzZsUHr16qVoNBrFyclJmTdvnpKYmFhj+S1btijdu3dXNBqN4u/vr2zdulVZtGiR4u3tXWPeTz/9VAkJCVFsbGwUe3t7JTAwUPn973+v3L9/3zDPjx/PLIQQQjzKxIkTFa1WqxQUFNQ5z+LFixUrKyvDvUxMTIwyfPhwRavVKu7u7spf/vIX5YsvvqjxuPofX5f0er3y97//XfH29lY0Go3Sq1cvZefOnbVe+8rLy5V//etfip+fn2Jtba04Ozsr4eHhytmzZ6vNt2XLFmXIkCGKra2tYmtrq/j5+Sm/+MUvlGvXrlWLIyAgoMZ+1bbdR91fPOj5559XAGXt2rV1Hrsf8/b2VsaPH//QeVasWKEAyunTpw3TEhMTlSlTpiitW7dWHB0dlRkzZij3799XAOX111+vtvxf/vIXxd3dXVGr1dV+Jg+7t3lwPWfPnlUsLS2VX/7yl9XmKS8vV/r27at06NBByc7Orvc+CyF++lSK0oSxKkIIIYQQQgjRAEOHDkWj0XDgwAFTh9IsXnrpJb744gtSUlJo1aqVqcMRQohmIz2UhBBCCCGEEI9NcnJynQ+y+KkrLi5m9erVTJs2TZJJQgizJz2UhBBCCCGEEM3uxIkTbN26lVu3bvGHP/zB1OEYVVpaGgcOHGDz5s1kZmby4osvmjokIYRodpJQEkIIIYQQQjS7zz77jD179vDrX/+62sNPzEFcXBzz5s3DxcWF//u//6Nnz56mDkkIIZqd9FASQgghhBBCCCGEeIyOHj3Kv/71L86ePUtycjLbtm1j8uTJD13m8OHDvPzyy1y+fBlPT0/+9Kc/sXjx4scSb22kh5IQQgghhBBCCCHEY1RQUEBwcDAffPBBveaPj49n/PjxjBw5kgsXLvDrX/+aZcuWsW/fvmaOtG5SoSSEEEIIIYQQQghhIiqV6pEVSn/4wx/YtWsXsbGxhmmzZ88mJyeHvXv3PoYoa5IeSkIIIYQQZkqv13P//n3s7e1RqVSmDkcIIYSolaIo5OXl0aFDB9Tq5h9IVVxcTGlpqdHXqyhKjeutRqNBo9E0ed0nT54kNDS02rSwsDB+/etfN3ndjSUJJSGEEEIIM3X//n08PT1NHYYQQghRL/fu3cPDw6NZt1FcXIyNjU2zrNvOzo78/Pxq015//XXeeOONJq87JSUFV1fXatNcXV3R6XQUFRU12z49jCSUhBBCCCHMlL29PVB5g+7g4GDiaJ4gX30FCxeaOgphYo6OjkZb13xgtRHWk5uba4S1GJ+xjpW5758xtbRjpdPp8PT0NFy3mlNzVCZVyc/Pr3HNNUZ1UkslCSUhhBBCCDNVVXbv4OAgCaXHqWdPkOMtjCjeSOsx9/cBc98/Y2qpx+pxD8825vaq2lM31zW3ffv2pKamVpuWmpqKg4ODSaqTQJ7yJoQQQgghhHG9/bapIxBm5vemDkAIM6RSqYz+1ZwGDhxIZGRktWkREREMHDiwWbf7MJJQEkIIIYQQQgghhHiM8vPzuXDhAhcuXAAgPj6eCxcucPfuXQD++Mc/svCB4dM/+9nPuH37Nr///e+5evUqH374IRs3buSll14yRfiAJJSEEEIIIVq0Dz74AB8fH7RaLf379yc6OtrUIYlH+cc/TB2BMDOvmDoAIcyQqSuUzpw5Q69evejVqxcAL7/8Mr169eK1114DIDk52ZBcAvD19WXXrl1EREQQHBzMv//9bz7//HPCwsKMd1AaSHooCSGEEEK0UBs2bODll1/m448/pn///rz77ruEhYVx7do1XFxcTB2eqMuuXeDvb+oohBkZD1wxdRBCCKMaMWKEoe9SbVauXFnrMufPn2/GqBpGKpSEEEIIIVqod955h+XLl7NkyRL8/f35+OOPadWqFV9++aWpQxMPc+yYqSMQZmaoqQMQwgyp1Wqjfz1ppEJJCCGEEKIFKi0t5ezZs/zxj380TFOr1YSGhnLy5MlalykpKaGkpMTwvU6na/Y4RS1a6NOTxE+X/CYLYXyPo5G2uXvyUmhCCCGEED8BGRkZVFRU4OrqWm26q6srKSkptS7z1ltv4ejoaPjy9PR8HKGKH1u92tQRCDOzwNQBCCFELSShJIQQQghhJv74xz+Sm5tr+Lp3756pQ3oyTZ1q6giEmdli6gCEMEOmbsptDmTImxBCCCFEC9SuXTssLCxITU2tNj01NZX27dvXuoxGo0Gj0TyO8MTDlJebOgJhZuSPNiFESyQVSkIIIYQQLZC1tTUhISFERkYapun1eiIjIxk4cKAJIxOPZMJHOAvztM/UAQhhhqRCqekk2S2EEEII0UK9/PLLLFq0iD59+tCvXz/effddCgoKWLJkialDEw/Tr5+pIxBmJtrUAQhhhp7UJJAxSUJJCCGEEKKFmjVrFunp6bz22mukpKTQs2dP9u7dW6NRt2hh/vIX2LHD1FEIM/JnYJKpgxBCiB+RhJIQQgghRAv2wgsv8MILL5g6DCGEEMKsSIVS00kPJSGEEEIIIYzpjTdMHYEwM2+YOgAhhKiFJJSEEEIIIYQwpuPHTR2BMDODTR2AEGZIrVYb/etJ8+TtsRBCCCGEEM0pIsLUEQgzM9rUAQhhhuQpb00nPZSEEEIIIYQwJo3G1BH8JBjzjy9FUYy2LmMxakwzZqBs2tTk1bTUY94Sf37m7klMfgjjk4SSEEIIIYQQxmSEP/yFqEbOKSGM7kmtKjImGfImhBBCCCGEMc2da+oIhLmRc0oI0QJJhZIQQgghhBDGlJ9v6giEuZFzSgijkwqlppOEkhBCCCGEEMY0fLipIxDmRs4pIYxOEkpNJ0PehBBCCCGEMKYxY0wdgTA3ck4JIVogSSgJIYQQQghhTK++auoIhLmRc0oIo6uqUDLm15NGEkpCCCGEEEIIIYQQokGkh5IQQgghhBDG9Morpo5AmBs5p4QwOpVKhVptvBobvV5vtHX9VEiFkhBCCCGEEMYUG2vqCIS5kXNKCKOTIW9NJxVKQgjxE1FUWsHuS8lcS82juKwCRxsrRnRzprdXmyfyAiaEEC3Wzp3w7LOmjkKYEzmnhBAtkCSUhBCihdMVl/F+5A3WRd8jv6QcSwsVKKAA7x+8STdXO54f2ZlJPd1NHaoQQgghhBA/CcauKnoSP+CVhJIQQrRg6XklzPksitvp+eiVymnlFUq1ea6n5vPi+gvEJet4ZazfE3kxE0KIFmXHDlNHIMyNnFNCiBZIeigJIUQLVVxWwaIvTxGfUWBIJtWm6qVPjtzms2O3H0tsQgghHmLJElNHIMyNnFNCGJ30UGo6SSgJIUQL9c35JOKS86h4WDbpR/69/zq5RWXNGJUQQohHysw0dQTC3Mg5JYTRSUKp6SShJIQQLZCiKKw4Hk9Dr0ul5Xq2nktsnqCEEELUz8CBpo5AmBs5p4QQLZAklIQQogW6lprHtdR8lPoXJwGVw9/WR99rlpiEEELU0/Tppo5AmBs5p4QwOqlQajpJKAkhRAt0P6eo0csm5zZ+WSGEEEbwm9+YOgJhbuScEkK0QPKUNyGEaIH0+iYs28CqJiGEEMIUlIaW4T7Bdnz7LZOewOqHhjJmhYgxz09jrasl7t9PuSpHrVajVkuNTVNIQkkIIVogVwdto5d1cdAYMRIhhBAN9vLLpo5AmJl3TB2AEGbI2MPUfsrJtcaSdJwQQrRAPdwd8HZqRUMvS2oVTA/xaJaYhBBC1NPdu6aOQJgZL1MHIIQQtZCEkhBCtEAqlYrFg30avJxapWJmH0/jBySEEKL+Nm82dQTCzEhLbiGMT5pyN50klIQQooWa0ccTT6dWWKjrf3FaPqwj7exkyJsQQgghhBCieUlCSQghWig7jSWrn+mPs501Kh7WOLHytSm93PndmG6PJzghhBB127jR1BEIMzPT1AEIYYakQqnpJKEkhBAtmFfbVvyhtxpfdRZqVWWPpMrkkoLF99csG1U5r47z452ZwagbUM0khBCimbz0kqkjEGbmP6YOQAgzJAmlppOnvAkhRAtWVFRE7OnjjHGwYunzM/jq6DX2nLyIXmWJj7srfg7lFN44Q69WHk/kRUwIIVqkpCRTRyDMjLupAxBCiFpIhZIQQrRgmzdvRq/XM3HiRFwcbJjUzZZh1glMaJPCQj8LfjllGGoVHDt2DEV52LA4IYQQj02vXqaOQJiZ86YOQAgzJBVKTScJJSGEaKHu3bvH7du3cXZ2JiAgAACdTodKpUKr1VJSUkKrVq3w9vZGp9Nx7949E0cshBACgGeeMXUEwsx8YeoAhBCiFpJQEkKIFkhRFDZ//9jpmTN/aMWZl5eHra2tIaEEMHz4cAAOHjz4+AMVQghR0wsvmDoCYWb+a+oAhDBDarXa6F9PGumhJIQQLVBUVBQ6nY6AgADatWtnmK7T6XBwcECr1VJcXAyAj48Ptra23Llzh5ycHFq3bm2iqIUQQgghhPhpMPYwNRnyJoQQwuSKi4uJjIzE0tKSiRMnVnstLy8PBwcHNBqNoUJJpVIxYMAAAI4fP/7Y4xVCCPEjzz9v6giEmfnQ1AEIIUQtJKEkhBAtzI4dO6ioqGDkyJFoNJpqr+l0Ouzt7asllAB69+6NSqXi/Pnz1aYLIYQwgdxcU0cgzIyjqQMQwgxJU+6mk4SSEEK0IMnJyVy5cgV7e3sGDhxY4/W8vDxDQqlqyBtAq1at6NatGxUVFZw/L8+CEUIIk1qzxtQRCDMzz9QBCCFELSShJIQQLcSDjbinTp1a41OOsrIyioqKDD2UflyJ1L9/f6By2Jter388QQshhBBCCPETJBVKTScJJSGEaCHOnj1LVlYWPj4++Pj41Hg9Ly8PwNBD6cEKJQBvb28cHR3Jz8/n+vXrjyNkIYQQtfn6a1NHIMzMAlMHIISZkmRS00hCSQghWoDi4mL279+PSqVi8uTJtc6j0+kAsLe3R6vVUlFRQXl5ueF1lUplqFI6ceJEs8cshBCiDq+/buoIhJl509QBCCFELSShJIQQLcDevXspKyujf//+ODrW3nrzxxVKQI1hb8HBwajVau7du0dKSkrzBi2EEKJ2t2+bOgJhZjqaOgAhzJBarTb615PmydtjIYRoYVJSUrh48SIajYannnqqzvl0Oh0ajQZra2u0Wi1AjWFvrVq1wt/fH7VazcmTJ5s1biGEEHXo3t3UETxxzH3YyhVTByBaBEVRjPbV0mLKladj/iRJQkkIIUxIURS2bt0KQHh4OFZWVnXOq9PpcHBwAKizQgmgT58+6PV6YmNjyc/Pb4aohRBCPNTLL5s6AmFm3jF1AEKYIWnK3XSSUBJCCBO6cOEC6enpODs7ExQU9NB58/LysLe3B6izQgnAy8sLJycnFEXh9OnTxg9aCCHEwy1fbuoIhJn5zNQBCGGGJKHUdJJQEkIIEykuLmbv3r0ATJo06ZEXoby8vHpVKKlUKvr06QPA6dOnqzXuFkIIIYQQQghjkISSEEKYyIEDBygtLcXf3x93d/dHzq/T6QwVSlUJpdoqlOCH5txFRUXExMQYL2ghhBCPtnSpqSMQZuZLUwcghBmSptxN9+TtsRBCtAApKSmcPXsWCwsLxo4d+8j59Xp9tQolCwsLrKysaq1Qgh+ac1tZWREVFWXU5otCCCGEEEIIIQklIYR4zBRFYceOHQAMHTrUUHX0MAUFBSiKUm1ejUZTZ4USQEhICGVlZaSnpxMfH9/0wIUQQtTPl1JPIoxLat6EMD7podR0klASQojHLCYmhuTkZGxtbRk8eHC9lsnLywMwVChBZWPuuiqUoLI5d7t27dBoNERFRTUtaCGEEEIIIcyIDHlruidvj4UQwoQebMQ9fvx4LC0t67WcTqcDqieUHlWhpFKp6N27N6Wlpdy4cYOMjIwmRC6EEKLePpNncgnjkucGCiFaIkkoCSHEY3Tw4EGKi4vx8PDAz8+v3svpdDrUajWtWrUyTNNoNA+tUIIfmnNbWVlx6tSpRscthBCiAd55x9QRCDPzsqkDEMIMyZC3ppOEkhBCPCYpKSmcPn0aqKxOashFJy8vD3t7+2rLPGrIG/zQnNvS0pILFy5QVFTUuOCFEELU35Urpo5AmJnupg5ACCFqIQklIYR4DBRFYefOnahUKnr16kX79u0btPyDT3irUp8KJahszl1UVIRer+fs2bMN2q4QQohG6NjR1BEIM3Pb1AEIYYakQqnpJKEkhBCPQUxMDElJSVhaWjJq1KgGL6/T6WpNKD2sh1KVqubcDg4OnD59moqKigZvXwghRAO8+aapIxBm5nVTByCEGZKm3E335O2xEEI8ZsXFxezbtw+AkSNHYmtr2+B16HQ67O3tq02rz5A3qPz0JSQkBJ1Oh06n44oMxRBCiOa1YIGpIxBm5mtTByCEELWQhJIQQjSzQ4cOUVxcTOvWrenXr1+Dl1cUpUkVSlDZnFulUtGmTRuioqJQFKXBcQghhBBCCGEuZMhb00lCSQghmlFVI25FUQgPD8fCwqLB6ygpKaGsrKzWCqXy8vJ6DWGzsbEhICCAsrIykpKSSExMbHAcQggh6mnePFNHIMzMGlMHIIQQtZCEkhBCNBNFUdi1axcqlYqOHTvSpUuXRq0nLy8PoNYKJaBew96gsjl3fn4+Dg4OREVFNSoWIYQQ9eDoaOoIhJnJNXUAQpgh6aHUdE/eHgshxGMSExNDYmIier2esWPHNroMVqfTAdRaoQTUe9ibp6cn7dq1o1WrVly5coWcnJxGxSOEEOIRPvzQ1BEIM/O8qQMQwgzJkLemszR1AEIIYY6Ki4vZv38/arWaPn364Ozs3Oh1VVUo/Tih1NAKparm3BEREVhbWxMdHc2YMWMaHZcQQgjRUkhvwPox9+NkzP17EpMDQjSUVCgJIUQzqGrEbW1tzYgRI5q0Lp1OR6tWrbC0rP4ZQEMrlOCH5tyurq6cO3eO0tLSJsUmhBCiFv/9r6kjEGbmBVMHIIQZUqlURh3u9iQmISWhJIQQRlbViFuv1zNy5EhsbGyatL7anvAGDa9Qgh+ac+fm5lJSUsKFCxeaFJsQQohafPGFqSMQZuYZUwcghBC1kISSEEIYkaIo7N69GwsLC9q1a0efPn2avM68vLxaE0qNqVCCyubcubm5eHt7c+rUKbMvfxdCiMfu/HlTRyDMTC9TByCEGZIeSk0nCSUhhDCimJgY7t27R3l5OeHh4UZ52oNOp6vRPwnAwsICS0vLBlUoQWVzbmdnZ9RqNVlZWVy/fr3JMQohhHiAu7upIxBmJsnUAQhhhiSh1HSSUBJCCCOpasRtaWlJt27d6Nixo1HWm5eXV2tCCSqHvTW0QkmlUtG7d2/u3LmDm5sbUVFRxghTCCFElf/8x9QRCDPzkqkDEEKIWkhCSQghjOTQoUOUlJRQUVHB6NGjjbLOiooKCgoKah3yBpUJpYZWKEFlc261Wk3btm1JSEggJSWlqaEKIYSoMnOmqSMQZmajqQMQwgwZsyF31deT5snbYyGEaAZVjbgVRWHAgAG0bdvWKOvNy8sDqDOhpNVqG5VQsrGxwd/fn6SkJOzt7Tl16lST4hRCCCGEEEI0zAcffICPjw9arZb+/fsTHR390PnfffddunXrho2NDZ6enrz00ksNHq1gTJJQEkKIJqpqxG1tbY1Wq2XYsGFGW7dOpwN46JC3xiSUoLI5d3Z2Np07d+bSpUvk5+c3Ok4hhBAPmD7d1BEIM7PZ1AEIYYZM3UNpw4YNvPzyy7z++uucO3eO4OBgwsLCSEtLq3X+tWvX8sorr/D6669z5coVvvjiCzZs2MD//M//GONwNIoklIQQoomqGnGXlJQwatQow9PXjKE+FUqN/VSiqjl3YWEharWaM2fONDpOIYQQD/DyMnUEwszcNXUAQpghUw95e+edd1i+fDlLlizB39+fjz/+mFatWvHll1/WOv+JEycYPHgwc+fOxcfHhzFjxjBnzpxHVjU1J0koCSFEExQXFxMREYGNjQ3t27enZ8+eRl2/TqfDysoKjUZT6+tNqVBSqVSEhIRw48YNAgICOH36NOXl5U0JVwghBMA775g6AmFmXjZ1AEKIetPpdNW+artXLy0t5ezZs4SGhhqmqdVqQkNDOXnyZK3rHTRoEGfPnjUkkG7fvs3u3bsZN25c8+xIPUhCSQghmqCqEXdRURFjx441ejO+vLw8HBwc6iyhbcxT3h4UFBSEWq3GxsaGwsJCLl261Oh1CSGEEEII8VPRXEPePD09cXR0NHy99dZbNbadkZFBRUUFrq6u1aa7urrW+bCcuXPn8r//+78MGTIEKysrOnXqxIgRI2TImxBC/BRVNeJWq9X4+/vj7e1t9G3odLo6+ydB45tyV7GxsSEgIICrV6/SpUsXoqKiUBSl0esTQggB/Pvfpo5AmJnfmDoAIUS93bt3j9zcXMPXH//4R6Os9/Dhw/z973/nww8/5Ny5c2zdupVdu3bxl7/8xSjrbwxJKAkhRCNUNeK2sbGhvLyc0aNHN8t2qiqU6tLUCiWA3r17k52djbe3N2lpacTHxzdpfUII8cTbLC2UhXFJm3chjK+5KpQcHByqfdXWuqJdu3ZYWFiQmppabXpqairt27evNd4///nPLFiwgGXLlhEYGMiUKVP4+9//zltvvYVerzf+AaoHSSgJIUQjVDXiLi4uZvDgwbRu3bpZtlOfCqWysrImXUSqmnMnJSXh6urKqVOnGr0uIYQQQB39L4RorIGmDkAIM2TKptzW1taEhIQQGRlpmKbX64mMjGTgwNp/46sepPMgCwsLAJONMJCEkhBCNFBVI24HBwdsbW0ZMmRIs2xHUZR6VSgBTRr2VtWc+9q1awQHB3P9+nUyMzMbvT4hhHjitW1r6giEmZGrshDm5+WXX+azzz5j1apVXLlyhZ///OcUFBSwZMkSABYuXFhtuNzEiRP56KOPWL9+PfHx8URERPDnP/+ZiRMnGhJLj5ulSbYqhHgsKvQK93OKyC8pp5W1Be6tbbC0kDxyU1U14i4vL2fy5MlYW1s3y3YKCwupqKh4ZIUSVCa5bGxsGr2toKAgDhw4QFlZGba2tpw6dcqkT4wQQoiftBUrTB2BMDNLTR2AEGbowWFqxlpfQ8yaNYv09HRee+01UlJS6NmzJ3v37jU06r579261iqQ//elPqFQq/vSnP5GUlISzszMTJ07kb3/7m9H2oaEkoSSEGcrIL2HjmXt8dSKBFN0PlStOttYsGODNnH5etHfUmjDCn66qRty2trY4OjoSFBTUbNvKy8sDaPYKJfihOfeFCxcICQnh5MmTjBw5sklJKiGEeGI9/TTs2GHqKIQZ2Q5MMnUQQgije+GFF3jhhRdqfe3w4cPVvre0tOT111/n9ddffwyR1Y+UKghhZg5eTWXIPw7y//Zdq5ZMAsgqKOX9gzcY8s+DbL+QZKIIf7qqGnHb2tqSn5/P2LFjjfqpxo/pdDrg4QmlByuUmiokJITs7GycnZ3R6/WcO3euyesUQgghhBCiJTJlDyVzIRVKQpiRQ9fSWLbqDIoCdbVl0yugVxReXH8BgEk93R9bfD91VY24NRoNQUFBeHh4NOv2dDodKpUKW1vbOucxVoUSgIeHBy4uLsTFxREYGEh0dDQDBgww2ZhsIYQRzZoFVlawZg38z//AnTvQowe88AL87GeV8yxfDmVlsHJl5fdffgn//CdcuwadO8Of/gSLF1e+tmABtGoFn3xS+f2HH1b+/+JF8PSEf/0LZs+ufG3mTHBzg/feq/z+P/+BdesgOhpcXCqXmzKl8rVJk6BbN3j77crv//EP2LULjh0DBwdYvRqmToXycggLg379oOpxyW+8AcePQ0QEaDSwaRPMnQv5+TB8OIwZA6++WjnvK69AbCzs3Fn5/Y4dsGQJZGbCwIEwfTr85vsHtb/8Mty9+8OT2zZuhJdegqQk6NULnnmm8jgCPP885OZWHt+nn4avv4bXX4fbt6F798p1LV9eOe/SpT8cZ4DPPoN33oErV6BjR3jzTViwgB3ffssaIBd4/vsf5wvAM0AvIAl4Cdj4/WubgbvAy99//xsqnxD21sSJlb2dVqyojA1gwoTK8+Af/6j8/m9/g/374cgRsLODtWthxgwoKYHRo2Hw4MrjDPDnP1f+DPftA0tL2LoV5s8HnQ6GDoXx4yuPM8Dvf195Hm3fXvn9tm3w3HPs+OILooF1wH++j/c9wA2Y+f33s4F/AZ7AReAT4MPvX/sEaAUs+P77xcCfgM7ANeCfwPdHl5VAGfD90edn3x/HHsAd4H+ANd+/to7KnkVVNQO/AhYCfYDk76dv+f61bcAt4Lfff/97KiuJBgPZ38e0jcpP8XcD54Hvz0JeA0YATwFF3+/resAGOAgcBv73+3mffuUVFG9v2L0b1Gr45htYtAiysyt/LpMmVR5ngN/+Fm7dqjzOAFu2VJ6jycnwv/8LCxfCr35V+doLL1Se9+vWVX4v7xGV877yCsonnxjtPWKHt3flYQAcgXnf/1wXAG8CHYErwDvAZ9+/VnXuVg13XA6k/v73Nd4jAJg3DxwdK48zwH//C198AefPg7t75TGd+f1v1fTp4OVV+X4D8O9/V8Z+8mSj3iM2qVRogAjgOPDG9/H+BegHhAHlwDTga8ABOAbsAr5fK28DvsBqxE+NSjFVO3AhhFHlFZcx4O+RFJZW1JlMepAKsLRQcfwPT+HiIMPfHqW4uJj//ve/aLVadDodL7zwwkMrh4zh0KFDnD9/npdffrnOecrLy/nb3/7G5MmTCQ4ObvI2T506xf79+5k3bx5ff/0106ZNo0ePHk1erxDCNHQ6HY6OjuTm5jb7e5Z4wIkTMGiQUVZlrErYlnjL35xVvuZGOX7caOeUePzk97j+Hsf1quraOGrUKCwtjVdjU15eTmRk5BN1zX3yarKEMFPbzifVO5kElRVMFXqF9afvNWdYZuPQoUOUlpaSlZXF4MGDH8tFQqfTPXI7FhYWqNVqo1QoAQQHB6NWq0lKSsLHx4dTp04ZZb1CCPFEqfo0XwhjkXNKCKOrasptzK8njSSUhDADiqKw8nhCg5fTK/DVyQQq9C3v046WpKoRt6OjIw4ODgx6TJ8Q5uXlPTKhpFKp0Gq1RksoabVaAgICOHfuHP379ycxMZHExESjrFsIIYQQQghhPiShJIQZKCqr4HZGQb2rkx6UkV9Kiq7pDZ3NVVUjbgcHBzIyMhg9ejRWVlaPZds6nQ57e/tHzqfRaIzSlLtKSEgIOTk5WFpa4uTkRFRUlNHWLYQQTwQTPsJZmCk5p4QwOpVKZdSG3FKhJIT4SSosrWjS8tu+3c2uXbs4ePAgUVFRXLx4kRs3bpCYmEhWVhZFRUUtcsz241DViBvAy8sLf3//x7btvLy8eiWUjFmhBD80566qUoqLiyM3N9do6xdC1N8bb7xRo5zez8/P1GGJR9m/39QRCHMj55QQogWSp7wJYQbsNE37VS7Jz+FeQRlFRUUUFRVRVlZWYx6VSoWNjQ02Nja0atWKVq1aVfu+rn9/yk8IKy4uJiIiAjc3N5KTk5k1a9Zj++ShtLSU4uLievVq0mg0Rk0oqVQqQkJC2LdvH6GhoVhbWxMdHc3o0aONtg1hOnnFZUTHZ5FbVIa1pZqurvZ0dX104lKYTkBAAAcOHDB8b8wGoqKZHDnywxOghDAGOaeEMDpj9z16EiuU5I5ECDOgtbKgRwcH4pJ1NKwdkoKdqoy81ERKNdb4+Pjg4+ODp6cn9vb2FBcXU1hYSFFRUY1/i4qKyMjIqPZ9baytrR+ZdPrxv9bW1o/1DVmvKGSUllNQocfOUk07K0tUKlW1Rty9evXCzc3tscWUl5cHUK+EklarNeqQN4CgoCAiIiK4fPkyvXv35ty5cwwfPhxra2ujbkc8PrfS81lxPJ7NZxMpLtNXe62XZ2sWD/ZhQlAHLNRP3s1QS2dpaUn79u1NHYZoCDs7U0cgzI2cU0IYXdVQNWOu70kjCSUhzMTiwb78dtPFBi2jQsWvwoMY17Ev8fHxxMfHc/DgQcrLy7GxscHX1xcfHx98fX1p27btQ5M8er2e4uLiWpNPDyad8vPzSU9Pp7CwkMLCQioqag7XU6vVtSab6kpAVf2/oW/iGaXlrEvO5MukDJJLfqjK8rWxZqaDhoxz5+nY3pW0tDSeeuqpBq27qXQ6HUC9eygVFBQYdftarZYePXpUJpJmzeXa9Xg+OHORvt396ONgi9biybtg/pTtjU3hl+vOoVeotQn/xcQcXlx/gZ0xybw/pxdaq59uZaE5unHjBh06dECr1TJw4EDeeustvLy8ap23pKSkWsVi1XuJeMzWrjV1BMLcyDklhGiBJKEkhJmYEOTG33dfIaewtJ5VSgpWapgc1B6X1rZ4eHgwdOhQysvLSUxMNCSY9u7di16vx97eHl9fX8OXo6NjtbWp1WpDcqdt27b1illRFMrKyh6ZhCosLCQtLc0wra5qHI1GU+8k1NESPb9LyKBcUdD/aD0JRaX8s7AE6/5jCLt8isXDhmH3mD8ZbEiFkrGbckNl1VZW1wBW6m1560oSBPRndwlw4RYOlmoWdGjHYvd2eGqlYqmlO3YjnefXnEVRqLNxf9V7RuSVVH657jwfzw+RSqUWon///qxcuZJu3bqRnJzMm2++ydChQ4mNja014fzWW2/x5ptvmiBSUc2MGbBpk6mjEOZEzikhjE6GvDWdJJSEMBNaKwu+WNSHGR8dRwEU6n5DU1H5hjfa5jZb1t1j1qxZODk5AZVDK6qGvo0cOZKSkhLu3r1LfHw8CQkJxMTEANCmTRtDcsnHx6dRCReVSoW1tTXW1tY1ElQPo9frqyWb6kpG6XQ6UlJSDNP0+srU0a12buzv3rcqiBrrV76fXqa2YFePgYy0tcbr3j1DMkqr1TZ7SatOp0Or1dbriXLGbspdVKHn53F32JuRj8qxZnJQV67n47tprEjMYGWgL8OcpP9OS1VeoefljRe/f094NL0CEXGp7I1NYXzQ4xviKeoWHh5u+H9QUBD9+/fH29ubjRs38swzz9SY/49//CMvv/yy4XudToenp+djiVU8wIjvyUIAck4JIVokSSgJYUaybpxjrPVVjqkCyC3Wo1ZRrVpJpQJFAUvK+fekbgzo2JcNGzbw2WefMW3aNDp37lxjnRqNhi5dutClSxcAioqKSEhIMCSYzp07B4CLi4theJyPjw9arbbZ9lOtVmNra4utrW29l1EUhdLSUu7q8njqciKqh1RrGJZRqQCFV9IKWfjtN1jpfxiep9Vqax1297D+UPVJDlXR6XT1qk4C41YoVSgKP49LYH9G5TAZpY5PWiqAYr2eeTG32darM30c6/+zEI9P5NU00vMa9keIWgUrT8RLQqmFat26NV27duXmzZu1vq7RaNBoNI85KlGDPMRAGJucU0IYnfRQajpJKAlhJi5cuMB3333HnDGh/Lv/AHZfSmbl8QQuJv7wuPdurvYsGuhNxrl93L+QTNu+y1m2bBlbt25l7dq1jBo1ikGDBj20XNPGxobu3bvTvXt3oHJoVlWC6fr160RHR6NSqXBzczMkmLy8vEzezFmlUqHRaNhZkE1FPZJJVRSVmlIrazxmziNcq66zGio7O5ukpCTD94pScwuWlpaPHJJX9f/MzExsbW1RFOWR5bNarZbS0lL0en2TL2Tb03LYm1G/nit6AEXhF3F3iBrQ/Yks823p1kTdwUIFFQ1o1q9X4HRCNrfS8+nkLE1gW5r8/Hxu3brFggULTB2KeJjBg00dgTA3ck4JYXQy5K3pJKEkhBm4c+cO3377Lb169TIkhKb08mBKLw/KKvQUlJTTytoSa8vKZMN9zwl8/vnnREVFMXjwYObMmcOhQ4c4cOAAycnJPP300/VOANnb2xMYGEhgYCAA2dnZhgRTTEwMJ06cQK1W4+HhYRgi5+7ubpLHXpfrFVYkZdTomfQoamBDbgk/6+ZXr/kVRaGkpKTO5NOD/aGysrIM08rKymqs6y9/+UudlU9V/8/IyAAgMTGRNm3a0KpVKywsGtdU+fPEdNRQ72OkB+4Ul/Jddj5DZeib0SiKgqIoVFRUoNfrDV8N/T42MbtByaQH3UqThFJL8Nvf/paJEyfi7e3N/fv3ef3117GwsGDOnDmmDk08zBtvwI4dpo5CmBM5p4QQLZAklIT4icvMzGTDhg14e3szfvz4GplxKws1rVtVTw516NCBAQMGcPjwYbp3746TkxOjRo3Czc2Nb775hi+//JJZs2bRpk2bBsfTpk0b2rRpQ69evVAUhYyMDMPwuFOnTnHkyBEsLS3x8vIyJJjc3NweS4no/ZJS0krLG7ycHrhSUExqVhY2lpaoVCrUarXhU42q/z/4r1arbfCwv/LyckOy6auvvjJUeP04CZWRkVFtWpUVK1YY/m9tbd2gJ+XZ2NgQX6bnnK6wwcfHQgUrkzIeW0JJUZQmJVl+/L2x1mGsdVVUVNRa4dYYBUXBQP2HWj6opLyhqVfRHBITE5kzZw6ZmZk4OzszZMgQoqKicHZ2NnVoQgghxE+aVCg1nUox1l2rEOKxKyoq4osvvgDgmWeewcbGpt7LlpaW8uGHH9K2bVvmz59veANMS0tj/fr1FBcXM23aNDp16mS0eBVFISUlxZBgunPnDqWlpWg0Gry9vQ0JJhcXl2Z5Q76SX8TI09cavfziE3uwKS+t9/wPSzg9KimVnp6Og4MDtra2D11OpVJRVFREUlISHTp0wNLS0pCgqKioMHyVl5cb/i0vL681YXHTxZ0Ivz6NOjauSgVvl2XUK8HS1KRLc162qo6vWq3GwsLC8P/6fF/feYy1rvqsY9wHp7iX07hGrl8/04+hXSRp8VOn0+lwdHQkNze33n3ZhBGcPg19+xplVca6HrbEW/4n8Y+vxlKio412TonHT36P6+9xXK+qro0TJ05sUI/TRykrK+Pbb799oq65UqEkxE9URUUFGzdupLCwkGXLljUomQSVFSzjx49n7dq1xMTEEBwcDFQ2116+fDlbtmxhzZo1hIaGMnDgQKNcLKp6K7m5uTFo0CAqKiq4f/8+8fHxxMfHc+DAASoqKmjVqpWhubevry9OTk5G2b6dZeOGgVVZNGsGVmBIalT9++D/6/q3IfOUlJSQnp6Oi4sLDg4OhtfqWvbBC6GlpSVqtfqR23kw6VSVqMGq8Y18C8rLuXHjRr0SI1ZWViZLsjxqnebwx41Op+PKlSvExcXROr+CRNo/9KmPtbHTWNLXx6mZIhTiCSB//Atjk3NKCKOTCqWmk4SSED9BiqKwc+dO7t69y8KFC3Fyatwffl26dKFHjx7s27ePLl260KpVK6Cy8fbcuXM5ePAgERERhr5KxszgA1hYWODp6YmnpyfDhg2jrKyMxMREQ4Jp9+7dKIqCg4ODoXrJ19e30Rn/Dhor2ltbktLAYW8qRU+HshLKiyzo7Odn9OPwY0lJSZw/f55Ro0bRvn37R86fl5fHO++8w/Dhw+natWujt7s3PZeI2PhGLevZ2pEXXnih0dsWTaPT6YiLiyMuLo579+4Z+pYNaQ+XEhu2Lgu1ijn9PNFaNS0BK8QTbd8++MUvTB2FMCdyTglhdJJQajpJKAnxE3TixAkuXLjA5MmT8fb2btK6wsLC+OCDD9i/fz+TJ082TFer1YSGhuLm5sb27dv54osvGt1Xqb6srKwMSSOAkpIS7ty5Yxgid/HiRQCcnJwM8/n4+GBrW79H1luoVCxxd+af8ckNasytqNT0uH+brVE3sba2pnv37gQGBuLr69ssvZ90usqnrNU3cVb1iPDi4uImbTfIUsFKUShr4MVQDYQ7OzZp26LhcnNzDUmkxMRELCws6NSpE6NHjyYlJYXY2FgcHR0Z4GbJqeTyelUpqVRgZaFi4UCf5t8BIcyZCR48IcycnFNCiBZI3pmE+Im5cuUKBw4cYOjQoYZhak1hZ2fHmDFj2LFjB0FBQXTs2LHa6wEBAbRr147169fz2WefMX369BrzNBeNRkPXrl0NVTeFhYWGJ8glJCRw9uxZoHKYXlWCydvb+6HNsOe6teH/xd9Hr1D51/MjqFCwLivDK/E2FhYWtG/fnjt37nDx4kXs7OwIDAwkKCgIV1dXo30qodPpsLCwqPcwRisrK1QqFSUljeuVk5ycTFRUFJcuXaJL5yCuuHqhNDBRNt+tbaO2LRomJyfHkERKSkoyJJEmT56Ml5cX0dHRHDx4EI1GQ1hYWGXvnC3buKvxI7nE6qFJJbUK1CoVnyzog6dTq8e4V0KYH9W2bfW6xtSHOfdMaYn7Bi20ymDrVlNHIJqgpZ7rxmCsfavqa/Q4SYVS00lCSYifkPv377N161YCAgIYOXKk0dbbs2dPYmJi2LlzJz//+c9rDOlydXXl2WefZfPmzaxevZrRo0czYMCAx/6m2apVK/z9/fH39wcqh3pVDY+7evUqp06dQqVS0aFDB0P/JS8vL8P+VFRUcHLfXkbdSWZfQD8AHnYJVCkKlmo1KwK8ScnoxI0bN7h37x7W1tb07dsXvV7PxYsXOXnyJC4uLgQGBhIYGNjki2FeXh729vb1Pr4qlQqtVtughJJer+fatWtERUVx9+5dLC0tURSFp0p1XFerKVeU+iXcFIWprk500Fo/cl7RONnZ2YYk0v3797GwsKBz585MmTKFbt26oVKpiIqK4pNPPkFRFIYOHcqAAQOIi4tj48aNdO3alVBfT/68PY7b+raoVFQmVL9noVZRoVfo0NqG/8zqKb2ThDCCr4EFpg5CmJf582H1alNHIYQQ1UhCSYifiNzcXNatW4erqyuTJk0yejZ9woQJfPTRRxw5coTQ0NAa89jY2DBv3jwiIyPZv38/ycnJRn8yQkPZ29sTFBREUFAQiqKQk5NjSDBduHCB48ePo1ar8fT0xN3dndu3b5OWlsavJ05krocvz11OoFhf2aT6weSJCgUFFdblZfy6PIen3INh7lyuXr3Krl27KCgo4MyZM9jZ2TF8+HAcHBy4fPkyR44cITIyEh8fH4KCgujevftDq6XqkpeX1+A+URqNpl5D3oqLizl//jzR0dHk5ORga2uLSqXC3t6eUaNG4eHhwf1vdrPN0w94dMLNOS+HkYX3Ufy9nshPZZpLdnY2ly9fJi4ujuTkZCwtLencuTMDBgyga9euaDQaKioqOHv2LEePHqW4uJg+ffowdOhQWrVqxdGjRzl8+DAhISEMHjyYTz75hF/286PfiKdYH32XvZdTyCksw9pSTXc3BxYM8GZI53ao1fIzFMIYnoxn+4jH6vvh8EII45EKpaaThJIQPwGlpaWsW7cOCwsLZs+e3SxJnLZt2zJs2DAOHz5Mjx49am0GrVarGT16tKGvUnp6OrNmzaJ169ZGj6ehVCoVbdq0oU2bNvTu3RtFUcjIyOD27dtcu3aNkydPoigKFhYWxMbG4ltQwN6O3vw35hr71Tbkan8Y4uNSVsLvenTBJymeyN0nudrRCz8/P/z8/OjYsSOHDh0iKiqK0tJS9uzZg5OTEyNHjmT8+PFcvXqVmJgYduzYwe7du+nWrRuBgYF07twZC4v6NTnW6XQNTig9qkIpKyuL6Ohozp8/T1lZGc7OzlhaWqLX6xkzZgx9+/aloKCAlStX0lWv56MRw3n1XhaZZeWoFD2K6ochcGpAryh0yUxm+LXzxFaU46CxJjQ09Im8kBpLVlYWly9f5sqVK4YkUpcuXRg0aBBdu3bF2rqyCkxRFC5dusShQ4fIzs4mODiYESNG0Lp1a/R6PTt37uTcuXOMHDmSIUOGsGbNGjQaDWPHjkWr1fLymG68PKabifdWCPN2zNQBCPMzdKipIxDC7EhCqekkoSREC6fX69myZQvZ2dk888wz2NnZNdu2Bg8eTGxsLN9++y3PPPNMnQ2ne/ToQbt27diwYYOhr1JVI+2WQqVS4ezsTG5uLvfv36ddu3Y89dRTZGZmkpCQwJEjRygrK6Md8GtXV7r27IWtU1u+3bgBR2sr5o3uD25OJN66yY4dO3B3d8fe3h5ra2vCwsIIDg5m586dJCUlUV5ezpYtW2jfvj1PPfUUCxYsIC8vj0uXLhETE8P69euxsbGhR48eBAUF4e7u/tALjk6nw83NrUH7q9FoaiSUFEXhzp07REVFce3aNbRaLZ6eniQnJ5OZmcmAAQMYMmQIWq2W3NxcVq1ahV6vZ9GiRbRp04ZQFyd+seJr4jp0pNCpHfnFJTi3smGyW1scTn9HWdI98ivKUalUnDhxwpCcehIvpo2VmZlpGM6WkpKClZUVXbp0YfDgwXTp0sWQRILKn+fNmzeJjIwkNTWVbt26MXv2bFxcXIDKxPPmzZu5desWkyZNomfPnkRHR3P79m3mz5/fqGo5IUTj7DJ1AML8jB9v6giEEKIGSSgJ0cLt37+fGzduMHfuXMMfjs3FwsKCiRMn8uWXX3L69Gn69+9f57zt27dn+fLlbN68ma+//poxY8bQv3//FpNMUBSF6Oho9u3bR+fOnZk2bZrhaWiDBw+mvLycTz/9lMLCQrQaDScPRFBRUYE1UFRUzvHjx/H392fixIl8/PHHfPPNN8yfP9+wf+3bt2fp0qWcPXuWyMhINBoNZWVlrF27Fi8vL0aNGsXgwYMZPHgwqampxMTEcOnSJU6fPo2Tk5OhmbeTk1ONuBsz5E2r1RqGvJWXlxMbG8upU6dISUmhXbt29OnTh9u3b3Pr1i2Cg4MZOXKkodfTg8mkxYsXGyrObl2/Rsf0+0xq35ZBXQP45JNPWL58OR06dCDFdhiffPIJXl5e3L17F29vb6KiotDr9YwdO7bFnActUUZGhiGJlJqaipWVFV27dmXo0KF07ty5WhKpSmJiIgcOHODOnTt4eXmxZMkSvLy8DK8XFBSwdu1aMjIymDNnDp07dyYzM5MDBw7Qp08fOnXq9Dh3UYgn3j+ASaYOQpiXV16BHTtMHYUQZkUqlJpOEkpCtGCnT5/m1KlThIeH07lz58eyTU9PT/r27UtkZCR+fn4PbTDdqlUr5s+fz4EDB9i3bx/JyclMmDDBpH2VoLL59p49ezh79iwDBgxg9OjRNaqt4uLiSE9PZ+HChfj6+lJWVsa9e/fYvHkzRUVFREZGEhkZiaOjI66urty6dYvDhw9Xa4auVqvp27cvfn5+7Nu3j8uXL+Pq6kpBQQErVqyga9euPPXUU7i6ujJ69GhGjRpFQkICly5d4uTJkxw5cgQPDw+CgoJw7tKNY4WlpBYWE+3qTVtrW3rr9VjX82lrGo2GzMxMDh8+zJkzZygoKKBLly707NmTy5cvc+bMGTp27MiMGTOqDWesSiYpilItmQRw7tw5oPJJf5bfP664vLwcqEyo9ejRg4SEBGxsbLh37x6jR48mIiICvV7PuHHjnsiLal3S09MNSaS0tDSsra3p2rUrw4cPp3PnznX+zqSnp3Pw4EGuXr2Kq6src+fOpXPnztWObVZWFqtXr6a0tJTFixfj5uaGXq9n+/bt2NnZMXr06Me1m0IIIYQQ4gkiCSUhWqibN2+yZ88e+vXrR79+/R7rtkeNGsXVq1fZvXs3s2fPfmhiQK1WM2bMGNzc3NixY4ehr9LjfuxnlaKiIjZt2sSdO3eYOHEivXv3rjFPaWkpBw4cwM/PzzBUz8rKio4dO+Lt7c3Nmzfp1asXnTp1Ij4+noSEBACOHj3KxYsX6dKlC76+vvj4+NCqVSvs7e2ZPn06PXv2ZNeuXeh0Orp3705KSgoff/wxgYGBjBw5kjZt2tCxY0c6duzIuHHjuHbtGrvirvNifDrxeRYoqLBQgd63O1G5Fbx7/DKL3Nvxc09nHK3qfrtOSUnh/v37ZGRkkJaWRnBwMN26deP8+fPs3bsXV1dX5s+fX6NK5cFk0qJFi6olkwoKCrh79y5qtRpfX18KCwuBHxJKACNHjuSDDz4gMDCQixcvcuXKFSZMmMDOnTtRFIXx48c/0UmltLQ0QxIpPT0da2trunXrxsiRI+nUqdNDE6+5ubkcPnyYixcv4ujoyJQpUwgMDKxxPJOSkli7di02NjY888wztGnTBoCTJ09y7949lixZUmvFkxCieb1t6gCE+fn9700dgRBmR61W19nio7Hre9JIQkmIFigtLY3NmzfTuXNnwsLCHvv2NRoN48aNY8OGDcTFxREQEPDIZQIDAw19lT799FNmzJiBj49P8wf7gMzMTNauXUtRURELFiyoc/vHjx+nsLCQMWPG1HjNyckJlUpFamoq48aNo1u3yubFubm5rFixgpKSEm7fvs2ZM2cAcHV1xdfXF19fX7y9vXn++ec5evQoJ06coHXr1vTv35/Lly9z+fJlevfuzbBhw7C3t8fKyopbLu68n1GOovzwNLUKMDxxLru8gvfvpLIjLYdNPTvhrv0hMaDX67lx4wZRUVEkJCRgbW2NVqtl2bJlREdHs27dOuzs7Jg0aRJBQUE1LnC5ubmsXLkSoEYyCSoruAC8vLywtramtLQUqJ5QcnJyonfv3sTGxtK2bVsSExPp2bMnkyZNYvv27ej1eiZOnPjEJJUURamWRMrIyECj0dCtWzdGjRpFp06dDJVedSksLOTYsWOcPn0ajUZDWFgYffr0qbWh+/Xr19m8eTOurq7MmTOHVq0qG8unpaVx6NAhBg4cWG1YnBDi8ekGHDd1EMK8XLsGQ4aYOgohzIoMeWs6SSgJ0cIUFBSwbt06HB0dmTZtmsky3VVPNduzZw8dO3bExsbmkcu4ubnx7LPPsnnzZr766ivCwsLo16/fY3lzvX37Nps2bcLOzo5ly5bV6E1UJScnhxMnTjBgwABDNceDnJycKCsr4/79+1RUVBj+kHd0dGTevHl8+umndOzYkUWLFhEfH098fDxxcXFERUWhUqlwd3fHx8eH8ePHc/78eU6dOkVgYCCtW7fm9OnTXLx4kf79+6MP6MnPr9xD4YdkUm0qgITCYqaevUZEf380FeVcuHCBU6dOkZ2djYeHB9OnTyc9PZ3vvvuOzz77DKisHurfv3+tVTA5OTmsWrUKqD2ZBBATE4NKpTIk1H485K3KsGHDuHDhAq6urmRmZrJnzx6effZZJk+ezPbt21EUhYkTJ5rtJzaKopCammpIImVmZqLRaPDz82P06NF07NjxkUkkqKyai4qK4sSJEyiKwtChQxkwYICh79ePnT17ll27dtGtWzemTp1q+DlXVFSwbds2nJyceOqpp4y6r0KI+psEfGnqIIR52b4dnnnG1FEIIUQ1klASogUpLy9n/fr1lJWVsXjx4jr/mHxcwsPD+eCDDzhw4AATJ06s1zJVfZUiIiLYu3evoa9Sff6obqwzZ86we/duOnbsyPTp0x/6NKsDBw6g1WoZWsfjd9u2bQtU/izS0tKqPW3N2dmZMWPGsHv3bjp37kxwcDDBwcEoikJ2drYhwXTu3DkKCwtRq9W0bduWK1euYGFhwfDhwykoKOBkVBRfl9qgaG1QeHSyTa9ScbeknMXrtxFy5xoVFRUEBAQwdepUOnToQExMDKdOnaKiooKQkBCGDx9uqFb5sQeTSYsXL651aGJOTg6JiYkAdOnSBfghoVRWVlZtXnt7ewYMGMCpU6dwcHCgpKSEzZs3s3z5ctRqNdu2bUOv1zNp0iSzSSopikJKSoohiZSVlYVWq8XPz4+wsDB8fX3rfb5XVFRw9uxZjh49SnFxMX369GHo0KHY2trWue3Dhw9z9OhR+vTpQ3h4eLXjeuzYMVJTU1m2bFmz/s4JIYQQQpiDJ7GqyJjkblOIFkJRFLZv305KSkqdf+g/bg4ODoSGhrJ7926CgoLw9vau13JqtZqwsDDc3Nz49ttvSU9PZ+bMmUbfJ71ez759+4iOjqZfv36EhYU9NGlx584dLl++zKRJk+pM1lVVNqlUKhITE6sllAD69OnDzZs32bFjBz//+c+xs7NDpVLh5OSEk5MTISEhKIpCeno6t2/fJiEhgby8PEpKSti/fz9arRbrXn3J1dae8KmLApx39iDo9hVUikJRURFxcXF8++23pKWl4e7uTlJSEk899VSd+1afZBJAbGwsKpWK1q1bGxJsVZVaP65Qgsqn5p05c4bWrVtz9+5dsrOz2bNnD08//TQqlYqtW7ei1+uZMmXKTzappCgKycnJhiRSdna2IYkUHh6Or69vrcPSHra+2NhYDh06RHZ2NsHBwYwYMaLWarEqFRUV7Ny5kwsXLhieIvjgTdD9+/c5evQow4YNo0OHDk3ZXSFEE00xdQDC/GzbZuoIhBCiBkkoCdFCHDlyhNjYWGbMmIG7u7upwzHo06cPly5dYufOnTz33HMNqnoICgrC2dnZ0Fdp5syZ9U5KPUpxcTGbN2/m9u3bjB8/nj59+jx0fkVR2LdvHx06dCA4OLjO+ezt7bG0tKRVq1YkJSXRt2/faq+rVCqefvppPvroI7755hvmzZtX45MNlUqFi4sLLi4uDBgwAL1eT3JyMmfPniU2NpbdeSWoNHqUhiRXVCqKrLX0W/YztFcvcfr0aW7duoVKpaJTp054eXmRlJREcXFxrQmlqmSSSqVi0aJFD03uXbp0CUtLS0N1UtU+WVpa1ppQ0mq1DBkyhIMHD2JtbY2npyfnz5/H19eXwMBA1Go1W7ZsQa/XM3Xq1AYlXkypKol0+fJlrly5QnZ2NjY2Nvj5+TFu3LgGJ5Gq1nnz5k0iIyNJTU2lW7duzJ49GxcXl4cuV1payqZNm7h9+zaTJ0+ucQ6Xl5ezbds22rdvX2f1nRDi8fkEWG7qIIR5ee45+PxzU0chhFmRHkpNJwklIVqAmJgYjhw5wlNPPYW/v7+pw6lGpVIxYcIEPvnkE7777jtGjBjRoOXd3NxYvnx5tb5Kffv2bdIbblZWFuvWrSM/P5/58+fTsWPHRy5z4cIFkpOTWbJkyUO3XVVtpCiKYdjXj9na2jJ58mTWrFnDqVOnGDBgwEO3rVarcXd3x93dnXHjxvHt0QsoqoZX6qiAfecv4nTmOG3btiU0NJSCggIuXbrEoUOHADh48CD9+/fHzc3NsJ85OTmsXLkStVr9yGRSeno6aWlpAHTt2rXaa3UllAD69evHqVOn0Gg0JCYm4u/vz86dO3F3d8ff3x+1Ws2mTZvYsmUL06ZNa7FJJUVRuH//viGJlJOTQ6tWrfDz82P8+PH4+Pg0OvZ79+4RGRnJnTt38PLyYunSpXh6ej5yufz8fNauXUtmZiZz586t8bQ+qPy5Z2dn8+yzz7bYYyvEk+ThKWIhGuH7a7MQwngkodR0klASwsTu3r3Ljh07CA4OZkgLfXqHi4sLgwcP5tixYwQEBODs7Nyg5W1tbQ19lfbs2UNycjLjx49vVI+XhIQENm7ciI2NDcuWLTMMyXqYkpISIiMj6dGjR72eeuXk5ERmZiaZmZkUFRXV2pC8c+fO9O/fnwMHDuDr64urq2u94re0tMTGzg4Kius1fzWKQlpmJgvGj6dXr16GxMHQoUOJi4tj8+bNXL9+nZiYGNq1a2cYprh169Z6JZPgh+oklUpVo5rsYQklKysrhg8fzs6dOwHw8PAgJSWFzZs3s3TpUvz8/Jg5cyabNm1i06ZNzJgxo8UkPhRFISkpyZBEys3NpVWrVnTv3h1/f398fHyaNFQvPT2dyMhIrl27hqurK3PnzqVz5871uunIzMxk9erVlJeXs2TJEtq3b19jnjt37nDy5ElCQ0MfWekkhHg8ok0dgDA//fqZOgIhhKhBEkpCmFB2djYbNmzAw8OjxT9efdiwYVy+fJmdO3eyePHiBsdqYWHB2LFjDX2V0tLSmDVrFg4ODvVex7lz59i1axfe3t7MmDGjXk+eg8pGxSUlJYSGhtZrficnJ5KSkgBISkqic+fOtc4XGhpKQkICW7ZsYfny5bU+Ua027TVWXC0oRl+vuX+gqFQ4oJCVlUVWVpYhsadSqQyVLpMnT8bCwoKYmBiOHj1KeXk5lpaWDB8+HGtr64ev//u+Plqtlg4dOtRI+D0soQTQs2dPTpw4QWlpKWfPnmXatGl8+eWXREREEB4eTrdu3Zg1axYbNmxg48aNzJgxw2SNo6sq0KqSSDqdDltbW0MSydvbu8n9nnJzczl8+DAXL17E0dGRKVOmEBgYWO/fncTERNauXYutrW2dT+MrLS1l+/bteHp6MnDgwCbFK4QwnnWmDkCYnzlzTB2BEGZHKpSaThJKQphIcXExa9euRavVMnPmzBZTrVEXS0tLJk6cyKpVqzh37hwhISGNWk9wcHC1vkozZsx4ZF8lvV5PREQEUVFRhISEEB4eXu/jlZWVRVRUFEOGDKl3U3AnJyfy8vKwsbEhMTGxzoSSpaUlU6dO5bPPPiMiIoJx48bVa/1PO7fmYFZeveZ9kIW+grZ3b3Ey/honT57E0tKSdu3a0bVrV3r06AFUPoWtW7dutG3bljt37lBRUUHbtm05ePAghw8fpmvXrgQFBdGlS5caxzApKYns7GxUKlW1/kkP7u/DEkoWFhY89dRTbN68mfz8fPLz8xk9ejR79+7F19cXPz8/unTpwuzZs1m/fj0bN25k5syZjy2ppCgK9+7dMySR8vLysLOzMySRvLy8jNI0vLCwkGPHjnH69Gm0Wi1jx44lJCSkQb/j165dY/Pmzbi5uTFnzpw6k6cRERGGoZ8/1YbnQpij/wCTTB2EMC8vvQQ7dpg6CiGEqEYSSkKYQEVFBZs2bSI/P59ly5bV+Yj3lsbHx4eePXsSERFB165dsbe3b9R6OnTowLPPPsumTZv46quvGDt2LH369Kk1q19SUsKWLVu4efMm4eHhDe6/FBERga2tLYMHD673MlXD6JydnQ2VSnVxcXFh9OjR7Nmzhy5dutSaiHlQQkICaXv3YdWpN2WW9atoAlApevqV5NHWRkt+fj42NjaoVCpSUlJISUnh6NGjAERGRpKcnExsbCyWlpY888wzODg4kJeXR2xsLDExMWzYsAEbGxv8/f0JCgrC09MTlUplqE4qLi6uNYn2qIQSgL+/P25ubmRkZHDy5EkWLlxIfHw827dvx83NDUdHRzp37szcuXNZt24d69evZ9asWfWu7moovV7PvXv3iIuLMySR7O3tDUkkT09PoyViSktLOXnyJCdOnAAqhyIOHDjwkZVhP3bmzBl2796Nn58fU6ZMqfPY3Lp1izNnzjBu3DjD0wmFEEIIIUT9SIVS00lCSYjHTFEUdu/eTUJCAgsWLKhXD6CWZMyYMdy4cYO9e/cyY8aMRq/H1taWBQsWsH//fnbv3k1ycjLjxo2rVq2SnZ3NunXr0Ol0hr4zDXH79m2uXr3K1KlTG5SwqPrj3MHBgVu3bqEoykMvEH379uXmzZts376dn/3sZ9jZ2dWY5/79+0RERJCQkADAEIe7HHKr2Vy5Nioq36y9Y8/i4e1Bt27duHLlCjdu3MDKygovLy8UReH27dvk5OQYEhoajYZt27bh7+9PcHAwAwcOZODAgaSlpRETE8OlS5c4e/YsrVu3JjAwkJiYGOzt7bG3t691eFV9EkoqlYpRo0axevXqyuRZWhqTJk3i448/ZsuWLSxevBi1Wk3Hjh2rJZVmz55ttKSSXq/n7t27hiRSfn4+9vb2+Pv7G5JIxrzgV1RUcPbsWY4ePUpxcTF9+/ZlyJAh2NraNmg9iqJw6NAhjh07Rr9+/QgLC6sz2VVcXMz27dvp2LHjI59wKIR4/J4+cABl1ChThyHMyYsvmjqCZmWs67KiKEZZDxg3OWDMuIylJR7zx00SSk0nCSUhHrOoqCjOnTvH008/jY+Pj6nDaTAbGxvGjh3Lli1buHbtGt26dWv0uiwsLAgPD8fNzY2dO3eSlpbGzJkzcXBw4O7du2zYsAGNRsMzzzzT4Ebger2effv24enpaRgOVl/29vZYWlpibW1NUVERWVlZD038qVQqJk2axEcffcT27duZO3eu4YKSkZHBwYMHuXLlCiqVyjAs7NV+/fifW8l8dT/zobGoFD0WwMdd3PBxHcuePXtISEggLCyMcePGceHCBc6fP09ubi4qlQq1Wo1Wq6V9+/akpKSQkJBAQkICu3fvplWrVri7u9OjRw9GjhzJqFGjuHPnDjExMURFRVFWVkZxcTE+Pj4UFBTUSIjUJ6EE0LFjR7y9vbl37x4nT55k8uTJTJ8+nRUrVnDo0CFGff9Hlq+vL3PnzmXt2rWsXbuWOXPmNLiap4per+fOnTuGJFJBQQEODg706NEDf39/PDw8jH6RVxTF8IS93NxcgoODGT58eK3JuEepqKjg22+/5eLFi4SGhjJo0KCHxrt3715KS0t5+umnn8ibFyFavORkU0cgzI2cU0KIFkgSSkI8RlevXmX//v0MHjyYXr16mTqcRgsICODixYvs3r0bHx8fNBpNk9bXs2fPan2VevXqxYkTJ/D09GTmzJmNGhJ49uxZ0tLSWLZsWYP/4FapVDg5OaHXV7bNTkpKemQlma2tLZMmTWLt2rVER0fTvXt3Dh8+zPnz5w29c7p27Up4eDiOjo6UlpYSfv8WtxOSOe3eiRIra9RgaNStUvQoKjWdLNX0v3yamFMZtB05kp/97GdERESwfft2OnfuzIQJExg2bBgXL15k+/btVFRUGJ5MN23aNDw8PIiNjeXy5cvcv3+fGzducOPGDbZt24adnR1eXl4EBwdTXl7OzZs3KSoqIiEhgX//+9907tyZoKAgunXrhpWVFVZWVvVKKKlUKkJDQ/niiy+IiYlhZGgoGY5taT08lA3nz2Hn6U3/rpXVZj4+PsyfP581a9awdu1a5s6dW++kkl6vJyEhwZBEKiwsxNHRkaCgIPz9/XF3d2+WZIuiKNy8eZPIyEhSU1Pp1q0bc+bMafQT1kpKSti0aRPx8fFMnTqVwMDAh85/9epVLl68yKRJk+rdF0wI8Zht3Ajz55s6CmFO5JwSwuikQqnpVMpPuUZNiJ+Q5ORkVqxYQefOnZkxY8ZP/g0nJyeHDz/8kF69ehEeHm6Udep0Oj7//HPy8vLw9PRk0aJFjWpWXlRUxPvvv0/Xrl2ZPHlyo2LZsGEDpaWl5Obm0rFjx3o33P722285f/48UFmBpdfrsbe3Z9y4cXTt2hW9Xs+5c+c4fPgwxcXFuLi4kJqVTdf5S9iXXUBaaRkatRrL9BTaXTrLixPD8fLy4uDBg5w+fZr27dszceJE8vPz2blzJyUlJQwaNIizZ89SVFSEr68v3t7enD9/nszMTJycnOjVqxc9e/bEzs6OkpISLly4wJUrV0hJSaGkpMQQu4WFBYqiMH36dPLz84mJiSExMRFra2v8/f3JysrC2tqaefPm1etYfLx+A7uK9Fz36UYuDwzdUhRGtrblWe/2jHCyR6VSce/ePVavXo2rqyvz5s2rM0mp1+uJj48nLi6Oq1evUlhYSOvWrQ3D2Tp06NCsv1v37t0jMjKSO3fu4OXlRWhoqOEJe42Rn5/P2rVrycrKYtasWfj6+j50/oKCAj766CM8PDyYNWvWT/59RDQ/nU6Ho6Mjubm5DXqqpmiip5826wbK5j5UpiW+tyoTJ8o5VQ8y5K3+Wtoxf5zXq6ptzZ8/v9HV8bUpLS1l9erVT9Q1VxJKQjwGVYkSe3t7Fi9e3GwNiB+3kydPsn//fpYtW4a7u3uT1lVaWsrWrVu5fv06Hh4e3Lt3j969exMeHt7gp4Dt3buX8+fP88ILLzS6cXhERARxcXF4eXmRkZHB8uXLHzp/SUkJUVFRHD9+nLKyMsNFevDgwQwbNgxLS0uuX7/OgQMHyMjIICgoiP79+7NixQoGDRrEyJEjq60vPT2dDz/8EG9vbxYvXgxUVkp9++23pKWl0bdvXwYNGkRERASXL1/G0tISNzc3bGxsmDNnDoqicOfOHc6fP8/ly5dRFIVu3brRq1cvOnXqZOjNk5+fz759+4iNja22fbVaTevWrenQoQMajYbbt2+TnZ2NhYUF/fv3JygoCFdX1zqPx6mcfOZdvEVBhR6llhsWtaKgV6mY6dqGf/t5YaVWkZiYyOrVq3F2dmbevHlotVqgcjjYg0mkoqIi2rRpY0giubm5NfvNf1paGgcPHuTatWu4uroyatQoOnfu3KTtZmRksGbNGioqKpg3b95DjydU3rBt2rSJhIQEnn/++Vp7dQnxY5JQMpHCQviJPHCjMVraH6LG1iITSgUFck7VgySU6q+lHXNTJJQWLFhg9ITS119//URdc2XImxDNrLS0lHXr1qFSqYzaeLgl6N+/P5cuXWLHjh08++yzjaomAsjNzWXdunVkZ2cze/Zsunbtyvnz59m1a5ehr1J9E0MZGRmcPn2aESNGNDqZBJWNuXNzc+nQoQOxsbGUlZXV+rMrLy/nzJkzHDt2jOLiYtq0aUNmZiaKohAUFMSoUaNISkoiIiKCO3fu4Ovry9SpU3Fzc+PAgQOo1WoGDBhQY73Ozs7Y2tpy9+5dSkpK0Gg0uLu78+yzz3Lq1CkOHTrE5cuXDRVQarWaxMREHB0d0ev1qNVqfHx88PHxYezYscTExHDu3DnWrl2Lo6MjPXv2pFevXob5XVxcSEtLIzQ0lOLiYm7cuEFGRgZZWVlAZYLJ2toaRVE4d+4cJ06cwNXVlcDAQAIDA6tdNC/oCpl58RZleqXWZBKA/vvpm1KzKQc+6O6Fh4cHCxYsYPXq1Xz99dcMGjSImzdvcu3aNUMSqXfv3gQEBNC+ffvHcsOfk5PDkSNHuHjxIo6OjkyZMoXAwMAmb/vevXusW7cOOzs7Fi9eXK+ha7GxsVy5coUZM2ZIMkmIlu53v4MPPjB1FMKcyDklhNHJkLemk4SSEM1Ir9ezdetWsrKyWLJkSZMSHC2RWq1m4sSJfPbZZ5w8eZIhQ4Y0eB337t1jw4YNWFlZ8cwzzxj60PTq1QtnZ2c2btzIp59+ysyZM+s1tGjfvn04ODgwcODABsfyoLZt26IoCvb29uj1elJSUqptX6/XExMTw+HDh8nNzcXd3Z309HSKioqYPHkyRUVF7Nu3j5ycHO7evYuLi4vhSXUqlYrCwkJOnz5N3759sbGxqTWGwMBAoqKiuHTpkuFJXmq1moEDB9KhQwdWr15NeXk5vr6+jB07lq1bt5KamsoXX3zBpEmTDMfSxsaG/v37069fP5KSkgwJoaNHj9KxY0fi4+Px8/MjLS2NoKAg7O3tDY2zU1NTOXv2LLdv3yYzs7KBeFlZGWq1mtzcXCIjIzlw4AC+vr4EBQXh5+fH83F3KNcrhn5QD6MAW1OzGe/syFgnewoKCvDy8uL69ets3ryZ1q1bExISQkBAAK6uro/tQl1YWMixY8c4ffo0Wq2WsWPHEhIS0uik6YOuXr3Kli1b6NChA7Nnz67z5/+gvLw8du/ebWgyLoRo4e7dM3UEwtzIOSWEaIEkoSREMzpw4ADXr19n9uzZtG/f3tThNAs3NzcGDBjAkSNH8Pf3x8nJqd7LxsTEsGPHDtzd3Zk5c2aNp4p5eHjw7LPPsnHjRlauXMm4ceMICQmpc303btzg5s2bzJw5s8HD5H6saj/UajWWlpYkJibi6emJoihcvXqVQ4cOkZ6ejo+PD9bW1iQlJRESEsKoUaNQFIUjR44AlQmzsLAw+vXrV+0R8FFRUSiK8tDEV69evYiKiiI6Orrao+EzMzPZsmULjo6ODB48mMOHD/PZZ5/h4eGBra0tpaWlfPLJJwwbNowhQ4YYkiAqlQoPDw88PDwICwsjNjaW7777Dr1ez7Vr17C1taWsrKxaDK6urob+Ufv27ePKlSv4+vqSkJBAbm6uocw5ISGB+Ph4Pjp6gtuBgxp0rNXAPy5c4dLZI5SUlNC2bVt69erFlStX0Gq1DBw4sFGN2RujtLSUkydPcuLECQCGDh3KwIEDjVYOffr0afbs2UP37t2ZMmVKvc5TRVHYsWMHlpaW9e7lJYQwseBgU0cgzI2cU0IYnVQoNZ0klIRoJufOnePkyZOEhYXRtWtXU4fTrEaMGMGVK1fYuXMnCxYseOSbqaIoHDx4kO+++47g4GAmTJhQ5x/WdnZ2LFq0iL1797Jz506Sk5MJDw+vUSlSUVHBvn378PHxwc/Pr8n7ZG9vj6WlJdnZ2bi5uZGUlER8fDyRkZEkJSXh5eVF9+7duXLlCu3bt+eZZ57B1dWV6Ohojh07hqIoDB48mPPnzxMfH0///v0N6y4uLiY6OpqQkJAaSbQHOTs7Y2dnR3p6Ojk5ObRu3ZrMzExWrVqFRqNh4cKF2Nvb4+/vz+HDh4mKikKlUjF9+nRu377NkSNHiIuLY9KkSXTo0KHaujUaDSEhIVy9ehWNRkNGRgbFxcW8//77+Pr60rt3b/z8/Kr9XKysrFCpVEyaNAmorNK6desWFy9e5O7du+Tl5XHJ1RuVXo/yQPLsUfTADUsbPPsPZHRAd5ydnVGpVPTv35+vvvqKr776ioULFzZrUqmiooKzZ89y9OhRiouL6du3L0OHDjXaNhVFITIykuPHj9O/f3/CwsLqfdNx7tw5bt68ydy5c+tVzSSEaAGee87UEQhzI+eUEKIFkoSSEM3g9u3b7Nq1iz59+lRLJJgra2trxo8fz5o1a4iJiSH4IZ+ilZaW8s0333DlyhVCQ0MZNGjQI/+wtrCwYPz48bi5ubF7927S0tKYMWNGtSGEp0+fJisri+nTpxvl0wGVSoWTkxNZWVm0bt2aK1eucPnyZdzc3Bg8eDAXLlwgJSWFsLAw+vbtS2xsLJs2bSI/P5+QkBCGDx+Ora0tXl5erFu3jjNnztC3b18ATp06RXl5OYMGPbySR6VSERwczPHjxzl//jxBQUGGZNKiRYsMfXQ0Gg1hYWFYWlry3XffsWrVKnr37m1IxH3++ecMHDiQESNGVOsDVVBQwK1btxgwYACpqaksWrSI3Nxczp07x5YtW7CxsSE4OJjevXvj7OyMpaUl5eXlhuXVajVdunShS5cuQGWCaduxGJT6jHWrhUNAMC4urQ3fu7q6smjRIr766itWrVrFwoULH5qAawxFUbh06RKHDh0iNzeX4OBgRowYUa+eRvVVUVHBjh07iImJYcyYMQ0ajpmdnc3+/fvp1auX4TgLIX4Cnn/erJ/IJUxAzikhjE4qlJpOEkpCGFlGRgYbN27E19eX8PDwJ+aNpXPnzgQGBrJv3z46d+5c6x/+Op2OdevWkZmZyaxZsxpcSdS7d29cXFzYsGEDn332GTNnzsTDw4PCwkKOHDlC7969jTq00NbWlitXrlBQUADAyJEjiY+P5/jx4/j7+xMWFkZGRgaff/45KSkpdO/enVGjRtG2bVvDOrp27Urfvn3Zv38/3t7eODo6curUKUJCQurVUyswMJDjx49z5swZzp8/XyOZ9KCqnkljxozh8OHDXLt2jdDQUHQ6HUePHuXatWs8/fTTeHl5ARAXF4dKpUJRFGxsbPDy8kKtVhMcHExGRgbnzp3j4sWLREVF4enpiYODQ7WE0o+p1Wr0lpZQWvc8D5OSlQUPJJSq9unHSSVjNKRWFIWbN28SGRlJamoq3bp1Y86cOYZjaCwlJSVs3LiRO3fuMG3aNHr06NGgGLdv346NjQ1hYWFGjUsIIYQQ4kknCaWmq/+YBCHEIxUWFrJ27VocHByYPn16tZ45T4KqP3r3799f47WkpCQ+++wzCgsLWbp0aaOHpVX1VWrdujUrV67k3LlzHDp0CEVRGDlyZJPir5Kbm8v27duJj4+nsLDQsN4jR46Qm5vLvHnzGDZsGDt27ODrr7/G0tKSpUuXMnPmzGrJpCqjR4+mTZs2bN26lVOnTlFaWsrgwYPrFYuLiwu2trYUFhZiYWFRZzIJKiuVAAICAnjhhRfw9vZm+/bt3Llzh1mzZmFjY8OKFSvYvXs3paWlXLp0iU6dOpGQkEDnzp2rna/t2rVjzJgxvPTSS0yfPh0rKysuX75McXExu3btIjk5GcDQsPzs2bNs374dfZ6uQcf6QTFRJykpKakx3dnZmUWLFlFcXMyqVavIy8tr9Dagsq/VypUrWbt2LVqtlqVLlzJ79myjJ5Py8vJYuXIlSUlJzJ8/v0HJJKisZLtz5w6TJk0y/GyFED8RMjxJGJucU0KIFkgqlIQwkvLycjZs2EBpaSkLFy5Eq9WaOqTHztbWljFjxrB9+3aCgoLo1KkTUPm48+3bt9O+fXtmzZrV5AoTe3t7Fi1axJ49e/j2228BCA0NbfJwqIKCAr777jtOnz6NRqPB39+fuLg4zp8/D4C7uzuTJk3iu+++48KFCzg5OTFz5kz8/Pwe+omElZUVU6dO5fPPP+fYsWP07NkTBweHesWUmZlJaWkpAJ6eng89dlXnXElJCc7OzsyYMYMbN26we/duNmzYwJAhQ+jevTuHDx/m6tWr5OXlMXbsWPbu3Vvn8DtLS0sCAgIICAjg2LFjHDx4kEuXLnHmzBmsra0pLy9Hr9ejUqlwcHCgY3vIdPFEUTUsmWqtgrZp99m1axdTpkypcTzbtWvH4sWLWbVqlaFSqb7HsEpaWhoHDx7k2rVruLq6VnvqnrGlp6ezZs0a9Ho9S5YswdXVtUHLZ2RkEBkZSf/+/fH19TV6fEKIZlZYaOoIhLmRc0oIo5MKpaZ7ssonhGgmiqLw7bffkpSUxKxZs2jdurWpQzKZ4OBgfHx82LlzJ6WlpRw+fJgtW7bQvXv3h1bXNFRVX6WqiqBr166Rn5/fqHWVlJRw+PBh/u///o9z584xdOhQlixZYhjqZmdnh7e3Nzqdjo8//pjr168THh7O888/T/fu3et18Wjfvj2dO3emvLwcT0/PesWVkZHBqlWrDImyq1evPnTIWVUVy4NVPl26dOH5559nwIABHDt2jHPnzjFx4kRDs+3Y2FgAQ/LvQcXFxdy6dYujR4+ybt06jh8/bli/ra0t1tbWhmQSVFZ2jagobHAySaXXM4RSpoSN4dKlS1y4cKHW+ZycnFi8eDHl5eWsXLmS3Nzceq0/JyeHb775ho8++oi0tDSmTp3Kc889R5cuXZrlwn/37l2+/PJLNBoNy5Yta3AySa/X88033+Do6MioUaOMHp8Q4jH4+mtTRyDMjZxTQogWSCqUhDCCY8eOERMTw7Rp0+qdLDBXKpWKCRMm8OGHH/Lpp5+SmZnJU089xZAhQ4z+x/u1a9fIzMxk9OjRnDx5kk8//ZRZs2bh7u5er+XLy8s5c+YMx44do6SkhL59+zJ48GAuXbrEZ599Zki6uLi4cOnSJcrKyhgyZAhDhgxp8BCksrIyEhMTsbe358CBA3X2mapSlUyysbFhwYIFfP755+h0Oq5du0ZAQECty1RVKBUXF1ebbmVlRWhoKEFBQezcuZOtW7ei1WpxdXXl/v37qNVqEhISaN26NUlJSYavjIwMoDJR5e7ujq+vL1evXmXOnDncuXOHS5cuAWBjY4Ner6e4uBhtbjYDPCqI1ltQ397cKpUK5zPHOaqxpFOnTuzevRt3d/dah6C1adPGUKm0cuVKFi1aVGcCt6CggGPHjnHmzBm0Wi3h4eGEhITUeEKgMV25coUtW7bg4eHB7NmzG1Wp+N1333H//n2WLl1arYm6EEIIIYQwHqlQajpJKAnRRLGxsRw6dIgRI0Y0uEeKubK2tsbW1taQ7HnU08wao7y8nP3799OpUycGDhxIYGAgGzduZMWKFYwfP55evXrVuaxer+fixYscPnyYvLw8evbsyfDhw8nLy2P16tWkpqbSp08f3N3d2b59O+fOnaNz587cvHmTwMDARvWzOX/+PIWFhSxZsoT169fz7bffMmvWrFovPA8mk6qaUPfo0YOoqCguXrxYZ0KptgqlB7m4uLBkyRIOHz7M0aNHKSsrQ1EU1Go1mzZtAiovhG5ubvj6+jJkyBDc3d1p27YtBQUFHDp0CIB169ZhY2NDYGAgwcHBuLm5AZVPNzx37hw9ju/nWtBgclrZPbxaSVEA+F/31kwKnM+ePXu4desW1tbWbNiwgZ/97Ge1JlRat27NokWLqiWV2rRpY3i9pKSEqKgoTpw4AcCwYcMYMGAA1tbWdcdiBNHR0ezZs4eAgAAmT55sSEg2REpKCkeOHGHw4MF4eHg0Q5RCiMdi5UpTRyDMjZxTQhidJJSaToa8CdEEiYmJfPPNNwQFBTFs2DBTh9MiJCcn89lnnwGV1SSXL19Gr2/kc+QfIioqipycHMLCwlCpVIa+SkFBQezYsYPdu3dTUVFRbRlFUYiLi+Ojjz5ix44deHh48PzzzzN69GiOHj3KF198gVqtZsKECaSkpLB9+3asra3x9/dnxowZqFQqEhMTGxxreXk5x48fJzAwEE9PT55++mmuXbvG2bNna8z7YDLpwSGCAQEB6PV6bty4UefQvqqE0o8rlAoLC7l58yaHDx9m7dq1hkRLRUUFiqJgZWVF165d0Wg02NjYMGDAAMLDwwkICCA1NZV169bxzjvvGHpJTZgwgd/85jeEh4fToUMHw8W4U6dOjB8/Hld7O2ZfPY1vXjYAaqX6z19FZSLJzkLN7OSb6HZtw9ramgULFjBjxgysrKzIysriyy+/pKysrNZ9bd26NYsXL0atVrNq1SqysrKoqKjg1KlT/N///R/Hjh2jd+/evPjiiwwbNqxZk0mKohAREcGePXsYOHAg06ZNa1Qyqby8nG+++QZnZ2eGDx/eDJEKIR6bv/7V1BEIcyPnlBCiBZIKJSEaKScnh/Xr1+Pu7s7EiROfyIz0j8XFxbFt2zZcXFyYPXs2ubm5fPHFF0RHRzNgwACjbSc/P59jx47Rt29fnJ2dDdMtLS2ZOHEiHTp0YM+ePaSmpjJjxgzs7Oy4ffs2kZGR3L9/n06dOjFlyhTc3NyIiYlh//79VFRUMHToUNLS0ti5cydubm4sWLCA06dPU1xcjLW1NS4uLiQmJtK7d+8GxXvx4kV0Oh1Dhw4FoFu3boSEhLBv3z68vb0N+5Cenm7ombRw4cJqQ+Lc3NxwcHAgLy+P2NjYWo+nSqXC2tqa1NRUTp06ZRi6lpWVBVQOTXN3d8fS0hIvLy/atm1LbGwsWq2Wmzdv0q9fP3Jycti6dSuRkZEUFRVRWlqKh4cH4eHhtG7dmrVr1+Lt7V3rsLGSkhLWrFlDSUkJLyxZwmtOTkTeuM0ntxI5o9ZQYmmFFeBjbYFH3AWWdO/EgEnhfP7556xdu5alS5fi7+9Ply5d2LRpEzdu3OA///kPEyZMqLVXlaOjo2H42+eff46lpSX5+fkEBwczYsQIHB0dG/RzaoyKigq2b9/OpUuXCAsLa9J5fuTIEdLT01m+fHmjElJCiBbk5k1TRyDMjZxTQhidVCg1ndyxCtEIxcXFrF27Fmtra2bNmvXE//GnKArHjh3j0KFDBAQEMGnSJKysrLC3t6dv374cPHgQPz8/ozUrj4yMxMLCghEjRtR4TaVS0adPH1xcXNi4cSMff/wxjo6O3L9/H3d3dxYuXIivr68heXPnzh38/PzQaDR89913ODg4MGXKFAIDA1GpVNy6dYu4uDig8ilvDa1Qqqio4LvvviMgIIB27doZpoeFhXHnzh22bt3KM888Q3Z2dp3JpKr9CggIIDo6mgsXLjBgwAAURSEzM7Na36PS0lJOnz6NhYUFbm5udOnSBXd3d9zd3WnTpg1JSUl88cUXDBkyhD179tCtWzfGjx/P/v37OXXqlOFCqNPpUKvVjBw5kqFDh6JSqbh//z5ArVVD5eXlrF+/nszMTBYtWmRolh7atROjunTkrbfewtfXl5ycHNLS0rCysuLMiRRCAnswd+5cvvzySzZt2sScOXOwsrJizpw5rFu3jlu3brFp0yZ8fX0JDw+vlkBUFIWUlBTUajVFRUVYWloye/Zsunbt2qCfUWMVFxezceNG7t69y/Tp0+scilgfiYmJHD9+nBEjRtC+fXsjRimEMIlu3UwdgTA3ck4JIVqgJ/uvYCEaQa/Xs3nzZnQ6HcuWLaNVq1amDsmkysvL2bFjB5cuXWL48OEMHz68WnZ+1KhRXL16ld27dzNnzpwmZ+7v37/PhQsXCA8Px8bGps75bGxscHNz4+bNmxQUFNCvXz/Gjh1LeXk5kZGRnDhxAkdHR4KCgrh69SpqtZrQ0FD69etXLUHo5OREbm4uFRUVuLu7c+7cOUpKSurdRykmJoacnBxmz55dbbqVlRVTp07l888/Z9euXdy4caPOZFKVjh07cvLkSVJTU/niiy/IyMgwDG9r27YtHh4e6HQ6vLy8mDp1aq1VRJcuXcLOzg5HR0fS09Px8vLiq6++4t69e1hZWaHRaMjPz8fPzw+1Ws2hQ4e4c+cOEyZMMByXHz9pTq/Xs2XLFhITE5k/f76hp1KV4uJiysrKCAoKwt/fn6SkJL777juuXbvG+++/T+fOnRk4cCBHjhxh165dhoq/adOm8cknn6BSqcjJyeHjjz+mX79+DB8+nPT0dA4cOMDdu3fx9vYmNDSUyMhIvv32WxYtWlQtedccdDoda9euJTc3l/nz5+Pj49PodZWVlfHNN9/QoUMHhgwZYrwghRCm84c/GG1VLfETb+X7HnhN1RL3rcUy4jnVEhnrnDKmlhiTMZn7/tWHVCg1nSSUhGgARVHYs2cP8fHxzJs3r9n/aG3p8vPzWb9+PampqUybNq3WpuQajYZx48axYcMG4uLimlTFoSgKe/fuxdnZmT59+tQ6T05ODkeOHOHixYs4ODjw/9m7z7A20zP/+18J0bswzWDTTTHNBtx77723cZmW3WT3v8mmPenZTTZlN5mUSWaSscdlxn1s7MHd4F4pBlMNmGq6AdGbpPt54aCYoRgwGIyvz3FwjAdJt06EENw/ndd5LV26lLy8PO7fv09lZSWlpaXU1NTg6elJYWEhycnJhIWFMW3atA4DKhsbGyRJorKyUjckubCwEDc3txfWq9VquXnzJj4+Ph1uHe/o6MiECRO4ffs2VlZWbcKklpYWioqK2nQfqVQq3W3r6uqYOHGirvuodTexPXv2oK+v32GYpNVqSUpKYsSIEboh3LGxsXh6erJ69Wq8vb1RKBRtlgGGhYXx6NEj/vrXvzJx4kSgbaAkSRJffvkl6enprF+/HhcXl3b3W1VVBTxboiaTyXQ7oP3tb39DrVZTV1fH1atXMTQ05MGDBxgaGjJ//nwMDQ1Zs2YNu3fvJjQ0FHNzc65du0Z0dDQajQY7Ozs2bdqEp6en7rj79+9n7969bNu2rcNd4vpCWVkZn332GQA7dux46fu5fPkyVVVVbNiwAblcjDYUhCFh5044fXqgqxCGEvGcEoQ+JwKllycCJUHogfv37xMTE8OSJUtwd3cf6HIGVHFxMYcOHUKr1bJ9+3acnJw6va6Pjw++vr6cO3cOd3f3LjuLupKcnEx+fj5bt25td+L9/BbxrYFESEgICoUCd3d3iouLycjIQF9fHwsLC9LT0/H392fWrFltdgj7KqVSCUBFRQWenp4YGBjw5MmTbgVKSUlJVFRUsGbNmg4vLy0tJT4+Hn19fZqamkhKSqKsrIyCggJKSkqQJAmFQsHw4cPx8fHB2dmZzMxMkpOTaW5uZsqUKe0eByMjo3ZDuVuXhl2/fp36+noePXqEgYEB1tbW7NixA3Nz8zbXDwoKwsvLi0uXLhEdHc3w4cMZMWIE169fB6C8vBw3NzckSeLixYvEx8ezcuXKTpeatQZhX13yOH78eMLDw/n6179OS0sLcXFxxMXFcffuXR4/fsy0adPw8fFh7ty5XLhwAVdXV9RqNfr6+mg0GgwMDDAzM9P98jY1NeWtt95i//797Nu3j23btnUY5L2M3NxcDh8+jIWFBZs3b8bCwuKljpednc39+/eZP3/+Gx9QC4IgCIIgCK8XESgJQjelp6dz4cIFJk6cSEhIyECXM6DS0tI4ceIENjY2bNy4sVsn1QsXLuTDDz/k0qVLLFu2rMf32dLSwqVLl/D29m4T5jU1NXH79m3u3r2LTCZrs0W8RqPh9u3bXL16FYVCgZWVFSqVipqaGlasWEFQUNAL79fc3ByFQkFFRQVyuRwnJycKCgpeeLvWuVJeXl7tloDV1NSQkpJCZGQkMpkMSZJoaGjg/PnzDBs2DGdnZ0JCQnB2dsbW1rZNt5G5uTnx8fG0tLSQlZWFp6dnm2O3LlmDZ8uyEhMTSUhIoKysDIVCgZGREZs2bWL//v2EhIS0C5NamZiYsHz5coKDg4mIiCAlJQUfHx/S0tI4d+4cjY2NaDQa7t69y8KFCwkMDOz0saiqqkJPT6/dUr7Ro0dz4cIFYmJimD9/PosWLWLOnDl89tln5Ofn88UXX2BsbKx7fuXk5DBjxgymTJlCfn4+586d429/+xtjx45l9uzZmJiYYGJiwrZt2zhw4IAuVOqrmUTJycmcPHmSkSNHsm7dOl1XWG81NTVx6tQpXFxcGD9+fJ/UKAjCILF9+0BXIAw14jklCP3iTewq6ksiUBKEbigpKeGLL75g1KhRzJkzZ6DLGTCSJHHr1i0iIyPx9fVlxYoV3d6O3dzcnDlz5nDmzBkCAwN7PHPm9u3b1NbWMnfuXODZsqvo6Ghu3LhBS0sLYWFhTJkyRTfTKi8vjzNnzlBaWopSqaSiogIzMzOWL1/O/fv3+fLLLwFeGCrJZDKUSiXl5eXAs8Hc8fHxSJLU5S+glJQUnj59yqJFi8jJyWmzdK26uhoAuVyOu7s7Li4uaDQarl69yoQJE7oMLEeMGIG5uTlqtZqEhIR2gZJCoaCyspIDBw6QlZWFQqHAx8eHWbNmcfLkScaNG0dTUxNqtbpbw6tdXFx4//33uX37tq5Dyd7ensjISABCQ0MZN25cl8dQqVS65W5frXXMmDHExcUxa9Ys9PX1MTAw0HUZFRQU0NTURElJCQB6eno8fPiQCRMm4OrqynvvvUd0dDRXrlwhJSWFWbNmERISoguVPvvsM/bv38/WrVvbhXo9dffuXS5cuEBAQADLly/vcElhT124cIGGhgbeeust8ceMIAw1+voDXYEw1IjnlCAIg5AIlAThBWpqajh48CBKpZJVq1a9sTNO1Go1ERERJCQkMHXqVGbOnNnjk+CQkBAePnxIREQE77//frd3x6uurubWrVtMmDABa2tr4uLiuHbtGjU1NYwZM4bp06fruljq6+u5fPkyDx48wNTUFLlcTnNzM0uXLiU4OBi5XI6/vz9nzpwhPDycoqIi5s6d22VAoFQqqaysBMDZ2ZmbN29SVVXVbgmXVqulrKyM/Px8IiMj0dfX58CBA0iShL6+Pk5OTri5uZGWloaFhQXbt29vM9S9urqaCxcu4OLi0unyJ5lMhq+vLwkJCaSmptLY2IihoSE5OTkkJCSQmJiIVqvFysqKpUuX4ufnh5GREampqTQ3NxMQEEB0dDSWlpbdXmKlp6fH1KlT8fX15cMPP6SoqAh4trwuLi4OY2Njpk2b1un3s6PHqlVoaCi3b98mMTGRsWPHolariY2NpaysDI1Gg6GhIdu3b6e8vJzbt29TWFjIb3/7W8aMGcPYsWMZP348/v7+REZGcvbsWeLi4li4cCEjR45k69atbUKl4cOHt7t/SZJoliQMO/m5liSJS5cucefOHSZNmsScOXP6JPxJT0/nwYMHLFmypMsll4IgvKb+/ndYunSgqxCGEvGcEoQ+J2YovTwRKAlCF1paWjh8+DCSJLFx48Zud+MMNXV1dRw5coTCwkJWrVpFQEBAr44jk8lYsmQJH3/8MTdu3GDmzJndut3ly5fR19fHzs6Ov/zlL5SXlzN69Ghmzpyp255ekiTi4+O5ePEiLS0tKBQKWlpamDZtGhMnTmzzvVMoFCxbtgxHR0fOnz9PSUkJa9as6XR3NaVSSUpKCoBuVtSTJ0+QyWQUFBTw5MkTCgsLKSwspKWlRXe7UaNG4e3tjZOTE7a2tjx9+pR9+/bpBnB/dYfA+fPnk5uby4kTJ9i1a1enIZefnx/3798H4IsvvqC0tJTq6mqUSiUuLi4UFhay/Sut8UlJSTg4OGBjY0NGRgZeXl49/qU3bNgw3RI9hUKBVqvFzc2NmzdvkpaWxrJly3SDy59XVVXV6Swja2trvLy8iI6ORk9Pj6tXr1JVVUVQUBBjxozh6NGjRERE8NZbbzF69GguXrzInTt3SEpKIiYmBkdHR8aOHaubmXX27Fk+/fRTAgMDmTNnDlu2bOHzzz9n//79bNmyBWdnZ+o1WsJLKtlT8JSU2ga0gIFMxnSlOTudhjFdaY5cJkOtVnPq1CmSkpJYsGBBny1Lq6+v58svv8TT05OxY8f2yTEFQRAEQRCEnhGB0ssTgZIgdEKSJE6ePElZWRk7dux46eG7r6vS0lIOHTpES0sL27dv7zAw6Ak7OzumTJnCzZs3GT169At3yMrLyyMxMRFLS0vCw8N1O5I9v4SptLSUiIgI8vPz0dfXR6vVEhISwvTp0zEzM+vwuDKZjHHjxmFnZ8exY8f4+9//zvr16ztcGqVUKlGpVGRmZlJUVIS+vj6nT5/WhUeWlpY4OTkxY8YMhg8fzoULFzAyMmLjxo1taty3bx8WFhZs3bq1XZgEYGBgwOrVq/nkk0+IiorSLe97Xn19PcXFxcjlcrRaLY8fPyYkJISgoCCcnJyIiYkhNze3zZK8pqYm0tPTmTFjBhUVFVRWVuLl5dXl496RvLw8JEnC1taWt956i6tXrxITE8OwYcOQJIk9e/Ywfvx43fK1ViqVqtPldZIkMXz4cK5du0Z4eDg+Pj5s2rQJW1tbADZt2sTevXs5efIka9euZc6cORQXF1NWVsaKFStISUnh7NmzXLx4kdGjR7NgwQJKS0uJiooiLS2N6dOns3HjRo4cOcKBAwdwW7mOH5XWUaPRIge0/6ijWZKIKq/mUnk1niaG7PF24s6pk+Tn57N27Vr8/Px6/Hh15ty5c6jVapYtW/ZG/uEhCG+Ejz4a6AqEoUY8pwRBGIREoCQInYiKiiI1NbXTkOFNkJ6ezhdffIG1tTXbt2/H0tKyT447depUkpOTiYiIYMeOHZ2eVOfn5/P5558Dz2YwrVixos3spebmZq5du8adO3d0SxE9PDyYPXt2t5dzubq68u6773LkyBH27NnD0qVLGT16NKWlpTx58oSCggJycnIA+PzzzzE0NMTAwAC5XM7q1asZPnx4m8HWGRkZFBcXs23bNt3nSkpK2L9/f5dhUitHR0dmzZrF5cuX8fT0xM3NDbVaTUZGBgkJCWRkZABgYWFBfX09zc3NTJo0SbdsytDQEK1Wq9sNDZ4NUVer1fj7+5OSkoKenl6PZ1iVlJRw6NAh5HI5fn5+mJqasnjxYoKCgoiIiKC0tBRnZ2eio6N59OgRy5Ytw9XVlZaWFurr6ztc8paXl0dkZCR5eXkoFApcXFxYv359m+sMHz6c1atXc+TIES5dusS8efNYtWoVH330EYmJiWzevJmamhoePHjAgwcPiI+Px87OjgkTJqBSqbh8+TJxcXHMmTOH3Qmp/LGwGv7xfNN+pR7NP/6bXd/E/OhHbKis4mvbtjFy5MgePVZdSU5OJikpiVWrVnU6EF0QhCHgz3+GX/5yoKsQhhLxnBKEPic6lF6eCJQEoQMPHjzg5s2bzJ07Fx8fn4Eu55WTJIm7d+9y8eJFvL29WbVqVZ8u91MoFCxZsoR9+/YRExOLbJQvBwqf8qiukSathCVaRhTnY/EwBgONmlmzZjFlypQ2L9JpaWmcOXOGuro6JEnC3t6eefPm4eLi0uOvVavVMm7cOG7dusXJkycJDw9HkiTkcjn29va4uLjw8OFDFi1aRGhoKPfu3SMyMhJPT882y9IkSeLatWuMGDFCF9j0JExqNWnSJDIzMzl+/DijRo0iLS2NxsZGhg8fzrx58/D396e0tJT9+/ejUChISEhgxowZwLNACZ51JbUGSklJSbi4uGBpaUlmZiaurq49+n5WVFRw4MABrKysqK+vR5Ik3WXOzs68++673L17l6tXr2JkZISenh779u0jJCREt6Tr+TCytLSUyMhI0tPTsbe3Z/PmzZSUlHDlyhXq6uraLT309vZmwYIFnDt3DisrK8aNG8fKlSv57LPPuHXrFlOmTGH69OlMnTqVrKws4uLiuHr1KjKZDA8PD2pqavgk/DSHx81B4sU0QKOeHtfHzeKXI0Z0+3F6kdraWs6cOYOvry/+/v59dlxBEAahpKSBrkAYasRzShCEQUgESoLwFTk5OURERDB27FgmTpw40OW8chqNhjNnzvDgwQMmT57M7Nmz+yVtd3V1xTJkPNtLGyivzUBPBprWs31J4q6ZHYoJC5jVqOKHz4VJKpWK06dPk52dDTwLKubOnYufn1+36mxoaGiz41pBQQH19fXAs3k+Dg4OFBcX4+joyPr167G0tESSJFJSUtBoNMhkMpydnVGr1ZSUlLQZ9JyVlUVBQQGbN29GJpNRUlLCvn37sLS0ZNu2bRgbG7+wPpVKxcOHD1GpVNTX15OUlMS4ceMIDg7WLQODZ7uvmZiYYGZmxsOHD5k+fToymUy3lX1jYyNmZmbU1dXx+PFjFi1aRHNzMzk5OcybN69b3yN4NpT+wIEDGBkZsWXLFj799FPUanWb68jlciZNmoSfnx/nzp0jPT0dW1tb3eBwACsrK1QqFVevXiUhIQFra2tWrVqFv78/MpmM4cOHc/XqVR48eMCUKVPa1TFu3DgqKys5f/48VlZWjBo1ismTJxMVFYWLiwsjRoxALpfj6emJp6cndXV1xMfHExcXR0VFBRlegWiQ6bqTXkSSyXncpOaWqpYp1i/fSSRJEhEREcjlchYvXvxGvoMlCG+UHr65IQgvJJ5TgtDnRIfSyxOBkiA8p7y8nCNHjuDi4sKiRYveuBeF+vp6jh49Sn5+PsuXLyc4OLjf7ut6RQ2/M3OkRfts4ZHm+daRfzzuaj09Lpra8F5yDn/xGcHtmze5fv06kiRhYGDArFmzCA0N7XR4dWvo0zo0+8mTJ1RUVADPdihzcnIiNDQUJycnnJycdJ0xOTk5HDt2jE8//ZQNGzbg4OCAUqmkvLwcAEtbOx45uPCTx0VY1WiwUOgxU2lO+vXrDB8+HA8PD12YZGVlxdatW7sMk5qamkhJSSEhIYHc3Fz09fXx8/MjMDCQ69evY2Nj0yZMgmchjq+vL48ePaK2tpb8/HxGjhzZpkMJni2xkslk+Pn5kZWVhVar7fb8pIaGBj777DO0Wi3bt2/H1NRUN+y8I1ZWVmzYsIG0tDTOnTv3j2/ls+/lZ599RmVlJcbGxixatIixY8e2+b6ZmJjg7+9PTEwMkyZN6nA3xblz56JSqTh+/Djbt29n5syZ5Obm8sUXX/Dee++1eYxNTU2ZPHkykyZNIiMnh31ZFUg9/HnWk8HuJ0/7JFBKSEjg0aNHrF+/vtPh74IgDCFiaZLQ18RzShD6nAiUXp4IlAThHxoaGjh48CBmZmasW7euy23kh6KysjIOHTpEU1MTb731Vp/Ojfmq7Pom3krMokWSunWSH1FWRWliAiHpCchkMiZOnMi0adN03TjwrAOkoqKiza5rxcXFaDQa9PT0cHBwwNPTUxceKZXKTl/0XV1deeeddzhy5Ai7d+9m2bJlKJVKClVV/CSjgM+KyqnzCkKvBWRFz0KmD/NKsbTz4r3h1hQXF+uWiHUWJmm1WrKyskhISNDNOHJ3d2fFihX4+vrqlqTV1NRw/vx5XFxcdDvatfLz8yM2NhYzMzMSEhIYOXJkmw4leLbczcPDAxMTEzIyMrCxsUGpVL7wMW9ububgwYPU1NSwY8cO3ZI1hULRrkPpeTKZDF9fX9zd3bl8+TIxMTHAs7DWwMCAefPmERgY2OFtw8LCiI+PJyMjA29v73aXy+VyVq1axb59+zh06BC7du1i9erVfPzxx5w+fZp169a1+57KZDIah9lTn1P1wq/5qzQSXK+s6fHtvqqqqorz588TFBT0Ri6hFYQ30ubNcPr0QFchDCXiOSUIwiAkAiVB4NkyryNHjtDQ0MDbb7/dJqh4E7TO62md89M64Lm/fJxXQpNWi0T3U/wYuxGskDWxeuECLC0tqaurIz09vc3StdYQRalU4uzsTGBgIE5OTtjb26NQ9OzlzsrKip07dxIREcGJEyewGDGSTxxHoXpS9mx4s0z27L/PdVZVGZvyG1ULFx5Fs6qTMKmkpISEhAQSExOpra3F1taW6dOnExgY2OFOggsWLCA3N5cTJ06wc+fONkGnq6srxsbGWFlZkZyczIIFC9p0KKlUKvLz81m5ciWSJJGZmYmvr+8Lv3a1Ws3Ro0cpLS3lrbfeatMdpaenR0tLC01NTWg0GrRaLRqNps2/m5ubSUlJITExkWcPlQxJklAoFJw8eZJ79+7h7++v25Hv+dubmZlx/vx5cnNz2x1frVbT0tKCnp4eDQ0NfPjhh1hZWaFQKEhLS+PXv/41enp6aLVa3YckSeRbKCFgUre/98+r12jb7JjXU5Ikcfr0aQwNDVmwYEGvjiEIgiAIgiD0Pblc3mFX/Msc700jAiXhjdc62+TJkyds27atW90bQ4UkSdy/f58LFy7g6enJ6tWrdYFEf9BqtdyOe8BnKtD2sANMkuuR6eTG5cuXefLkCSqVCni2VMrJyYkJEybouo+6M6uoO/T19VmxYgU2Do78y9NGKgyMux7q/I/QIcF+JLNCxujqqK2tJTExkfj4eEpLSzE2NsbX1xdfX19sbW3RarU0NzdTWlraLpzRarWEhoZy6dIljh07hp+fX5vLlUolT58+pampiZMnT+qevzExMTQ3NyOTycjMzCQxMZHq6moKCws5ePBgp2GQRqOhpqaGlpYWjIyMOHDgQJvLWyX1YDho6xDv1llVhYWFFBYW6i6Xy+W6wKZ1SPr9+/d1/9/60ZGnT5/q/t3U1ISenh4KhQJ9fX3dvxvMer9kzVD+cq3QMTExZGVlsWXLljcuqBaEN9rGjQNdgTDUiOeUIAiDkAiUhDferVu3iI+PZ+XKlf26zGuw0Wg0nDt3jtjYWCZMmMDcuXP7LVVvHWodFRVFrMwA9ejxvTrGmYpa3Csr8fT0xN7eHnt7e8zMzNqELxUVFe0CmY5Ck55cflPPmKdmdj2q9w95ZdSFH0HRUN8uDGloaCAuLo64uLgeHfPRo0c8evRI9/96enrIZDLUajUymYz09HTdVvSlpaU0NTVhZGSESqWipqYGmUyGgYEBenp6usDlq2FOfn4+LS0tuLi4YG5ujiRJusdBq9VSWFiIJEnY2NjouoY0Gg0NDQ00NjZ2Gvx0RqFQYGlpibGxMQYGBigUCh4/fsywYcPw8PDAwMAAAwMDDA0Ndf9u/SgrK+PUqVP4+/uzePFi9u7dS3NzM++++26bYLRareHAzSSae1ibHAg0f/GufJ2pqKjg0qVLhIaG4uHh0evjCILwGvrKEmVBeGniOSUIfU7MUHp5IlAS3mgpKSlERkYybdq0Tue6DEUNDQ0cO3aM3Nxcli5dqtvava9JksTjx4+JjIykuLgYLy8vwsZM4Hxxdc8PJpPRoG+oW972suRyOXp6erpQ5fn/fvXfkcN9kHVz3lMrrUzGQ6UjM2uf6jqnjIyMunV/HV0OcPToUVQqFW+99RZ6eno0NzfT2NjI559/jlKppKSkhJCQEG7evImFhQVFRUWMHDkSExMTnj59ipGREQ0NDVRVVdHc3ExTUxPNzc0dhkC5ubltHqvWUKe1S0lfXx9TU1NaWlooLS2loaEBS0tLvL29sbW1xdDQEIVCwdGjR5kyZQqBgYG6Y+Tm5nL+/Hmqq6uRy+VUV1czYcIEQkJCkMlkXLp0ibi4OGbMmIG+vn6nj/Hw4cORyWScPHkSGxsb1qxZw9/+9jfOnj3LihUrdL/ULRR6rHGw5mhxBeoeZEpaYKfTsO7f4PnbarWEh4djZmbG3Llze3UMQRBeY3/+M/RgR01BeCHxnBKEPicCpZcnAiXhjVVQUMDJkyfx9/dnxowZA13OK1NeXs7BgwdpaGhg69atuLq69sv95OfnExkZSW5uLiNGjGD79u24uLhwuKgcehMoAXJJi1wuR/uPneG6oqen166jxdDQsM3HV7tfOvpcvkaiMCGn58XKoMgniPdCPHXBTUcfXV321es1NTUhSRJ//vOf291dcXExAJGRkchkMkpKSpDJZDQ0NNDS0kJDQwPDhw/HwcGhw8fl8ePHPHz4kHHjxhESEtLmsufnNoWHh1NRUcH8+fOJiooiKysLBwcHli9fjoeHR5tfpK3LEl1cXNrMYfL29sbd3Z1r165x584d9PX1OXPmDElJSSxbtozQ0FBu375NUlISY8aM6fJhDgwMRKVSceXKFaytrVm8eDEnT57Ezc2tzS6FO52GcbCootvfPjlgra9gka1lt2/zvDt37pCfn8+OHTt0A9YFQRAEQRAEYSgRgZLwRqqqquLw4cO6E+E3JU3Oysri2LFjmJmZ8fbbb/fLvKjS0lKioqJ49OgR9vb2bNy4ES8vL91j7G7cuxlNcknCXtPS5ntlamqKjY0N1tbWmJubY25ujpGRkW4wdGtY83xo09TURHV1dbvPdxZS5VvZQmBvBjrLKGho5Ne//nWX1/pqsNP6bxMTE6ysrDpc5hUTE8PEiRN1u8EVFhZy+vRpXF1daWhoQF9fn9LSUkaPHs2yZctITk4mPz+fdevW6XZre15cXBwPHz5k6tSpzJo1q8t6NRoNT58+5aOPPsLa2ppVq1bh7+/f4c9Qa6BkZWXV7jJ9fX3mzJlDQECAboZZUVERf/nLX5g1axaenp5ER0cTHBz8wp/PqVOnUllZyalTp9i6dSvBwcGcPXsWJycnXZClKMhjQm4ad11evMuaHJDL4BN/Vwx6sQy0tLSUK1euMHHixDdqGa3wZuir35c9XR77unH98ktyh/BjNRifB4Pxb7k+/d7l5PTdsQRBAAZHh9KHH37Ib3/7W4qLiwkKCuJPf/oT48aN6/T6KpWKH/zgB5w4cYKKigpcXFz44IMPWLRo0cuU3msiUBLeOE1NTRw8eBCFQsH69et7vPvX6yomJoazZ8/i7u7OmjVr+nxAcGVlJVevXuXhw4cdBg3Nzc0kJibyIDYWC2c/qo1MdUOsu0Mrk/GjyaHMWjKD8vJySktLKSkpobS0lLy8PCorK4FnL+RKpRJ7e3vs7Ox0u7xZW1t3+iLfOieoowDqVnUDEVWaDm/3IjK5nPnz52NjY9PhDCB9ff1e/eJRq9XExMQQGhqKUqlk2LBhXLhwATMzM3JycrCzs6O5uZmAgAAAMjIysLOz6zBMSk1NJSIigpCQEGbOnNnpfdbV1XHjxg2Sk5MBWLRoEWPHjm3TvfRVVVVVAB3ebyt7e3t27txJXFwcly9fRqvVcunSJZRKJRUVFRQUFODs7Nzl4yGTyViyZAnV1dUcOXKErVu38uTJE44fP87bb79NXFwc58+fZ5OfHzNc7flVTgl6MtC0+ztfQo4MI7mcfQFuTLQy6/J+O6LRaHTD0V8UzgmCMHRtA/5roIsQhpb9++HHPx7oKgRB6ENHjhzhm9/8Jh999BHjx4/ngw8+YP78+Tx69Ag7u/bzW5ubm5k7dy52dnYcP34cJycncnNzO3zz9lV5M86kBeEftFotX3zxBVVVVezcuRMzs56fML5utFotFy5c4P79+4wbN4758+f36fDt2tparl+/TmxsLCYmJu2ChpKSEmJiYnj48CEtLS14eXmx3cGaP1W1dL1j2nNkgKOhPjOV5shlMmxtbbG1tWX06NG66zQ1NVFWVqYLmUpLS7l37x4NDQ3As44YW1tb7OzsdGGTvb09pqamyGQyFAoFCoUCU1NT4FnIVFZWhkFRKdCLwcyShHFjAxduXEZfXx97e3scHBx0H3Z2dr1+R2TBggXk5uZy4sQJduzYgZ6eHj4+PhQUFGBiYkJ1dTV6enq4uLggSRKZmZltln+1ysrK4osvvmD06NEsWrSow3qampq4c+cOd+7cQSaTMWLECKqrqwkLC3thnSqVChMTky7nIMGzQCgkJARvb28uXryo25EOICIignfeeafL4AqeLXFcu3Ytn376KUePHmXFihV8/vnn7N69m5KSEiZOnMjcuXORyWTMt7ViX2E5h4vKadT+81looVbzr14j2TRcia1B1zV35saNG5SUlPD222+/MWG1IAjthQ50AcLQExMz0BUIwpAz0B1Kv/vd73jnnXfYsWMHAB999BFnzpxhz549fO9732t3/T179lBRUcHt27d1f1/31/iS7hJ/7QpvlIsXL5KZmcmmTZs6TH2HmsbGRo4fP05WVhaLFy8mNLTv/sRtbGzk9u3b3L17Fz09PWbOnMm4ceMwMDCgpaWFxMREYmNjefLkCWZmZkyYMIGxY8diaWlJg0bL9QcZJNY08KLeH9k/Pv7PewR6XbxIGxoa4uzs3KabRZIkamtr23QzlZSUkJSUhFqtBp4tm2sNmJRKJc3NzTx9+pSsrKxnwYxCgUPYbEr0DZHo/i8JGeBTkqe7D41GQ1ZWFrGxsUiShEwmY9iwYTg4OLQJm1oDra4YGhqyevVqdu/ezbVr15g1axa+vr4kJCQQEBBAYmIiJiYmyOVyCgoKqKurw8vLq80xnjx5wuHDh3Fzc2PFihXtQka1Wk1sbCzXr1+nqamJcePGMWXKFO7fv9/t3emqqqq67E76KjMzM1atWkVwcDARERFUVlZSUlLCRx99xMqVKxk+fHiXtzcyMmLTpk188sknXLx4kWHDhlFcXExwcDDznhtk6mtmzK9GOfMjd0dyG5up12g5uvdTbNVN/Pvcb3W73q8qLCzk+vXrTJs27YW1CoIwtBUNdAHC0OPoONAVCMKQ01+BUusbo61a57c+r7m5mdjYWL7//e/rPieXy5kzZw537tzp8PinT59m4sSJ/Ou//iunTp3C1taWTZs28d3vfveFb772FxEoCW+M6Oho7t27x6JFi/D09BzocvpdRUUFhw4dora2li1btuDu7t4nx21paeH+/fvcvHkTtVrN+PHjmTx5MsbGxjx9+pSYmBgSEhJobGzEw8ODdevWMWrUqDYvcsZ6cj4P9GBdXDrJ9U3PPtnBi7lM+2wI919GuzDTxqLHtcpkMt1spee3bddqtVRUVFBSUkJ2djZ5eXnk5eXpQiZ4Fk6MGDECV1dXDCxM+V1Nz5a9yWUy/rRyMZU5vqSmpvL48WM0Gg0ODg44OztjZmZGbW0tJSUlpKWl0dLSAoC5uXmbTiYHB4cOl+s5OTkxY8YMrly5goeHBx4eHhgYGNDU9OzxbJ3bkJGRoQvbWpWWlnLw4EEcHBxYt25dm++NVqslMTGRK1euUF1dTVBQEDNmzNAFQwqFos3j1JWqqqpeteC6u7vzL//yL0RFRXHnzh3Ky8v5+9//zuTJk5kxY0aXnT+WlpasWrWKAwcOIEkSzs7OpKamMm3aNKytrdtc11Shh5+ZMQAPTAwpKqrQhX09pVarCQ8Px8HBgalTp/b49oIgDC1fH+gChKGngw05BEEYnEaMGNHm/3/yk5/w05/+tM3nnj59ikajwd7evs3n7e3tSUtL6/C4WVlZREVFsXnzZs6ePUtmZib/8i//QktLCz/5yU9eWNfPf/5z/vM//xMTk7arLxoaGvjtb3/Lj3uxrFYESsIbITMzk3PnzjF+/PhuLdV53eXk5HD06FGMjY15++23sbGxeeljajQaHjx4wPXr16mrq2Ps2LFMmzYNY2Nj0tLSiImJITc3FxMTE0JCQhg7dmyXQ7+V+npsyYrngtaAdDcfCpvVum4kLaCQQXBzLX7ZqSyY5PvS9bdqamoiOzubjIwMMjMzqa6uRqFQ4ObmhqurK0qlkoaGBl1HU2xsLNWNTViNnU6VsSmSrHvLBd8faYeLlQUuwcEEBwfT1NRERkYGaWlpJCQk0NLSwrBhw/D19WX+/PkYGhpSUlJCcXExxcXFPHjwgNraWuDZ4O6OlsxNmTKFx48fc/LkSd5//328vb1JzXxMsYWSFgNDblbW8CA7Bw8PD11opFKp+OyzzzA3N2fjxo26dllJksjIyCAyMpLS0lJ8fHzYvHlzm93ZoGeBkkqlYtSoUd391rS7n3nz5lFRUUFmZiYajYbbt2+TkpLCihUrOh12XVlZyZkzZzAwMKC5uRl7e3vq6uo4fvw4O3fu7PTdmxEjRlBYWEhpaWm7X+zdERUVRUVFBe++++6AvUMkCMLg8QWwfKCLEIaW1avh9OmBrkIQhpT+6lDKz8/HwuKfb4Z/tTupt7RaLXZ2dvztb39DT0+PkJAQCgoK+O1vf9utQOlnP/sZ77//frtAqb6+np/97GciUBKEjpSWlnLs2DE8PT3bLHsZquLi4jhz5gwuLi6sXbsWY2PjlzqeJEkkJydz5coVKioqCAgIYMaMGQDcvXuX+Ph46uvrcXV1ZfXq1fj4+HRrdkxqaip5GRn8dP16Rnl7c7OylscNTTRrtVjrK5iltEBRX8uHcTe4ceMGc+bM6XX9ZWVlugApLy8PrVaLjY0Nvr6+eHp64urq2mXNtbW1LC4s5r3Casq02s5DJUkCmQy/8iL+NdilzUWGhob4+/vj7++PWq3m8ePHpKWlER0dzY0bN7CyssLHxwdfX19mzZqFTCbTdTAVFRXpuqmio6OBZ7+wbG1tUSqVFBYW8tGxL8h09+W0mTPN+s+2qY+If4zMJYhJBjIcK2sIUsCBAwdQKBRs2bJF99zIy8vj8uXL5Ofn4+rqyq5duzodhN0aKL2ok0eSpB4veevI1KlTefToEePHjychIQGVSsWnn35KWFgYc+bMwcDAQHfdwsJCDh48iKGhIe+++y6PHz/m7NmzTJgwgfv37xMZGdnpa4C3tzf37t0jNTW1x4FSXl4ed+7cYc6cOW/EUlpBEARBEAShcxYWFm0CpY4MGzYMPT09SkpK2ny+pKQEBweHDm/j6OiIvr5+mzcvfX19KS4uprm5uc3fxR3p7O/3hISEXu/+LQIlYUirra3l4MGDWFtbs3r16j4dRj3YtO6OdffuXUJCQli4cOFLdUq0DnOOioqiuLgYLy8vVq1aRXV1NWfPnuXx48cYGRkRFBREaGgow4YN6/axm5qaOH/+PN7e3vj4PNvGfZrSnGmYt72igRWTJ0/m5s2bjBkzptudVl11Ic2fPx8vL692y5+6YmZmxsRRnlxxVbPlTCSJlnZoZDLkgATIkNAgw0zdTFBeBgEFj/lT8n2srKywt7dvMwRcqVSiUCjw9vbG29ubJUuWkJubS2pqKklJSdy9exczMzO8vb3x9fXF1dW1zXK95uZmSktLdZ1MxcXFZFkO47yjD9omkPTb/iKRZDLutsCa+MeEVRYzrbmZt3fuxNzcnJKSEqKiokhPT8fBwYHNmzfj4eHRZVCkUCiQJAmtVtvl86uurg6NRvPSu044OTkxfPhwysvL+cY3vsGlS5eIj48nOjqatLQ0VqxYgbu7O+np6Rw/fhx7e3s2btyIiYkJSqWSyspK7ty5Q3BwMHfu3MHV1bXDrqnWjqecHm7L3NzcTHh4OCNGjGDixIkv9bUKgjB0nBzoAoShZ+XKga5AEIacgRzKbWBgQEhICJGRkaxYsQJ4dj4XGRnJ17/e8cLpyZMnc/DgQbT/GAsCkJ6ejqOjY5dhUuv4DJlMxqhRo9rUqdFoqK2t5f333+927c8TgZIwZLW0tHDkyBE0Gg0bN27ss1bDwaipqYkvvviCzMxMFi5cSFhY2Eu9OObl5REZGUleXh4jR45k7dq1lJSUcPjwYWpra3F2dmbFihX4+fm9cAevjly5coXGxkYWLFjwwutOnjyZ+Ph4Ll68yMaNGzu8Tl90IXWHjYGC7c0qqorKkU2bS0pdA40aLRYKPWbZWDDHxgKteixJSUl8+eWXKBQKWlpaiIuL0y1f09PTw9bWVhcytQZNbm5uLFq0iCdPnpCamkpqaiqxsbEYGRnpwiV3d3cMDAzaDB+/WVnDTxIeo9FKHc6hAnSDz6Ot7FGOVVJaWkpUVBRJSUm6sHX06NHdes60PoZqtbrLQKmqqgrgpTuUAEJDQzl9+jSNjY0sX76c4OBgTp06RWVlJQcOHMDJyYmCggJ8fHxYtWpVm+fk3LlzqaqqIjExkREjRhAeHs7777/f7l0jPT09jIyMePr0aY9qu3Tpkm5O2VAOrAVB6JnHA12AMPQ89+aSIAh9Y6B3efvmN7/JW2+9RWhoKOPGjeODDz6grq5Ot+vbtm3bcHJy4n/+538A+NrXvsaf//xn/v3f/51vfOMbZGRk8Mtf/pJ/+7d/6/J+PvjgAyRJYufOnfzsZz9r8/e5gYEBrq6uvX5jVARKwpAkSRKnTp2iuLiY7du398lJ7WBVWVnJoUOHqK6uZtOmTS81cPz5jhU7OzumT59OYWEhx48fR19fn8DAQEJDQ3s1Y6ZVUVER9+/fZ/bs2d3qXtHX12fevHkcO3aMjIwM3W5lL+pC8vT07HXrZleUSiXFKSn8+wjbDi/X09dnzJgxGBgYcPz4cfz8/Ni6dSt1dXWUlpa22XEuJSVFN4zb2Ni4TcC08h/vRGZmZurmLunr6+Pl5YWvry9eXl7I9Q14PzkXSaLTMKkNmYwLGGB47jJOVU8xNzfH2dmZmpoacnJycHBweOESydawRq1WdxnSqlQqgJfuUALw9/fn0qVLxMTEMG/ePFxcXPjXf/1Xbt68ybVr1ygoKEBPT4/AwMB2AadMJmPFihXs37+f8vJy5HI5J06cYNu2be0CIBsbGwoKCtq869OVx48fExMTw6JFi/rluSYIwuvrP4EbA12EMLT87//CtGkDXYUgCH1o/fr1lJWV8eMf/1i3M/H58+d151p5eXlt/iYdMWIEFy5c4D/+4z8IDAzEycmJf//3f+e73/1ul/fz1ltvAeDm5sakSZN61RDQGREoCUPS1atXSU5OZt26dTg5OQ10Of0mLy+PI0eOYGhoyK5du9oNUO6uyspKrly5QmJiIpaWlvj5+VFQUMC1a9dwdHRk8eLFBAQEvHBd7ototVrOnDnDsGHDmDBhQrdv17r0KyIigrCwMLKyssjNzUWr1aJUKnVdSC4uLn36AtkRpVJJVVUVGo2myw6d0aNHU1FRQVRUFEqlkqCgINzc3HBzc9NdR5IkKisr24RM2dnZxMTE6HZps7Kyws7OjpEjR9LY2KgLovT09KjxC+apdcezjjoj02p5MnoMO83llJWVUVJSQmpqqm7QtqWlZbtd5iwtLXXvuDzfodSVqqoqDAwMMDIy6lF9HdHX1yc4OJgHDx4wc+ZM9PX1kSSJp0+fIkkS1tbWVFZWcvToUby9vVm6dCmmpqZtbr9hwwZ2796NVqslLy+Pa9euMXPmzDb3M3LkSAoKCigsLOx0hlSrxsZGTp8+jbu7O6GhoS/9NQqCIAiCIAiv1kB3KAF8/etf73SJ29WrV9t9buLEidy9e7fH9wMwffp0tFot6enplJaWotVq21w+rRehtQiUhCEnISGB69evM3v2bHx9+253sMEmPj6eL7/8khEjRrBu3bp20/q7o6amhuvXrxMbG4uhoSEODg6UlpaSkZGBv78/oaGhDB8+vM9qjouLo6CggB07dnRrvtPzXUhPnz6ltraWK1eu4OHh0a9dSF1RKpW6IOhFc6OmTJlCRUUFp0+fxsrKCheXtoO6ZTIZSqUSpVKpmyUFz8KasrKyNkFTeno6NTU1wLPlWSYmJpzSM0EmdTEkvAOSXE683AS3MaOZYPgsfNNqtZSXl7eZyxQdHU19fT2A7rnh4OCgC+yampq6vB+VStUmiHpZoaGh3Llzh6SkJHx8fDhy5AhPnjxh7dq1+Pr6kpSUxJkzZ3j06BFZWVksXboUf39/3f2bmpqyefNmdu/ejaWlJdevX8fV1bVNwOfj48OdO3d49OjRCwOl8+fP09TUxLJly/r0DxFBEIaG7wx0AcLQ85vfDHQFgiC85u7evcumTZvIzc3VvXndSiaTodFoOrll50SgJAwpeXl5fPnllwQHBzN58uSBLqdftA5ru337NmPGjGHx4sU9Hr7d0NDArVu3uHv3LjKZDCMjIxoaGtBqtcyfP5/AwMA+6Sx5Xm1tLZcvXyY4OLjTLd9bZyFlZmaSmZnZpgvJz88PlUpFdnY2S5cuxdzcvMNj9LfWweAVFRUvDJRkMhlLlixBpVJx5MgRdu3a1a3B4gqFAkdHRxwdHdt8vr6+vs2yuTJjix6FSa20QEZ9I/b/CJTkcjm2trbY2toSEBAAPPte1NbWtgmZMjIyqKioAODjjz/Gzs4OBwcH7O3tdYFT6/OmqqqqT5a7tVIqlXh6enL37l1u3bpFfX0927Zt0z2XAgIC8PLy4vz58yQkJHDixAliY2NZvXq17rliY2PDhg0b2LdvH2ZmZpw4cYL3339f183U2s2Ym5vbZS2tSxCXL18+pJfTCoLQe8sBcfov9KlTp+C5N58EQXh5g6FD6VV6//33CQ0N5cyZMzg6OvZJvSJQEoaMiooKDh8+zIgRI1iyZMmg/4HujebmZk6cOEF6ejrz5s1jwoQJPfo6W1pauHv3Ljdv3tTN7pHL5Xh5eREaGoqzs3O/PW6XLl1CLpczd+7cNp9/vgvp8ePHVFVVdToLqaGhgT//+c9tdkN41czNzVEoFLpg5UX09PRYt24de/bs4eDBg+zatatX3WQAJiYmuLq64urqCsA3riWAVur6Rp1IfJSOo60VVlZWWFpathtYLpPJMDc3x9zcXDe3CiA/P589e/YwYcIEGhoaKCkpITExUfeOhpWVFQ4ODhQUFODo6EhVVRUWFhZ98rzy8PDgwoULmJubdxjOGRkZsWLFCkJDQzl+/Di5ubn84Q9/YP78+YSGhiKTyRg5ciQrV67kiy++QF9fn/DwcDZt2oRMJkNPTw9jY+MuB3PX1dURERGBt7c3QUFBL/01CYIwNA3Nt7SEAXXr1kBXIAhDjkwm69NNVQb7+WdGRgbHjx9/qZm7XyUCJWFIaGho4ODBgxgbG7Nu3boed+y8Dqqqqjh06BCVlZVs2LChw63PO6PRaLh37x7Xrl2jubkZeLZ9ZFhYGEFBQb0OOLorOzubhw8fsmzZMoyNjSktLe2wC8nb2xsvL69OZyEZGxsza9YsIiIiCAkJYcSIEf1ad0dal6l1N1CCZ3Vv2rSJTz75hCNHjrB169aX3nEOwFxPj0Zt17OMOpNw5zal1f/8GszNzbGy+mfA1PrvrwZOrc+VUaNG6ZbwaTSadkvm6urqyMzM5IMPPsDIyKjdXKZhw4b16Oc0IyODyMhI9PT0GDFiRJedXs7OznzjG9/g5s2bXL9+nbNnzxIbG8v69euxtrbG398flUpFZGQkmZmZ3L59W9fROGzYMPLz81Gr1e2+R5IkcebMGbRa7ZANrQVB6BuVA12AMPRYWw90BYIgvObGjx9PZmamCJQE4XkajYZjx45RX1/Prl27XrhL1esoPz+fI0eOoK+vz65du7Czs+vW7bRaLTdu3OD27ds0Nzcjk8nw8vJi4sSJuLq6vpITYrVaTUREBMOGDdMN+m7tQnJ1dWXevHl4eXl1exbSmDFjiI2N5dy5c7z99tsDslV7TwMleBbgtS63+vLLL1mxYsVLP/7zhllwuKiCnq52tlTo8X9ff5/m2lpUKlWbj6qqKvLy8qiurm6zttrMzAwrKyvd8rDWQd6tgVPrDnWBgYE0Njby61//moULF2JlZUVRURElJSU8evRIN0RQT09Pt6Pd80FTRzvHxcXFERERgZeXF8OHD+fGjRvU19d3GYTq6ekxffp0goKCOHbsGIWFhfzpT39i2rRpTJ8+ncmTJ1NZWUlcXByRkZG4uLjg7OzMyJEjSS0t48uMHGwd7LHRV+BjaoRMJiMpKYnU1FTWrFmDmZlZDx91QRDeJNsHugBh6Nm3b6ArEIQh501Y8vbw4UPdv7/xjW/wrW99i+LiYgICAtq9gR8YGNjj44tASXittXYM5ObmsnXr1m7Np3ndPHz4kNOnT+Pk5MS6deva7F7VmcbGRiIjI4mPj9d1WowfP54pU6a8khPh1h24MjIyiI6O1m0hr9VqX9iF9CJyuZwFCxbw6aefEh8fz9ixY/u4+hdTKpWkpKT0+HYjRoxgxYoVfPHFFyiVSqZPn/5SdWx3GsbnRT0LtvSArcNtMNXXx9TaGutO3vHUaDRUV1e3C5vKy8sBuH//Pvfu3dNdvzVwsrKy0n1fNRoNSqUSNzc33ecaGxspKSnRdTJ9dcmctbW1Llyyt7cnKyuL+/fvExoaysKFC2lsbOTGjRs8ePCgW3PSrKysePvtt0lMTCQiIoJr166RkJDAhg0bWLRokW4u15GjRxm1YSt/N3Pk/vj5HCiuheJaANyNDdk8zJzy8xfw9/dn9OjRPXrMBUF485wEVg50EcLQsmIFhIcPdBWCILxmgoODkclkbd4o3rlzp+7frZeJodzCG+nOnTs8ePCA5cuX6+bKDBWSJBEVFcXNmzcJCgpiyZIlL1wmVVRUxNWrV8nIyECSJN0SsZ7OWuqN5uZmsrKydEvZqqqq0NPTQ6PR4ObmxpIlS/psR7aRI0cSGBhIZGQkfn5+fT5A/EWUSiVVVVVoNJoeL6/09/enoqKCK1euYG1t3at3AuBZOFcRF81wVTNFljbdGs4tAxRyGW85dT1MHJ51+Fh3EDg1NTXxq1/9ipUrVzJixIh2HU4qlYqysjIALl68yMWLF4G2gVPrkrrRo0czefJkzMzMqKqqarNk7s6dOzQ2NgKgr69PeXk5ly9fxsHBAQ8PD6Kjo5k4cWK3OtRkMhmBgYF4e3tz6tQpUlNT+eijjwgNDWXNmjV89OleDtm5kfeogI6+m9kNTfxXXiPmgVM4GSYGogqC8GKvvndWGPK+sr23IAgv703oUMrOzu7X44tASXhtpaWlcenSJaZMmUJwcPBAl9OnmpubCQ8PJzU1lTlz5jBp0qROX6Cam5tJTk7mzp07uhN5MzMz5s6dS0BAQL+9sD3fhdTRLCRPT0/u3LlDRUUFGzZswMDAoE/vf86cOaSmpnL16lUWLFjQp8d+EaVSiSRJVFZWvnCnt45MnTqViooKTp8+jaWlpW4WUXdVVFRw8uRJCgoKmKfQ58KUhZRq6HLpm0ySkMngk9FujDDq/feiNdTUaDS6gOir7t+/z4ULF/j6179OVVVVmw4nlUrFkydPqKqqavNOiampqe549vb2VFdX09TURGBgIBYWFpSVlZGamsqdO3d0t/nwww9xcXFp09HU0ZK5VoaGhqxbt468vDyOHj1KTEwMiampXJ84l/ymZ3+od/QYSgAyGfUGRqxLyedCqMlLPYaCIAx9Zwe6AGHoWbRooCsQhCHnTQiUenqe0VMiUBJeS0VFRZw4cQI/Pz9mzZo10OX0qerqag4dOkR5eTnr16/Hp5MtYktLS4mNjSU+Pl43aLu/g6SOupA6m4WUnJxMdnZ2v4RJ8GyI9LRp04iKimLs2LHdnivVF1qXVlZUVPQqUJLJZCxdupSqqiqOHDnC22+/3a3uLUmSePDgAefPn8fMzIyAgADS09O5EObL+2l53FbVIZO0bbqV5JKEVibDVNKwMv8Rc2YE97je58nlcmQyGWp158PAVSoVlpaWHXY4tdJqtW2W1LWGTU+fPiU1NRXtP96JTUhIAP4ZODk4OKCnp8fjx49paGggPz+f+Ph4XTilVCrbDQA3MzNr8/MwcuRIvvnNb3L58mX+lldCXJMWuvHzogGq1Bq+nZbP4WCP7j5kgjCkPB8EDxZ99fuuL7+2B312pKGtL/9WGYzPzT41ZsxAV9CO+P4Jwuvl9OnTHX5eJpNhZGSEp6cnbm5uPTqmCJSE105r4GJra9sng40Hk4KCAg4fPoxcLmfnzp04ODi0uVytVpOSkkJsbCx5eXkoFArUajWmpqbMnDmT4ODgPt3h7qtdSHl5ebq5OK1dSK6uru1mITU1NXH+/Hl8fHzw9vbus3q+asKECbqAZevWra/suWBubo5CoejxYO7n6enpsW7dOnbv3s3BgwdfOFC+dbv6tLQ0xowZw7x58/j444/x8/PDztiQQ34j+d5Hn1AcGEqivim1Gg0Gcjme+nKGxd5mi68Hd3IyKSkpafe86gmZTKZ73nWmqqqqw86l58nl8nYdTsXFxRw8eBBzc3M2btyIkZFRh0PDVSoVTU1NSJJEQ0MDAEZGRrqlj0+ePCE9PV1Xo7GxMY6Ojm1CJhsbG+bOncv/dzsJmrq/U55GgmuVNeQ0NOFq3Hk3lCAIb7YfAMsHughhaPnFL6CTk0FBEHrnTehQel7rufNXA9zn5yhNmTKF8PDwTt8U/ioRKAmvlebmZg4dOoRMJmPjxo29Guo8WCUlJXHq1CkcHBxYv359m+HZ5eXlum6khoYGLC0tkcvlKBQKZs6cSVhYWJ89Fs3NzWRnZ+tCpOe7kObOndutHdmioqJoamrq96VoCoWC+fPnc+jQIdLS0vD19e3X+2slk8l6tdPbVxkbG7Np0yY++eQTjhw5wtatWzsMBDMyMjh16hRarVbXtfbkyRNUKhX+/v7As+Ht1lXl/CzEFwsLiza3/yTpDqWFhZiamhIfH//S35fuBEq2trY9Oubjx485evQoNjY2bNq0Sff872xJYFNTE7///e/x9PTEy8urXeCkfW7WRENDA7m5ueTm5uqGDcrlcqqcXHniFtCt7qTnyYH9BeX82HN4j24nCIIgCIIgCAPl0qVL/OAHP+AXv/gF48aNA56NqvjRj37ED3/4QywtLXnvvff4z//8T3bv3t2tY4pASXhtaLVaTpw4QUVFBTt37hwy23ZLksS1a9e4du0aAQEBLFu2DIVCgUajIS0tjdjYWLKzszE2NsbW1paioiLq6+uZPHkykyZNeumB1L3tQupMYWEh0dHRzJkzB0tLy5eqrTtGjRqFl5cXFy5cwNPT85WFjH0RKLUeZ8OGDezfv58vv/yS5cuX697daGlp4eLFi8TExODp6cmyZcswNzcHIDExEXNzc1xcXJAkiZiYGLy9vduFSQAhISGcPn2a4OBgkpKSmDt37kt1sr0oUFKpVHh6enb7eA8ePCAiIgIPDw/WrFnTrSWShoaGjBkzhoSEBJYvX97u+67VaqmtrW3X4VRRUUFFRQW1tbVkaWXIJAmph4GSBkisre/RbQRBeLP8eKALEIaen/98oCsQhCHnTetQ+vd//3f+9re/MWnSJN3nZs+ejZGREe+++y7Jycl88MEHbXaBexERKAmvjcuXL5Oens7GjRuxt7cf6HL6REtLC6dOnSI5OZlZs2YxZcoUVCoVcXFxPHjwgLq6OkaMGEFgYCCZmZk8efKE0NBQpk6d+lKBWl90IXVEq9Vy5swZbG1tGT9+fK/r66n58+fzl7/8hdu3bzN9+vRXcp9KpZLU1NQ+OdbIkSNZvnw5J06cQKlUMm3aNAoLCzlx4gRVVVUsWrSI0NBQ3S8prVZLcnIyAQEByOVy8vPzKS0tZd68eR0ef/To0Vy4cAF4tnTu8ePHjBo1qtf1dhUoqdVq6urqXrjkDdqGqWPHjmXx4sXd2rWtVVhYGHfv3iU5ObndYH65XI6FhQUWFhaMHDmy3W21Wi2/ycjnXmFll8PMO1OnEbvtCILQuRlAwkAXIQwtV6/CENuERhAG2psWKD1+/LjDN58tLCzIysoCwMvLi6dPn3b7mCJQEl4LsbGx3LlzhwULFuDl5TXQ5fSJmpoaDh8+TFlZGWvWrEGhUHDw4EEyMzMxNDTU7W4VGxtLfn4+QUFBzJgxo1sn6l/V111InYmJiaGwsJCdO3f26SynF7GxsWHChAncvHmToKCgXj1GPaVUKlGpVGg0mj75WgMCAqioqODKlSuUlJSQlpaGvb097733XrvB39nZ2dTV1REQEAA8e9ytra1xd3fv8NgGBgYEBgaSkpKCnZ0dCQkJ/RYoVVVVAbywO02j0RAREUF8fLwuTO3pL2GlUomnpyfR0dE93ulRLpdjZ2qClsoe3Q5ABlgrXt3zWxi6rl+/zm9/+1tiY2MpKiri5MmTrFixQne5JEn85Cc/4e9//zsqlYrJkyfz17/+dcj8HhzKZgF/GOgihKElKgr+3/8b6CoEQXiNhYSE8O1vf5v9+/frxlOUlZXxne98h7CwMODZqI0RI0Z0+5giUBIGvaysLM6cOUNYWNgr7XrpT0VFRRw6dAitVktgYCAXLlygpqYGJycnli1bhoGBAdevX6e0tBQfHx82btzY413MXtSF5OnpqdutrC/U1tbqdlzryYtQX5k2bRoPHz7k0qVLrF27tt/vT6lUIkkSlZWVvdrprSMBAQHcv3+flJQUAgMDWbZsWYdhVVJSEkqlEkdHR+rr60lOTmbmzJldBjKhoaFER0fj4eFBcnIyDQ0NXQ4B70pXgZJKpQLoMtRramri6NGj5OTksHLlSgIDA3tVBzz7ug4fPkxBQQFOTk49uu00pTm93VNmpk37d3cEoafq6uoICgpi586drFq1qt3lv/nNb/jjH//Ivn37cHNz40c/+hHz588nJSXlpZc7C/2rYaALEIaeXv7OFgShc29ah9Lu3btZvnw5zs7OuvO1/Px83N3dOXXqFPDsnO6HP/xht48pAiVhUCsrK+Po0aN4eHj0+4DnVyU5OZkTJ05gYGBAU1MTDx8+JDAwkJCQEJqbm4mMjCQ/Px9XV1d27dqFs7Nzt47b2oWUmZlJRkaGrgvJ2tq6T7uQOnPhwgX09PSYM2dOvxz/RQwNDZk7dy4nT54kOzu7x1te9lTrksCKioqXDpQkSSIhIYFz585hbGyMvb29LgT86tJDtVpNamoq48ePRyaTER8fD/DCDh07OztGjBihG1idnJxMaGhor+rtTodSR+208GyXxoMHD6JSqdiyZctLf5+8vLywtLQkOjq6x4GSp4kRk63MuKuq7dGyNwO5jHUOPV8SKghftXDhQhYuXNjhZZIk8cEHH/DDH/6Q5cuf7Re2f/9+7O3tCQ8PZ8OGDa+yVKGHxHdH6HNHjgx0BYIgvOa8vb1JSUnh4sWLpKen6z43d+5c3diJ5zulu0MESsKgVVdXx8GDB7G0tGTNmjU9mq0yGNXU1BAeHq5bn2phYUFYWJhuqVNUVBSZmZk4OjqyZcsW3N3dX5hyv+oupM48fvyYpKQkli9f3uuul74QEBBAdHQ058+f57333uvX54yFhQUKheKlB3PX19cTERFBamoqwcHBLFiwAI1Gw+7duzl48CC7du1q85hmZGTQ1NREQEAAkiQRGxuLn58fpqamL7yvkJAQwsPDGTlyJA8fPuyXQEmlUmFubt5hZ1VJSQkHDx4EYOfOnT3uuuuIXC4nNDSUq1evMm/ePExMTHp0+38dacctVW337w/YNtwGC7HkTehn2dnZFBcXtwnpLS0tGT9+PHfu3Ok0UGpqaqKpqUn3/9XV1f1eq9DeYUSoJPSx9etFqCQIfexN61CCZ387L1iwoM+aNUSgJAxKarWaI0eO0NLSwltvvYWhoeFAl9QrkiSRk5NDdHQ0aWlpSJKEvb09ixcvxtnZmYqKCr788kuSk5OxsbFh7dq1+Pr6dvpi9HwXUmZmpm4bdGtra91uZ/3ZhdQRtVrN2bNncXFxISgo6JXdb0dkMhkLFy7k73//OzExMbrtMPvrvl52p7fMzExOnTqFRqNh7dq1+Pn56S7btGkTu3fv5ujRo2zZskUX0CQlJeHo6MiwYcPIysqioqJC173wIn5+fpw/fx4jIyPS09MpLy/vVeCor6/fZYdSR8vdsrOzOXLkCNbW1mzatEm3W11fGDNmDFevXuXBgwdMnjy5R7c1epTEuJxc7rv6vvC6cmC8lSk/9Bjey0oFofuKi4sB2m1CYW9vr7usI//zP//Dz372s36tTXgxsThJ6HMNYiGlIPS1NyFQ+uMf/8i7776LkZERf/zjH7u87r/927/1+PgiUBIGHUmSOH36NEVFRbz11luvZMByb6mbm2luqEdhaIi+oZHuRaS+vp6EhARiY2MpLy9HoVAgk8lYsmQJY8eOpbq6moiICB48eIC5uTlLly4lODi4w46ajrqQ9PT0cHNze6VdSJ25efMmKpWKDRs2DIoX0eHDhzN27FiuXLmCv79/jztWeqK3gVJLSwuXL1/m/v37eHh4sHz58nYBi42NDevXr+fAgQNERESwbNkympubefToEbNmzQKeDeO2tbXt9swqfX19goKCePjwIQYGBjx8+JCZM2f2uH6FQtGmA+J5VVVV7QZyJyQkcPr0adzc3Fi7dm2fB8SmpqaMHj2amJgYJk2a1K3noSRJREZGcuvWLf7f1KlkeQ7n54+LaJGeTVV6fraSHqABlttZ8TufkRi+5t2SwsuLi4tDX19fNxj/1KlTfPrpp/j5+fHTn/4UAwODAavt+9//Pt/85jd1/19dXT0gc+3edFEDXYAw9Pzjd78gCEJP/P73v2fz5s0YGRnx+9//vtPryWQyESgJQ8P169dJTExkzZo13Z4f9CqpW1rIuH+bB+e+pCgjTfd5Szt7XCdMRaUwIi0jEwA3NzcaGhqQyWRs3LgRa2trLl26xP3799HX12fu3LmEhYWhUPzzR3EwdiF1pry8nJs3bzJp0iTdTgGDwaxZs0hOTiYqKoolS5b02/0olUpSU1N7dJuioiJOnDiBSqViwYIFjBs3rtMAxMXFhWXLlnHy5EmUSiXm5uZoNBr8/f2pqakhLS2NBQsW9CjICw0N5d69e7i6uvLw4UNmzJjR4yBQoVBQV1fX4WUqlUr3cytJEjdu3ODKlSsEBwezZMmSftv9LywsjIcPH5KZmfnCHbC0Wq0u0J03bx4TJ05kFrDGQcnR4gr2F5aT39hMi0aLYUsTy2ws+Dc/dzxMxBBk4Zn33nuP733vewQEBJCVlcWGDRtYuXIlx44do76+ng8++OCl78PBwQF4tlTU0dFR9/mSkpIuZ6YZGhq+tl29Q8nVgS5AGHpmzBjoCgRhyJHL5X06ImMwjmjJzs7u8N99RQRKwqCSmJjI1atXmTlzJqNHjx7octopzcnixK9+Sl1lBTJZ2xeMqtIS4k8fRyaXE7hgOSODQjh79iw2NjasXr2alJQUbt++jSRJTJo0iUmTJun+6G/tQmoNkVQqFXp6eri6ujJnzhy8vLwGtAupI5IkcfbsWczNzZk2bdpAl9OGqakpM2fO5Pz584SEhLQ5GetLSqUSlUqFRqN5YVCi1Wq5ffs2V65cwc7OjnfffbdbIVxgYKBuxpa9vT0uLi5YWFhw7do1FApFj3dIGzZsGC4uLjQ2NqJSqcjNzcXV1bVHx9DT0+twyZtWq6W6uhorK6s2oc2MGTOYNm1av3awOTk54ejoSHR0dJeBklqt5sSJE6SlpbF8+fI2J+ZW+greHWHHuyOezXbKyclh3759TJw4EQ8Tv06OKLyJ0tPTdc+dY8eOMW3aNA4ePMitW7fYsGFDnwRKbm5uODg4EBkZqbuv6upq7t27x9e+9rWXPr7Qv34OdG8xsiB0049/DKdPD3QVgiAMAa3nnh4eHm0aG3pDBErCoJGfn8+pU6cIDAxk6tSpA11OO2V5ORz+yXdQNzcDIEnadteRPbuAjLMnSUx4iOf4STg7O7N3714aGxsJDQ1l6tSpmJiYdNqF5OXlNai6kDqTnJxMVlYWmzZtGpR1hoaGEhsby7lz59ixY0e/hBlKpRJJklCpVF0GfiqVipMnT5KXl8fkyZOZOXNmjzp1pk+fTmlpKampqUyaNAmtVktcXBz+/v692jo8JCSEEydOYGFhQUJCQo8Dpc6GctfU1CBJEqamphw6dIisrKx2oU1/kclkhIaG8uWXX1JZWYm1tXW76zQ3N3PkyBFyc3NZv3493t7eXR5z+PBns5Ly8/P7pWbh9SVJElrts98Bly9f1nVCjhgxgqdPn3b7OLW1tWRmZur+Pzs7m/j4eJRKJSNHjuT//b//x3//93/j5eWFm5sbP/rRjxg+fHiPd2ARBEEQBKG9N2GG0vPq6+v5xje+wb59+4Bnb5C5u7vzjW98AycnJ773ve/1+JgiUBIGhcrKSg4fPoyTkxNLly4ddD+MWq2G8F//HHVzM5K2fZDUhiQhAUaF2RTmOPDo0SOCgoKYNGkSFRUVXL16tdMuJKVSOei+9o40NjZy4cIFfH19X7i8aKDo6emxYMECDhw4QFJSkm7WSV9SKp9tHd/ZcGtJknj48CHnzp3DyMiI7du34+Li0uP7kclkjBgxgtTUVN3JZnV1da93afP19cXExARzc3NSUlJYtGhRj0LBzgIllUoFQFRUFNXV1WzatAkPD49e1dgbAQEBXLp0iZiYGObOndvmsvr6eg4ePEhZWRlbtmzpVohmYGCAkZFRjwIC4c0QGhrKf//3fzNnzhyuXbvGX//6V+BZIPTVIdpdiYmJaTPHrHX20VtvvcXevXv5zne+Q11dHe+++y4qlYopU6boBusLg9svBroAYej5wQ8GugJBGHLetEDp+9//PgkJCVy9erXNLm9z5szhpz/9qQiUhNdTY2Mjhw4dwtDQkPXr1790211/iIu6TPXT0m5fX8azDiaj6gr8Z8yjuLiYjz/++LXrQupMVFQUzc3NfbbdZH9xd3fH19eXS5cu4e3t3eeDci0sLFAoFB0O5m5oaCAiIoKUlBQCAwNZuHDhS50Epqam4u7uTmVlJRcuXMDBwUHXQdNTCoWC4OBgYmNjaW5uJi0trUeBW2e7vLV28jQ2NrJz584enVj3BX19fYKDg3XL7Fp/tqqrqzlw4AD19fVs3769R0sgbWxsKCgooKWl5bX8WRX6xwcffMDmzZsJDw/nBz/4AZ6engAcP36cSZMmdfs4M2bMQJKkTi+XyWT8/Oc/5+c///lL1yy8WmOA+wNdhDC0PHgA48cPdBWCILzGwsPDOXLkCBMmTGgTfo0ePZrHjx/36piD78xdeKNotVqOHz9OTU0Nu3bt6tcduXqqpaWF5ORkYmNjeXorssc/LDKgLiude4bmuLq7v3ZdSJ0pKCggOjqaefPmYWFhMdDlvNC8efP48MMPuX79OnPmzOnTY8tkMqytrdsFSllZWYSHh9PS0sKaNWteeh6YSqUiPz+fVatWYWpqyoEDB1Cr1d2a3dSZkJAQbt++jY2NDQkJCT0KlDrqUMrJyeHatWvIZDLeeeedAXtuhIaGcvfuXZKTkwkODqa8vJwDBw4AsHPnzh7PIhsxYgQFBQUUFRUxcuTI/ihZeA0FBgaSmJjY7vO//e1v+23wvPB6WQR8PNBFCEPL2bPw/vsDXYUgDClvWodSWVkZdnZ27T5fV1fX69oH3xhy4Y3ROtQ5OzubdevWMWzYsIEuCYCnT59y/vx5fve733Hq1CkMDQ3Rb+x4R6sXkWk17Nq8kS1btjBhwgRsbGwG/QtNV7RaLWfOnMHe3p7xr8m7ZFZWVkyePJm7d+9SXl7e58e3sbHRBUpqtZrz589z4MABbG1t+drXvtYnw+WTkpLQ19fH29ubrKws9PX1qaioICIiosvuhq4olUrc3NzQarVkZWVRU1PT7dt+NVBKTEzks88+w9jYGDs7uwENGm1sbPDw8CAmJoaioiL27NmDgYFBr8IkQNd5kpGR0delCq85lUrFJ598wve//33da0BKSgqlpd3vZhWGrhcsjheEnhuEu0cJgvB6CQ0N5cyZM7r/bz0v/eSTT5g4cWKvjik6lIQBc+/ePWJjY1m6dClubm4DWotarSYtLY2YmBhyc3MxMTEhJCSEsWPHYmVpye+/PNzrY2tamvuw0oEVHR1NUVERu3btGpTbYnZm8uTJxMfHc/HiRTZu3Ninx1YqlaSmplJcXMyJEyeoqKhg/vz5jB8/vs/Cw8TERLy9vdHT0+PBgweMGTOG4cOHEx4ejo2NDVOmTOnVcUNDQzl27Bh6eno8fPiQyZMnd+t2CoWClpYWJEni1q1bREZGEhQURE1NTZ8vK+yNsLAwDh8+zKeffoqdnR2bNm3qdfejs7MzAHl5eX1ZovCae/jwIbNnz8bKyoqcnBzeeecdlEolJ06cIC8vj/379w90icIAWznQBQhDT3j4QFcgCEPOm9ah9Mtf/pKFCxeSkpKCWq3mD3/4g24n8mvXrvXqmK/PGaEwpKSnp3PhwgUmTZrE2LFjB6yOiooKLl26xO9//3u++OILZDIZq1ev5j/+4z+YM2fOs+Vpcjnyl1jCYGBk3IcVD5yamhqioqIICQnRnWS/LvT19Zk3bx7p6el93mlibW1NZWUln3zyCXK5nHfffbfduuSXUVpaSmlpKf7+/qSmplJfX09oaChBQUFMmzaNyMhIkpOTe3Vsb29vTE1NsbS0JCEhodvdTgqFQtetFhkZybRp01i+fDlVVVVYWlr2qpa+1Lr7lqGhIdu2bXuppbSGhoYYGhqKwdxCG9/85jfZsWMHGRkZbWajLVq0iOvXrw9gZW8mSZL65KMv7e3DY7We8AymD6F7+vQxf+utgf5y2umrn72+/vkThO56014fp0yZQnx8PGq1moCAAC5evIidnR137twhJCSkV8cUHUrCK1dcXMzx48fx8fHp85k23aHRaEhPTyc2NpbHjx9jZGREUFAQoaGh7ZbdPX36lJSUFDC1QKqupKcvEfpGxlgPd+q74gfQhQsXUCgUzJ49e6BL6RVfX19cXV05f/487u7ufTLnpKqqipiYGODZTJVFixb1+VD5xMREjIyM8PT05MCBA7i4uGBraws8G+hbUVFBeHg4lpaWPQ769PT0GDNmDPfu3aOlpYXi4uIeDaxu7TAcO3YskiQNikApPj6e06dPY2trS0VFBWq1+qW7ppRKJUVFRajV6kG5aYDw6kVHR/Pxx+0n5Dg5OVFcXDwAFQmDjfVAFyAMPZWVA12BIAivqZ/85CfMnj2bCRMm4OHhwd///vc+O7boUBJeqZqaGg4dOsSwYcNYuXLlK01xq6qquHLlCh988AFHjx6lqamJFStW8M1vfpMFCxbowqTy8nKuX7/ORx99xIcffsitW7ewGR3U4zBJJpcTOHse+gaGff/FvGKZmZkkJyczf/58jI1fz44rmUzGggULqKys5O7duy99vMTERP76179SX18PgI+PT5+HDZIkkZSUhJ+fHxUVFeTm5hIaGqq7XCaTsXz5chwdHTl8+DAqlarH9zF27FhaWlowNDQkISHhhdevra3lxo0bAKxZs0bXYVhfX49arcbKyqrHNfSVO3fucOrUKcaMGcPWrVuBZwHTy2oN6kpKSl76WMLQYGhoSHV1dbvPp6en6wJf4c12a6ALEIaebi5LFwShZ96E7qT9+/czY8YMrKysmD17Nr/4xS+4fft2h7s295R4q1V4ZZqbmzl06BCSJLFx48ZXMmtFq9WSmZlJbGwsGRkZ6OvrExgYSGhoaJstzcvLy0lJSSE5OZmSkhLdAOTp06fj6emJXAZ/S4mnoaYaSdvNUZuSRNDcRf30lb06LS0tnD17FldX1x7tBDYY2dvbExYWxvXr1wkMDMTc3LzHx2hoaODs2bMkJSUREBDAwoUL+d3vftdup7e+UFBQgEqlIiAggJiYGExMTPD19W1zHYVCwfr169m9ezcHDx5k586dbZbgvIi1tTWenp4UFxeTmJjI3LlzO+3eevr0KZ9//jmNjY0AbXY9aw2zBqJDSZIkoqKiuHnzJlOmTGHWrFnIZDL8/PyIiYlh4sSJL/VL3svLi+joaDIzM3FyGhodh8LLWbZsGT//+c85evQo8OyP0by8PL773e+yevXqAa5OGAxODXQBwtCzfPlAVyAIwmsqOzubnJwcrly5wtWrV/n73//Oj370I0xNTZk8eTIzZ85k5syZjBs3rsfHFh1KwishSRLh4eE8ffqUjRs39upEvidqamq4fv06f/zjHzl06BA1NTUsXryYb33rWyxevBh7e3sqKiq4ceMGH3/8MX/+85+5ceMGtra2rFu3jm9/+9usXr0aX19f9PX10VPos/w/fwgyGd1d5T17179g7fj6n3zevHmTqqoqFi9ePKiT9+6aMWMGenp6REZG9vi22dnZfPTRR2RkZLBq1SpWrVqFsbEx1tbW/RIoJSYmYm5ujqOjIwkJCYwZM6bDsMfU1JRNmzZRU1PDsWPH0Gg0PbqfkJAQamtrqa+vJzMzs8Pr5OXlsWfPHvT19Vm06FlQ+vy7GlVVVQCvvEOpdZbTzZs3mTt3LrNnz9Y9T8PCwqisrOz0a+quESNGAJCbm/vS9QpDw//93/9RW1uLnZ0dDQ0NujcfzM3N+cUvfjHQ5QmDwG8GugBh6PnOdwa6AkEYct6kGUqurq7s2LGDffv2kZOTw+PHj/nDH/6AnZ0dv/zlL5k0aVKvjis6lIRXIjIyktTUVDZs2NCjGS09IUkSWVlZxMbG8ujRI/T09PD39yc0NJThw4cDz4ZwJycnk5KSQnFxMfr6+owaNYpp06bh6emJvr5+53dgZkGjqw/GeRloW5qRoN0yONk/dj6b+87XCZg1r1++zlfp6dOn3Lx5k8mTJ7ebL/W6MjY2Zvbs2URERBASEqILC7qiVquJiorizp07uLq6smLFijadODY2Nn0eKGm1WpKTkwkICCAlJYWmpqYuh+UNGzaMdevW8dlnn3HmzBmWLl3a7V9qo0aNwtzcHLVaTUJCAt7e3m0uT05O5uTJk4wYMYJ169bpBlR/NVDS19d/pUsi1Wo1J0+eJDU1lWXLljFmzJg2lzs7O+Pg4EBMTAxeXl69vh8jIyMMDAzEdvCCjqWlJZcuXeLmzZs8fPiQ2tpaxo4dOyBzAQVBEARB6J2+DoEGc6D0vNzcXK5fv861a9e4fv06LS0tTJs2rVfHEoGS0O8ePHjArVu3mDdvXrsT1b5QV1dHfHw8sbGxVFZWYmdnx/z58wkMDMTIyIiKigpu3rxJSkoKRUVFuhBp6tSpeHl5dR0i/UNNTQ2HDx/Gzt2Ljd/7/4jY+wn5MXegqVF3HSMzc4LnLSJg9gIshr3+MzQkSeLs2bNYWloyderUgS6nT40ZM4bY2FjOnTvHO++80+WLf0lJCSdOnKC8vJy5c+d2uHzK2tqatLS0Pq0xOzuburo6AgICOHPmDJ6enlhbdz3m1c3NjaVLl3Lq1ClsbGyY3M15C3K5nDFjxnDr1i0ePXpEQ0MDxsbGSJLEnTt3uHTpEgEBASxbtgyFQqGbFdXS0qI7hkqlwtLS8pX9Im1ububIkSPk5uaybt06fHx82l1HJpMRFhbGl19+SWVl5Qsfv64olUpKSkrQarXI5aK5V3hmypQpTJkyZaDLEAah/x3oAoSh5z//c6ArEAThNZWXl8fVq1d1S96ePn3KpEmTmD59Ou+88w7jxo3r9TgaESgJ/So7O1vXCTJhwoQ+O64kSeTl5RETE0NqaioAo0ePZuXKlTg7O6NSqYiJiWkTInl5eTFlyhQ8PT179AOjVqt1czLWr1+PiZkZpTIDPFdtYfa0KTTX16NvaISptRK9IbQDVGJiItnZ2WzevLlbodvrRC6Xs2DBAj799FMePHigGyz9PEmSuHv3LpGRkdjY2PDOO++0mbv1PBsbG1QqFRqNpk92jwNISkpCqVQiSRKFhYVs2LChW7cLDg6moqKCy5cvY21tjZ+fX7duN3bsWG7cuIEkSSQnJzN27FguXLjA/fv3mTx5cpulZK2B0lc7lF7Vcrf6+noOHjxIWVkZmzdvxs3NrdPrtm6JGhsb+1LdI8OHD6e4uJiysrJOnwfC0PbHP/6x29f9t3/7t36sRHgdeAA3BroIYWh5/Bh62UEgCELH3pQOJVdXV0aOHMnXvvY1vva1rxESEtJn5yxD5+xXGHSePn3K0aNHcXV1ZeHChX3yA9bQ0EBCQgKxsbE8ffoUGxsbZs+eTVBQEE1NTaSkpHDu3DmKiopQKBSMGjWKyZMn4+Xl1avUVZIkzpw5Q1FRETt27MDc3JzCwkIqKipYtGgR5sphoHzpL2vQaWho4OLFi/j5+eHp6TnQ5fSLkSNHEhgYSGRkJH5+fm0GWVdXVxMeHk52djYTJkxg9uzZXe7g1hr8qFQqbGxsXro2tVpNamoqEyZMIDY2FgsLix4t2Zo5cyYVFRWcPHkSS0vLbg2StrS0xMvLi9zcXB48eMDjx4959OgRixcvbrOzHHQeKL2KgdXV1dV89tln1NXV8dZbb+mWs3ZGX1+f4OBg4uLimDFjRq934vPy8iIuLo6MjAwRKL2hfv/737f5/7KyMurr63VBqkqlwsTEBDs7OxEoCawE9g50EcLQcvIk7Ngx0FUIgvAaWrduHdeuXePXv/41t27dYvr06cycOZMxY8a89Dm6CJSEftHaQWBmZsbatWtfKgGVJImCggJiY2NJSkpCq9Xi6+vLokWLsLKyIiUlhc8//5zCwkIUCgVeXl4vFSI97969e8THx7Ny5UrdyXJycjImJiZddkW87iIjI2lpaWH+/PkDXUq/mjNnDqmpqVy9epUFCxYAzzqDzpw5g76+Plu3bsXd3f2Fx1Eqn6WK5eXlfRIoZWRk0NTUhJeXF/v27WPy5Mk9WmYlk8lYsWIF+/bt49ChQ7z99tvd6h4KCQkhPT2dwsJCSktL2bBhA6NGjWp3vdaOtecDJZVK1e1uqN4qLy/nwIEDSJLEjh07uj3XKywsjHv37pGcnExQUFCv7tvFxQWAnJwcscTpDZWdna3798GDB/nLX/7C7t27dUu5Hz16xDvvvMN77703UCUKgiAIgtADcrm8T0cZDNaxCIcPHwYgLS1Nt+ztt7/9LY2NjUyZMoXp06czY8YMwsLCenxsESgJfa51iVhTUxNvv/12j7Ywf15TUxOJiYnExMRQUlKClZUV06dPx83NjdzcXC5fvtwmRJo4cSKjRo166RCp1ePHj7l48SKTJk0iMDAQQLccyM/Pb9C+YLysJ0+eEBsby4IFC7CwsBjocvqVubk506ZNIyoqCn9/f6Kjo3n48CGjR49m8eLF3R4wbWFhgUKh6LPB3ImJiTg6OlJQUIBare5wSd6LKBQKNmzYwCeffMLBgwfZuXPnC38Wra2tkclkSJKEv79/h2FS67Hhn4FSU1MTjY2N/brkraioiM8//xxjY2O2bNnSZij6i9jY2ODu7k50dHSvAyVjY2P09fXFYG4BgB/96EccP368zVxAb29vfv/737NmzRo2b948gNUJg8HqgS5AGHq++GKgKxCEIedNWfLWysfHBx8fH772ta8BkJKSwsGDB/nv//5vvv/977d5s7i7RKAk9ClJkoiIiODJkyds27atV0Nwi4qKiImJITExEbVajbe3NxMnTqS2tpbU1FQiIyP7LURqVV5ezvHjx/Hw8GD27Nm6zz958oSqqir8/f379P4Gi9Yt2B0dHXuVUL+OJkyYwP3799m7dy8KhYKVK1cSEBDQo18IMpkMa2vrPgmUmpqaSE9PZ+bMmcTExODj44O5uXmvjmVqasqmTZvYvXs3x48fZ+PGjZ12C+bn53Po0CGMjIxobGwkKysLSZI6fBy+GihVVVUB9Cjk6Ync3FwOHTqEjY0NmzdvxsTEpMfHCAsL48iRIxQWFr5wmVxnrK2tKSsr6/RxEd4cRUVFHf7RpdFoKCkpGYCKhMHmz8D7A12EMLR8/evw8ccDXYUgCK+5kpISrl69qhvSnZ6ejqGhYa83YRKBktCnbt68SUJCAqtWrWLkyJHdvl1zczPJycnExMRQWFiIhYUFISEhGBgY8PjxY8LDw9HT08PLy4tVq1YxatQoDA0N++VraGxs5PDhw5iamrJ69eo2nUhJSUmYm5v36Gt7ndy/f5/i4mLefvvtIduB9Ty1Ws2VK1eoqakBYMGCBbputJ6ysbHpk0ApNTUVjUaDUqmkrKxMtxSvt2xtbVm/fj2fffYZ586dY/Hixe3CkNTUVE6cOMHw4cNZvHgxH330EdXV1eTk5HS4tLM1lGo9oVapVAD90qH06NEjjh8/zogRI1i/fn2vf+5HjRqFhYUF0dHRLF++vFfHGD58OKWlpZSXl3d7uZ0wNM2ePZv33nuPTz75RNdBGBsby9e+9rWXGv4uDB2OA12AMPQUFQ10BYIw5LwpHUpHjx7VhUiPHj1CX1+fsLAw1q1bx8yZM5k0aVKv/8YWgZLQZ5KTk4mKimL69OkEBAR06zalpaXExsaSkJBAU1MTrq6uBAcHU1ZWxt27d19ZiNRKq9Vy4sQJampqeOedd9osEdJqtaSkpODv7z9oXyxeRnV1NVeuXCE0NPSVDFceaKWlpZw8eZLS0lLmzJlDTk4Ot27dIigoqFe72llbW5OWlvbSdSUlJeHi4kJqaipKpbJPZnW5ubmxZMkSTp8+jVKpZNKkSbrL7t27x/nz5xk9ejQrVqxAoVDg7e1NRkYGCQkJHd6/TCZDT0+vTYeSXC7HzMzspWt9XkJCAqdOncLHx4dVq1b1eqA2PFvTHhoayvXr15k3b163lzM+z9PTk/j4eDIyMkSg9Ibbs2cPb731FqGhoW1mis2fP59PPvlkgKsTBoOYgS5AGHq+skGGIAhCd23ZsoXQ0FBWrlzJzJkzmTx5cq/+Fu6ICJSEblM3N9NQU41MJsPYwgI9xT9PugsKCggPD8ff35/p06d3fRy1mpSUFGJjY8nLy8PExIThw4fT0NBATk4Oenp6eHp6vrIQ6XlRUVFkZmayadOmdsOVc3Nzqa2tZfTo0a+snlfpwoUL6Ovrt1niNxRJksS9e/e4fPkySqWSt99+G0dHR3x8fPjLX/7C7du3X/gc7oiNjQ0qlQqNRtPrIfS1tbVkZWUxZ84coqKimDVrVp+Fl2PGjKGiooJLly5hbW2Nj48PFy9e5O7du0ycOJG5c+fq7iskJIS0tDSSk5NZtGhRh0tKFQpFmw4lCwuLPu1qu3v3LhcuXGDMmDEsWbKkT449duxYrl69Snx8PBMnTuzx7VvDtZycnF7dXhg6bG1tOXv2LOnp6aSmpiKTyfDx8el07pjw5tk/0AUIQ8+2bQNdgSAMOW9Kh1JlZSWmpqb9cmwRKAldkiSJJ6lJxF88Q8a920haLQB6Cn18p84geN5iDJXDOHToEI6OjixfvrzTH6Ty8nJiY2OJj4+noaEBpVKJjY0N5eXl5OXl4enpycSJE/H29n6lIVKrxMREbt26xdy5c/H09Gx3eVJSElZWVkOyeycjI4OUlBRWrVrV6yHqr4Pq6mpOnTpFVlYW48ePZ/bs2bruAhsbGyZMmMDNmzcJCgrq8fItpVKJJEmoVKpe7/SWkpKCTCajqakJgODg4F4dpzOzZs2ioqKCEydO4OzsTE5ODgsXLmTcuHFtrufh4YGFhQXV1dWkpaV1uAxQX1+/TYdSXy13kySJK1eucOPGDSZNmsScOXP67Jezqakpo0ePJjo6mgkTJvT4uCYmJigUCjEjR9AZNWoUXl5ewOD9I1IYGH8Eere4VhA68W//BqdPD3QVgiC8hvorTAIRKAldaKqv58vf/w+5Dx8gk8t1YRKARt1C8rUokq5cQs/eCYWbD+vXr2+3JEWj0ZCWlkZsbCzZ2dno6+vrAouqqio8PDyYNm0ao0aNGtAgo7CwkNOnTxMUFNRh54FGoyE1NZWxY8cOuZOGlpYWzp49i5ub25AdNg7Pwpovv/wSfX19tmzZgoeHR7vrTJs2jYcPH3Lp0iXWrl3bo+MrlUrgWXDa20ApMTERDw8PEhMTGT16dK+GT3dFJpMxb948MjMzycnJYcmSJYSEhHR4vbCwMKKiooiLi+swUHq+Q6mqqqrXX/PztFot586dIyYmhjlz5jB58uSXPuZXhYWFkZiYyOPHjzsMjl/EysqKiooKMZhbYP/+/fz2t78lIyMDeBYuffvb32br1q0DXJkgCIIgCN0hl8v7tMP+TZhB+1UiUBI61NLcxPH//iEl2ZkAbcKkVpJWA4C6pIARdrYYG/8zEKqsrCQuLo64uDjq6+t1HUdqtRpHR0dmz56Nt7f3oOiGqamp4fDhw9jb27NkyZIOTxKzs7NpaGgYkoHLjRs3qKmpYcuWLUPyBLmpqYlz586RkJCAn58fixcv7jSoMTQ0ZM6cOYSHh5Odnd2j+UUWFhYoFIpeD+aurKzkyZMnTJ48mYyMDFauXNmr43SloqKCzz//HD09PczMzLh//z7+/v4ddgQGBwcTFRVFbm4u1dXVWFhYtLn8q0ve3N3dX6o2jUbDyZMnSUlJYenSpbpBx33N2dkZe3t7oqOjexUoOTo68vTpU1QqVa92sRSGht/97nf86Ec/4utf/7ou+Lx58ybvv/8+T58+5T/+4z8GuEJhoP15oAsQhp6vf32gKxCEIedNWfLWn0SgJHTo5qH9lGRlIkntg6SvkgFPEuOJO3sacy8/7t69S05ODjKZTPcu/siRIxk9evSgCZFaqdVqjh49CtBhh1WrpKQkbGxssLe3f5Xl9buysjJu3brF1KlT+6TDZLDJzc0lPDyc+vp6VqxYQWBg4Atf6AMDA4mJieH8+fO899573X6nQSaTYW1t3etAKSkpCX19fcrKyrC3t8fZ2blXx+lMQUEBBw8exMjIiLfffhuNRsPu3bs5fvw4GzdubPd1mpmZ4e3tTVpaGgkJCe22ElUoFLS0tKBWq6mtrX2pJW/Nzc0cPXqUnJwc1q5di6+vb6+P9SKt3VcRERGoVKoe1+3p6UliYiKZmZmEhYX1T5HCoPenP/2Jv/71r2x7bqbJsmXLGD16ND/96U8HZaBkaWnZJ8eRJKlPjjPUDb3fqP1jsD6f+uqksE+/vkOH+u5Ywis3KJ9TgtAH3ryeLOGFmhsbeBh5vlth0vOuHj7A4UOHdGGSu7s7y5cv5zvf+Q6bNm0iKChoUIVJkiRx5swZioqKWL9+Pebm5h1eT61Wk5aWNuR2d2v9+q2srJgyZcpAl9OnNBoNkZGR7N27F3Nzc95//32CgoK69f2TyWQsXLiQ0tJSYmJ6tk+PjY3NSwVK7u7uZGRkEBIS0qfPtUePHrF3716USiW7du1CqVRia2vLunXryMrK4ty5cx3+gdI6Wyk2Nrbd5a0dStXV1UDvT1YbGho4cOAA+fn5bN68uV/DpFYBAQEYGhr2+PsL6DqxsrKy+ros4TVSVFTUZrfEVpMmTaJIbO0tABsHugBh6BGBkiD0udYOpb78eB1kZmZy4cIFGhoagJcLKkWgJLSTeuMq6n8MBe4JWUszDsYGLF++nG9/+9ts2bKF4ODgQRUiPe/evXvEx8ezbNmyLgdtZ2Zm0tTUNOR2d3v48CG5ubksWrTopbZjH2zKysrYvXs3t2/fZtasWWzfvr3HS5OGDx/OmDFjuHLlCvX19d2+XW87lEpKSigtLUWhUKCvr9/hzKLeun//PkeOHMHLy4tt27a1We7n7u7O4sWLiYmJ4e7du+1u6+rqirm5OVVVVe1OkhUKBRqNBpVKBdCrDqWamhr27t1LeXk527Zt69ESw5dhYGBAcHAwDx480C3b6y4zMzP09PTEYO43nKenp6679XmtP2uCIAiCIAiDTXl5OXPmzGHUqFEsWrRI9/f9rl27+Na3vtWrY4pASWin8FEKsl4MFJPp6THaZQTBwcEYGxv3Q2V95/Hjx1y8eJFJkya98OQ9OTkZe3t7bG1tX1F1/a+hoYGLFy/i7+/f4XDq15EkSdy/f5+//e1vtLS0sGvXLqZOndrr4XizZ89GkiSioqK6fRsbGxtUKhUajaZH95WUlIShoSF5eXm67pmXJUkSly5d4ty5c4wbN441a9bodrR73tixY5k0aRIXL14kLS2tzWUymYzx48cDtOvmae1QqqqqAmg3Y+lFKioq2LNnD42NjezcufOV754YGhpKfX09KSkpPb6tlZUV1dXVou38Dfazn/2MH//4xyxYsID/+q//4r/+679YsGABP/vZz/j5z38+0OUJg8DmgS5AGHo+/3ygKxCEIedN61D6j//4DxQKBXl5eW3eZF6/fj3nz5/v1TFFoCS009zY0OEQ7heRAc0N3e/mGCjl5eUcP34cDw8PZs+e3eV1m5ubefTo0ZDrTrp8+TIajYZ58+YNdCl9oqamhoMHD3Lu3DnGjBnDu+++y/Dhw1/qmKampsyYMYPY2NhuL2FRKpVIkqTr2ukOSZJISkrCycmJmpoaQkNDe1nxP6nVar744gtu377N/PnzWbBgQZfB2pw5c/D19eXEiRMUFha2uWzMmDHIZDISExPbBGWtgZJKpcLMzKxHXW7FxcXs2bMHPT09du7cybBhw3r+Rb6kYcOG4e7uTnR0dI9v6+DggEajoaamph8qE14Hq1ev5t69e9jY2BAeHk54eDjDhg3j/v37/TJQX3j9/HKgCxCGnv/v/xvoCgRhyHnTAqWLFy/y61//ut2sVi8vL3Jzc3t1TBEoCe0YGBn3qkMJwGCQdyY1NjZy+PBhTE1NWb169Qu7V9LT02lpaRlSu7vl5+cTFxfHrFmzOp0b9TpJTU3lr3/9K8XFxWzevJlFixZ12InTG2FhYdja2nY6Y+irlEol8Cy07K4nT56gUqlobGzE2dkZBweHXtcLz7rPPvvsMx49esTatWuZMGHCC28jk8lYuXIldnZ2HDp0SNd1BGBiYoKnpydqtZr09HTd55/vUOrJcrfc3Fz27t2LhYUFO3bs6LNBwb0RFhbGkydPejzzprWrLzMzsz/KEl4TISEhfP7558TGxhIbG8tnn33GmDFjBrosYZBwGegChKGnlyd7giAIrerq6jrc7bqioqLXKyREoCS0M9zbt1cdSlqNhuHe/T9Qt7e0Wi0nTpygpqaGjRs3dmu2U3JyMk5OTkNme3CtVsuZM2dwdHTsk06YgdTU1MSpU6c4evQoLi4ufO1rX+vVNvBd0dPTY8GCBeTn55OUlPTC61tYWKBQKHo0RykpKQlTU1MKCwsJCQl5mXJRqVTs2bOH0tJStm3bhp+fX7dvq6+vz4YNG9DT0+PQoUM0PTdHrXVb9OfnLLXu8lZVVdXtUCg9PZ3PPvsMR0dH3nrrLUxNTbtdX38YNWoUFhYWPe5Sag2UxGDuN49cLkdPT6/Lj6E0k07ovRf/xhCEHhpCb24KwmAhl8v7/GMwmzp1Kvv379f9v0wmQ6vV8pvf/IaZM2f26pjirx6hHd8pM7i6fzfq5p4N5ja3GYZr0Nh+qurlRUVFkZmZyaZNm7CxefGGvo2NjWRkZLxwWdzr5N69e5SWlvL2228P+he8ruTn53Py5Enq6upYtmwZwcHB/dZi6u7ujq+vL5cuXcLb2xsDA4NOryuTyXo0mFur1ZKcnIyFhQUajealllYWFhZy8OBBDAwM2LVrV7ee419lZmbGpk2b2LNnD8ePH2fjxo3I5XJGjhyJqakpeXl51NfXY2JioutQqq2t7dbywocPHxIeHo63tzerV68eFCfdcrmckJAQbty4wdy5c7s9+83CwgI9PT2xm9cb6OTJk51edufOHf74xz+i7cUbMsLQ8+eBLkAYer7+9YGuQBCE19xvfvMbZs+eTUxMDM3NzXznO98hOTmZiooKbt261atjvr5nlEK/MTA2IXD2fGSynj09xixchlyu109VvZzExERu3brFnDlzut3F8ujRo5c+yR9MqqqquHLlCmFhYS89X2igaDQaoqKi+PTTTzEzM+P999/XzfjpT/PmzaOhoYEbN2688Lo2NjbdDpSys7Opq6ujoqKC4ODgXi/VS09PZ+/evVhZWfU6TGplZ2fH2rVrefz4MefPn0eSJGQyGePGjQMgLi4O+OeSt+rq6hcuebt37x4nT54kKCiItWvXDoowqdXYsWPRarXEx8f36HYWFhZUV1f3T1HCoLV8+fJ2Hz4+Puzdu5f//d//Ze3atTx69GigyxQGgY8GugBh6Hn//YGuQBCGnDdthpK/vz/p6elMmTKF5cuXU1dXx6pVq3jw4EGvN2oaPH/VC4PKlI3byE9NojQnixf/WMhQm1lQLCnQarWDrvOlsLCQ06dPExgYyMSJE7t9u6SkJEaOHNnj3asGq/Pnz2NoaNjrdsaB9vTpU06ePElxcTEzZsxgypQpr+y5ZmVlxeTJk7l58yZjxozRzUrqiLW1dbvd0jqTlJSEmZkZtbW1vV7uFhsby5kzZxg1ahSrV6/uk/lRHh4eLF68mIiICJRKJRMmTCAsLIyrV68SHR3NlClTUCgUNDc3o9VqO13yJkkSV69e5fr160ycOJG5c+cOul+0ZmZm+Pn5ERMTw4QJE7pdn729PZWVldTW1mJmZtbPVQqDUWFhIT/5yU/Yt28f8+fPJz4+fkjN2xMEQRCEN8Fg+9u0v1laWvKDH/ygz44nAiWhQzI9BY2uPsgqKqG6Eplc3m6ukkyuh6TV4DNlOg4TpnPm3Dnq6uv77KS2L9TU1HD48GHs7e1ZunRpt18w6uvrycrKYsGCBf1c4auRnp5OWloaq1ev7tbsqMFEkiRiYmK4ePEilpaWA7LFPDybIxQfH8+FCxfYuHFjp9ezsbFBpVKh0WjQ0+u8Y6+lpYWUlBSMjIxwc3Pr8U5nkiQRFRXFzZs3CQsLe+FObj0VEhJCeXk5Fy5cwNraGm9vb0aOHElubi5lZWW6GUpAhx1KkiRx7tw5oqOjmT17NlOmTOmz2vpaWFgYn376KVlZWd1+d8bDw4O0tDSysrIIDAzs5wqFwaSqqopf/vKX/OlPfyI4OJjIyEimTp060GUJg8zfB7oAYeh5552BrkAQhNfcw4cPO/y8TCbDyMiIkSNH9ng4twiUhHYkSeLLL7+krKKS7T/9FVpVOef2fUJN7nMDaOVy/KbNJHjeYhw8vACwsLLi2LFj7N+/n40bN3Y4Qf5VUqvVHD16FEmSWL9+fY+W2aSmpiJJEr6+g3fIeHe1tLRw9uxZPDw8Xrvle7W1tZw+fZqMjAxCQkKYN29elzOM+pO+vj7z5s3j2LFjZGRk4OXl1eH1RxRSJwAAnMNJREFUlEolkiShUqm6XHqWkZFBc3Mzzc3NzJs3r0e1aDQaTp06RWJiInPnzmXixIn98u7K3Llzqays5IsvvmDHjh3MmDGDD45+wdejk8kzMafCfzL66hbUlY3sNGvCzcRQV194eDjJycksWbLkpYeN97cRI0Zgb29PdHR0twOl1u//48ePRaD0BvnNb37Dr3/9axwcHDh06BDLly8f6JKEQWpwvK0mDCn/eBNHEIS+09fL1AZ7t9Pzc2dbd7B+vmZ9fX3Wr1/Pxx9/3O0mBBEoCe3cvXuXhw8fsnLlymedIE5OtLh44zlxBjOnTuHMmbM0abQs2Lmzze28vLzYvn07Bw8eZPfu3WzZsmXAdkeTJIkzZ85QVFTEjh07MDc379Htk5OTcXNzGxJLWa5du0ZtbS3btm0b9C9yz3v06BGnT59GJpOxceNGRo0aNdAl4evri6urKxcuXMDd3b3DDqTW5XDl5eVdBkpJSUmYmJggl8vx8fHpdg2NjY0cOXKE/Px8Vq9e3a9LbGQyGatWrWLv3r387fgJ4ibM5l7YbGSSFkmSg/GzXdr2FFbw98IKZivN+T+v4USePEF2djZr1qzp0U5zA0UmkxEWFsaZM2dQqVQvnAkFz2YoyeVyCgsL+79AYdD43ve+h7GxMZ6enuzbt499+/Z1eL0TJ0684sqEwWY70PkId0Hohb17YdWqga5CEITX2MmTJ/nud7/Lt7/9bd181Pv37/N///d//OQnP0GtVvO9732PH/7wh/zv//5vt44pAiWhjaysLC5dusSkSZN077rX1NTw9OlTpk+fjsUwO2ydnDvdQn348OHs3LmTzz//nN27d7Np06YBGQB979494uPj/xmK9UBtbS05OTksWbKkn6p7dUpLS7lz5w7Tpk3rcu7PYNLc3MyFCxeIi4vD29ubpUuXDvj28q1kMhkLFizg448/5t69e0yaNKnddSwsLFAoFF0O5m5sbOTRo0fIZDImTZrU5dK451VVVfH5559TU1PD1q1bcXFx6fXX0l36+vpMWbWGJbEZNNQ0gEyG9JWB/Zp//PdqRQ0zbj5kdWExuzZtwt3dvd/r6ysBAQFcunSJ2NjYbu3sKJPJMDc3p6qq6hVUJwwWr1swLwiCIAhC5+RyeZ+OjBhss4S/6he/+AV/+MMfmD9/vu5zAQEBODs786Mf/Yj79+9jamrKt771LREoCT1XUVHBsWPHcHd3b3NClZOTA4CrqyvwbOhwVVUVarW6w2VkSqWSnTt3cujQIfbu3cu6deu6vbNaX3j8+DEXL15sE4r1REpKCjKZ7LVf7tbapWVtbc3kyZMHupxuefLkCSdPnqSmpoYlS5YwduzYQXfyZm9vT1hYGNeuXSMgIKBd95tMJsPa2rrLQCktLU23tfjYsWO7db/FxcV8/vnnKBQKdu7cia2tbe+/iB5o1mrZlVFMo74BL9oMXQNUKfS5OXke/+Xm9irK6zMGBgYEBQURFxfH9OnTu7VE1t7envT0dBoaGjA2Nn4FVQoDbe/evQNdgvCa2PniqwhCz+zZM9AVCMKQ86YteUtMTOzwDWkXFxcSExOBZ8viioqKun3MwR2hCa9MU1MThw8fxsTEhNWrV7dJV7Ozs7G1tdUt/2rtdFGpVJ0ez9TUlG3btuHq6sqhQ4d6vCV3b5WXl3P8+HE8PDy61WXQkaSkJDw8PF77E8SEhATy8vJYtGjRoNqmvSMajYarV6+yZ88ejI2Nef/99wkJCRm0L8ozZsxAT0+PyMjIDi9XKpVdBkqJiYkYGBgwatSobi2vyszM5NNPP8Xc3Jxdu3a9sjAJ4GxZFVkNTboupBeRZHIeNWm4VlHTr3X1h7CwMOrr60lJSenW9d3+EZplZ2f3Z1mCILyGvjvQBQhDz69/PdAVCILwmvPx8eFXv/oVzc3Nus+1tLTwq1/9SjeCo6CgAHt7+24fUwRKApIkER4eTlVVFRs2bGgXpOTk5Oi6k+CfgVJlZWWXxzUwMGDDhg0EBwdz6tQpbty4oRv+1R8aGxs5fPgwpqam7UKx7qqqqiI/P/+13/q5vr6eixcvEhAQMOiXHZWXl/Ppp59y/fp1pk2bxs6dOwf98jxjY2Nmz55NQkICT548aXd5V4FSbW0tWVlZNDc3d2tYdVxcHAcPHsTFxYXt27e/8rleu5+U9fgXhR6wp+Bpf5TTr4YNG4abmxvR0dHdur63tzfwLPATBEF4nvdAFyAMPY8eDXQFgjDktHYo9eXHYPbhhx8SERGBs7Mzc+bMYc6cOTg7OxMREcFf//pX4NkInH/5l3/p9jEHd9uC8Epcu3aNtLQ0NmzY0K7zQaVSUVlZqXsnHsDc3Bw9Pb0uOzBayeVylixZgoWFBVFRUVRVVbFo0aI+X1+q1Wo5ceIENTU1vP32292eSv9VycnJKBQK3Yni6+ry5ctotdoe7x72KkmSRFxcHBcuXMDc3JydO3fi7Ow80GV125gxY4iJieHcuXO8/fbbbX6B2NjYoFKp0Gg07eYjtXa/WFhYdLkUVJIkrl69yvXr1wkJCemXn5sXqWhRE11d3+PbaYDL5dU0a7UYDPK15F8VFhbG0aNHKSoqwtHRscvrWllZIZPJKCgoeEXVCYLwuhAxs9DnXuH4CEEQhqZJkyaRnZ3N559/Tnp6OgBr165l06ZNujEeW7du7dExRaD0hktNTeXatWvMnDmzwxCldSnH8x1KcrkcKyurF3YotZLJZEyfPh1zc3MiIiKora1l9erV6Ov33aa6UVFRZGZmsmnTJoYNG9br4yQnJ+Pl5YWhoWGf1faq5eXl8eDBAxYtWjRod6mrq6vj9OnTpKenM3bsWObPn4+BgcFAl9UjcrmchQsX8umnn/LgwYM2s5CUSiWSJKFSqdrt9JaQkIBMJiM0NLTTgEij0fDll1+SkJDArFmzmDJlyoC841HRou71bSWgSq3B1uD1CpS8vb2xsLAgOjqaZcuWdXnd1sHcXS3/FQThzfTfA12AMPT88IcDXYEgDDlv2gwleNYc8v777/fZ8USg9AYrLS0lPDwcX19fpk6d2uF1cnJycHR0bLcMTqlUdjtQajV27FjMzc05duwY+/fvZ+PGjZiYmPS6/laJiYncunWLuXPnvtTw74qKCgoLCzvcuet1odFoOHPmDE5OTt1aTjUQ0tPTOX36NJIksWHDhte6G2zkyJEEBAQQGRmJn5+frjOudcleRUVFm0CpsrKSwsJCZDIZY8aM6fCYjY2NHDt2jJycHFauXNmrwfJ9xeAlfym+7O0HglwuJyQkhBs3bjB37twXzlKzs7MjMzOT5ubm1y4UFd4shwATYDPwS8AFSAL+DHz0j+v8HdDn/2fvvuOjuO/E/7921btWAvUCSBTRRBO9m45Fb8aYaps4cZqTfC+53MXJ3eWc5H6Xdolt3HBs0zG9FwnRe5VAAoQqQgLUe9md3x+yFGQEqIw0q9X7+XjIWLuzM+8ZzZZ57/vz/lRPeQ/VjaX/herhW3f5JklSk2h97TVwdIQ1a6p/f//96v+/dg0CA+F//gcWLaq+b8EC8PWFv/yl+vc//Yl/Cw1lMPAQWA1s/2abO4EE4P998/vPgenAKKAAeA34muoPsAeB88C/f7Psr4ERwESgHFgArAOcgRjgEPDbb5b9HdAbqJnPdSbwGeAJnAG2Av/7zX1/BIKAed/8vgD4E+APXAE+/eY4ArwPuAE53t4weDB8+SW8+y7cuwdhYfDOO/DGG98c4G9ad9c0W/74Y/jjH+HWLejSBX7zm+rjDPDqq+DmVn2cAf72N/j0U7hyBfz94U9/qj7OAPPmQVBQ9boA/vd/YetWOHMGPD1h7dp//h1ffhl694bf/a7699/+Fg4dgpgYcHaG9eth/nwoL4eJE2HECPj1r6uX/fd/h/Pn4eBBsLaGbdtgyRIoKIBRo2D6dPj5z6uX/X//r3rI1s6d1b9v3w6rV1fHMXgwvPIK/PjH1ff98Ifw4AFs3lz9+8aN8LOfQVoahIdXP65mOMbq1VBSUn2cAT7/HP7rv+DuXejeHf7lX/55nJcvBxub6uMM8OGH1ccxNhaCg+G//7v6OAPK+vXVx+pv3/xl//pX+OILuHix+lz+299g7tzq+2bPhpAQqJkR6Q9/qN7PU6dg2TL4xz9g1iwwmWDaNOjfv/o4A/zHf8CxYxAVBQ4OsGkTLFwIpaUwfjyMHQu/+lX1srm51fHt2wd6PezYUb3+3Nzqv8vMmdXHGeCnP4XExOrjDPD11/D22/DgAb/avZsvgL9+c87+jerz/pVvfm/ua8Tn39z3JVBC9fMb4Lvf/H84kAb8DNj4zX2bgQfAD7/5/cffxGNJrxHfnPm1rxGvfvP7a8BvgC7ArW/W9c0ZSk0b9pom/28Av9fpCAPuAe9SfZz5Zj/yqT7OAG8Dq4D+wP1vjuk3zyi2AqnAO9/8/pNvYh8GZH+zvZp491B9HnzzTOaXwCRgDFD0zX5sBuyAw8Apqo8zwH9S/TecDFQBc7+J1xU4Aeyl+jgD/AHQYjqX9pBQ2rVrV4OXfdGXqfXRKS3Z1EaYrdLSUj7++GNsbGxYtWpVvRdCiqLwpz/9id69ez81dGr//v3cu3eP733ve43e9v3791m/fj0ODg68+uqrGAyGJu9HRkYGa9eupWfPnsyaNatZT+Ljx49z8uRJfvazn6laPdWaTp06xdGjR3njjTdeOFyntVVUVHDo0CEuXbpE165dmTFjhtlWUDVGQUEBf/vb3xgwYABTpkwBqp87//3f/81LL73E0KFDa5c9fvw40dHRhIWFsaDmg/+31rV+/Xry8vJYuHBhnaGmWigzmgg7eYNSU+PfJgzWVsSN7I3eDN9YX6SoqIg//elPTJw4sc7frz6nTp3iyJEjvPLKK3Tr1q2VIhSi4QoKCnBzc1NtfWp9bDTHD91qUiIjoREf4oV4oRkzVDmnLP25J9q+/Px8XF1dW3QbNe+N//jHP1QpcKhRUlLCsmXLWmUfGurbIyJ0Ot1T7+U1rwtGY0On4Xli/U0PTbRVJpOJrVu3UlZWxqJFi575rXp2djaFhYX1XtQaDAZyc3Ob9MHS39+fVatWYTKZ+PTTTxs1LeGTioqK2LhxI97e3kRGRjb7DTIuLo4ePXq02WRSXl4eMTExDB482OySSffv32fNmjVcu3aN6dOn88orr1hEMgmqeyGNHj2a8+fP8+jRI6D6RdlgMDzVZ+zKlStAdZ+eb8vKyuKTTz6htLSUlStXap5MArC30rPQ1xOrRj61rIBl/h3aZDIJwNnZmZ49e3LhwoUXvsbVVNjduXOnNUITQrQVjexBIcQLyTklhOr0er3qP+bGZDLV/hw6dIh+/fqxf/9+8vLyyMvLY//+/QwYMIADBw40af3mt8eixR0+fJikpCTmz5//3Oqg5ORkdDodQUFBT93n4eGB0WikoKCgSTF4eHiwatUq3Nzc+Pzzz0lMTGzU46uqqti0aROKorBw4UKsrZs3evPhw4c8fPiQXr16NWs9Wjpw4AD29vaMGzdO61BqmUwmYmJi+PTTT7G3t2f16tUMGjTI4r4dGzp0KO7u7uzfv782AfHtmd6ysrLIy8vDxcWlTk8yqJ5NYe3atTg5OfH666/j5eXVmuE/1zI/T4yNzBubgCV+ni9czpwNGjSInJwc7t2799zlPD090el09c72J4Rox1T8xlsIQM4pIUSz/ehHP+Ivf/kLkydPxtXVFVdXVyZPnswf//hHfvCDHzRpnZJQameuXbvG2bNnmTx58gsrIJKSkvD396+3QXVNIqqxfZSe5OTkxLJlywgODmb9+vVcu3atQY9TFIW9e/fy4MEDFi1aVNuRvjni4uKws7MjJCSk2evSQnx8PAkJCUyZMsVsGorn5OSwdu1aYmJiGDVqFCtXrmxWw3RzZm1tzZQpU0hKSiI+Ph54OqF0+fJloDr59GRC7erVq6xbt46AgACWL1+uyvmspjBnB74b2LgE1887+xJg37b7CQUFBeHl5cWFCxeeu5xOp8PZ2blZr4VCCAtU01tKCLXIOSWE6mp6KKn5Y84SExNxd3d/6nY3NzeSk5ObtE5JKLUj9+/fZ/fu3fTr14/Bgwc/d1lFUUhOTn5m0qkmofTtIT2NZWtry6JFiwgPD2fHjh2cOHHihUNMzp07x9WrV4mMjMTf379Z24fqfY2NjSUsLKzZlU5aqKioYP/+/YSGhhIWFqZ1OCiKwuXLl/nwww8pLi5mxYoVjBs3DisrK61Da1Fdu3YlNDSUgwcPEXXzAR/d0rHmQSD9/+MQY/4nmg/OPqRAsa9txq0oCjExMezcuZPw8HBeeeUVs0kGftu/hfiy4puKI90znp81w+J+FOzND4LNp8KqqXQ6HREREdy+fZv8/PznLtuxY0fKy8upqmr6rHhCCCGEEKJ1tbeEUkREBO+88w5ZWVm1t2VlZfGzn/3shfmBZ5GEUjtRWFjIpk2b8PHxYfr06S882R8+fEhJSckzE0rW1ta4urqq8q28Xq8nMjKSMWPGEBUVxb59+zCZTPUum5iYyKFDhxg2bBjh4eHN3jZAZmYmOTk59O7dW5X1tbaYmBhKSkqYOnWq5i9ixcXFbN68md27d9O7d29Wr15NYGCgpjG1Fp1Oh1+f4XySFcjKLy5zJbOCYsWW3JJKUrJLuFHuyddlvfn+5lhyi8rYvXs3x44dY+zYsURGRpp1wk2v0xGZnc7UuHMMdPxn5ZHuiX/HGFzYGN6Fn3fx1fw8VEvfvn2xtbXl4sWLz10uODgYgJSUlNYISwjRFtTMxiaEWuScEkI002effcaDBw8ICgoiNDSU0NBQgoKCuH//Pp9++mmT1tn2yjFEo1VVVbF58+ZG9RtKSkrCysqKgICAZy5T05hbDTqdjrFjx+Lq6sqePXsoKipizpw5dRpkZ2dns3XrVkJCQpgwYYIq2wWIjY3F0dHRLJogN1ZWVhZnz55lzJgxtVPVa+XOnTvs3LkTk8nEwoUL6dGjh6bxtLYzidm8uekWVUp1ldG3+w4p36RfouIfMul/DjHZKpZ5M2fSr1+/Vo608QoKCoiJOcb88HCmDe1FYkkZlwpKKDaacLHSE+HmRLCDeVZXNYetrS3h4eFcvnyZMWPGPPO1s0ePHkRHR3Pnzp02O2xWCKGyNWvgP/9T6yiEJZFzSgjVqV1VZO5fqoaGhnL9+nUOHz5c26YjLCyMCRMmNDl2SShZOEVR2LdvHw8ePGhUf5akpCQCAwOfO+OZh4cHmZmZaoUKwIABA3B2dmbr1q188cUXvPLKKzg6OlJeXs7GjRtxcnJi7ty5qnXQVxSFuLg4wsLCzLIr//PU9JLy8PBg+PDhmsVRWVnJoUOHuHjxIqGhocyYMcPs+gC1tKyCMl7/xwWMJoUX9a82KfC4XE9C4PA2kUwCOHjwIDY2NowfPx6AEEd7QhztNY6qdQwaNIjz589z69Yt+vTpU+8yHTt2RKfTkZaW1srRCSHMVgP7QgrRYHJOCSFUoNPpmDRpEpMmTVJlfW3rClo02oULF7hy5Qovv/zyc6uNnmQymUhJSXlhxY6aFUpP6tatG8uWLSMnJ4fPPvuM7Oxsvv76awoLC1m0aBH29updyKanp5Ofn98mh7tduXKFtLQ0pk2bplnvp4yMDNasWcPVq1eZNm0aixcvbnfJJIB151IprTRiauBsaAo6LqQVk5BZ2LKBqeDu3bvcvHmTyZMnq/rcays6duxI586dn9ucW6fT4ejo2OyeckIIC9JOhnuLViTnlBCq0+v1qv+Yo2nTptXpCfq73/2OvLy82t+zs7Pp2bNnk9ZtnnssVJGcnMyBAwcYMmRIoyohHjx4QHl5+QsTSh4eHpSVlVFaWtrMSJ/m7+/PqlWrMJlMrFmzhrt37zJv3jzVZwmLi4vDxcWFoKAgVdfb0kpKSjhy5Ah9+/bVZKieyWTixIkTfPrpp9ja2rJ69WoiIiLMvsyzJVQaTXx1JqXByaQaVnodX5017547VVVV7Nu3j06dOrXJpKtaBg0aRFpa2nMrMjt27EhZWRlGo7EVIxNCmK3/+R+tIxCWRs4pIVTXXppyHzx4kPLy8trf//u//7vOF6FVVVUkJCQ0ad2SULJQeXl5bNmyhU6dOjW6nC0pKQkbGxv8/Pyeu5xaM709S81QrsrKSvR6vepPUJPJRFxcHD179jTbbPKzHD58GEVRVCtVbIzc3Fw+//xzoqOjGT58OKtWrVI90deW3LifT05JRaMfZzQp7I990AIRqefkyZPk5+c3qJG/JevRowcuLi7PrVKqSUqnp6e3VlhCCHO2aJHWEQhLI+eUEBbp73//O506dcLe3p4hQ4Zw/vz5Bj1u48aN6HQ6Zs2a9cJlvz2L+otmVW+MtnUVLRqkoqKCjRs3Ymtry7x58xqdLElOTiY4OPiFs07VNIFuiWFvUD2c6uDBg/Tu3ZvOnTuzfv16rqk4fjw1NZWioqI2V3mRkpLC1atXmTBhAk5OTq22XUVRuHr1Kh9++CGFhYUsX76cl156yaxnJ2sN+SWVTX5sYZn5TjOfk5PDyZMnGT58eLtOGEJ1OfTAgQO5ceMGZWVl9S5T04S+qd/uCCGEEEKI1qV1hdKmTZt45513ePfdd7l8+TLh4eFMnjyZhw8fPvdxycnJ/PSnP2XUqFHN2X1VSELJwiiKws6dO8nJyWHRokU4Ojo26vFGo5GUlBQ6der0wmXt7e1xcHBokQqloqIiNm7ciLe3NzNnzuSVV14hPDycHTt2cOLECVWyqrGxsbi5ueHv769CxK3DaDSyd+9eAgICGDBgQKttt6SkhC1btrBz50569uzJd77znTY3TLCl2Fk3/WXUthmPbUk1zfydnZ0ZPXq01uGYhQEDBmA0Grl69Wq99/v4+ABIY24hRLUFC7SOQFgaOaeEsDh//OMfeeONN1ixYgU9e/bkww8/xNHRkc8+++yZjzEajbz66qv85je/oUuXLg3aTn3JLrVGH8gsbxbm5MmT3Lx5k/nz5+Pt7d3ox6enp1NVVdXgvjwt0Zi7qqqKTZs2oSgKCxcurG04HRkZiaurK1FRURQUFDB16tQmD1UzGo3cunWL/v37t6mhPGfOnOHx48e8+eabrRb33bt32blzJ0ajkfnz5ze5YZul6tLRGZ0OGpvj1Ougq5dzywTVTLdu3SIxMZFFixY9d6bH9sTFxYWwsDAuXrzIkCFD6n1TdnR0JDs7W6MIhRBmxddX6wiEpZFzSgjVqd33qGZdBQUFdW63s7PDzs6uzm0VFRVcunSJX/ziF7W36fV6JkyYwJkzZ565jf/4j//Ay8uLVatWceLEiQbFpSgKy5cvr42hrKyM73znO7WjXZ7sr9RY5vn1uGiS27dvExUVxejRo5t80Z+UlIS9vX3tt+0v4uHhoWpCSVEU9u7dy4MHD1i0aFGdGcN0Oh1jx44lMjKSS5cusWXLFiormzbcKCkpiZKSEnr16qVW6C0uLy+PmJgYhgwZ0uC/T3NUVlayf/9+1q1bh7e3N2+99ZYkk+rh42bP+O5eWOkb92ZkUmDpsE4tE1QzlJeXc+DAAbp370737t21DsesREREkJ2dTVJSUr33d+jQgdLSUlXHpQsh2qi//EXrCISlkXNKCNW11JC3wMBA3Nzcan/ee++9p7b9+PFjjEbjU0Ug3t7ez5wI5uTJk3z66ad8/PHHjdrPZcuW4eXlVRvPkiVL8PPzq/3dy8uLpUuXNmqdNaRCyUI8fvyYr7/+mu7duzN27Ngmryc5OZlOnTo1uPLHYDCQkqLeTFXnzp3j6tWrzJo165lD0QYMGICzszNbt27lyy+/bNLQvri4ODw9PVslMaOGmiFIDg4Ozfr7NtSDBw/Ytm0beXl5TJkyhcGDB7epSq7WtnR4J47GP3+s85N0gKuDNVP7mN/5d+zYMUpLS5kyZYrWoZidoKAgvLy8uHDhQr0lxoGBgaSmpnL//n0CAgI0iFAIIYQQQmgtLS0NV1fX2t+/XZ3UFIWFhbz22mt8/PHHje5vunbt2mZv/1mkQskClJWVsXHjRlxdXZk9e3aTL/wrKytJS0trUP+kGgaDgcLCwiZXCj0pMTGRQ4cOMWzYMMLDw5+7bLdu3Vi2bBnZ2dl89tln5OXlNXg7VVVV3Lp1i169erWZJEl8fDx37txh6tSpqrwgPYvJZOLkyZN88sknWFtb8+abb9Y7vEfUNbprB+b290fHiytTdN/853/n98PO2rwammdlZXHu3DnGjBmDu7u71uGYHZ1Ox6BBg0hISCA/P/+p+2squqQxtxCCP/1J6wiEpZFzSgjV6XQ69Hq9aj8110yurq51fuq7fuvQoQNWVlZkZWXVuT0rK6veoofExESSk5OJjIzE2toaa2trvvjiC3bt2oW1tTWJiYktc5BeQBJKbZzJZOLrr7+muLiYRYsWNSvZkJqaislkanD/JFBvprfs7Gy2bt1KSEgIEyZMaNBj/P39WblyJSaTiU8//fSZpYHflpiYSHl5eZuZ3a2iooIDBw7QtWvX2pmkWkJeXh7/+Mc/OHr0KMOGDeP111+nY8eOLbY9SzPG8T5drKob1Fs9I/9mpddhpdfxl0X9mdCz8T3OWlLNcFNPT0+GDRumdThmq2/fvtjY2HDp0qWn7qupqpTG3MIc5efnoyhKs3+0mAWntahxfGp+2LBB690RFubfQkNVee6peZ6r+pwRrU7rv/m3f+r7ss6S2draMnDgQI4ePVp7m8lkqr0W+7YePXpw48YNrl69WvszY8YMxo0bx9WrVwkMDGzN8GvJkLc2LioqisTERBYvXoynp2ez1pWUlISTk1OjkggGgwGoTih5eXk1abvl5eVs3LgRJycn5s6d26hG256enqxcuZINGzawdu1aFixYQEhIyHMfExsbi5eXV5tJlhw7doySkhKmTp3aIh/CFUXh+vXr7N+/H3t7e5YvX05wcLDq27FkZ8+e5crli/x+9nRyHAL4/HQypxPrNme2t9Ezb2AAy4Z1oqu3yzPWpJ2rV6+SlpbGsmXLsLIyr8opc2JnZ0d4eDiXL19mzJgxdY6VXq/HwcGBx48faxihEMIsnD+vdQTCwgzWOgAhLFBLNeVuqHfeeYdly5YxaNAgBg8ezJ///GeKi4tZsWIFAEuXLsXf35/33nsPe3v7pwoiakYUaFkoIQmlNuzGjRucOnWKiRMnEhoa2uz11fRPaswTwcXFBWtra3Jycpq0TZPJxLZt2ygsLOT111/H3t6+0etwdnZm2bJlbNmyhfXr1zNjxoxnDpmrqKggISGBUaNGNSne1paZmcnZs2cZN25cbfJOTaWlpezdu5e4uDj69u3L1KlTm/Q3aM9u3brFoUOHGDFiBIMGDQJgUi8fkh8Xk5BVSFmlEVcHGwYFG3CxN88Z00pKSjh8+DB9+/Zt1JDX9ioiIoILFy5w8+ZN+vTpU+c+T09P7t+/X1vJIYRop5r4JZsQz9LwTo1CiIbSOqG0cOFCHj16xK9+9SsyMzPp168fBw4cqG3UnZqa2uRZzVuLJJTaqAcPHrBr1y769OmjyvCUsrIyMjIy6N+/f6Mep9PpMBgMTR7yFh0dzZ07d3jllVca3VzsSba2tixatIg9e/awY8cOCgsLGTFixFNP6jt37lBZWdkmZnd7cgjS8OHDVV//vXv32LFjB5WVlcydO7fNDAE0J+np6Wzbto1evXrx0ksv1bmvUwcnOnVw0iiyxjly5Agmk4mJEydqHUqb0LFjRzp16sSFCxeeSigFBgaSnp7+zPHvQoh2Ys0arSMQFma11gEIIVrE22+/zdtvv13vfceOHXvuYz///HP1A2ok8053iXoVFxezadMmOnbsSGRkpCpZ1dTUVBRFaVT/pBoeHh5NSijduHGDkydPMmHCBLp27drox3+blZUVM2bMYPTo0Rw9epT9+/djMpnqLBMXF4efn19t7ydzdvnyZdLT03n55ZdVHYJUVVXFgQMH+PLLL+nQoQNvvfWWJJOaIDc3lw0bNuDr68usWbPabDVKWloaV65c4aWXXsLZ2VnrcNqMiIgI0tLSnurd1q1bN0AacwvR7s2erXUEwsJs1zoAISyQWn0Bzb1HYEuSCqU2xmg0snnzZqqqqli4cCE2NuoMoUlKSsLV1bVJw6oMBgO3b99u1GMyMjLYtWsXffv2VbUBsE6nY9y4cbi6urJ3714KCwuZM2cONjY2lJeXc/v2bcaPH6/a9lpKcXExR44coV+/fqr2M8rMzGTbtm3k5OQwefJkmcGtiUpLS1m/fj329vYsWrQIa+u2+VJqMpnYu3cvfn5+DBw4UOtw2pTu3bvj4uLChQsXiIyMrL09KCgIgJSUFK1CE0IIIYQQolVIhVIbc+DAAdLT01mwYAFubm6qrTcpKYnOnTs3KblgMBjIy8t7qhroWYqKiti4cSPe3t6qVVh928CBA1m0aBF3797lyy+/pKSkhPj4eIxGY5sY7nb48GGABs949yKKonD69Gk++eQT9Ho9b775JkOHDpVkUhNUVVWxefNmiouLWbx4MY6OjlqH1GTnz58nKyuL6dOnm/34bHNjZWXFgAEDuHHjBmVlZbW36/V67O3tefTokYbRCSE0N3Om1hEIC7NT6wCEsEB6vV71n/am/e1xG3bp0iUuXrzItGnTar8FV0NJSQlZWVlNGu4G1UPeTCYTBQUFL1y2qqqKTZs2oSgKCxcubNHKjm7durFs2TKys7NZu3YtV69eJSgoSNVEXEtITk7m2rVrTJw4ESen5vfgyc/P54svvuDw4cMMHjyY119/vckz8rV3iqKwe/du0tLSWLRoUbNnVtRSQUEB0dHRDBo0CD8/P63DaZMGDhyI0Wjk2rVrdW738PCguLhYpkEWoj3r3l3rCISFkYHUQqhPhrw1nySU2ojU1FT27dvHoEGDVB+akpycDNDk2Z1qhsm9aKa3mibTDx48YNGiRbi4tPzU6QEBAaxcuZLKykqSk5MJDAxs8W02h9FoZO/evQQGBja6QXp9bty4wQcffEBOTg5Lly5l0qRJbXZ4ljmIiYnh+vXrzJo1S9WkrhYOHTqEjY3NU83ERcO5uLjQo0cPLly4UCd55O/vj6IoZGdnaxidEEJTf/iD1hEIC/P/tA5ACCHqIQmlNiA/P5/NmzcTGBjIlClTVF9/UlISHh4eTa7ccXd3R6fTvbAx97lz57h69SqRkZH4+/s3aVtN4enpyeDBg4HqIT737t1rtW031unTp8nOzmb69OnNynCXlpby9ddfs23bNrp168Zbb73V5Ao0Ue3q1avExMQwfvz4Nt/EPDExkbi4OCZNmoS9vb3W4bRpERERZGdnk5SUVHtb928qE+Lj47UKSwghhBBCiBYnCSUzV1lZyaZNm7C2tmb+/PmqzvZVIzk5ucnVSVDdS8TNze25FUqJiYkcOnSIYcOGER4e3uRtNdXdu3fp1KkTwcHBrFu3juvXr7d6DC+Sm5vL8ePHGTp0KN7e3k1eT1JSEh9++CF37txhzpw5zJkzR5IGzZSUlMTu3bvp378/I0eO1DqcZqmqqmLfvn106tTpqSnvReMFBwfTsWNHLly4UHtbzetpTfWnEKId+t3vtI5AWJifax2AEELUQxJKZqymX8ujR49YuHChKv10vq2wsJDHjx83u3rFYDA8s0IpJyeHrVu3EhISolqT6cYoKioiOTmZPn36sGjRIvr27cv27ds5efKk2fQ4URSFffv24ejoyNixY5u0jqqqKg4dOsQXX3yBh4cHb731liQMVPDo0SM2bdpEp06dml05Zg5OnTpFXl4e06ZNa/P7Yg50Oh0REREkJCTU9pGzsrLCzs5OGnML0Z7t3at1BMLCTNc6ACEskPRQaj5JKJmxM2fOcOPGDWbOnImvr2+LbKNmmEZzKpSgOqFUX4VSeXk5GzZswMnJiblz52rS+f7mzZvodDrCwsKwsrJixowZjB49mqNHj7J///4Gz07Xkm7dusXdu3eZOnUqtra2jX58VlYWn3zyCefPn2fixIksXbrU7JuPtwVFRUWsX78eNze3FqsQbE05OTmcOHGCYcOG0bFjR63DsRh9+/bFxsaGixcv1t5mMBgoKirSMCohhKZOnNA6AmFhRmkdgBAWSBJKzScJJTN19+5djhw5wogRI1q0X0tSUhJeXl44Ozs3az0eHh7k5ubWqfgxmUxs27aNwsJCFi1apNmwq7i4OEJCQnBwcACqXzjGjRvHyy+/zMWLF9myZQuVlZWaxAbVSbcDBw7QvXt3evTo0ajHKorCmTNn+Pjjj1EUhTfeeIPhw4e3yxcztVVWVrJhwwaqqqpYvHhxmx82qCgK+/fvx9nZmdGjR2sdjkWxs7Ojb9++XL58GaPRCFQ35jaZTC/sLSeEsFCurlpHICzMi+dSFkKI1icJJTOUk5PD119/TUhICOPHj2/RbTW3f1INDw8PKioqKCkpqb0tOjqaO3fuMHfuXDp06NDsbTRFfn4+qamp9OrV66n7Bg4cyMKFC7l79y5ffvklpaWlGkRYfZzKysoa3XC9oKCAL7/8kkOHDhEREcEbb7zRrN5L4p9qkqGPHj1i8eLFFlHtFR8f36wqOPF8ERERFBcXc+vWLQC6du0KSGNuIdqtr77SOgJhYV7TOgAhLJBUKDWfJJTMTGsOEcvNzSUvL0+V2b8MBgNA7bC3GzducPLkSSZMmFB7YaWFmzdvYmVl9czKn+7du7Ns2TIeP37MZ599Rl5eXqvG9+DBA86fP8+YMWNwd3dv8ONiY2P54IMPePz4Ma+99hqTJ0/G2tq65QJtZw4fPkxCQgLz5s1rseGmramiooIDBw7QrVu32hnIhLq8vLwIDg6ubc4dEhICUGf2NyFEOzJnjtYRCAvztdYBCCFEPSShZEYURWH79u2tNkQsKSkJnU6nSoVSTUIpNzeXjIwMdu3aRd++fRk2bFiz190csbGxdO3aFTs7u2cuExAQwKpVq6iqquLTTz8lMzOzVWIzmUzs3buXDh06MHTo0AY9pqysjO3bt9dWsL311lt06dKlhSNtX86fP8/Zs2eZMmUK3bp10zocVRw7doySkhKmTp2qdSgWLSIigtTUVLKysrC2tsbW1paHDx9qHZYQQgtVVVpHICyMfG0ohPqkQqn5JKFkRo4dO0ZCQgJz5sxplSFiycnJ+Pr6qpK4srOzw8nJiczMTDZt2oS3tzeRkZGaPqlycnLIyMhoUA8qT09PVq1ahYuLC2vXruXevXstHt/ly5e5f/8+L7/8coOaPScnJ/Phhx+SkJDA7NmzmTt3bm1fKKGO27dvc+DAAYYOHcrgwYO1DkcVDx8+5OzZs4wePbpRVXCi8Xr06IGzs3NtlZK7uzuFhYUaRyWE0MTkyVpHICzMQa0DEMICSUKp+SShZCZu3rzJ8ePHGT9+fKtURSiKQlJSkirVSTXc3d25du0aJpOJhQsXaj4EKy4uDhsbmwYPuXN2dmb58uUEBQWxbt06rl+/3mKxFRUVceTIEfr160dQUNBzl62qquLw4cP84x//wN3dne985zv07du3Xb5gtaSMjAy2bt1K9+7dmThxotbhqEJRFPbu3YunpyfDhw/XOhyLZ2VlxcCBA7l+/TplZWX4+flhMpkoKJBWqkK0OxbypYQwH+e1DkAIIeohCSUzkJWVxY4dO+jVqxcjR45slW1mZ2dTVFSkSv8kqL5wLSkpoaSkhIULF+Li4qLKepsjLi6O7t27N6oBsa2tLYsWLaJv375s376dU6dO1Zm5Ti2HDx9Gr9e/MHHx8OFDPv30U86ePcuECRNYunSpVJm0gPz8fDZs2ICXlxdz5sxp0d5lrenatWukpqYybdq0BlXBieYbOHAgVVVVXLt2jdDQUEAacwvLoiiKxf6o6j//U931iRey9AqDf9c6ANEsZvk6pRK1nndaTIIjFUrNZxlXTW1YSUkJGzduxMPDgxkzZrTaSZiUlIRer39hdUxDnTt3jtzcXOzs7AgICFBlnc3x6NEjsrKy6p3d7UWsrKyYMWMGo0eP5siRIxw4cACTyaRabElJSVy/fp2JEyfi6OhY7zKKonDu3Dk++ugjjEYjr7/+OiNGjLCYRIc5KSsrY/369VhbW7No0SJsbGy0DkkVpaWlHD58mD59+qiWOBYv5uLiQlhYGBcvXqxNKEljbiGEEEIIYYmkv5uGTCYTW7dupaKigmXLlrXqVN5JSUn4+/urss3ExEQOHTpEaGgod+/epaKiQvNpyWNjY7Gzs6u9oGssnU7HuHHjcHFxYd++fRQWFjJ79uxmJxuqqqrYu3cvQUFB9OvXr95lCgsL2bFjB/fu3WPw4MFMmDDBYpIc5sZoNLJlyxYKCgpYuXIlzs7OWoekmiNHjmA0Gpk0aZLWobQ7ERER/OMf/yAjIwMbGxuysrK0DkkI0dp+/WutIxAW5tdaByCEBVK7qkgqlESrOnToEMnJycyfP79VhzEpikJycrIqVQs5OTls3bqVkJCQ2uF6ubm5zV5vcyiKQlxcHGFhYc3u4zRo0CAWLlzInTt3+OqrrygtLW3W+k6dOkVubi7Tp0+v9wXn5s2bfPDBBzx8+JAlS5YwdepUSSa1kJr+QsnJySxYsICOHTtqHZJq0tPTuXz5MuPHj7eoJFlbERwcTMeOHblw4QJubm7SQ0mI9ujUKa0jEBZmhNYBCCFEPSShpJErV65w7tw5pkyZompj7IbIysqitLS02Qml8vJyNmzYgJOTE3PnzsXT0xOoTjJpKSsri+zs7CYNd6tP9+7dWbp0KY8ePeKzzz4jPz+/SevJycnhxIkTDBs2DC8vrzr3lZeXs2PHDrZs2ULnzp156623CAkJUSN88QwnT57kypUrzJgxw6KGhJlMJvbu3Yuvry+DBg3SOpx2SafTMWjQIOLj4+nQoQNGo5GSkhKtwxJCtKbDh7WOQFgYy5guRAhhaSShpIH09HT27t1L//79iYiIaPXtJyUlYW1t3axeRyaTiW3btlFYWMiiRYuwt7fHyckJGxsbzRNKsbGxODg4qJokCAwMZNWqVVRVVfHpp5+SmZnZqMcrisK+fftwdnZm9OjRde5LSUnhww8/5NatW8yaNYt58+Y9s7eSUMeNGzeIiopizJgxhIeHax2Oqi5cuEBmZibTp0+XnlsaCg8Px8bGBkVRMCo6Tl+OJTO/jLJKo9ahCTNy/PhxIiMj8fPzQ6fTsWPHjjr3L1++/Klmn1OmTNEmWNE4dnZaRyAsTLnWAQhhgaQpd/NJD6VWVlhYyKZNm/D19WXatGmanHRJSUkEBgY2azhYdHQ0t2/fZvHixXTo0AGofkJ6eHhoOuStZrhbz549VZ/VytPTk1WrVrF+/XrWrl3LwoUL6dKlS51linKyuXflImVFhVhZ2+Dh509weH9u3YonMTGRRYsW1faXMhqNHDt2jJMnTxIYGMjSpUsxGAyqxiyelpqays6dO+nbty9jxozROhxVFRYWEhUVxcCBA/H399c6nHbNzs4Ojy59+fJmDvHl/flizyPYcxQrnY6JvbxZOiyYYV082+UHD/FPxcXFhIeHs3LlSubMmVPvMlOmTGHt2rW1v9tJoqJt2LJF6wiEhVmgdQBCCFEPSSi1oqqqKjZt2oROp2PBggXN7u/TFCaTiZSUlNp+R01x48YNTp48ycSJE+natWud+7ROKN2/f5+8vDx69+7dIut3dnZm2bJlbNmyhXXr1jFr1iz69OnDg7sJXNj5NXcvnEFRFHR6PXwzvaeTu4FiZwPdBgyme/fuQPUsdNu3bycrK4vx48fLDG6tJDs7m40bNxIYGNiqsyq2lkOHDmFtbc1LL72kdSjtWqXRxL9tj2XTFdBhQOGf55lRUTh8M4sDsZkM7eLBmtcG4eYgfdLaq6lTpzJ16tTnLmNnZ4ePj08rRSRUs3gxrF+vdRTCgqwDXtU6CCEsjDTlbj5JKLWSmgbAmZmZrFixAhcXF03iyMjIoKKiosl9mzIyMti1axd9+/Zl2LBhT91vMBi4efNmM6NsutjYWJydnQkKCmqxbdjZ2fHKK6+we/dutm3bRuK5U9w7ug+o/jsDKCZT7fLFebkoebmU64wUv/wycQm3OXz4MO7u7qxatQo/P78Wi1X8U3FxMevWrcPJyYkFCxaoXsGmtXv37hEbG8usWbNwcHDQOpx2y2RS+NHGq+y78QCgTjKphtFU/TpxISmXxR+fZct3huFoK2/Hon7Hjh3Dy8sLg8HA+PHj+a//+q/anoX1KS8vp7z8n4NjpCm8RoqKtI5AWBiZYkMI9UlCqfmkJKKVnD9/nqtXrxIZGanpUJSkpCRsbW2blMQoKipi06ZNeHt7ExkZWe8TxmAwkJ+fj9HY+n1CTCZT7XC3lq72sbKyYubMmfQN9OPu4T0oJlOdJNK36YCc+2l88rPvs3/vHvr378+bb74pyaRWUlMdWFFRweLFiy0u4VJVVcW+ffsIDg6mb9++WofTrq07n8reGw9QGrCsUVG49aCA9/bFt3hcom2aMmUKX3zxBUePHuX3v/89MTExTJ069bnvse+99x5ubm61P4GBga0YsahlYUOqhfZitA5ACCHqIQmlVpCUlMTBgwcZOnSo5g2Ak5OTCQ4ObnR1Rs0FuclkYuHChc8crufh4YGiKE2eCa05UlNTKSoqarHhbt+mmExknTteT/3Bs5evys9laEgw06ZNw8ZGhrm0BkVR2LFjBw8ePOCVV16xyD5Vp0+fJjc3V7O+bKKaoih8cuJeg18TAEwKbL6YRkFZZYvFJdquRYsWMWPGDPr06cOsWbPYs2cPFy5c4NixY898zC9+8Qvy8/Nrf9LS0lovYPFPkyZpHYGwMIe0DkAICyUNuZtHEkotLDc3t3Yq+IkTtZ3ws6qqitTU1EYPd6sZrvfgwQMWLlz43OF6NRfrWsz0FhcXh5ubW7Nmr2uMe5cvUJzX+H5R6ZfO1Q6NEy3v6NGjxMXFMWfOHItsVJ2bm8uJEycYOnQoXl5eWofTrp25l01KdkmDqpOeVFFlYtul9BaJSViWLl260KFDB+7evfvMZezs7HB1da3zIzTwy19qHYGwML/VOgAhhKiHJJRaUEVFBRs3bsTe3p558+Zp3nQ5PT2dqqoqOnfu3KjHPTlc70XJGjc3N/R6fas35jaZTNy8eZNevXq1Wnb4+tGD1c23GykvM4OMhFstEJH4tkuXLnHq1CkmTZpEWFiY1uGoTlEU9u/fj6Ojo8XNWNcWXUzOxUrfhNcfHVxI0W4yA9F2pKenk52dja+vr9ahCCGEEG2emtVJ7bVKSRJKLaRmmE1eXh6LFi0yi54tSUlJ2NvbN2q2mHv37nHw4EGGDRvWoOF6er0ed3f3Vq9QSkpKoqSkpNWGuwHkPrj/3L5Jz5P/MFPlaMS33b17l7179xIREcHQoUO1DqdFJCQkcOfOHaZOnYqtra3W4bR7xeVVNCWfpChQWFalfkDC7BUVFXH16lWuXr0KVL+XXb16tXYI989+9jPOnj1LcnIyR48eZebMmYSGhjJ58mRtAxcv9vOfax2BsDC/0zoAISyQJJSaTxJKLeTEiRPcunWL2bNnm80wlOTkZDp37tzgEz0nJ4ctW7YQEhLChAkTGrwdg8HQ6hVKsbGxeHh4tOrUyiZj0y8AjVVy8diSsrKy2LJlC6GhoUyZMsUiX9wrKirYv38/Xbt2pXv37lqHIwAnO2tMTRjNqteBi53M8tYeXbx4kf79+9O/f38A3nnnHfr378+vfvUrrKysuH79OjNmzKBbt26sWrWKgQMHcuLECezs7DSOXLxQbKzWEQgL03pfmQohRMPJJ9gWkJCQQHR0NGPGjKFHjx5ahwNUX3ymp6c3+FvN8vJyNmzYgJOTE3Pnzm3UcD2DwUBqampTQ220qqoq4uPjGTx4cIsmDhRFIT09nevXr5OcnExxUQl6aFQD3hqObm5qhye+UVBQwPr16/Hw8DCLoaYtJSYmhpKSEqZOnWqRCbO2aGCwAWMTMkqKUv1Y0f6MHTv2uT31Dh482IrRCFXt2QNvvql1FMKCvAx8rHUQQlgYtauK2uNnckkoqezRo0ds27aNHj16mFVPk7S0NEwmU4P6J5lMJrZt20ZhYSGvv/469vb2jdqWh4cH165dQ1GUVnlSJSYmUlZWRq9evVRdb1VVFXfv3iUuLo709HTy8/NrP/hbWVnh4htA1b3GT/dt6+BAUG9tZ/uzVDWJUIDFixdb7DCwhw8fcvbsWcaMGWORs9a1RYqi4Fr6AHerSvKM1jQm1WxjpWfuwNaZTEAIIYQQQgi1SEJJRaWlpWzcuBE3NzdmzZplVhnKpKQknJyc6NChwwuXjY6O5vbt2yxevLhBy3+bwWCgsrKSoqKi584Ip5a4uDi8vLyaPbSwvLycmzdvcuvWLTIyMiguLq69z8bGBh8fH7p06UJ4eDgdO3akrKiID1e/hrGq4dN963R6+oyfjI1d45J04sVMJhNff/01OTk5rFy5slXOPS0oisK+ffswGAwMHz5c63DaPUVRuH37NtHR0WRlZTHKuye7M2wa/Hi9DuYN9MfNoeGPEUK0Abt2aR2BsDAztQ5ACCHqIQklldRczJaUlPDGG2+YXX+DpKSkBvVPio2N5eTJk0yYMIGuXbs2aVseHh5AdQ+mlr6or6ysJD4+npEjRzb6sQUFBdy4cYPbt2+TlZVFeXl57X329vYEBwfTtWtX+vbtW+9+2Ds7M/DlWZzfsaWBW9Rh0kGevTNVVVVYW8vTTy01s53dvXuXV199FW9vb61DajHXr18nJSWF1157Tc4hjd27d4/o6GjS09MJDg5mxYoVBAQEUrn+MgdjM3nR4DcrnY5u3s78cnrPVolXCNGKVqyAtWu1jkJYkM+AlVoHIYSFkSFvzSdXIyo5evQo9+7dY8mSJbUJFXNRVlbGgwcPGDhw4HOXy8jIYOfOnfTt27dZlQ81Q3Byc3MJDg5u8noa4s6dO1RWVr5wdjdFUXj48CHXr18nKSmJx48fU1n5z8oiJycngoKC6NGjB7169WpwQnDEwiXkZT7g9tmTz11Op9ejt7Km15xXOHczgUdr1zJ//nzc3d0btB3xfGfOnOHixYtERkYSEhKidTgtprS0lEOHDtG7d2+6dOmidTjtVlpaGlFRUSQnJ+Pv78+SJUvo0qVL7YeIvy7qz79uv8HWS+lY6XVP9VWquW1AsDufLI3ASRpyi1bgplLvvuf1fBJPyM7WOoKnqHmhY47ngTnGpCZPldZjrhe8av39zHX/zDEuc4xJtD3yKVYF169f5/Tp00yaNMksL/JSUlJQFOW5/ZOKiorYtGkTXl5evPzyy816gbGxscHFxYWcnJwmr6OhYmNj8fX1fSqJZzQaSUtLIzY2luTkZHJzczGZTED1i6erqyuBgYH06tWL0NDQJld66PVWvPzD/8eZgCAu7tlGZVkZ6HTVXXapTiQpJhMdgzsz6c3v490llF5DM9i8eTNr1qxhzpw5Ta4EE9Vu3rzJ4cOHGTlyJAMGDNA6nBZ19OhRqqqqmDRpktahtEuZmZlERUVx584dvLy8WLRoEd26dXvq9dLWWs//Nz+cZcM68eXZZHZcyaDCWPP6A+N7eLFsWCeGh3ii18uHOSEs0rBhWkcgLMwZrQMQwgJJhVLzSUKpmTIyMti9ezfh4eEMHTpU63DqlZSUhJub2zOrYaqqqti8eTMmk4mFCxdiY9P8Xh4Gg4Hc3Nxmr+d5ysvLuXPnDuPGjaO8vJzExMTaBtoFBQW1y+n1egwGA506daJPnz4EBgaqOvOXTq9n+PzFRETOIf70ce6cP0NJQR4PMjPx7RzKxFeX4d0ltHZ5Pz8/Vq9ezY4dO1i/fj0jR45k3LhxFjsbWUtKT09n+/bt9OrVi/Hjx2sdTou6f/8+ly5dYsqUKRbbH8pcPX78mOjoaG7evImHhwdz586lV69eL/zQ0CfAjT/MC+c/ZvYmt6QCo0nBw8kWR1t56xXC4s2bp3UEwsJs1ToAIYSoh3yqbQY1q3pa0vP6JymKwt69e8nIyGD58uW4urqqsk0PDw8ePXqkyrrqU1hYSFRUFFVVVZw4cYLDhw/X3mdtbY2Pjw8hISH06dMHLy+vVvnb2Njb02f8JPqMr64e+eCDDzAEBdVJJtVwcHBg0aJFnDp1iqioKNLT05k7dy7Ozs4tHqelyM3NZcOGDfj6+ppdE3y1mUwm9u7di4+PDxEREVqH027k5uYSExPD9evXcXV1ZcaMGYSHhzc6+WtvY4Wvm0MLRSmEMEs/+Yk05haq+l+kMbcQapMKpeaThFITGY3GOlU95toct7i4mIcPHzJixIh67z9//jxXr15l1qxZBASoN221wWAgISFBlXUpisLjx4+Jj4/nzp07ZGVlUVFRUef+oKAgunXrRs+ePXF3dzeLJ/OLqrR0Oh0jR44kICCArVu3smbNGubNm9fifacsQWlpKevWrcPe3p5FixaZ7fNPLRcvXuTBgwesWrVKKtlaQUFBAcePH+fKlSs4OjoyZcoUBgwYYPHnmRBCCCFEeyIJpeaTT8dNtH//fjIyMli2bJlqVT0tITk5GYBOnTo9dd+9e/c4ePAgw4YNIzw8XNXtGgwGSktLKSsrw97evlGPNRqNZGRkcPPmTe7du0d2djZGo7H2fkdHR/z9/UlOTmbs2LGMHj1a1djVYjAYuH379guX69SpE6tXr+brr7/mH//4By+99BLDhw9vly9IDVFVVcWmTZsoKSlh1apVODo6ah1SiyoqKiIqKooBAwaomvQVTysuLubkyZNcvHgRGxsbxo8fz+DBg1UZBiyEaGfeeUfrCISF+aPWAQghRD0kodQEFy9e5NKlS8yYMYPAwECtw3mupKQkPD09n0p65eTksGXLFrp06cKECRNU325Nk+zc3Fx8fX2fu2x5eTkpKSncunWLlJQU8vLy6sz0UNNAOywsjJCQEOzt7bl8+TLJyclm3YTZYDCQl5eHyWR6YVWJi4sLS5cuJTo6miNHjpCamsqsWbNwcJBhMk9SFIXdu3eTnp7O0qVL8fRUa84T83Xo0CGsrKxa5HkqqpWVlXH69GnOnTsHwIgRIxg6dGijk+FCCFErNVXrCISFCdI6ACEskFQoNZ8klBopJSWF/fv3ExERQf/+/bUO54WSk5Ofqk4qLy9n48aNODk5MW/evBYZQmMwGIDqxNW3E0oFBQUkJSVx69Yt7t+/T1FRUe19Op2utoF2z549CQoKqrc6IC4ujk6dOpl1zyGDwYDJZKKgoOCZDdGfpNfreemllwgMDGT79u189NFHzJ8/Hz8/v5YPto04duwY169fZ+7cuQQFWf5Hq6SkJG7cuMHMmTMludgCKioqOHfuHKdPn6aqqorBgwczYsQIi696E0K0gq1bYelSraMQFmQe8KXWQQghxLdIQqkR8vPz2bx5M0FBQUyePFnrcF6ooKCA7Oxsxo0bV3uboihs27aNgoICXn/99Rb7Bt7BwQE7OztycnJ49OgRiYmJJCQk8ODBA8rLy2uX0+v1eHt7ExISQo8ePfDz88PKyuq56y4uLiYpKYnp06e3SOxqebJKqyEJpRrdunVj9erVbNmyhc8++4wpU6YwcODAdpnxftLVq1c5fvw4L730Er1799Y6nBZnNBrZu3cvQUFBqg9Jbe+qqqq4ePEiJ0+epLS0lIEDBzJq1CiZPU8IIYQQoh2RCqXmk4RSA1VWVrJx40ZsbGyYP3/+C5Me5iApKQmo2z8pKiqK27dvs3jxYjp06KD6Nmv6H929exeTyUR0dDRRUVG199vY2BAQEEC3bt3o2rUrXl5eja6QunnzJjqdjrCwMLXDV5WbmxtQnVDq3Llzox7r7u7OihUrOHjwIHv37iU1NZWXX34ZW1vblgjV7CUlJbF792769+//zAbzlub06dPk5OSwYMGCdvnm1BKMRmNtYrKwsJDw8HDGjBnTqISvEEI0yObNWkcgLMwCrQMQwgJJQqn5JKHUAIqisGvXLrKzs1m5cqVZD4coLymmOC8XxaSQmBCPt7c3Tk5OAMTGxnLy5EkmTJhA165dVdleWVkZaWlp3L59m6SkJHJycur0P9Lr9XTu3JkePXrQpUsXPDw8mv1Ei42NpUuXLmb9dwCwtrbG1dX1uTO9vejx06dPJygoiN27d/PgwQMWLFhAx44dVY7UvD169IhNmzbRuXNnpk+f3i5eqHNzczl+/DhDhw7Fy8tL63DaPJPJRGxsLMeOHSM3N5fevXszduzYdtGDSwihkR//GD74QOsohAX5E/BdrYMQQohvkYRSA5w+fZrY2FjmzZuHj4+P1uE8RVEU0m/e4MrBvdy9cAbFZKq9z8k/iHuXL2Dr5cvOnTvp27cvw4cPb/K2CgoKSElJ4fbt26SkpFBYWFjnficnJ4KCgujevTv379/n9u3bvPbaa03eXn3br2lY3RYYDIYmJ5Rq9OnTBx8fH7Zs2cLHH39MZGQkffr0USlC81ZUVMS6detwc3NrM5WBajhw4ACOjo6MHTtW61DaNEVRiI+PJzo6mkePHtG9e3cWLlyIt7e31qEJISzd/ftaRyAsjL/WAQhhgaRCqfkkofQCd+7c4ciRI4waNYpevXppHc5TKsvL2PvX/yHx4jl0en2dZBJAyYN0tv/+N+DsRseBw3n55ZcbfKIrisKjR49ISUnhzp07pKWlUVZWVmcZNzc3OnXqRPfu3QkODq5TNWQ0Grlw4QJVVVVYW6tzqsXFxWFlZUX37t1VWV9LMxgMPHz4sNnr6dixI6+//jp79uxh27ZtpKamMnnyZNWOqzmqrKxkw4YNGI1GFi9ejJ2dndYhtYqEhARu377NggUL2u0Qx+ZSFIXExESioqJ48OABXbp0YcaMGQQEBGgdmhCivWgDE7eItuWK1gEIIUQ9LPdqVAXZ2dl8/fXXdOvWrU5ja3NhrKpi+x/+k/SbNwCeSibVua0oH5vEOBRjFdQzaxpUN6rNyMggOTmZu3fv8uDBA6qqqmrv1+l0dOjQgZCQEEJDQwkMDHzuRX5NU+q8vDzV+jXFxcXRtWvXNjOdt8FgICEhQZV12draMnv2bIKCgjhw4AD3799n/vz5tTPqWRKTycS2bdt49OgRK1asqO1HZekqKirYv38/oaGh9OjRQ+tw2qSUlBSioqJITU0lMDCQZcuWPTXTpRBCtLhVq7SOQFiYT7UOQAgh6iEJpWcoKytj48aNuLi4MHv2bLMsX7u4extpcdfhiZ5Fz5Obkc6J9Z/z0sq3gH/2P0pKSiIxMZFHjx491f/I19eXrl270qVLF/z9/RtVEVOT6MjJyVEloZSbm8v9+/eZO3dus9fVWgwGA6WlpZSVlamSBNPpdAwaNAh/f382b97MRx99xKxZs9pMxVZDHTp0iISEBBYtWoSvr6/W4bSa48ePU1xczLJly8zyNcec3b9/n+joaBITE/Hx8WHx4sWEhobKcRRCaOPtt2HXLq2jEBbkb8BMrYMQwsLIkLfmk4RSPRRFYfv27RQWFvLGG2+YZTWMyWjk8oHdDU4mQXW10vWjhyhw7UBK+n3y8/Pr3G9jY4Ofnx/dunWjU6dO+Pj4NHoGtie5urpiZWXV7B5CNeLi4rCxsaFbt26qrK811CTVcnNzVU2M+Pr68uabb7Jz5042btzIiBEjGD9+fLP+Xubi3LlznDt3jmnTprWpv3VzPXr0iDNnzjB69GiLrDprKQ8fPiQ6Opr4+Hg6dOjA/PnzCQsLa5dv6EIIIYQQQrQmSSjVIzo6mtu3b/Pqq6+a7SxA9y5foCSv8YkaY1UlN08co8rDC3t7e4KCgggNDSU4OJiOHTuqnqE1GAzk5OSosr7Y2Fi6devWpvrK1Az7UzuhBODg4MDChQs5ffo0R48eJT09nblz5+Li4qLqdlpTQkICBw8eZOjQoURERGgdTqtRFIW9e/fi7u7OiBEjtA6nTcjJyeHYsWPcuHEDg8HArFmz6NOnj0UkVYUQFuC7Mh+XUNf7WgcghAWSCqXmk4TSt8TFxXHixAkmTJhAaGio1uE804M78eitrDAZjY16nE6no1MHA9Pe/gHu7u4tftKrMcsZVFdvZGVltblZrxwcHLC1tVWtSuvbdDodI0aMICAggK1bt7JmzRrmzp1L586dW2R7LSkjI4Ovv/6aHj16MGnSJK3DaVU3btwgJSWFJUuWWHSjdTXk5+cTExPD1atXcXZ2Zvr06fTv37/dzAAohGgjvlUFLkRztY9ukkKItkauXJ6QmZnJzp076d27N8OHD9c6nOcqLSpqzGi3f1LA2cGh1YbUGAwG7t271+z1xMXFYWdnZ9ZJvvrUVGm1VEKpRnBwMKtXr2bbtm18+eWXjBs3jpEjR7aZLHleXh4bNmzAy8vLbHuWtZTS0lIOHTpEr169CAkJ0Tocs1VUVMSJEye4dOkSdnZ2TJw4kUGDBmHzjEkGhBB15efn4+rqqnUYtczxdV5p0gerZ1i3DhYuVG99KlB1/0SrexXYrHUQLUit1wQ1z3M1X6fUisscXzvbMqlQaj5JKH2jpKSEjRs34unpyYwZM8zuZMjLyyM1NZW7d++SkpJC2d2b2JiMNDZKnV6HnaNji8RYHw8PDy5duoSiKE0+poqiEBcXR48ePdpk9UZrJJQAnJ2dWbJkCceOHSMqKoq0tDRmz56Ng4NDi2+7OcrKyli/fj3W1tYsWrSo3SUIoqKiqKysZPLkyVqHYpZKS0s5deoU58+fR6/XM3r0aIYOHdqmhr4KIYQQQgjzIwml5mt7V+ctwGg0smXLFiorK1mxYoXmF7Qmk4lHjx6RnJzMnTt3SE9Pp7y8vM4yjoYO6B4/aPS6FZOJgLDeaoX6QgaDAaPRSEFBQZOnfs/KyuLx48dtdhiUwWAgPj6+Vbal1+sZP348gYGBbN++nTVr1jB//nz8/f1bZfuNVfPcKywsZOXKlTg7O2sdUqvKyMjg4sWLTJ48uU33vmoJ5eXlnD17ljNnzmAymRgyZAjDhw83+wSpEEIA8OWXWkcgLMxrWgcghBD1kIQScPDgQVJTU1m6dGmTkx7NUVVVxf3797l79y6JiYk8fPgQ4xO9kXQ6HZ6ennTu3JkuXboQEBCAs5MTn/zgdQoePWzUtmzsHeg+YrTau/BMTzalbuqxjY2NxcHBgS5duqgZWqsxGAzk5+djMplarWFw165dWb16NVu2bOGzzz5j8uTJREREmFXWXFEU9uzZQ3JyMq+99hodO3bUOqRWZTKZ2LNnD97e3gwePFjrcMxGZWUlFy5c4OTJk1RUVDBo0CBGjRqFk5OT1qEJIUTDvfsu/PnPWkchLMhvgB9rHYQQFkYqlJqv3SeULl++zIULF5g+fTrBwcGtss3S0lKSk5NJSEggNTWVvLy8OuNqbW1tCQgIqJ19zdfXt96hXoNenk3U2jUN3q4ClLt5cis+gT59+rTKCe/u7g5Uz8jUqVOnRj++ZrhbWFhYm226azAYMJlM5Ofnt+p08G5ubqxYsYJDhw6xf/9+0tLSePnll7Gzs2u1GJ7n5MmTXL16lVmzZjXp3GjrLl26xIMHD1i5cqXMTEZ1tdrly5c5fvw4JSUl9OvXjzFjxphVzxchhGgwFfpHCvGktvm1qhDC0rXrhFJaWhp79+5l4MCBDBo0qEW2oSgK+fn5JCYmkpCQwP379ykpKamzjKurK4GBgXTr1o2goCDc3NwalOzpN2k69+NvknD2JC/s0K3TYXRwxi0snO3bt3Pr1i1efvnlFv/W39raGjc3tyb3EMrIyCAvL4/evVtvmJ7aapJIubm5rZpQArCysmLq1KkEBQWxa9cuPv74YxYsWICXl1erxvFtN27cICoqijFjxhAeHq5pLFooKiri6NGjDBgwgMDAQK3D0ZTJZOL69evExMSQl5dH3759GTNmTG11oxBCtElhYVpHICzMLa0DEMICSYVS81l0Qulh8j3uXjhLaWEBVjY2ePgF0GP4KGwdHCkoKGDz5s0EBAQwdepU1bZpMpnIysoiPj6+dvhaZWVl7f1WVlZ4e3vTpUsXunbtir+/f5Oby+r0eqZ9/6fYOTlx/cgBdHo9islUZxm9lRUmo5HQQUNw7DOI02fPERYWRkpKCu+//z7Tp0+nZ8+ezdrnF2lOU+rY2FicnZ1brXqsJbi7u6PT6VqlMfez9OrVC29vb7Zs2cInn3zC9OnTNUvkpKSksHPnTsLDwxkzZowmMWjt8OHD6PV6XnrpJa1D0YyiKNy8eZPo6Giys7MJCwtj8eLF7W7ooxDCQr3zjtYRCAvzR60DEEKIelhkQinx0nnOfr2BzMQ76PT6bzKFOkzGKqI//4ieo8dzr0JBr9czf/78Zg2lqqysJCUlhZs3b5Kamkpubi6mJ5I6Dg4OtdVHISEheHp6qpq51FtZMfGNtxkwdSbXDu8jNvowleVlAFhZ29Bj5Fj6T56Od5dQABydXThy5Aj9+/entLSULVu20Lt3b6ZOnYpjC83+ZjAYyMzMbPTjaoa79ezZs00PCbKyssLV1VXThBJAhw4deP3119m7dy87duwgNTWVqVOnturMednZ2WzatInAwEAiIyPbZRY/OTmZ69evM2PGjBZ7zpkzRVG4c+cOUVFRZGVlERoaypw5c/Dz89M6NCGEUM8bb8CuXVpHISzIx8BMrYMQQohvsbiE0oVdX3N83Vr45kJVMZl4cjBYVUU5148ewGRtw8z/926jZ5UqKSkhPj6ehIQEMjIyKCoqqr1Pp9Ph7u5OUFAQPXr0IDg4uNVmJPIMCGT8itWMW/YGFWVlKIoJOwdHdN9KxIwYMQJ7e3v27NlD3759mTVrFgcOHOCDDz7g5Zdfpnv37qrH5uHhwc2bN1EUpVEJhNTUVAoLC9v0cLcazanSUpONjQ0zZ84kKCiIffv2kZGRwYIFC1plKF5xcTHr1q3DycmJBQsWtNmeWM1hNBrZu3cvgYGB9OvXT+twWl1SUhJRUVGkp6cTHBzMihUrCAoK0josIYQQQgjRTrXHL7jVZFEJpdhjR6qTSfD8nkKKglVVFcc//j+Cfvdn7J3qTyopikJ2djY3btzg3r17PHz4kIqKitr7bW1t8fPzo0uXLoSFheHj46N5JY1Or8fuBVUPAwcOxM7Oju3bt1NRUcGbb77J/v372bhxI+Hh4UyZMgV7e3vVYjIYDJSXl1NaWtqoiozY2FhcXV0JCAhQLRatNLVKqyXodDoGDBiAr68vW7ZsYc2aNcyaNYsePXq02DYrKyvZuHEjFRUVrFq1qt1O/X7mzBmys7NZvXp1u3rzSktLIzo6mqSkJPz8/FiyZAldunRpV8dACNHOrFypdQTCwnymdQBCCFEPi0koVVVWEvPFJw1eXlFMFDzK4tqhfQyZvQCo7n+UlJREXFxc7exrRqOx9jE1vXy6d+9Ot27dcHFxUX0/Wkvv3r2xtbVly5YtVFRUsGDBAm7evMnBgwe5d+8eM2bMIDQ0VJVt1TTXzc3NbXBCyWQycfPmTcLDwy3iotNgMHDrlnm1U/T19eXNN99k586dbNq0ieHDhzN+/HjVK4cURWHHjh1kZmayfPnyVm9Mbi7y8vKIiYlhyJAheHt7ax1Oq8jMzCQqKoo7d+7g5eXFwoUL6d69u0U8p4UQQgghRNsmTbmbz2ISSnfOnaKsuOjFCz5BURTO79lOYmklDx5k1hm+ZmVlVTt8rXfv3gQHB1vcEJ1u3brx6quvsmHDBr766isWL15Mly5d2LVrF+vWrWPAgAFMmjSp2dPM1yQQcnJy8Pf3b9BjkpKSKCkpsYjhblB9DMrKyigtLTWr6hx7e3sWLFjA2bNnOXz4MOnp6cybN0/VZOnRo0e5efMmCxYsaPDf3xIdOHAABwcHxo4dq3UoLe7x48dER0dz8+ZNPDw8mDNnDr17926Xb7JCiHbqs89g1iytoxAWZCWwU+sghBDiWywmoRR77DA6nR5FMb144SdUFBVy78plrD07EhAQQEhICH379m03U1Z36tSJpUuXsm7dOv7xj3+wZMkSlixZwqVLlzh06BCJiYnMnDmTzp07N3kb9vb2ODg4NKqHUFxcHB4eHvj6+jZ5u+akJqmWm5trVgklqM6kDxs2DH9/f7Zu3cqaNWuYM2cOXbp0afa6L126xKlTp5g0aRJh7XgK5YSEBBISEpg/f36zE7TmLDc3l5iYGK5fv46rqyuRkZH069dP86HAQgghhBBCCPVZTEKp4OHDRieTakROmUT4S5NVjqjt8Pf3Z/ny5Xz55ZesXbuW1157jUGDBhESEsLOnTv54osviIiIYMKECdja2jZpGx4eHg1OKBmNRm7dukVERITFVDQ8OezPXGezCgoKYvXq1Wzbto2vvvqKsWPHMmrUqCb/De7evcvevXuJiIhg6NChKkfbdlRWVrJ//35CQkIsNqlWWFjI8ePHuXz5Mg4ODkyZMoUBAwa06gyCQghhVj7+WOsIhIV5Q+sAhLBAMuSt+Szma+OmJpMArOTbc7y8vFi5ciWKorB27VoeP36MwWBg2bJlTJ48mStXrrBmzRpSU1ObtH6DwUBOTk6Dlk1MTKSsrMxihrtBdZWWnZ2dWcz09jxOTk68+uqrjBo1iujoaNavX09JSUmj15OZmcmWLVvo2rUrU6ZMaZcvrjWOHz9OUVER06ZNs7jjUFJSwqFDh/jrX/9KXFwc48eP54c//CGDBw+WZJIQon374x+1jkBYmHe0DkAIIephMZkUZ48O0MSLtWOnz7B//37i4uLq9FFqbwwGAytWrMDOzo61a9fy4MEDdDodQ4cO5Tvf+Q6Ojo6sXbuWQ4cOUVlZ2eh1NzSZEhsbS8eOHfHy8mrKbpglnU7XqGOgJb1ez7hx43j11Ve5f/8+a9asIT09vcGPLygoYP369Xh4eDB37tx2Pdzp0aNHnD59mpEjR1rUMNqysjKio6P5y1/+wqVLlxgxYgQ/+MEPGDFiBDY2NlqHJ4QQ2jOziThE22eZNc5CaKumQknNn/bGYr5C7jl6PPfj4xr9OBsHRwLCenPnzh3Onz8PgKenJ0FBQQQHBxMUFIS7u3u7OTlcXFxYvnx5bU+lxYsXExQUhKenJytWrODMmTNER0dz584dZs2a1eAmyx4eHhQWFlJZWfncC87KykoSEhIYMWKEWrtkNtpKQqlGaGgoq1evZuvWraxdu5ZJkyYxePDg5z4XysvLWb9+PTqdjsWLFzd5iKQlUBSFffv24e7uzsiRI7UORxUVFRWcP3+eU6dOUVVVxeDBgxkxYkSDZ28UQoh2Q4U+hEI86Z7WAQhhgWTIW/NZTEIpbMQYjn3xMZVlZQ1+jE6vZ+DUSEbMmQNU9wFJSUkhJSWF1NRUrly5AoCrq2udBFPHjh0t+mRxdHRk6dKlbNiwgS+//JKFCxcSGhqKXq9nxIgRdOvWjR07dvDpp58yYsQIxowZ88LhLU/2EHpe5dGdO3eoqKigV69equ6TOTAYDNy8eVPrMBrFzc2N5cuXc/jwYQ4cOEBqaiozZsyot7G0yWRi69at5ObmsnLlSlVnimuLYmNjSU5OZsmSJW1++FdVVRUXL17k5MmTlJaWMnDgQEaNGtXu/8ZCCPFMv/mN1hEIC/Ou1gEIIUQ92vZVzhNs7O0ZPm8xMV991qDldXo9Di4u9Jv8cu1tLi4u9O7du7Z3T2lpKampqbUJpri4OBRFwcHBoTa5FBwcjI+Pj8UN67Gzs+PVV19l69atbNiwgblz59KzZ08AOnbsyMqVKzl16hQxMTHcvn2bWbNmPXdGtidnOXteQikuLg5fX188PT3V3SEzYDAYyM/Px2g0YmVlpXU4DWZlZcWUKVMICgpi586dfPzxx8yfPx9vb+/aZWqqce7du8fixYvr3NcelZWVcfDgQXr27ElISIjW4TSZ0Wjk6tWrHD9+nMLCQsLDwxkzZgzu7u5ahyaEEObttddg1y6toxAW5EtgptZBCCHEt1hMQglg4MuzKcrN4dLeHc9dTqfXY+foxLxf/hdO7oZnLufg4ED37t3p3r07UD3cIz09vTbBFBUVRVVVFba2tgQGBtYmmPz9/dt8RQKAjY0NCxYsYMeOHWzdupXIyEj69+8PVCcZRo8eXVut9MknnzBq1ChGjRpVb7LE2dkZGxub5zbmLi8v5/bt24wdO7aldklTBoMBRVHIz89vk/10evbsibe3N1u2bOGTTz5h+vTp9OvXD4AzZ85w6dIlIiMj23QCRS1RUVFUVlYyeXLbnD3SZDIRGxtLTEwMOTk59OrVi7Fjx9KhQwetQxNCWAhFUbQO4SlqVp8rkZGqrUstqu6fGf79hADzPc8teXSLaN/aftbjCTqdjjGvrcIzIIizX2+k4PFD9FZWmEym6iexAqAQMnAwY5e+jpuXT6PWb2trS5cuXejyzbj4qqoqHjx4UJtgOn36NNHR0VhZWeHv71+bYAoMDKx3iFBbYGVlxezZs7Gzs2PXrl2Ul5fXmQLex8eHN954g5iYGI4fP15brfTtKqSaptTPSyjdvn2bqqoqixzuBnWrtNpiQgmq+4utWrWKffv2sXPnTlJTU+ncuTOHDx9m5MiRDBgwQOsQNZeRkcHFixeZOHEirq6uWofTKIqiEB8fT3R0NI8ePaJbt27Mnz8fH5/GvVYKIUS79+qrWkcgLMw6rQMQwgJJD6Xms6iEElT/EfuMn0TvsRNIuX6FOxfOUFZUhJWNDQZfP3qPm4iLhzrfsltbWxMYGEhgYCBQ/a1+VlZW7TC5K1eucPLkSXQ6HT4+PnX6MDk5OakSQ2vQ6/VMnz4de3t7Dh48SFlZGWPGjKl9wlhZWTF+/Hi6d+/Ojh07+Oijjxg7dizDhw+vMxTwRU2pY2NjCQgIsNjhNG5ubuh0ujbVmLs+NjY2zJw5k6CgIPbu3cuVK1fo2rUr48eP1zo0zZlMJvbu3YuXlxdDhgzROpwGUxSFxMREoqOjycjIoEuXLsyYMYOAgACtQxNCiLbJzU3rCISFydc6ACEskCSUms/iEko1dHo9nfoNpFO/ga22Tb1ej6+vL76+vgwZMgRFUcjOzq5NMCUkJHDu3DkAOnToUJtgCg4Oxs3MP3jodDomTJiAvb09R48epaysjMmTJ9d50vj7+7N69Wqio6M5evQo8fHxzJo1q3aYjMFg4Pbt2/Wuv7S0lLt37zJp0qRW2R8tWFlZ4ebm1uYTSjWCg4OxsbFBp9ORmppKfHw8YWHte1Lby5cvk5GRwYoVK9pMX7WUlBSioqJITU0lMDCQZcuW0alTJ63DEkKItu3992HKFK2jEBbku8BBrYMQQqju73//O//zP/9DZmYm4eHh/N///R+DBw+ud9mPP/6YL774gtjYWAAGDhzIf//3fz9z+dZgsQklc6DT6ejQoQMdOnSoHQqUn59fm2BKSUnh8uXLQHX1ypONvj09Pc0ywzly5Ejs7OzYt28f5eXlREZG1rlwtra2ZuLEifTo0YMdO3awZs0axo8fz9ChQ/Hw8CAvLw+TyfTUxXZ8fDwmk6m28belelGVVltRWlrK+vXrcXR0ZMmSJRw+fJjNmzczdOhQJkyY0KaajquluLiYo0eP0r9/f4KCgrQO54UyMjKIiooiMTERHx8fFi9eTGhoqFm+7gghhBBCCGFpNm3axDvvvMOHH37IkCFD+POf/8zkyZNJSEiodyKrY8eO8corrzB8+HDs7e35/e9/z6RJk4iLi8Pf31+DPQCdIl31NFVcXExqamptkikzMxNFUXBycqozRM7b29usKh6uX7/Ojh07CAsLY/bs2fU2Ia+srOTIkSOcP3+eoKAg+vXrx65du/jBD35Q20+oxldffYXRaGTZsmWttQua2L17NxkZGaxevVrrUJqsqqqKr776iocPH/L666/j4eGBoiicO3eOw4cP4+/vz7x589pc/6Dm2rFjB7dv3+btt9/G0dFR63Ce6eHDh0RHRxMfH0+HDh0YN24cYWFhkkgSwkIVFBTg5uZGfn5+u3tdbixVm/mmpICZfblgrs2KRcME6XSkaR1EOyNNubXRGu9XNe+NsbGxuLi4qLbewsJCevfu3eB9GDJkCBEREfztb38DqttnBAYG8v3vf5+f//znL3y80WjEYDDwt7/9jaVLlzY7/qaQCiWNOTk5ERYWVjtUqLy8nLS0tNoE0+HDhzEajdjZ2REYGFibYPLz89N0Jrm+fftiZ2fHli1b2LhxIwsWLMDW1rbOMjY2NkydOpWwsDB27tzJ/v37AcjJyamTUCouLubevXtMmzatVfdBCwaDgbi4OBRFaZNvLIqisGvXLtLT01m6dGltc3GdTsfQoUPx9/dn69atrFmzhjlz5rSbGd+Sk5O5du0akZGRZptMysnJ4dixY9y4cQN3d3dmzZpFnz59zCpRLYQQFuPTT+E3v9E6CmFBVgG/1joIISxMS/VQKigoqHO7nZ3dU5N0VVRUcOnSJX7xi1/U3qbX65kwYQJnzpxp0PZKSkqorKzUdMInSSiZGTs7O0JDQwkNDQWqq0Hu379fO5PciRMnqKiowNramoCAgNoqpoCAgKcSOi2te/fuvPrqq2zYsIGvvvqKxYsXY29v/9RynTp14q233uLgwYNcvnyZ/fv389prr9X2jbp58yaAxQ93g+qEUnl5OaWlpWabeHiemoTEvHnz6h3WFRgYyOrVq9m2bRtfffUVY8aMYfTo0RadtDAajezbt4+AgAD69++vdThPyc/PJyYmhqtXr+Ls7Mz06dPp379/uxyWKIQQrebKFa0jEBbG/D5hCNH2tVRCqWbSrhrvvvsuv/71r+vc9vjxY4xGI97e3nVu9/b2Jj4+vkHb+5d/+Rf8/PyYMGFC04NuJkkomTlra+vaxt1QXQaXmZlZm2C6cOECx48fR6fT4efnV2eYnIODQ4vH17lzZ5YuXcq6dev4xz/+wZIlS+qdwc7W1pbIyEgSEhIoLCzk/fffZ/LkyfTv35+4uDhCQkLaZIKlsWoqs3Jzc9vc/l69epXjx4/z0ksv0atXr2cu5+joyOLFizlx4gTHjh0jPT2d2bNnt6mZDRvj7NmzPH78mDfffNOsqs6Kioo4ceIEly5dws7OjokTJzJo0CBsbGy0Dk0IISyfRr0shOW6r3UAQogGS0tLqzPk7dvVSWr43e9+x8aNGzl27Fi9RR2tRRJKbYxer8fPzw8/Pz+GDRuGoig8fvy4NsEUFxdXWyLn5eVVJ8HUUmNRAwICWLFiBV9++SVr166tU330bd7e3lhbW+Po6Mju3buJjY0lJSWFmTNntkhs5qamHDE3N1ezxmlNce/ePXbv3s2AAQMYMWLEC5fX6/WMGTOGgIAAtm3bxpo1a5g/f/5T2fq2rqb6Z/Dgwfj4+GgdDlDdMP3UqVOcP38evV7P6NGjGTJkSIu8kQkhhHiGP/1J6wiEhfmx1gEIYYFaqkLJ1dX1hdfeHTp0wMrKiqysrDq3Z2VlvfC64v/7//4/fve733HkyBH69u3bvKCbSRJKbZxOp6Njx4507NiRQYMGoSgK+fn5tbPIJSUlcfHiRaC6OubJmeQMBoNqTyAvL6+nkkqenp5PLWcwGEhPT+eVV14hLCyMr7/+GqgeNtRW+wo1hr29Pfb29m1qpreHDx+yefNmOnfuzLRp0xr1NwoJCWH16tVs3bqVzz//nIkTJzJkyBCL+TsfOHAAe3t7xo0bp3UolJeXc/bsWc6cOYPJZGLIkCEMHz68VSoVhRBCfMuCBbBrl9ZRCAuyGWgfX78K0T7Y2toycOBAjh49yqxZs4Dq0UhHjx7l7bfffubj/vCHP/Db3/6WgwcPMmjQoFaK9tkkoWRhdDod7u7uuLu7Ex4eDlQPfalp8p2amsrVq1cBcHZ2rpNg8vLyataFvoeHx1NJpW+PCbWrqiA/MYFrh/dj7+yCh6sLxeUV7Nmzh7t37zJ9+nScnZ2bHENbYDAY2kxCqaioiPXr1+Pm5sb8+fOb1HfH1dWVZcuWcfToUQ4ePEhqaiozZszQtDRTDbdv3yY+Pp558+ZpWv1TWVnJhQsXOHXqFOXl5QwaNIhRo0ZZ7BBDIYQQQgghLME777zDsmXLGDRoEIMHD+bPf/4zxcXFrFixAoClS5fi7+/Pe++9B8Dvf/97fvWrX7F+/Xo6depEZmYmUH1dr9U1tCSU2gFnZ2d69uxZ2/S6rKyMtLS02gTTwYMHMZlM2NvbExQUVJtg8vX1bXQCwdXVleXLl7Nu3To+//xzFi9ejL+/H7dOHOPy/l08TErEGjjyyR0AFHT49enH8FFjOHHpCu+//z7Tp09/bo+etq6tJJQqKirYsGEDJpOJxYsXNytpYmVlxaRJkwgMDGTnzp18/PHHzJ8/32yGiTVWZWUl+/fvJyQkRLNm8kajkcuXL3PixAmKi4vp168fY8aMkWnBhRDCHMybp3UEwsJs1ToAIYTqFi5cyKNHj/jVr35FZmYm/fr148CBA7VFGampqXUmN/rggw+oqKhg3rfeY+pr+t1adIqiKJpsWZiNysrKOjPJpaWlUVlZiY2NzVMzyTW0oW9ZWRkbNmzgwf10giuLyIyPQ6fTUd/ppvvmSTJu5VvcyS3k1q1b9OrVi2nTprW5xtUNceTIEWJjY/nRj36kdSjPZDKZ2Lx5M/fu3WPFihX4+vqqtu6cnBy2bNnC48ePmTZtmlnOjPYiUVFRnD59mrfeeqveoZ0tyWQycf36dWJiYsjLy6Nv376MGTNG0+lChRDmq6CgADc3N/Lz8yXh/AJqDsdWoqNh7FjV1qcGVfdPLh9a3Vidjhitg2hn1DzPLaXdQ2tojfermvfG+Ph4XFxcVFtvYWEhPXr0aFfvuZJQEk8xGo11ZpJLSUmhrKystiF4zTC5oKCg5w5bKi8v4+Of/ZCyrPs09CU08p1/pdzRhX379mFlZcXLL79Mjx491NkxM3Hp0iX27t3LL3/5S7Oduv3AgQOcP3+eV155ha5du6q+/poKnytXrtCvXz+mTZvWZmYfe/z4MR988AEjR45s1d5JiqJw8+ZNjh07xuPHjwkLC2PcuHF07Nix1WIQQrQ9klBqOFUTLpGRZtdDSRJKbdsunU56KLUySShpozUTSgkJCaonlLp3796u3nNlyJt4ipWVFf7+/vj7+zN8+HAUReHRo0e1jb6vXbvGqVOngOpZ24KDg2uTTE+O3Uy5eonyRiSTAA6v+Sur13xJp06d2LNnD5s2baJv375MmTLFYpoLGwwGFEUhLy+v1atbGuLcuXOcO3eOadOmtUgyCcDGxoYZM2YQFBTE3r17efDgAfPnzzfL4/EkRVHYt28fbm5ujBw5stW2eefOHaKjo8nMzCQ0NJTZs2fj5+fXKtsXQgghhBBCiPpIQkm8kE6nw8vLCy8vLyIiIlAUhdzc3Nrqpbt373L+/HkAPD09a4fIxe7ejk6vRzGZGrytsuIi7pw7RdjIsSxatIhr165x4MABkpKSmDFjBqGhoS21m63GYDAAkJuba3YJlISEBA4cOMCwYcOIiIho8e3169cPX19ftmzZwkcffcTMmTM160nUEHFxcSQlJbF48eJWqahKSkoiKiqK9PR0goODWbFiBUFBQS2+XSGEEM30v/+rdQTCwvxE6wCEsEA6nU7V6rH2WIkmCSXRaDqdDg8PDzw8POjXrx9QXd735BC5q+fO4HQ3vgnr1nPt8H7CRo5Fp9PRr18/OnfuzO7du1m3bh39+/dn8uTJms6q1Vxubm7o9Xqza8ydkZHB119/TVhYGBMnTmy17Xp7e/PGG2+we/dutmzZwpAhQ5g4caLZDQcsKyvj4MGDhIWFtVjlVo309HSioqJISkrCz8+PJUuW0KVLl3b5JiWEEG3S1q3wi19oHYWwIPOA32kdhBBCfIsklIQqXFxc6N27N7179wYg/txp9v7xRqPXoygmcu6n1bnNzc2NV199lUuXLnHo0CHu3bvHzJkz6dy5syqxtza9Xo+bm5tZJZTy8vJYv349Xl5ezJ49u9UTF3Z2dsydO5egoCAOHjzI/fv3mTdvHm5ubq0ax/NER0dTXl7OlClTWmwbmZmZREdHc/v2bby8vFi4cCHdu3eXRJIQQrQ1Z85oHYGwMMO0DkAIIeohCSXRIqz0Tb8ALisr5dixY7i5ueHu7o6bmxuurq4MGjSIkJAQdu3axRdffEFERAQTJkzA1tZWxchbh8FgMJuEUllZGevXr8fGxoZXXnlFs+bYOp2OwYMH4+fnx9atW1mzZg1z5swxi2GODx484MKFC0yYMKFFGuw9fvyYY8eOERcXh4eHB3PmzKF3796SSBJCqMacEvRg+U2d1+7ezUqVXsPVOlaWfszNkZrv45+ptib1mGPTanOMCdSLy9Jjam0y5K35JKEkWoSDczO65VvZcOnSJYqKiurc7OzsjJubG25ubnTq1IlLly5x69Ytxo8fT1hY2HNnnDM3BoOB9PR0rcPAaDSyefNmCgsLWbVqFU5OTlqHREBAAG+++Sbbt29n3bp1jB49mjFjxqDX6zWJR1EU9u7dS8eOHRkyZIiq687LyyMmJoZr167h6upKZGQk/fr102xfhRBCqGOl1gEIiyPnlBDCHElCSbQI367dsXd2oayosFGP0+n0DJw4lTFLVlBVVUVBQQF5eXnk5+c/9QNQVFTErl272LVrF7a2trUVTTU/T/7u7OxsNhfqBoOBGzduoCiKZplsRVHYs2cPKSkpvPbaa3To0EGTOOrj6OjI4sWLOXHiBMeOHSM9PZ05c+ZokvC6fPky9+/fZ8WKFar1dSosLOT48eNcvnwZBwcHpkyZwoABA7C2lpdkIYSwBDtBpngXqpJzSgj1SYVS88nVi2gRVtY29Js0jXM7tjRqljeTYiI+O5+AxES6dOlS2/y7PoqiUFBQwOnTp7l48SLW1tZ4enpiNBpJS0vjxo0blJeX1y6v1+txdXV9KulUk3hydXVtteFeBoOBiooKSkpKNKsKOnHiBFevXmX27Nl06tRJkxieR6fTMXr0aAIDA/n6669Zs2YN8+bNa9VZzoqLizly5Aj9+vVTZbslJSWcPHmSCxcuYGNjw/jx4xk8eLBmwwyFEEIIIYQQoqkkoSRaTPjEaVzev5vKsjIU5cVJJZ1OT0CffhQ5u/DVV18RHBzMSy+9RGBg4DOW1+Hm5sbUqVMZNGgQO3bsID4+nuHDhzN//nysra0pKyurU9WUl5dHQUEB2dnZ3Lt3j8LCuhVUTk5O9Sabav7fwcFBlcyzwWAAIDc3V5OE0o0bN4iOjmbs2LH07du31bffGJ07d2b16tVs3bqVzz//nAkTJjBs2LBW+QbgyJEjAEyYMKFZ6ykrK+PMmTOcPXsWgBEjRjB06NA2NUxTCCFEw+3ROgBhceScEkKYI0koiRbj7OHJ7H/5FV//9lcYjVXPrVTS6XT4hHZlzk//FWtbO+7cuUNUVBSfffYZXbt2Zfz48fj4+Dzz8R07dmTVqlWcPHmSmJgY7ty5w6xZs/D19cXe3h5vb+96H2c0GikoKKhNNj2ZfLpz5w75+flUVVXVLm9jY/NUkunJ311cXBo0rO7JhFJAQMALl1dTSkoKO3fuJDw8nNGjR7fqtpvKxcWFZcuWcfToUQ4fPkxaWhozZ85s0YRMSkoKV69e5eWXX25y0q+iooLz589z6tQpqqqqGDx4MCNGjMDR0VHlaIUQQpiTWK0DEBZHzikh1CdD3ppPp8iUD6KFZd27y76//S8599PQ6a1QTMba+3Q6Peig5+jxvLTqLWxs7WrvUxSFuLg4oqOjycnJoVevXowbNw5PT8/nbi8zM5MdO3bw6NEjRo0axahRo5rc+0ZRFIqLi5+qcnry99LS0if2R4erq2udYXTfTj7VzEr3hz/8gaFDh7ZqUufx48d8+umn+Pj4sGTJEtV6ArWmhIQEtm/fjqOjIwsWLHhuorGpjEYjH330ETY2NqxatarRbw5VVVVcunSJEydOUFpaysCBAxk1ahQuLs1oVi+EEE1QUFBgdjO8gXnOOKbmhYCa/W7M8ViJhjHXc0ot5jijmjnGBOY5o5o5xgSQn5/fIrMqP6nmvTExMVHVz+eFhYWEhIS0yj6YC0koiVahKAr3E25y7dA+HqUkUVlejoOLCyGDhtBn/GScDfX3SQIwmUxcvXqVmJgYCgsL6devH2PGjHnuB2Sj0cjx48c5ceIE3t7ezJo165lVSs1VUVFRb6Kp5rbCwsI6L9gODg64u7uTm5uLs7MzAwYMqFPl5Ojo2CLZ7eLiYj799FOsrKxYtWpVmx5ulZuby5YtW3j48CHTpk2jf//+qh6z06dPc+TIEd544w18fX0b/Dij0ci1a9dqz9Xw8HDGjBmDu7u7arEJIURjSEKp4cz14t8cj5VoGHM9p9Rijskbc4wJzDN5Y44xQesmlO7du6d6QqlLly6SUBLCHFVVVXHx4kVOnDhBeXk5gwYNYtSoUc8djpSRkcGOHTvIzs5m7NixjBgxotVnejMajRQWFj5V4XT79m3KysoA6gyrs7a2fmYPJ3d3d1xcXBpdWVRZWckXX3xBbm4ur7/+ukUkOKqqqjhw4ACXLl0iPDycadOm1VZ/NUd+fj5///vfGTBgAFOmTGnQYxRFITY2lmPHjtVW040dO9asZs4TQrRPklBqODUvinqj3hAlczxWomHM9ZxSizkmb8wxJjDP5I05xgSSUGprJKEk2pzy8nLOnTvH6dOnMZlMDB06lOHDhz+z4qaqqopjx45x+vRp/Pz8mDVrlllc6B89epTr16/zox/9iNLS0mdWOOXn51NSUlL7OJ1Oh4uLy3Obh9vZ1R06uHXrVm7fvs3y5cvx9/fXYndbzPXr19mzZw/u7u4sWLCg2X/bzZs3k5aWxttvv13nONZHURQSEhKIjo7m4cOHdOvWjXHjxrXIMDwhhGgKSSg1nJoXRe8Af1RpXeZ4rETDmOs5pRZzTN6YY0xgnskbc4wJWjehlJSUpHpCqXPnzu0qoSRNuUWbY2dnx+jRo4mIiODUqVOcOXOGCxcuMGLECAYPHvxUlYq1tTUTJkyge/fu7Ny5kzVr1jB+/HiGDBnS6tVKTzIYDBQUFGA0GnF0dMTR0RE/P796l62srHxmD6f09HQKCgowPdH03N7evjbJlJ+fT2ZmJsOHD0dRFIqKinBycrKYpnF9+/bFx8eHLVu28PHHHxMZGUnv3r2btK47d+5w69Yt5s6d+9xkkqIoJCYmEh0dTUZGBl26dCEyMrLVG6wLIYQwT2Mwv4t/0bbJOSWEMEdSoSTavMLCQk6cOMGlS5dwcHBg9OjRDBgwAGvrp/OllZWVHD16lHPnzhEUFMTMmTPx8Hh2/6aWlJSUxBdffMH3vve9ZlfVmEymOsPqahJPqampPHr0CCsrK4zGfzZDt7Kyem6Fk6ura73Hz5xVVFSwe/duYmNjiYiIYNKkSc/cB0VRqCyvHm5oY2ePTqejsrKSDz74AIPBwJIlS56ZcEtJSSEqKorU1FQCAwMZP348nTp1aqndEkKIZpEKpYZT84uWdcCrKq3LHI+VaBhzPafUYo7VQOYYE5hnNZA5xgRSodTWSEJJWIy8vDxiYmK4du0arq6ujB07lr59+9ZbhZSSksKOHTsoLi5mwoQJREREtHrFTl5eHn/5y19YvHgxXbt2VX39d+7cYcOGDQwaNIgpU6ZQXl7+3ObhxcXFdR7v7Oz81Ax1TyaezLGpt6IoXLx4kQMHDuDr68u8efPq9It6nJbCtcP7iDt2tE5CqdfYlyh368jlW/G89dZb9c4kmJGRQVRUFImJifj4+DB+/HhCQ0MtptJLCGGZJKHUcOb6em6Ox0o0jLmeU2oxx+SNOcYE5pm8MceYoPUTSmpuq6CgQBJKQrR1jx494tixY9y8eZMOHTowbtw4wsLCnnqxq6io4PDhw1y8eJHOnTszY8aMVm1WbTKZ+O1vf8vkyZMZPHiwquvOzMxk7dq1dOrUiYULFzZoaF9VVdVTSaaCgoI6Cagnh9XZ2dk9t8rJxcVFsw9S9+/fZ8uWLVRUVDB79my6dO7EoY/+j5sxUej0epQn9gOovc2jW0+WvvtbrKxtau97+PAh0dHRxMfHP/d8EkIIcyQJpYZT83V9M7BApXWZ47ESDWOu55RazDF5Y44xgXkmb8wxJpCEUlsjCSVhsTIyMoiOjubu3bv4+voyfvx4QkJCnnrRu3fvHjt37qSsrIzJkyerPgX98/zf//0f3bp1Y/Lkyaqts6CggE8++QRnZ2eWL1+uysxnQG3/pfqqnGp+Ly8vr11er9fj6ur6VJXTk7+35LC60tJStm/fzp3bt/ErzqYgLRle9HKn09FlQAQzf/pL8vLyOXbsGDdu3MDd3Z2xY8fSp08fTftuCSFEY0lCqeHMdYp3czxWomHM9ZxSizkmb8wxJjDP5I05xgStm1BKTk5WPaHUqVMnSSgJYUlSUlI4evQoaWlpBAUFMX78eIKDg+ssU1ZWxsGDB7l69SqhoaFERka2yovAV199hbW1NYsWLVJlfeXl5axdu5bS0lJef/11VccEN0RZWdkzm4fn5+dTWFhYZ3knJ6faJNO3k0/u7u7Y29s3601KURQ2/+X/I+1MDI1ZS4f+Q0ipUHB2dmb06NH0798fKyurJschhBBakYRSw6l5UfQ28DeV1mWOx0o0jLmeU2oxx+SNOcYE5pm8MceYQBJKbU3b6rorRBMEBwezYsUK7t69S1RUFJ9//jmhoaGMHz8eX19foHpWtJkzZxIWFsbu3bv54IMPmDJlCn379m3RaiWDwUBqaqoq6zKZTGzdupW8vDxWrFjR6skkqD6O9vb2eHt713u/0Wh8ahhdzdC6zMxM8vPz6zQPt7W1fWpY3ZNVTi4uLs+tGDIZjeTEXW1UMkkBHt24zITv/pSIwYOxsbF54WOEEEKIJ53SOgBhceScEkKYI0koiXZBp9PRtWtXQkNDuXnzJtHR0Xz00Uf07NmTcePG1c6y1q1bN7773e9y4MABduzYwa1bt3j55ZdxdnZukbgMBgPXrl1DUZRmV+Ls27ePe/fusXjx4mcmdLRmZWWFwWDAYDDUe7+iKBQXF9db5XT//n3i4uIoKyurXV6n0+Hq6vrUULqan8e3b1FSkN+oGHUAVZV0tNFJMkkIIUST/BrzG54k2rZfI+eUEGrT6XSqFg+0xx6rklAS7YpOp6NXr16EhYVx7do1YmJieP/99wkPD2fMmDG4u7vj4ODA7Nmz6dGjB3v37uX9999n2rRp9O7dW/V4DAYDlZWVFBcXNytpdfr0aS5dukRkZCQhISEqRti6dDodzs7OODs74+/vX+8yNbPVfbvCKTc3l+TkZAoLC2tLeG0zU7BBh47GlfTqraxIu3mDroOHN3ufhBBCPM0ch22oaUZkJMquXVqHITSm5rm5ywwvVM3x4tkcYwLLH9In2i9JKIl2Sa/X079/f/r06cOlS5c4ceIE169fZ+DAgYwePRpnZ2fCwsIICgpi3759fP3119y6dYvp06fj6OioWhw1lTq5ublNTijFxcVx5MgRRo4cyYABA1SLzVzZ2dnh5eWFl5dXvfcbjUYKCwvJz8/n1Jef8CD3EY3MJ6EoUFFSokK0Qggh2qV//3etIxAW5j+1DkAICyQVSs0n0xWJds3a2pohQ4bwgx/8gLFjx3Ljxg3++te/cuTIEUpLS3FycmL+/PnMnTuXpKQk3n//feLj41Xb/pMJpaZIS0tj+/bt9O7dm/Hjx6sWV1tVWVlJZmYm9+7dIy4ujpz8/BdO7FYfnQ5s7O3VD1AIIUT7cP681hEICzNY6wCEEKIeUqEkBNXNn0eNGsWgQYM4ffo0586d4+LFi4wYMYIhQ4bQu3dvOnXqxO7du9m0aRN9+/ZlypQpODg4NGu7dnZ2ODo6NimhlJOTw8aNG/H392fmzJntKiOuKApFRUVkZmaSlZVFVlYWmZmZZGdn1/aj8vT0xMXHj/LUe41ev8loxCekWwtELoQQol04eBC+9z2toxAWZDLwvtZBCCHEt0hCSYgnODg48NJLLzFkyBBOnDhBTEwM586dY9SoUQwcOJBFixZx7do1Dhw4QFJSEpGRkXTt2rVZ2zQYDI1OKJWWlrJ+/Xrs7e1ZuHAh1taW+1Q2Go08fvy4NmlU82/JN0PS7Ozs8Pb2pnPnzgwbNgxvb2+8vLywsbGhsqKcD9+8REVpaaO2aevgSPdho1pid4QQQrQHFvy+LLRRpXUAQlggGfLWfPJuJ0Q9nJ2dmTp1KsOGDSMmJoaDBw9y+vRpxo4dS3h4OF26dGHXrl2sX7+e/v37M3nyZOzs7Jq0rcYmlKqqqti4cSMlJSW8/vrrqvZ00lppaelTiaNHjx5hNBoBcHd3x8fHh4iICHx8fPD29sbd3f2ZL942tnaET5zGxd3bGtzEUKfTET5pGta2tqrtlxBC1Oe9995j27ZtxMfH4+DgwPDhw/n9739P9+7da5cpKyvjJz/5CRs3bqS8vJzJkyfz/vvvm+1snuIb27ZpHYGwMHO1DkAIIeohCSUhnsPd3Z2ZM2cyYsQIjh07xq5duzh16hTjxo1j8eLFXLlyhUOHDnHv3j1mzJhBly5dGr0Ng8FASkpKg5ZVFIVdu3Zx//59li1bhoeHR6O3Zw4URSE3N5fMzMw6w9by8/OB6t5WXl5e+Pr60r9/f7y9vfH29sa+CX2Nhs1fTGrcdR4mJaKYTM9dVqfX4905lGHzXmnSfgkhRGPExMTwve99j4iICKqqqvjXf/1XJk2axM2bN3FycgLgxz/+MXv37mXLli24ubnx9ttvM2fOHE6dOqVx9OK5liyBr77SOgphQb4EXtM6CCGE+BadYo5zrQphph48eEB0dDR37tzB29ub8ePH07FjR3bt2kVycjKDBg1i4sSJ2DaiuuXKlSvs2rWLX/7yly8cuhYVFcWJEyeYN28evXr1au7utIqKigoePnxYp+ro4cOHVFRUANXVYN7e3rUVRz4+Pnh6eqLXqzdnQHlJMTv/579Iu3kDnV7/VGKp5rbAXn2Z+dNfYufopNq2hRCioR49eoSXlxcxMTGMHj2a/Px8OnbsyPr165k3bx4A8fHxhIWFcebMGYYOHfrCdRYUFODm5tbSoWtKrY+yag5VUCIjYdcu1dYnxC6djplaByE0p+alu7kOz8rPz8fV1bVFt1Hz3pienq7qtgoKCggICGiVfTAXUqEkRCP4+vqyePFiUlNTOXr0KBs2bCAwMJBx48YRFhbGkSNHSExMZObMmQQHBzdonU/O9NaxY8dnLnflyhVOnDjBSy+9ZJbJJEVRKCwsrJM4ysrKIjs7G6h+0+rYsSPe3t706NGjNoHk7Ozc4rHZOTox/99/S/K1y1w5uIekKxfr3N8pfCD9p7xMp7790amYyBJCiMaoqdKsqT69dOkSlZWVTJgwoXaZHj16EBQU9MyEUnl5OeXl5bW/FxQUtHDUol6jpA+fUNcJrQMQQoh6SEJJiCYICgpi+fLlJCYmEhUVxRdffEFISAizZ8/mzJkzfP755wwZMoSXXnoJGxub566rIQmle/fusWfPHgYMGMCIESNU35/GMhqNPHr06KlZ1kq/aX5tb2+Pt7c3ISEhjBgxAh8fHzp27Khp83CdXk/n/oPo3H8QpYUFFOdV961ycjfg4NI+vkEQQpgvk8nEj370I0aMGEHv3r0ByMzMxNbWFnd39zrLent7k5mZWe963nvvPX7zm9+0dLjiRaZP1zoCYWH2ah2AEELUQxJKQjSRTqcjNDSUkJAQbt26RXR0NJs3b6ZHjx4MHz6cc+fOcffuXWbNmkVAQMAz1+Pq6oqVlRXZjx+jhIY+VSHz8OFDNm/eTOfOnZk+fXqrl6eWlJQ8lTh69OgRpm+GjRkMBnx8fBgyZEht1ZGbm5vZltECOLi4ShJJCGFWvve97xEbG8vJkyebtZ5f/OIXvPPOO7W/FxQUEBgY2NzwRGP9/Ocy5E2o6ncgQ96EEGZHEkpCNJNOp6Nnz5706NGD69evc+zYMRISEujWrRt5eXl89tlnDB8+nLFjxz5VoZN59zZXD+/DIe4Cp2+c5fRfwLWjF+ETp9F73ERMeivWr1+Pm5sb8+fPV7Wv0LeZTCZycnKemmWtsLAQqG6U7e3tjb+/PwMHDsTHxwcvL68mz24nhBCi2ttvv82ePXs4fvx4nS8gfHx8qKioIC8vr06VUlZWFj4+PvWuy87OTl6XhRBCiAbQ6XSqfgluzl+otxRpyi2Eyqqqqrh8+TLHjx+npKQEPz8/Hjx4gKenJ7NmzcLPz4+y4iL2/Pl3pFy/ik5vhWIy1lmHTqdDp9djExJGhcGLVatWqdpUtby8vLZRdk3y6OHDh1RWVgLg4uJSp0m2t7c3Hh4eLZrQEkKI9kZRFL7//e+zfft2jh07RteuXevcX9OUe8OGDcydWz1peEJCAj169JCm3E8wy6bcJ07AyJGqrU+IkTodMrejkKbc6qh5b7x//77qTbn9/f2lKbcQoumsra0ZPHgw/fr14/z585w6dQqdTkdJSQmffPIJw4cM4f7hXWTfTwN4KpkE1W8WitFI+e1YwqfPbvLFgKIoFBQU1EkcZWZmkptb3T9Ir9fXNsru1atXbQLJ0dGx6QdACCFEg3zve99j/fr17Ny5ExcXl9q+SG5ubjg4OODm5saqVat455138PDwwNXVle9///sMGzasQckkoaGEBEkoCVV1B0koCSHMjlQoCdHCysrKOHPmDKdPn0ZRFGxS72Cdn92odcz7t/8iuE+/5y5TVVVVp1F2zb9lZWUAODg41FYb1SSOOnTooGmjbCGEaM+e9e3w2rVrWb58OVD9HvKTn/yEDRs2UF5ezuTJk3n//fefOeTt26RCqeFUrVCKjJQeSkJVu3Q66aEkpEJJJTXvjRkZGapXKPn5+UmFkhBCPfb29owbN47BgwcTfegA8TfONurxOr2eS3t31EkoFRcXP5U4evz4cW2jbE9PT7y9vRk2bBg+Pj74+Pjg4uJitm8cQgjRHjXkwsDe3p6///3v/P3vf2+FiIQQQgghGk4SSkK0EicnJzyqytHrdI36dkExmUi6cpF9278mt6SMzMxMioqKALCxscHb25vAwEAiIiJqG2Xb2tq21G4IIYQQ4kW2b9c6AmFhZmsdgBBC1EMSSkK0opTrV5pcqhp//iy+fQfQv3//Oo2ypepICCGEMDOrV8Mnn2gdhbAga4A3tA5CCAsjs7w1nySUhGhFZcVFTXqcTqdj7KiRDJgmo+eFEEIIs/fwodYRCAvjpXUAQghRD0koCdGKbOztm/Q4RVGwtmvaY4UQQgi1GoSq9e2rxc8JM3iw1hE8RdWm45b+9zND51Vaj7n+7Sy9ssMsJw8ww5hE26PXOgAh2hPf0O7o9E172nl3CVU5GiGEEEK0iFde0ToCYWE2aB2AEELUQxJKQrSi8IlTUb6Zia2hdDod3l1C8e4c0kJRCSGEEEJVP/6x1hEIC/MnrQMQwgLV9FBS86e9kYSSEK2oQ2AwAWG9GlWlpCgKA6bOaMGohBBCCCGEEEKIxpGEkhCtbMp3f4ydk1PDkko6Hd2HjyZs5NgWj0sIIYQQKvnhD7WOQFiYv2gdgBBC1EMSSkK0MjcvHxb95g84uXtU31BPaaRObwVAz1HjmPq9Hze575IQQgghNPDggdYRCAvjq3UAQlggGfLWfHKVKoQGPP0DWfGnD5jw+vfw9A+sc59Or6frkGEsePc9pnz3x1hZ22gUpRBCCCGaZPNmrSMQFmaB1gEIIUQ9rLUOQIj2ytbegfCJU+k7YQr5WZmUFORjZW2Na0cvHFyaP7WzEEIIIYQQQgjRUiShJITGdDod7j6+uPtIMbMQQghhETZu1DoCYWEWaR2AEELUQ4a8CSGEEEIIoaaf/UzrCISF+R+tAxBCiHpIhZIQQgghhBBqSkvTOgJhYQJfvIgQopHUbqQtTbmFEEIIIYQQzRMernUEwsJc0zoAIYSohySUhBBCCCGEUNPq1VpHICzMGq0DEEKIekhCSQghhBBCCDV997taRyAszPtaByCEBaoZ8qbmT3sjCSUhhBBCCCGEEEII0SiSUBJCCCGEEEJNMuRNqEyGvAkhzJEklIQQQgghhFBTSYnWEQgL46h1AEIIUQ9JKAkhhBBCCKGmL7/UOgJhYV7TOgAhLJD0UGo+a60DEEIIIYQQ7YuaH7oVRVFtXWrZtXs3M1XaR7X2zxyPk2jb2uPFc1OZ47FSKya1XlsKCgpwc3NTZV2i9UiFkhBCCCGEECparnUAwuIs1zoAIYSohySUhBBCCCGEUNG/aR2AsDhyTgmhPhny1nySUBJCCCGEEEJFoVoHICyOnFNCCHMkCSUhhBBCCCFUlKB1AMLiyDklhDBH0pRbCCGEEEIIFf1e6wCExZFzSgj1qT1MTYa8CSGEEEIIIZrlM60DEBZHzikhhDmShJIQQgghhBBCCCGEaBRJKAkhhBBCCKGiz7UOQFicz7UOQAgh6iE9lIQQQgghhFBRpdYBCIsj55QQ6pMeSs0nFUpCCCGEEEKo6A2tAxAWR84pIYQ5koSSEEIIIYQQQgghhGgUGfImhBBCCCGEir6jdQDC4sg5JYT6ZMhb80mFkhBCCCGEECp6W+sAhMWRc0oIYY4koSSEEEIIIYSKemsdgLA4ck4JIcyRJJSEEEIIIYRQUYrWAQiLI+eUEOqrGfKm5k9j/f3vf6dTp07Y29szZMgQzp8//9zlt2zZQo8ePbC3t6dPnz7s27evqbuvCkkoCSGEEEIIoaJ/1ToAYXHknBLC8mzatIl33nmHd999l8uXLxMeHs7kyZN5+PBhvcufPn2aV155hVWrVnHlyhVmzZrFrFmziI2NbeXI/0mnKIqi2daFEEIIIUSLKSgowM3Njfz8fFxdXZu9PnNsOKrWR1k1920nMFOldclHdQGwS6dT5ZxS83wyx9cD0frUOqfUfr/SYluNXe+QIUOIiIjgb3/7GwAmk4nAwEC+//3v8/Of//yp5RcuXEhxcTF79uypvW3o0KH069ePDz/8ULX9aAyZ5U0IIYQQwkLVfNAvKCjQOJKWY477VqLiusxx/0TrU+uckvNJqE2tc6pmPa2ZRFf7+VCzvm+v187ODjs7uzq3VVRUcOnSJX7xi1/U3qbX65kwYQJnzpypd/1nzpzhnXfeqXPb5MmT2bFjhwrRN40klIQQQgghLFRhYSEAgYGBGkfSctzc3LQO4SmvqLguc9w/0XbJ+STUpvY5VVhY2OLnqa2tLT4+Pi3y3ujs7PzUet99911+/etf17nt8ePHGI1GvL2969zu7e1NfHx8vevOzMysd/nMzMzmB95EklASQgghhLBQfn5+pKWl4eLi8szhKQUFBQQGBpKWltbiwwxENTnmrU+OeeuTY9762vIxVxSFwsJC/Pz8Wnxb9vb2JCUlUVFRofq6FUV56v3229VJlkQSSkIIIYQQFkqv1xMQENCgZV1dXdvcBUhbJ8e89ckxb31yzFtfWz3mrVlBZ29vj729fatt79s6dOiAlZUVWVlZdW7PysrCx8en3sf4+Pg0avnWILO8CSGEEEIIIYQQQrQSW1tbBg4cyNGjR2tvM5lMHD16lGHDhtX7mGHDhtVZHuDw4cPPXL41SIWSEEIIIYQQQgghRCt65513WLZsGYMGDWLw4MH8+c9/pri4mBUrVgCwdOlS/P39ee+99wD44Q9/yJgxY/jf//1fpk+fzsaNG7l48SIfffSRZvsgCSUhhBBCiHbMzs6Od99916J7PJgbOeatT45565Nj3vrkmLctCxcu5NGjR/zqV78iMzOTfv36ceDAgdrG26mpqej1/xxUNnz4cNavX8+//du/8a//+q907dqVHTt20Lt3b612AZ3SmvPyCSGEEEIIIYQQQog2T3ooCSGEEEIIIYQQQohGkYSSEEIIIYQQQgghhGgUSSgJIYQQQgghhBBCiEaRhJIQQgghhBBCCCGEaBRJKAkhhBBCtGN///vf6dSpE/b29gwZMoTz589rHZLF+vWvf41Op6vz06NHD63DsijHjx8nMjISPz8/dDodO3bsqHO/oij86le/wtfXFwcHByZMmMCdO3e0CdZCvOiYL1++/KnzfsqUKdoEayHee+89IiIicHFxwcvLi1mzZpGQkFBnmbKyMr73ve/h6emJs7Mzc+fOJSsrS6OIhaWShJIQQgghRDu1adMm3nnnHd59910uX75MeHg4kydP5uHDh1qHZrF69erFgwcPan9OnjypdUgWpbi4mPDwcP7+97/Xe/8f/vAH/vrXv/Lhhx9y7tw5nJycmDx5MmVlZa0cqeV40TEHmDJlSp3zfsOGDa0YoeWJiYnhe9/7HmfPnuXw4cNUVlYyadIkiouLa5f58Y9/zO7du9myZQsxMTFkZGQwZ84cDaMWlkinKIqidRBCCCGEEKL1DRkyhIiICP72t78BYDKZCAwM5Pvf/z4///nPNY7O8vz6179mx44dXL16VetQ2gWdTsf27duZNWsWUF2d5Ofnx09+8hN++tOfApCfn4+3tzeff/7/t3fnIVH1exzHP9PYIpSKpU4SpS2jtiFamVhGOWQSQTuGUBNJERmULRRhtqe0EBUGQWhBC1FUEBWBZZFFy1DSYlZiWYRZ1lRGq87zx8Mz3Lnd5+HOvZOHZt4vEPR3DsfPGb5/ffidM2XKzs42MK1/+PfPXPpzh5LT6fxp5xJ85/Xr14qMjNSlS5eUnp6u9+/fKyIiQocOHdLUqVMlSQ8fPlRCQoKuXbum4cOHG5wY/oIdSgAAAAHo27dvcjgcstls7rV27drJZrPp2rVrBibzb48fP1Z0dLR69+6tnJwc1dfXGx0pYNTV1amhocFj5kNDQ5WSksLM/2IVFRWKjIxUXFyc5s+fr6amJqMj+ZX3799LksLDwyVJDodD379/95j1+Ph49ezZk1mHT1EoAQAABKA3b96opaVFUVFRHutRUVFqaGgwKJV/S0lJUVlZmc6dO6c9e/aorq5OI0eO1MePH42OFhD+mmtmvm2NGzdOBw4cUHl5uYqLi3Xp0iVlZWWppaXF6Gh+obW1VYsWLVJaWpoGDhwo6c9Z79Chg8LCwjzOZdbha0FGBwAAAAACQVZWlvv3wYMHKyUlRb169dLRo0c1Z84cA5MBv86/Pko4aNAgDR48WH369FFFRYUyMjIMTOYfFixYoHv37vE+NhiCHUoAAAABqFu3bjKbzT9968+rV69ksVgMShVYwsLCZLVa9eTJE6OjBIS/5pqZN1bv3r3VrVs35t4H8vLydPr0aV28eFE9evRwr1ssFn379k1Op9PjfGYdvkahBAAAEIA6dOig5ORklZeXu9daW1tVXl6u1NRUA5MFjubmZtXW1qp79+5GRwkIsbGxslgsHjP/4cMHXb9+nZlvQy9evFBTUxNz/39wuVzKy8vTiRMndOHCBcXGxnocT05OVvv27T1mvaamRvX19cw6fIpH3gAAAAJUfn6+Zs2apSFDhmjYsGHasWOHPn36pNmzZxsdzS8tXbpUEyZMUK9evfTy5UsVFhbKbDZrxowZRkfzG83NzR47X+rq6nTnzh2Fh4erZ8+eWrRokTZs2KB+/fopNjZWBQUFio6O9vhWMnjnnz7z8PBwrV27VlOmTJHFYlFtba2WL1+uvn37KjMz08DUv7cFCxbo0KFDOnXqlLp06eJ+L1JoaKiCg4MVGhqqOXPmKD8/X+Hh4QoJCdHChQuVmprKN7zBp0wul8tldAgAAAAYY/fu3dqyZYsaGhqUmJionTt3KiUlxehYfik7O1uXL19WU1OTIiIiNGLECG3cuFF9+vQxOprfqKio0OjRo39anzVrlsrKyuRyuVRYWKi9e/fK6XRqxIgRKikpkdVqNSCtf/inz3zPnj2aOHGibt++LafTqejoaI0dO1br16//6eXo+O+ZTKb/uF5aWiq73S5J+vLli5YsWaLDhw/r69evyszMVElJCY+8wacolAAAAAAAAOAV3qEEAAAAAAAAr1AoAQAAAAAAwCsUSgAAAAAAAPAKhRIAAAAAAAC8QqEEAAAAAAAAr1AoAQAAAAAAwCsUSgAAAAAAAPAKhRIAAAAA/I9iYmK0Y8cOo2MAQJujUAIAAADg1+x2u0wmk4qKijzWT548KZPJZFAqAPi9USgBAAAA8HudOnVScXGx3r17Z3QUAPALFEoAAAAA/J7NZpPFYtHmzZv/9pzjx49rwIAB6tixo2JiYrRt2zaP442NjZowYYKCg4MVGxurgwcP/nQNp9Op3NxcRUREKCQkRGPGjFFVVZX7eFVVlUaPHq0uXbooJCREycnJunXrlu9uFADaCIUSAAAAAL9nNpu1adMm7dq1Sy9evPjpuMPh0PTp05Wdna27d+9qzZo1KigoUFlZmfscu92u58+f6+LFizp27JhKSkrU2NjocZ1p06apsbFRZ8+elcPhUFJSkjIyMvT27VtJUk5Ojnr06KGbN2/K4XBoxYoVat++/S+9dwD4FYKMDgAAAAAAbWHSpElKTExUYWGh9u3b53Fs+/btysjIUEFBgSTJarXqwYMH2rJli+x2ux49eqSzZ8/qxo0bGjp0qCRp3759SkhIcF/jypUrunHjhhobG9WxY0dJ0tatW3Xy5EkdO3ZMc+fOVX19vZYtW6b4+HhJUr9+/dri1gHA59ihBAAAACBgFBcXa//+/aqurvZYr66uVlpamsdaWlqaHj9+rJaWFlVXVysoKEjJycnu4/Hx8QoLC3P/XVVVpebmZnXt2lWdO3d2/9TV1am2tlaSlJ+fr9zcXNlsNhUVFbnXAeB3Q6EEAAAAIGCkp6crMzNTK1eu9Pm1m5ub1b17d925c8fjp6amRsuWLZMkrVmzRvfv39f48eN14cIF9e/fXydOnPB5FgD41XjkDQAAAEBAKSoqUmJiouLi4txrCQkJqqys9DivsrJSVqtVZrNZ8fHx+vHjhxwOh/uRt5qaGjmdTvf5SUlJamhoUFBQkGJiYv72/1utVlmtVi1evFgzZsxQaWmpJk2a5NN7BIBfjR1KAAAAAALKoEGDlJOTo507d7rXlixZovLycq1fv16PHj3S/v37tXv3bi1dulSSFBcXp3HjxmnevHm6fv26HA6HcnNzFRwc7L6GzWZTamqqJk6cqPPnz+vp06e6evWqVq1apVu3bunz58/Ky8tTRUWFnj17psrKSt28edPjPUwA8LugUAIAAAAQcNatW6fW1lb330lJSTp69KiOHDmigQMHavXq1Vq3bp3sdrv7nNLSUkVHR2vUqFGaPHmy5s6dq8jISPdxk8mkM2fOKD09XbNnz5bValV2draePXumqKgomc1mNTU1aebMmbJarZo+fbqysrK0du3atrx1APAJk8vlchkdAgAAAAAAAL8PdigBAAAAAADAKxRKAAAAAAAA8AqFEgAAAAAAALxCoQQAAAAAAACvUCgBAAAAAADAKxRKAAAAAAAA8AqFEgAAAAAAALxCoQQAAAAAAACvUCgBAAAAAADAKxRKAAAAAAAA8AqFEgAAAAAAALxCoQQAAAAAAACv/AEHVFK5QMppQAAAAABJRU5ErkJggg==",
 34:       "text/plain": [
 35:        "<Figure size 1200x500 with 3 Axes>"
 36:       ]
 37:      },
 38:      "metadata": {},
 39:      "output_type": "display_data"
 40:     }
 41:    ],
 42:    "source": [
 43:     "import networkx as nx\n",
 44:     "import matplotlib.pyplot as plt\n",
 45:     "import numpy as np\n",
 46:     "\n",
 47:     "def plot_sbm_graph(block_sizes, p_matrix):\n",
 48:     "    # Validate the connectivity matrix\n",
 49:     "    n_blocks = len(block_sizes)\n",
 50:     "    if p_matrix.shape != (n_blocks, n_blocks):\n",
 51:     "        raise ValueError(\"The connectivity matrix dimensions must match the number of blocks.\")\n",
 52:     "    if np.any(p_matrix < 0) or np.any(p_matrix > 1):\n",
 53:     "        raise ValueError(\"All probabilities in the connectivity matrix must be between 0 and 1.\")\n",
 54:     "\n",
 55:     "    # Generate Stochastic Block Model graph\n",
 56:     "    G = nx.stochastic_block_model(block_sizes, p_matrix)\n",
 57:     "\n",
 58:     "    # Get adjacency matrix\n",
 59:     "    adj_matrix = nx.to_numpy_array(G)\n",
 60:     "\n",
 61:     "    # Assign colors based on block membership\n",
 62:     "    colors = [G.nodes[node]['block'] for node in G.nodes]\n",
 63:     "\n",
 64:     "    # Plotting the graph\n",
 65:     "    pos = nx.spring_layout(G, seed=42)  # For consistent layout\n",
 66:     "    plt.figure(figsize=(12, 5))\n",
 67:     "\n",
 68:     "    # Subplot 1: SBM graph\n",
 69:     "    plt.subplot(1, 2, 1)\n",
 70:     "    nx.draw(G, pos, node_color=colors, cmap=plt.cm.tab10, with_labels=False,\n",
 71:     "            node_size=100, edge_color='gray')\n",
 72:     "    plt.title('Stochastic Block Model')\n",
 73:     "\n",
 74:     "    # Subplot 2: Adjacency matrix with visible block structure\n",
 75:     "    plt.subplot(1, 2, 2)\n",
 76:     "    plt.imshow(adj_matrix, cmap='Greys', interpolation='none')\n",
 77:     "    plt.colorbar(label='Edge Weight')\n",
 78:     "    plt.title('Adjacency Matrix')\n",
 79:     "    plt.xlabel('Nodes')\n",
 80:     "    plt.ylabel('Nodes')\n",
 81:     "\n",
 82:     "    # Overlay block boundaries for visual separation\n",
 83:     "    block_boundaries = np.cumsum([0] + block_sizes)\n",
 84:     "    for boundary in block_boundaries:\n",
 85:     "        plt.axhline(boundary - 0.5, color='red', linestyle='--', linewidth=0.5)\n",
 86:     "        plt.axvline(boundary - 0.5, color='red', linestyle='--', linewidth=0.5)\n",
 87:     "\n",
 88:     "    plt.tight_layout()\n",
 89:     "    plt.show()\n",
 90:     "\n",
 91:     "# Example usage\n",
 92:     "block_sizes = [5, 8, 10]  # Sizes of each block\n",
 93:     "p_matrix = np.array([[0, 0.1, 0.5],\n",
 94:     "                     [0.1, 0.6, 0.1],\n",
 95:     "                     [0.5, 0.1, 0.8]])  # Full inter-block connectivity matrix\n",
 96:     "\n",
 97:     "plot_sbm_graph(block_sizes, p_matrix)\n"
 98:    ]
 99:   },
100:   {
101:    "cell_type": "code",
102:    "execution_count": null,
103:    "metadata": {},
104:    "outputs": [],
105:    "source": []
106:   }
107:  ],
108:  "metadata": {
109:   "kernelspec": {
110:    "display_name": "anon_sbm",
111:    "language": "python",
112:    "name": "python3"
113:   },
114:   "language_info": {
115:    "codemirror_mode": {
116:     "name": "ipython",
117:     "version": 3
118:    },
119:    "file_extension": ".py",
120:    "mimetype": "text/x-python",
121:    "name": "python",
122:    "nbconvert_exporter": "python",
123:    "pygments_lexer": "ipython3",
124:    "version": "3.13.0"
125:   }
126:  },
127:  "nbformat": 4,
128:  "nbformat_minor": 2
129: }

================
File: notebooks/surrogate_accuracy_26-06-2025.ipynb
================
  1: {
  2:  "cells": [
  3:   {
  4:    "cell_type": "markdown",
  5:    "id": "2b29dd78",
  6:    "metadata": {},
  7:    "source": [
  8:     "# Notebook for investigating network accuracy of surrogates"
  9:    ]
 10:   },
 11:   {
 12:    "cell_type": "code",
 13:    "execution_count": 1,
 14:    "id": "dfb246da",
 15:    "metadata": {},
 16:    "outputs": [],
 17:    "source": [
 18:     "import numpy as np\n",
 19:     "import pandas as pd\n",
 20:     "import matplotlib.pyplot as plt"
 21:    ]
 22:   },
 23:   {
 24:    "cell_type": "code",
 25:    "execution_count": 2,
 26:    "id": "fc84799c",
 27:    "metadata": {},
 28:    "outputs": [],
 29:    "source": [
 30:     "import sys\n",
 31:     "from pathlib import Path\n",
 32:     "\n",
 33:     "### Load all surrogate statistics\n",
 34:     "folder_path = Path('/Users/lmmi/anon_sbm/results/surrogate_statistics')\n",
 35:     "\n",
 36:     "# find all log files in the logs directory\n",
 37:     "stat_files = list(folder_path.glob(\"*.csv\"))"
 38:    ]
 39:   },
 40:   {
 41:    "cell_type": "code",
 42:    "execution_count": 3,
 43:    "id": "707ac12e",
 44:    "metadata": {},
 45:    "outputs": [
 46:     {
 47:      "data": {
 48:       "text/plain": [
 49:        "12"
 50:       ]
 51:      },
 52:      "execution_count": 3,
 53:      "metadata": {},
 54:      "output_type": "execute_result"
 55:     }
 56:    ],
 57:    "source": [
 58:     "len(stat_files)"
 59:    ]
 60:   },
 61:   {
 62:    "cell_type": "code",
 63:    "execution_count": 4,
 64:    "id": "8ee87d6c",
 65:    "metadata": {},
 66:    "outputs": [],
 67:    "source": [
 68:     "def determine_block_size(stat_file):\n",
 69:     "    \"\"\"\n",
 70:     "    Determine min_block_size from the filename.\n",
 71:     "\n",
 72:     "    min_block_size is encoded in filename as *min_block_size_{min_block_size}*.csv\n",
 73:     "    \"\"\"\n",
 74:     "\n",
 75:     "    # find location of substring 'min_block_size_'\n",
 76:     "    index = stat_file.name.find('min_block_size_')\n",
 77:     "\n",
 78:     "    tail = stat_file.name[index + len('min_block_size_'):]\n",
 79:     "    size = tail.split('_')[0]\n",
 80:     "\n",
 81:     "    # check if size is a digit\n",
 82:     "    if not size.isdigit():\n",
 83:     "        raise ValueError(f\"Invalid size in filename: {stat_file.name}\")\n",
 84:     "    return int(size)"
 85:    ]
 86:   },
 87:   {
 88:    "cell_type": "code",
 89:    "execution_count": 5,
 90:    "id": "f5f8ac7e",
 91:    "metadata": {},
 92:    "outputs": [],
 93:    "source": [
 94:     "df_list = []\n",
 95:     "\n",
 96:     "for stat_file in stat_files:\n",
 97:     "    df = pd.read_csv(stat_file)\n",
 98:     "    df[\"block_size\"] = determine_block_size(stat_file)\n",
 99:     "    df['surrogate'] = [int(surrogate_str.split(\"_\")[1]) for surrogate_str in df['surrogate']]\n",
100:     "\n",
101:     "    df_list.append(df)\n",
102:     "\n",
103:     "df = pd.concat(df_list, ignore_index=True)"
104:    ]
105:   },
106:   {
107:    "cell_type": "code",
108:    "execution_count": null,
109:    "id": "782cc864",
110:    "metadata": {},
111:    "outputs": [],
112:    "source": []
113:   },
114:   {
115:    "cell_type": "code",
116:    "execution_count": 6,
117:    "id": "0ddc127e",
118:    "metadata": {},
119:    "outputs": [],
120:    "source": [
121:     "marker_styles = {\n",
122:     "    \"congress_twitter\": \"o\",\n",
123:     "    \"caltech_fb\": \"s\",\n",
124:     "    \"eu_email\": \"D\",\n",
125:     "}\n",
126:     "colors = {\n",
127:     "    \"congress_twitter\": \"teal\",\n",
128:     "    \"caltech_fb\": \"salmon\",\n",
129:     "    \"eu_email\": \"black\",\n",
130:     "}"
131:    ]
132:   },
133:   {
134:    "cell_type": "code",
135:    "execution_count": null,
136:    "id": "57a9d87f",
137:    "metadata": {},
138:    "outputs": [
139:     {
140:      "name": "stderr",
141:      "output_type": "stream",
142:      "text": [
143:       "/var/folders/y6/j9fbqcvx6lb5l99614n30y4c0000gn/T/ipykernel_39806/3647360340.py:79: UserWarning: FigureCanvasAgg is non-interactive, and thus cannot be shown\n",
144:       "  fig.show()\n"
145:      ]
146:     },
147:     {
148:      "data": {
149:       "image/png": "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",
150:       "text/plain": [
151:        "<Figure size 1000x300 with 3 Axes>"
152:       ]
153:      },
154:      "metadata": {},
155:      "output_type": "display_data"
156:     }
157:    ],
158:    "source": [
159:     "### Visualize reconstruction error across block sizes and datasets\n",
160:     "fig, ax = plt.subplots(\n",
161:     "    figsize=(10, 3),\n",
162:     "    ncols = 3,\n",
163:     "    sharex=True,\n",
164:     "    sharey=False,\n",
165:     "    # set spacing between subplots\n",
166:     "    gridspec_kw={'wspace': 0.7}\n",
167:     "    )\n",
168:     "\n",
169:     "for group in df.groupby(['block_size', 'dataset']):\n",
170:     "    block_size, dataset = group[0]\n",
171:     "    group_data = group[1]\n",
172:     "\n",
173:     "    marker = marker_styles[dataset]\n",
174:     "    color = colors[dataset]\n",
175:     "\n",
176:     "    # plot the shortest-path reconstruction error for each surrogate\n",
177:     "    path_errors = group_data['shortest_path'].mean()\n",
178:     "    ax[0].plot(\n",
179:     "        [block_size],\n",
180:     "        [path_errors],\n",
181:     "        label=f\"{dataset}\",\n",
182:     "        marker=marker,\n",
183:     "        linewidth=0,\n",
184:     "        color=color\n",
185:     "    )\n",
186:     "\n",
187:     "    # plot the degree-dist reconstruction error for each surrogate\n",
188:     "    degree_errors = group_data['degree'].mean()\n",
189:     "    ax[1].plot(\n",
190:     "        [block_size],\n",
191:     "        [degree_errors],\n",
192:     "        marker=marker,\n",
193:     "        linewidth=0,\n",
194:     "        color=color\n",
195:     "    )\n",
196:     "\n",
197:     "    clustering_errors = group_data['clustering'].mean()\n",
198:     "    ax[2].plot(\n",
199:     "        [block_size],\n",
200:     "        [clustering_errors],\n",
201:     "        marker=marker,\n",
202:     "        linewidth=0,\n",
203:     "        color=color\n",
204:     "    )\n",
205:     "        \n",
206:     "ax[0].set_ylabel('Shortest-path distribution error', fontsize=12)\n",
207:     "ax[1].set_ylabel('Degree distribution error', fontsize=12)\n",
208:     "ax[2].set_ylabel('Clustering distribution error', fontsize=12)\n",
209:     "\n",
210:     "xticks = df['block_size'].unique()[::3]\n",
211:     "for axis in ax:\n",
212:     "    axis.set_xscale('log')\n",
213:     "    axis.set_xticks(xticks)\n",
214:     "    axis.set_xticklabels(xticks, fontsize=12)\n",
215:     "    axis.spines[['top', 'right']].set_visible(False)\n",
216:     "    axis.set_xlabel('Block size', fontsize=12)\n",
217:     "\n",
218:     "    axis.set_xlabel('Block Size')\n",
219:     "\n",
220:     "\n",
221:     "### Construct legend from single axis\n",
222:     "handles, labels = ax[0].get_legend_handles_labels()\n",
223:     "legend_set = set(zip(labels, handles))\n",
224:     "\n",
225:     "by_label = dict(legend_set)\n",
226:     "ax[0].legend(\n",
227:     "    by_label.values(),\n",
228:     "    by_label.keys(),\n",
229:     "    loc='lower left',\n",
230:     "    bbox_to_anchor=(0, -0.7),\n",
231:     "    fontsize=10,\n",
232:     "    )\n",
233:     "\n",
234:     "fig.show()"
235:    ]
236:   },
237:   {
238:    "cell_type": "code",
239:    "execution_count": null,
240:    "id": "1f49754b",
241:    "metadata": {},
242:    "outputs": [],
243:    "source": []
244:   }
245:  ],
246:  "metadata": {
247:   "kernelspec": {
248:    "display_name": "anon_sbm_notebook",
249:    "language": "python",
250:    "name": "python3"
251:   },
252:   "language_info": {
253:    "codemirror_mode": {
254:     "name": "ipython",
255:     "version": 3
256:    },
257:    "file_extension": ".py",
258:    "mimetype": "text/x-python",
259:    "name": "python",
260:    "nbconvert_exporter": "python",
261:    "pygments_lexer": "ipython3",
262:    "version": "3.12.11"
263:   }
264:  },
265:  "nbformat": 4,
266:  "nbformat_minor": 5
267: }

================
File: planted_partitions/undirected_planted_partitions.py
================
  1: #!/usr/bin/env python3
  2: """
  3: undirected_planted_partition.py
  4: --------------------------------
  5: Simple smoke-test for the swap-only MCMC implementation.
  6: For each of 100 independent repetitions we
  7: 1.  Draw an undirected 100-node SBM with
  8:          B = 10 blocks of size 10
  9:          p_in  = 0.30   (within-block connection probability)
 10:          p_out = 0.05   (between-block probability)
 11: 2.  Build an initial *random* equal-size partition with
 12:         UniformSmallBlockAssigner(min_block_size=10)             (code in block_assigner.py)
 13: 3.  Run the adaptive swap-only MCMC for `n_iter` iterations.
 14: 4.  Compute the Jaccard index between
 15:          the set of node pairs co-clustered in the *final* state, and
 16:          the same set for the planted partition.
 17: The script prints the mean, standard deviation and a histogram
 18: of the 100 Jaccard scores so you can eyeball whether the sampler
 19: typically finds the planted structure.
 20: Dependencies
 21: ------------
 22: Only `numpy`, `scipy` and the local `sbm` package (already required by
 23: your project).
 24: Author: Von Ngenmand
 25: """
 26: from typing import Sequence, Hashable
 27: from collections.abc import Sequence
 28: import numpy as np
 29: from scipy.sparse import csr_array
 30: from scipy.optimize import linear_sum_assignment
 31: from sklearn.metrics import (
 32:     adjusted_rand_score,
 33:     normalized_mutual_info_score,
 34: )
 35: from tqdm import tqdm
 36: from sbm.graph_data import GraphData
 37: from sbm.block_assigner import (
 38:     UniformSmallBlockAssigner,
 39:     MetisBlockAssigner,
 40: )
 41: from sbm.model import SBMModel
 42: ###############################################################################
 43: # utility helpers
 44: ###############################################################################
 45: def planted_blocks(n_nodes: int, block_size: int, rng) -> dict[int, int]:
 46:     """Random planted partition: block 0  nodes 09, block 1  1019, """
 47:     random_nodes = rng.permutation(n_nodes)
 48:     # generate a random list of blocks for the nodes ensuring the correct block size
 49:     random_blocks = np.arange(n_nodes) // block_size
 50:     random_blocks = rng.permutation(random_blocks)
 51:     return {v: block for (v, block) in zip(random_nodes, random_blocks)}
 52: def sample_sbm(rng: np.random.Generator,
 53:                blocks: dict[int, int],
 54:                p_in: float,
 55:                p_out: float) -> csr_array:
 56:     """Generate an undirected loop-free adjacency matrix for a binary SBM."""
 57:     n = len(blocks)
 58:     adj = np.zeros((n, n), dtype=np.int8)
 59:     # probability matrix look-up
 60:     for u in range(n):
 61:         for v in range(u + 1, n):          # u < v  strict upper triangle
 62:             p = p_in if blocks[u] == blocks[v] else p_out
 63:             if rng.random() < p:
 64:                 adj[u, v] = adj[v, u] = 1  # symmetrise
 65:     return csr_array(adj)                 # sparse CSR
 66: def misclassification_rate(
 67:     true_labels: Sequence[Hashable],
 68:     est_labels: Sequence[Hashable],
 69: ) -> float:
 70:     """
 71:     Percentage of vertices whose community label is wrong *after*
 72:     optimally permuting the estimated labels to match the true ones.
 73:     Parameters
 74:     ----------
 75:     true_labels : sequence
 76:         Ground-truth block labels  length N.
 77:     est_labels  : sequence
 78:         Estimated block labels   length N.
 79:     Returns
 80:     -------
 81:     float
 82:         Mis-classification rate in the interval [0, 1].
 83:     Notes
 84:     -----
 85:     * Label sets may use arbitrary hashables (str, int, ) and need not
 86:       have the same cardinality.  Any surplus estimated or true blocks
 87:       are matched to dummy columns/rows filled with zeros.
 88:     * Uses the Hungarian algorithm (via `scipy.optimize.linear_sum_assignment`)
 89:       to maximise the number of correctly matched vertices.
 90:     """
 91:     true = np.asarray(true_labels)
 92:     est  = np.asarray(est_labels)
 93:     if true.shape != est.shape:
 94:         raise ValueError("true_labels and est_labels must have the same length")
 95:     # Map arbitrary labels to contiguous integers 0..T-1 and 0..E-1
 96:     true_ids,  true_inv  = np.unique(true, return_inverse=True)
 97:     est_ids,   est_inv   = np.unique(est,  return_inverse=True)
 98:     T, E = len(true_ids), len(est_ids)
 99:     N    = len(true)
100:     # Build contingency matrix C[e, t] = |{ i : est_i=e and true_i=t }|
101:     C = np.zeros((E, T), dtype=int)
102:     np.add.at(C, (est_inv, true_inv), 1)
103:     # Pad to square (Hungarian implementation needs it or we need to
104:     # maximise on rectangles by padding zeros).
105:     if E != T:
106:         dim = max(E, T)
107:         C_padded = np.zeros((dim, dim), dtype=int)
108:         C_padded[:E, :T] = C
109:         C = C_padded
110:     # Maximise trace(C[perm])    minimise C for Hungarian
111:     row_ind, col_ind = linear_sum_assignment(-C)
112:     matched = C[row_ind, col_ind].sum()
113:     return 1.0 - matched / N
114: ###############################################################################
115: # main loop
116: ###############################################################################
117: def main(
118:     n_nodes = 100,
119:     block_size = 10,
120:     p_in = 0.30,
121:     p_out = 0.05,
122:     n_experiments = 10,
123:     n_iter = 3_000,
124:     rng_master = np.random.default_rng(42),
125:     temperature: float = 1
126: ):
127:     init_scores = []
128:     final_scores = []
129:     for rep in tqdm(range(n_experiments)):
130:         rng = np.random.default_rng(rng_master.integers(2**32))
131:         # --- 1. plant graph -----------------------------------------------------
132:         planted = planted_blocks(n_nodes, block_size, rng)
133:         adj     = sample_sbm(rng, planted, p_in, p_out)
134:         # --- 2. initial random partition ---------------------------------------
135:         gdata    = GraphData(adjacency_matrix=adj, directed=False)
136:         assigner = MetisBlockAssigner(graph_data=gdata,
137:                                             rng=rng,
138:                                             min_block_size=block_size
139:                                         )
140:         init_blocks = assigner.compute_assignment()
141:         init_scores.append(
142:             misclassification_rate(
143:                 true_labels=list(planted.values()),
144:                 est_labels=list(init_blocks.blocks.values())
145:             )
146:         )
147:         sbm = SBMModel(
148:                 initial_blocks=init_blocks,
149:                 rng=rng,
150:                 log=True,  # no logging
151:             )
152:         print(f"Initial ll {sbm.likelihood_calculator.ll:.3f}")
153:         sbm.fit(num_iterations=n_iter,
154:                 min_block_size=block_size,
155:                 initial_temperature=temperature,
156:                 cooling_rate=0.999)
157:         final_blocks = sbm.get_block_assignments()
158:         # --- 4. score -----------------------------------------------------------
159:         final_scores.append(
160:             misclassification_rate(
161:                 true_labels=list(planted.values()),
162:                 est_labels=list(final_blocks.values())
163:             )
164:         )
165:     # --- print results ----------------------------------------------------------
166:     print(f"Initial misclassification rate: {np.mean(init_scores):.3f}  {np.std(init_scores):.3f}")
167:     print(f"Final misclassification rate:   {np.mean(final_scores):.3f}  {np.std(final_scores):.3f}")
168: if __name__ == "__main__":
169:     main(
170:         n_nodes=300,
171:         block_size=3,
172:         p_in=0.5,
173:         p_out=0.01,
174:         n_experiments=1,
175:         n_iter=5_000,
176:         rng_master=np.random.default_rng(42),
177:         temperature=1e-2
178:     )

================
File: slurm_scripts/fit_sbm.sh
================
 1: #!/bin/sh
 2: ### General options
 3: #BSUB -q gpua100
 4: #BSUB -J anon_sbm_fit
 5: #BSUB -n 1
 6: #BSUB -R "span[hosts=1]"
 7: #BSUB -R "rusage[mem=10GB]"
 8: #BSUB -M 20GB
 9: #BSUB -W 12:00
10: #BSUB -o slurm_outputs/anon_sbm_fit_%J.out
11: #BSUB -e slurm_outputs/anon_sbm_fit_%J.err
12: module purge
13: module load python3/3.12.11
14: source /zhome/c1/2/109045/anon_sbm/bin/activate
15: python3 src/pipelines/run_all.py

================
File: src/data_processing/process_caltech.py
================
 1: """
 2: Script for converting caltech-facebook data to simple edgelist format
 3: change from format:
 4:     %MatrixMarket matrix coordinate pattern symmetric 
 5:     769 769 16656
 6:     5 1
 7:     31 1
 8: to format:
 9:     769 769 16656
10:     5 1
11:     31 1
12: """
13: from pathlib import Path
14: if __name__ == "__main__":
15:     file_path = Path("data/raw/socfb-Caltech36/socfb-Caltech36.mtx")
16:     # read file
17:     with file_path.open("r") as f:
18:         lines = f.readlines()
19:     # process lines
20:     processed_lines = []
21:     # skip first two lines (Matrix Market header)
22:     for idx, line in enumerate(lines):
23:         if idx < 2:
24:             continue
25:         parts = line.split()
26:         if len(parts) >= 2:
27:             processed_lines.append(f"{parts[0]} {parts[1]}\n")
28:     # processed data goes in the "processed" folder in the parent-folder
29:     out_folder_path = Path("data/processed")
30:     out_file_path = out_folder_path / "caltech_fb.edgelist"
31:     # write to output file
32:     out_folder_path.mkdir(parents=True, exist_ok=True)
33:     with out_file_path.open("w") as f:
34:         f.writelines(processed_lines)
35:     print(f"Processed edgelist saved to {out_file_path}")

================
File: src/data_processing/process_congress_twitter.py
================
 1: """
 2: Script for converting congress data to simple edgelist format
 3: change from format:
 4:   0 4 {'weight': 0.002105263157894737}
 5:   0 12 {'weight': 0.002105263157894737}
 6:   0 18 {'weight': 0.002105263157894737}
 7:   0 25 {'weight': 0.004210526315789474}
 8: to format:
 9:   0 4
10:   0 12
11:   0 18
12:   0 25
13: """
14: from pathlib import Path
15: if __name__ == "__main__":
16:     file_path = Path("data/raw/congress_twitter/congress.edgelist")
17:     # read file
18:     with file_path.open("r") as f:
19:         lines = f.readlines()
20:     # process lines
21:     processed_lines = []
22:     for line in lines:
23:         parts = line.split()
24:         if len(parts) >= 2:
25:             processed_lines.append(f"{parts[0]} {parts[1]}\n")
26:     # processed data goes in the "processed" folder in the parent-folder
27:     out_folder_path = Path("data/processed")
28:     out_file_path = out_folder_path / "congress_twitter.edgelist"
29:     # write to output file
30:     out_folder_path.mkdir(parents=True, exist_ok=True)
31:     with out_file_path.open("w") as f:
32:         f.writelines(processed_lines)
33:     print(f"Processed edgelist saved to {out_file_path}")

================
File: src/data_processing/process_email_eu.py
================
 1: """
 2: Script for converting email-eu data to simple edgelist format
 3: change from format:
 4:     582 364 0
 5:     168 472 2797
 6:     168 912 3304
 7:     2 790 4523
 8: to format:
 9:     582 364
10:     168 472
11:     168 912
12:     2 790
13: while removing self-loops and duplicate edges.
14: """
15: from pathlib import Path
16: if __name__ == "__main__":
17:     file_path = Path("data/raw/email_eu/email-Eu-core-temporal.txt")
18:     # read file
19:     with file_path.open("r") as f:
20:         lines = f.readlines()
21:     # process lines
22:     processed_lines = []
23:     edgeset = set()
24:     for line in lines:
25:         parts = line.split()
26:         edge = tuple(sorted(( int(parts[0]), int(parts[1]) )))
27:         if edge not in edgeset:
28:             edgeset.add(edge)
29:             # only keep the first two parts of the line
30:             # and ignore the third part (weight)
31:             # also ignore self-loops
32:             if len(parts) >= 2 and parts[0] != parts[1]:
33:                 processed_lines.append(f"{parts[0]} {parts[1]}\n")
34:     # processed data goes in the "processed" folder in the parent-folder
35:     out_folder_path = Path("data/processed")
36:     out_file_path = out_folder_path / "eu_email.edgelist"
37:     # write to output file
38:     out_folder_path.mkdir(parents=True, exist_ok=True)
39:     with out_file_path.open("w") as f:
40:         f.writelines(processed_lines)
41:     print(f"Processed edgelist saved to {out_file_path}")

================
File: src/data_processing/process_enron_email.py
================
 1: """
 2: Script for converting enron-email data to simple edgelist format
 3: change from format:
 4:     # Directed graph (each unordered pair of nodes is saved once): Email-Enron.txt 
 5:     # Enron email network (edge indicated that email was exchanged, undirected edges)
 6:     # Nodes: 36692 Edges: 367662
 7:     # FromNodeId	ToNodeId
 8:     0	1
 9:     1	0
10:     1	2
11:     1	3
12: to format:
13:     0	1
14:     1	0
15:     1	2
16:     1	3
17: while removing self-loops and duplicate edges.
18: """
19: from pathlib import Path
20: if __name__ == "__main__":
21:     file_path = Path("data/raw/enron_email/email-Enron.txt")
22:     # read file
23:     with file_path.open("r") as f:
24:         lines = f.readlines()
25:     # process lines
26:     processed_lines = []
27:     edgeset = set()
28:     for index, line in enumerate(lines):
29:         if index >= 4:
30:             parts = line.split()
31:             edge = tuple(sorted(( int(parts[0]), int(parts[1]) )))
32:             if edge not in edgeset:
33:                 edgeset.add(edge)
34:                 if parts[0] != parts[1]:
35:                     processed_lines.append(f"{parts[0]} {parts[1]}\n")
36:     # processed data goes in the "processed" folder in the parent-folder
37:     out_folder_path = Path("data/processed")
38:     out_file_path = out_folder_path / "enron_email.edgelist"
39:     # write to output file
40:     out_folder_path.mkdir(parents=True, exist_ok=True)
41:     with out_file_path.open("w") as f:
42:         f.writelines(processed_lines)
43:     print(f"Processed edgelist saved to {out_file_path}")

================
File: src/data_processing/process_lastfm_asia.py
================
 1: """
 2: Script for converting lastfm-asia data to simple edgelist format
 3: remove the header and remove self-loops and duplicate edges.
 4: """
 5: from pathlib import Path
 6: if __name__ == "__main__":
 7:     file_path = Path("data/raw/lastfm_asia/lastfm_asia_edges.csv")
 8:     # read file
 9:     with file_path.open("r") as f:
10:         lines = f.readlines()
11:     # process lines
12:     processed_lines = []
13:     edgeset = set()
14:     for index, line in enumerate(lines):
15:         if index >= 1:
16:             parts = line.split(",")
17:             edge = tuple(sorted(( int(parts[0]), int(parts[1]) )))
18:             if edge not in edgeset:
19:                 edgeset.add(edge)
20:                 if len(parts) >= 1 and parts[0] != parts[1]:
21:                     processed_lines.append(f"{parts[0]} {parts[1]}\n")
22:     # processed data goes in the "processed" folder in the parent-folder
23:     out_folder_path = Path("data/processed")
24:     out_file_path = out_folder_path / "lastfm_asia.edgelist"
25:     # write to output file
26:     out_folder_path.mkdir(parents=True, exist_ok=True)
27:     with out_file_path.open("w") as f:
28:         f.writelines(processed_lines)
29:     print(f"Processed edgelist saved to {out_file_path}")

================
File: src/data_processing/process_wiki_vote.py
================
 1: """
 2: Script for converting wiki-voce data to simple edgelist format
 3: change from format:
 4:     # Directed graph (each unordered pair of nodes is saved once): Wiki-Vote.txt 
 5:     # Wikipedia voting on promotion to administratorship (till January 2008). Directed edge A->B means user A voted on B becoming Wikipedia administrator.
 6:     # Nodes: 7115 Edges: 103689
 7:     # FromNodeId	ToNodeId
 8:     30	1412
 9:     30	3352
10:     30	5254
11: to format:
12:     30	1412
13:     30	3352
14:     30	5254
15: while removing self-loops and duplicate edges.
16: """
17: from pathlib import Path
18: if __name__ == "__main__":
19:     file_path = Path("data/raw/wiki_vote/wiki-vote.txt")
20:     # read file
21:     with file_path.open("r") as f:
22:         lines = f.readlines()
23:     # process lines
24:     processed_lines = []
25:     edgeset = set()
26:     for index, line in enumerate(lines):
27:         if index >= 4:
28:             parts = line.split()
29:             edge = tuple(sorted(( int(parts[0]), int(parts[1]) )))
30:             if edge not in edgeset:
31:                 edgeset.add(edge)
32:                 # only keep the first two parts of the line
33:                 # and ignore the third part (weight)
34:                 # also ignore self-loops
35:                 if parts[0] != parts[1]:
36:                     processed_lines.append(f"{parts[0]} {parts[1]}\n")
37:     # processed data goes in the "processed" folder in the parent-folder
38:     out_folder_path = Path("data/processed")
39:     out_file_path = out_folder_path / "wiki_vote.edgelist"
40:     # write to output file
41:     out_folder_path.mkdir(parents=True, exist_ok=True)
42:     with out_file_path.open("w") as f:
43:         f.writelines(processed_lines)
44:     print(f"Processed edgelist saved to {out_file_path}")

================
File: src/metrics/__init__.py
================
1: from .shortest_path import shortest_path_distance
2: from .degree import degree_distance
3: from .clustering import clustering_distance
4: # registry maps a short name -> call-able
5: REGISTRY = {
6:     "shortest_path": shortest_path_distance,
7:     "degree": degree_distance,
8:     "clustering": clustering_distance,
9: }

================
File: src/pipelines/generate_and_evaluate_surrogates.py
================
 1: """
 2:     Generate surrogate SBM graphs and evaluate them against empirical data.
 3: """
 4: from typing import TypedDict, List, Union
 5: import argparse
 6: import yaml
 7: import csv
 8: from pathlib import Path
 9: import numpy as np
10: from metrics import REGISTRY
11: from sbm.io import SBMWriter
12: from sbm.sampling import sample_sbm_graph_from_fit
13: from sbm.io import GraphLoader
14: from sbm.utils.pipeline_utils import (
15:     sbmfit_folderpath,
16:     surrogate_statistics_filename,
17:     FitConfig,
18:     EvalConfig,
19: )
20: #######################
21: ### Configuration Types 
22: #######################
23: ############################################
24: ### main function
25: ############################################
26: def main(fit_config: str, eval_config: str): # type: ignore
27:     fit_config: FitConfig = yaml.safe_load(Path(fit_config).read_text())
28:     rng = np.random.default_rng(fit_config["seed"])
29:     data_config = fit_config["datasets"] # type: ignore
30:     eval_config: EvalConfig = yaml.safe_load(Path(eval_config).read_text())
31:     for sbm_config in fit_config["sbm"]:
32:         for ds in data_config:
33:             # Load empirical graph
34:             g = GraphLoader.load(
35:                     Path(ds["path"]),
36:                     force_undirected=sbm_config["force_undirected"], # type: ignore
37:                 )
38:             emp = g.adjacency
39:             # load fitted model
40:             fit_folder_path = sbmfit_folderpath(
41:                 base_dir=Path("results/sbm_fits"),
42:                 sbm_config=sbm_config,# type: ignore
43:                 data_spec=ds,
44:             )
45:             # load the sbm fit
46:             sbm_fit = SBMWriter.load(fit_folder_path)
47:             # check if metrics have been cached earlier
48:             out = surrogate_statistics_filename(
49:                 base_dir=Path("results/surrogate_statistics"),
50:                 eval_configs=eval_config,
51:                 sbm_config=sbm_config,# type: ignore
52:                 data_spec=ds,
53:             )
54:             out.parent.mkdir(exist_ok=True)
55:             if out.exists() and not eval_config["overwrite"]:
56:                 continue
57:             # Generate surrogates and campare metrics
58:             results = []
59:             for i in range(eval_config["n_surrogates"]):
60:                 surr = sample_sbm_graph_from_fit(
61:                     sbm_fit=sbm_fit,
62:                     rng=rng,
63:                 )
64:                 surr = surr.adjacency
65:                 row = {"dataset": ds["name"], "surrogate": f'surr_{i}'}
66:                 for m in eval_config["metrics"]:
67:                     row[m] = REGISTRY[m](emp, surr)
68:                 results.append(row)
69:             with out.open("w", newline="") as f:
70:                 w = csv.DictWriter(f, fieldnames=results[0].keys())
71:                 w.writeheader(); w.writerows(results)
72: if __name__ == "__main__":
73:     p = argparse.ArgumentParser()
74:     p.add_argument("--fit_config", type=str, help="Path to the configuration file.")
75:     p.add_argument("--eval_config", type=str, help="Path to the configuration file.")
76:     args = p.parse_args()
77:     main(
78:         fit_config=args.fit_config,
79:         eval_config=args.eval_config
80:     )

================
File: src/sbm/utils/logger.py
================
 1: # sbm/utils/logger.py
 2: import csv
 3: import time
 4: from pathlib import Path
 5: from typing import Union, TextIO
 6: class CSVLogger:
 7:     """
 8:     Minimal CSV logger for long-running SBM fits.
 9:     Each row contains:
10:         iteration, elapsed_seconds, neg_log_likelihood,
11:         accept_rate_window, temperature
12:     Parameters
13:     ----------
14:     file : str | pathlib.Path | TextIO
15:         Where to write.  If a path is given and the file does not yet
16:         exist, a header row is written automatically.
17:     log_every : int
18:         Only rows for which ``iteration % log_every == 0`` are written.
19:     """
20:     header = [
21:         "iteration",
22:         "elapsed_seconds",
23:         "neg_log_likelihood",
24:         "accept_rate_window",
25:         "temperature",
26:     ]
27:     def __init__(self,
28:                  file: Union[str, Path, TextIO],
29:                  *,
30:                  log_every: int = 1000,
31:                  ):
32:         self.log_every = int(log_every)
33:         self._start = time.time()
34:         # if prior log file exists, delete
35:         if isinstance(file, (str, Path)):
36:             file = Path(file)
37:             if file.exists():
38:                 file.unlink()
39:         # open the handle
40:         if isinstance(file, (str, Path)):
41:             self._own_handle = True
42:             path = Path(file)
43:             path.parent.mkdir(parents=True, exist_ok=True)
44:             first = not path.exists()
45:             self._fh = path.open("a", newline="")
46:             self._writer = csv.writer(self._fh)
47:             if first:
48:                 self._writer.writerow(self.header)
49:         else:                                  # file-like object supplied
50:             self._own_handle = False
51:             self._fh: TextIO = file
52:             self._writer = csv.writer(self._fh)
53:             # assume caller already wrote header
54:     # -----------------------------------------------------------------
55:     def log(self,
56:             iteration: int,
57:             neg_loglike: float,
58:             accept_rate_window: float,
59:             temperature: float,
60:             ) -> None:
61:         """
62:         Append a row
63:         """
64:         elapsed = time.time() - self._start
65:         self._writer.writerow([
66:             iteration,
67:             f"{elapsed:.3f}",
68:             f"{neg_loglike:.6f}",
69:             f"{accept_rate_window:.6f}",
70:             f"{temperature:.6f}",
71:         ])
72:         self._fh.flush()
73:     # -----------------------------------------------------------------
74:     def close(self):
75:         if self._own_handle:
76:             self._fh.close()
77:     # allow usage as a context manager -------------------------------
78:     def __enter__(self):
79:         return self
80:     def __exit__(self, exc_type, exc, tb):
81:         self.close()

================
File: src/sbm/utils/pipeline_utils.py
================
  1: from typing import Dict, Union, TypedDict, List, Literal
  2: from pathlib import Path
  3: import numpy as np
  4: import scipy.sparse as sp
  5: def load_csr_npz(fn: Path):
  6:     with np.load(fn) as z:
  7:         return sp.csr_matrix(
  8:             (z["data"], z["indices"], z["indptr"]),
  9:             shape=z["shape"]
 10:         )
 11: InitMethodName = Literal["metis", "random", "ProneKMeans"]
 12: class DatasetSpec(TypedDict):
 13:     name: str
 14:     path: str
 15: class SBMConfig(TypedDict):
 16:     force_undirected: bool
 17:     min_block_size: int
 18:     n_iter: int
 19:     temperature: float
 20:     cooling_rate: float
 21:     init_method: InitMethodName
 22: class LoggingConfig(TypedDict):
 23:     logging_folder: str
 24:     log_every: int
 25: class FitConfig(TypedDict):
 26:     seed: int
 27:     sbm: SBMConfig
 28:     logging: LoggingConfig
 29:     datasets: List[DatasetSpec]
 30: class EvalConfig(TypedDict):
 31:     n_surrogates: int
 32:     overwrite: bool
 33:     metrics: List[str]
 34: def clean_filename(name: str) -> str:
 35:     """
 36:     Clean the name of all special characters and spaces, replacing them with underscores.
 37:     """
 38:     name = name.replace(":", "_")
 39:     name = name.replace(".", "_")
 40:     name = name.replace(",", "_")
 41:     return name
 42: def sbmfit_folderpath(
 43:     base_dir: Path,
 44:     sbm_config: SBMConfig,
 45:     data_spec: DatasetSpec,
 46: ) -> Path:
 47:     """
 48:     Generate the folderpath for storing a fitted SBM model based on the fit configuration.
 49:     Filename is created by unrolling the fit_config dictionary, using all fields and their values. 
 50:     :param name: Name of the dataset. 
 51:     """
 52:     folder_name = data_spec["name"] + "_" + "_".join(
 53:         f"{k}_{v}" for k, v in sorted(sbm_config.items())
 54:     )
 55:     folder_name = clean_filename(folder_name)
 56:     return base_dir / f"sbm_fit_{folder_name}"
 57: def surrogate_statistics_filename(
 58:     base_dir: Path,
 59:     eval_configs: EvalConfig,
 60:     sbm_config: SBMConfig,
 61:     data_spec: DatasetSpec,
 62: ) -> Path:
 63:     """
 64:     Generate the folfor surrogate statistics based on evaluation and fit configurations.
 65:     :param eval_configs: Evaluation configuration dictionary.
 66:     :param fit_config: Fit configuration dictionary.
 67:     :return: Path object representing the filename.
 68:     """
 69:     file_name = (
 70:         f"{data_spec['name']}_"
 71:         f"surrogates_{eval_configs['n_surrogates']}_"
 72:         f"{'_'.join(eval_configs['metrics'])}_"
 73:         f"{'_'.join(f'{k}_{v}' for k, v in sorted(sbm_config.items()))}"
 74:     )
 75:     file_name = clean_filename(file_name)
 76:     return base_dir / f"{file_name}.csv"
 77: def dataset_filepath(
 78:     base_dir: Path,
 79:     dataset_name: str,
 80: )-> Path:
 81:     """
 82:     Generate the filepath for a dataset based on its name.
 83:     :param base_dir: Base directory where datasets are stored.
 84:     :param dataset_name: Name of the dataset.
 85:     :return: Path object representing the dataset file path.
 86:     """
 87:     dataset_name = clean_filename(dataset_name)
 88:     return base_dir / f"{dataset_name}.npz"
 89: ##### Helper functions #####
 90: def fit_config_to_dicts(fit_config: FitConfig) -> List[dict[str, str]]:
 91:     """ 
 92:     Convert FitConfig to a list of DatasetSpec dictionaries.
 93:     One dictionary per dataset.
 94:     """
 95:     configs = [
 96:         {
 97:             "name": ds["name"],
 98:             "path": ds["path"],
 99:             **fit_config["sbm"],
100:         }
101:         for ds in fit_config["datasets"]
102:     ]
103:     for config in configs:
104:         if "seed" in config:
105:             config["seed"] = str(fit_config["seed"])
106:     return configs
107: def eval_config_to_dict(eval_config: EvalConfig) -> dict[str, str]:
108:     """
109:     Convert EvalConfig to a dictionary.
110:     """
111:     return {
112:         "n_surrogates": str(eval_config["n_surrogates"]),
113:         "metrics": "_".join(
114:                 eval_config["metrics"]    
115:             )
116:     }

================
File: src/sbm/edge_delta.py
================
  1: """
  2: Classes to build and hold changes in edge counts between blocks in a Stochastic Block Model (SBM).
  3: """
  4: from typing import DefaultDict, Tuple, List, Literal, Tuple, Iterator, Iterable, Literal
  5: from collections import defaultdict, Counter
  6: import numpy as np
  7: from numba import jit
  8: EdgeDeltas = Literal["PythonEdgeDelta", "NumpyEdgeDelta"]
  9: #### Pure python class for edge deltas #######
 10: class EdgeDelta: # edge-count changes between blocks
 11:     def __init__(self, n_blocks: int):
 12:         self._deltas: DefaultDict[Tuple[int, int], int] = defaultdict(int)
 13:     def _increment(self, count: int, block_i: int, block_j: int,
 14:      ) -> None:
 15:         """
 16:         Increment the edge count delta for a pair of blocks.
 17:         :param count: The change in edge count.
 18:         :param block_i: The first block index.
 19:         :param block_j: The second block index.
 20:         :return: Updated edge count delta.
 21:         """
 22:         if block_i < block_j:
 23:             self._deltas[(block_i, block_j)] = count
 24:         else:
 25:             self._deltas[(block_j, block_i)] = count
 26:     def __getitem__(self, pair: Tuple[int, int]) -> int:
 27:         """
 28:         Get the edge count delta for a pair of blocks.
 29:         :param pair: A tuple containing the block indices (i, j).
 30:         :return: The edge count delta for the pair.
 31:         """
 32:         if pair[0] < pair[1]:
 33:             return self._deltas.get(pair, 0)
 34:         else:
 35:             return self._deltas.get((pair[1], pair[0]), 0)
 36:     def __len__(self) -> int:
 37:         """
 38:         Return the number of non-zero edge count deltas.
 39:         :return: The number of non-zero edge count deltas.
 40:         """
 41:         return len([v for v in self._deltas.values() if v != 0])
 42:     def items(self) -> Iterator[Tuple[Tuple[int, int], int]]:
 43:         """
 44:         Yield tuple ((i, j), delta_e) for all stored pairs.
 45:         :return: An iterator over tuples of (block_i, block_j, delta_e).
 46:         """
 47:         for (i, j), delta_e in self._deltas.items():
 48:             yield (i, j), delta_e
 49:     def increment(self,
 50:                   counts: Iterable[int],
 51:                   blocks_i: Iterable[int],
 52:                   blocks_j: Iterable[int],
 53:      ) -> None:
 54:         """
 55:         Increment the edge counts deltas for a list of block pairs.
 56:         :param counts: List of changes in edge counts.
 57:         :param blocks_i: List of first block indices.
 58:         :param blocks_j: List of second block indices.
 59:         """
 60:         for count, block_i, block_j in zip(counts, blocks_i, blocks_j):
 61:             self._increment(count, block_i, block_j)
 62: ##### NumPy class for edge deltas ######
 63: class NumpyEdgeDelta(EdgeDelta):
 64:     """Sparse, symmetric (i <= j) container for edgecount deltas.
 65:     Overwrites the purePython :py:class:`EdgeDelta` class
 66:     Internally stores three *contiguous* onedimensional NumPy arrays
 67:     (`rows`, `cols`, `data`) in **COO** fashion as well as a Python
 68:     ``dict`` that maps the linearised pair key ``i * n_blocks + j`` to the
 69:     corresponding position in the arrays.  Only the *active* prefix
 70:     (``self.size``) of the arrays is considered valid  this makes the
 71:     structure friendly to NumbaJITd consumers that expect fixedsize
 72:     buffers.
 73:     The class focuses on *fast incremental updates* (``O(1)`` expected)
 74:     and cheap vector export; memory usage is proportional to the number
 75:     of *nonzero* block pairs actually visited by the MCMC chain.
 76:     """
 77:     __slots__ = ("n_blocks", "rows", "cols", "data", "size", "_key2idx")
 78:     def __init__(self,
 79:                  n_blocks: int,
 80:                  initial_capacity: int = 64
 81:     ):
 82:         self.n_blocks: int = int(n_blocks)
 83:         cap = max(1, initial_capacity)
 84:         self.rows: np.ndarray = np.empty(cap, dtype=np.int32)
 85:         self.cols: np.ndarray = np.empty(cap, dtype=np.int32)
 86:         self.data: np.ndarray = np.zeros(cap, dtype=np.int32)
 87:         self.size: int = 0
 88:         # auxiliary map for *O(1)* lookup  not accessed inside JIT code
 89:         self._key2idx: dict[int, int] = {}
 90:     ### function for printing the object
 91:     def __repr__(self) -> str:
 92:         """Return a string representation of the NumpyEdgeDelta object."""
 93:         return (f"NumpyEdgeDelta(n_blocks={self.n_blocks}, "
 94:                 f"size={self.size}, "
 95:                 f"rows={self.rows[:self.size]}, "
 96:                 f"cols={self.cols[:self.size]}, "
 97:                 f"data={self.data[:self.size]})")
 98:     # ------------------------------------------------------------------
 99:     # Private helpers
100:     # ------------------------------------------------------------------
101:     def _encode(self, i: int, j: int) -> int:
102:         """Encode an ordered pair (i  j) into a unique scalar."""
103:         return i * self.n_blocks + j
104:     def _ensure_capacity(self):
105:         if self.size == len(self.rows):
106:             # double inplace (amortised O(1))
107:             new_cap = len(self.rows) * 2
108:             self.rows = np.resize(self.rows, new_cap)
109:             self.cols = np.resize(self.cols, new_cap)
110:             self.data = np.resize(self.data, new_cap)
111:     def _increment(self, count: int, block_i: int, block_j: int):
112:         """Add *value* to entry (i, j) (symmetric pair)."""
113:         if block_i > block_j:
114:             block_i, block_j = block_j, block_i
115:         key = self._encode(block_i, block_j)
116:         idx = self._key2idx.get(key)
117:         if idx is None:
118:             self._ensure_capacity()
119:             idx = self.size
120:             self.size += 1
121:             self.rows[idx] = block_i
122:             self.cols[idx] = block_j
123:             self.data[idx] = count
124:             self._key2idx[key] = idx
125:         else:
126:             self.data[idx] += count
127:     # ------------------------------------------------------------------
128:     # Public API
129:     # ------------------------------------------------------------------
130:     def __getitem__(self, pair: Tuple[int, int]) -> int:
131:         i, j = pair
132:         if i > j:
133:             i, j = j, i
134:         idx = self._key2idx.get(self._encode(i, j))
135:         return 0 if idx is None else int(self.data[idx])
136:     def __len__(self) -> int:
137:         """Return the number of non-zero and *active* pairs."""
138:         #return self.size
139:         active_pairs = self.data[:self.size]
140:         print(f"Active pairs: {active_pairs}")
141:         return active_pairs[active_pairs != 0].shape[0]
142:     def __setitem__(self, pair: Tuple[int, int], value: int):
143:         i, j = pair
144:         current = self[pair]
145:         self._increment(i, j, value - current)
146:     def items(self) -> Iterator[Tuple[Tuple[int, int], int]]:
147:         """Yield triples ``(i, j, delta_e)`` for all stored pairs."""
148:         for k in range(self.size):
149:             yield (int(self.rows[k]), int(self.cols[k])), int(self.data[k])
150:     def to_coo(self) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
151:         """Return the *active* COO view (no copying)."""
152:         return (self.rows[:self.size], self.cols[:self.size], self.data[:self.size])
153:     def increment(self,
154:             counts: Iterable[int],
155:             blocks_i: Iterable[int],
156:             blocks_j: Iterable[int],
157:      ) -> None:
158:         """Vectorised equivalent of ``increment`` for ``NumpyEdgeDelta``.
159:         Parameters
160:         ----------
161:         counts : 1D ``int`` array
162:             Changes in edge counts (positive or negative).
163:         blocks_i, blocks_j : 1D ``int`` arrays
164:             Block indices *parallel* to ``counts``.
165:         Notes
166:         -----
167:         The function works fully in **NumPy** space  no Python loops  by
168:         linearising the symmetric pair ``(i, j)`` into a *key* and then
169:         accumulating duplicate keys with :pyfunc:`numpy.add.at`.
170:         """
171:         # ------------------------------------------------------------------
172:         # Ensure ndarray inputs (copy=False promotes views)
173:         # ------------------------------------------------------------------
174:         assert isinstance(counts, (list, np.ndarray)) and \
175:                 isinstance(blocks_i, (list, np.ndarray)) and \
176:                 isinstance(blocks_j, (list, np.ndarray)), \
177:             "Counts and block indices must be list or ndarray."
178:         counts = np.asarray(counts, dtype=np.int32)
179:         blocks_i = np.asarray(blocks_i, dtype=np.int32)
180:         blocks_j = np.asarray(blocks_j, dtype=np.int32)
181:         # ------------------------------------------------------------------
182:         # Normalise the pair ordering so that i  j
183:         # ------------------------------------------------------------------
184:         swap_mask = blocks_i > blocks_j
185:         if swap_mask.any():
186:             blocks_i, blocks_j = blocks_i.copy(), blocks_j.copy()  # avoid aliasing
187:             blocks_i[swap_mask], blocks_j[swap_mask] = blocks_j[swap_mask], blocks_i[swap_mask]
188:         # ------------------------------------------------------------------
189:         # Encode pairs  scalar keys and reduce duplicates in *one* pass
190:         # ------------------------------------------------------------------
191:         n_blocks = self.n_blocks
192:         keys = blocks_i.astype(np.int64) * n_blocks + blocks_j
193:         # ``np.unique`` already sorts  good for cache locality
194:         uniq_keys, inverse = np.unique(keys, return_inverse=True)
195:         reduced = np.zeros_like(uniq_keys, dtype=np.int32)
196:         np.add.at(reduced, inverse, counts)
197:         # ------------------------------------------------------------------
198:         # Decode unique keys and perform bulk update via the fast method
199:         # ------------------------------------------------------------------
200:         rows = (uniq_keys // n_blocks).astype(np.int32)
201:         cols = (uniq_keys %  n_blocks).astype(np.int32)
202:         for r, c, dv in zip(rows, cols, reduced):
203:             if dv != 0:
204:                 self._increment(block_i=int(r), block_j=int(c), count=int(dv))

================
File: src/sbm/initial_partition.py
================
 1: import numpy as np
 2: import scipy.sparse as sp
 3: from scipy.sparse.linalg import eigsh
 4: from typing import Dict, Optional
 5: from sklearn.cluster import KMeans
 6: from scipy.sparse import csr_matrix
 7: class SpectralPartitioner:
 8:     def __init__(self, adjacency: csr_matrix, seed: Optional[int] = None):
 9:         """
10:         Initialize the SpectralPartitioner.
11:         :param adjacency: The adjacency matrix of the network (sparse CSR matrix).
12:         :param seed: Random seed for reproducibility.
13:         """
14:         self.adjacency: csr_matrix = adjacency.tocsr()
15:         self.num_nodes: int = self.adjacency.shape[0]
16:         self.rng = np.random.default_rng(seed)
17:         self.degree_vector = np.array(self.adjacency.sum(axis=1)).flatten()
18:         self.laplacian = self._compute_normalized_laplacian()
19:     def _compute_normalized_laplacian(self) -> csr_matrix:
20:         """
21:         Compute the normalized Laplacian matrix of the graph.
22:         :return: The normalized Laplacian matrix (sparse CSR matrix).
23:         """
24:         # Avoid division by zero
25:         with np.errstate(divide='ignore'):
26:             d_inv_sqrt = np.power(self.degree_vector, -0.5)
27:             d_inv_sqrt[np.isinf(d_inv_sqrt)] = 0.0
28:         D_inv_sqrt = sp.diags(d_inv_sqrt)
29:         L = sp.eye(self.num_nodes) - D_inv_sqrt @ self.adjacency @ D_inv_sqrt
30:         return L
31:     def partition(self, num_blocks: int) -> Dict[int, int]:
32:         """
33:         Partition the nodes into blocks using spectral clustering.
34:         :param num_blocks: The desired number of blocks.
35:         :return: A dictionary mapping node indices to block indices.
36:         """
37:         # Compute the first (num_blocks) eigenvectors of the normalized Laplacian
38:         # Use 'SM' to find eigenvalues closest to zero
39:         eigenvalues, eigenvectors = eigsh(
40:             self.laplacian, k=num_blocks, which='SM', tol=1e-6, maxiter=5000
41:         )
42:         # Normalize rows to unit length to improve clustering
43:         embedding = eigenvectors
44:         row_norms = np.linalg.norm(embedding, axis=1, keepdims=True)
45:         row_norms[row_norms == 0] = 1e-10  # Avoid division by zero
46:         embedding_normalized = embedding / row_norms
47:         # Use k-means clustering on the spectral embeddings
48:         kmeans = KMeans(n_clusters=num_blocks, random_state=self.rng.integers(1 << 32))
49:         labels = kmeans.fit_predict(embedding_normalized)
50:         # Map nodes to blocks
51:         blocks = {node: int(label) for node, label in enumerate(labels)}
52:         return blocks

================
File: src/sbm/sampling.py
================
  1: """ 
  2: Functions for sampling graph from SBM model
  3: """
  4: # sbm/sampling.py
  5: from typing import List, Optional
  6: import numpy as np
  7: from scipy.sparse import csr_array, coo_matrix
  8: from sbm.graph_data import GraphData
  9: from sbm.io import SBMFit
 10: def sample_adjacency_matrix(
 11:     block_sizes: List[int],
 12:     block_connectivity: csr_array,
 13:     rng: np.random.Generator,
 14:     directed: bool = False,
 15: ) -> csr_array:
 16:     """
 17:     Draw a random graph from the *profile* Bernoulli SBM specified by
 18:     `block_edge_counts` (edge counts m_rs) and `block_sizes`.
 19:     :param block_sizes: Sizes of the blocks.
 20:     :param block_connectivity: Sparse matrix of edge counts m_rs between blocks.
 21:     :param directed: Whether the graph is directed or undirected.
 22:     :param rng: Random number generator for reproducibility.
 23:     :return: Sparse adjacency matrix of the sampled graph.
 24:     """
 25:     block_sizes = list(map(int, block_sizes))
 26:     B = len(block_sizes)
 27:     N = sum(block_sizes)
 28:     # cumulative offsets  map local idx  global idx
 29:     offsets = np.cumsum([0] + block_sizes)
 30:     rows: list[int] = []
 31:     cols: list[int] = []
 32:     # ------------------------------------------------------------------
 33:     for r in range(B):
 34:         n_r = block_sizes[r]
 35:         off_r = offsets[r]
 36:         # -- diagonal block -------------------------------------------
 37:         m_rr = int(block_connectivity[r, r]) # type: ignore
 38:         if m_rr:
 39:             if directed:
 40:                 n_poss = n_r * (n_r - 1)
 41:                 p = m_rr / n_poss
 42:                 mask = (rng.random((n_r, n_r)) < p).astype(int)
 43:                 mask[np.diag_indices(n_r)] = 0
 44:                 rr, cc = np.nonzero(mask)
 45:                 rows.extend(off_r + rr)
 46:                 cols.extend(off_r + cc)
 47:             else:
 48:                 n_poss = n_r * (n_r - 1) // 2
 49:                 p = m_rr / n_poss
 50:                 triu_mask = rng.random((n_r, n_r)) < p
 51:                 tri_r, tri_c = np.triu_indices(n_r, k=1)
 52:                 sel = triu_mask[tri_r, tri_c]
 53:                 rr = tri_r[sel]; cc = tri_c[sel]
 54:                 rows.extend(off_r + rr); cols.extend(off_r + cc)
 55:                 rows.extend(off_r + cc); cols.extend(off_r + rr)
 56:         # -- off-diagonal blocks --------------------------------------
 57:         s_iter = range(B) if directed else range(r + 1, B)
 58:         for s in s_iter:
 59:             if s == r:
 60:                 continue
 61:             if not directed and s <= r:
 62:                 continue
 63:             m_rs = int(block_connectivity[r, s]) # type: ignore
 64:             if m_rs == 0:
 65:                 continue
 66:             n_s = block_sizes[s]
 67:             off_s = offsets[s]
 68:             n_poss = n_r * n_s
 69:             p = m_rs / n_poss
 70:             mask = rng.random((n_r, n_s)) < p
 71:             rr, cc = np.nonzero(mask)
 72:             rows.extend(off_r + rr)
 73:             cols.extend(off_s + cc)
 74:             if not directed:
 75:                 # mirror block
 76:                 rows.extend(off_s + cc)
 77:                 cols.extend(off_r + rr)
 78:     data = np.ones(len(rows), dtype=np.int8)
 79:     adj = coo_matrix((data, (rows, cols)), shape=(N, N))
 80:     # ensure no duplicate edge
 81:     adj.sum_duplicates() 
 82:     adj.data.fill(1)
 83:     # convert to csr format
 84:     adj = csr_array(adj)
 85:     adj.sort_indices()
 86:     return adj
 87: def sample_sbm_graph(
 88:             block_sizes: List[int],
 89:             block_connectivity: csr_array,
 90:             directed:bool,
 91:             rng: np.random.Generator,
 92:             metadata: Optional[dict] = None
 93:     )->GraphData:
 94:     """
 95:     Sample a graph from a Stochastic Block Model (SBM) given block sizes and connectivity.
 96:     :param block_sizes: List of sizes for each block.
 97:     :param block_connectivity: Sparse matrix representing connectivity between blocks.
 98:     :param directed: Whether the graph is directed or undirected.
 99:     :param rng: Random number generator for reproducibility.
100:     :param metadata: Optional metadata to include in the graph data.
101:     :return: GraphData object containing the sampled graph.
102:     """
103:     if metadata is None:
104:         metadata = {}
105:     # Validate inputs
106:     if not isinstance(block_sizes, list) or not all(isinstance(size, int) for size in block_sizes):
107:         raise ValueError("block_sizes must be a list of integers.")
108:     if not isinstance(block_connectivity, csr_array):
109:         raise ValueError("block_connectivity must be a scipy.sparse.csr_array.")
110:     if len(block_sizes) != block_connectivity.shape[0] or len(block_sizes) != block_connectivity.shape[1]: #type: ignore
111:         raise ValueError("block_sizes length must match the dimensions of block_connectivity.")
112:     if not isinstance(directed, bool):
113:         raise ValueError("directed must be a boolean value.")
114:     if not isinstance(rng, np.random.Generator):
115:         raise ValueError("rng must be a numpy random Generator instance.")    
116:     adj = sample_adjacency_matrix(
117:         block_sizes=block_sizes,
118:         block_connectivity=block_connectivity,
119:         directed=directed,
120:         rng=rng
121:     )
122:     return GraphData(adjacency_matrix=adj, directed=directed)
123: def sample_sbm_graph_from_fit(sbm_fit: SBMFit, rng: np.random.Generator) -> GraphData:
124:     """
125:     Sample a graph from a Stochastic Block Model (SBM) fit.
126:     :param sbm_fit: SBMFit object containing block sizes and connectivity.
127:     :param rng: Random number generator for reproducibility.
128:     :return: GraphData object containing the sampled graph.
129:     """
130:     return sample_sbm_graph(
131:         block_sizes=sbm_fit.block_sizes,
132:         block_connectivity=sbm_fit.block_conn,
133:         directed=sbm_fit.directed_graph,
134:         rng=rng,
135:         metadata=sbm_fit.metadata
136:     )

================
File: src/sbm/stopping_criteria.py
================
 1: """ 
 2: Stopping criteria for the MCMC algorithm in the Stochastic Block Model (SBM).
 3: """
 4: class StoppingCriteria:
 5:     """
 6:     Base class for stopping criteria in the MCMC algorithm.
 7:     """
 8:     def __init__(self, stopping_configs: dict):
 9:         pass
10:     def should_stop(self, iteration: int, current_ll: float) -> bool:
11:         """
12:         Check if the stopping criteria are met.
13:         :param iteration: Current iteration number.
14:         :param current_ll: Current log-likelihood value.
15:         :return: True if the algorithm should stop, False otherwise.
16:         """
17:         raise NotImplementedError("Subclasses should implement this method.")

================
File: src/tests/planted_partition_tests.py
================
 1: # src/tests/test_regressions.py
 2: """
 3: Targeted regression tests for issues uncovered in the plantedpartition script.
 4: * size-1 blocks must not crash likelihood computation
 5: * -dicts must use *matrix indices*, not block-IDs
 6: """
 7: import numpy as np
 8: import pytest
 9: from scipy.sparse import csr_array
10: from sbm.block_data import BlockData
11: from sbm.likelihood import compute_global_bernoulli_ll
12: from sbm.block_change_proposers import NodeSwapProposer
13: from sbm.block_data import BlockData
14: from sbm.graph_data import GraphData
15: # -------------------------------------------------------------------
16: # 1. size-1 diagonal must be ignored (or handled gracefully)
17: # -------------------------------------------------------------------
18: @pytest.mark.parametrize("singletons", [1, 3])
19: def test_singleton_blocks_allowed(singletons):
20:     """
21:     A partition containing blocks of size 1 must not raise or return NaN.
22:     """
23:     n = 6
24:     # make a path graph (any sparse graph works)
25:     rows = np.arange(n-1)
26:     cols = rows + 1
27:     data = np.ones(n-1, dtype=int)
28:     A = csr_array((data, (rows, cols)), shape=(n, n))
29:     A = A + A.T
30:     # put the first `singletons` nodes into their own blocks
31:     blocks = {v: v if v < singletons else singletons for v in range(n)}
32:     bd = BlockData(
33:         initial_blocks=blocks,
34:         graph_data=GraphData(adjacency_matrix=A, directed=False)
35:     )
36:     ll = compute_global_bernoulli_ll(bd)
37:     assert np.isfinite(ll), "likelihood should be finite even with size-1 blocks"
38: # -------------------------------------------------------------------
39: # 2. -dicts must reference matrix indices, not block-IDs
40: # -------------------------------------------------------------------
41: def test_delta_keys_are_matrix_indices():
42:     """
43:     When block IDs are non-contiguous (e.g. {0,10}), the delta_e keys
44:     must still be *matrix indices* (0 or 1), otherwise the likelihood
45:     updater crashes with an IndexError.
46:     """
47:     # two blocks with ids 0 and 10, one edge across
48:     adj = csr_array([[0,1],[1,0]])
49:     blocks = {0: 0, 1: 10}
50:     bd = BlockData(
51:         initial_blocks=blocks,
52:         graph_data=GraphData(adjacency_matrix=adj, directed=False)
53:     )
54:     proposer = NodeSwapProposer(bd)
55:     swap = [(0, 10)]  # move node 0 to block 10 -> will create a singleton & trigger 
56:     _, delta_e, _ = proposer.propose_change(swap)
57:     # the only valid matrix indices are 0 and 1
58:     valid = {0,1}
59:     for (r, s) in delta_e:
60:         assert r in valid and s in valid, (
61:             "delta_e must use matrix indices (0..B-1), "
62:             "not raw block IDs"
63:         )

================
File: src/tests/test_block_assigner.py
================
  1: """PyTest suites for structural blockmodel code.
  2: These unit tests focus on two invariants that *must* hold for the current
  3: pipeline:
  4: 1. **MetisBlockAssigner should only emit blocks whose sizes are either
  5:    `min_block_size` or `min_block_size + 1`.**  (Because the assigner first
  6:    builds blocks of exactly `min_block_size` vertices and then distributes any
  7:    leftovers onebyone.)
  8: 2. **A SWAP move in the MCMC sampler must leave every block size unchanged.**
  9: The tests rely only on public APIs plus `_attempt_move`, which is part of the
 10: MCMC samplers stable interface (it is used by `fit` internally).  If the
 11: namesor module paths differ in your codebase, tweak the imports at the top of
 12: each file  the assertions themselves should stay valid.
 13: Run with::
 14:     pytest -q tests/
 15: """
 16: # 
 17: # tests/test_block_assigner.py
 18: # 
 19: import networkx as nx
 20: import numpy as np
 21: import pytest
 22: # Adjust the import path to wherever MetisBlockAssigner lives in your project
 23: from sbm.block_assigner import MetisBlockAssigner
 24: from sbm.block_assigner import ProNEAndConstrKMeansAssigner
 25: from sbm.graph_data import gd_from_networkx
 26: @pytest.mark.parametrize(
 27:     "num_nodes,num_blocks,min_block_size,edge_p",
 28:     [
 29:         (97, 10, 8, 0.05),
 30:         (50, 5, 6, 0.10),
 31:         (23, 4, 5, 0.30),
 32:         (128, 16, 7, 0.02),
 33:     ],
 34: )
 35: def test_metis_block_sizes_are_balanced(num_nodes, num_blocks, min_block_size, edge_p):
 36:     """The initial partition must use only *min* and *min+1* sized blocks."""
 37:     G = nx.erdos_renyi_graph(
 38:             n=num_nodes,
 39:             p=edge_p,
 40:             seed=1,
 41:             directed=False
 42:         )
 43:     graph_data = gd_from_networkx(G)
 44:     assigner = MetisBlockAssigner(
 45:         graph_data=graph_data,
 46:         num_blocks=num_blocks,
 47:         min_block_size=min_block_size,
 48:         rng=np.random.default_rng(42),
 49:     )
 50:     block_data = assigner.compute_assignment()
 51:     # ensure that block_sizes correspond to 
 52:     # Ensure every vertex received exactly one label
 53:     assert len(block_data.blocks) == num_nodes
 54:     # Compute blocksize histogram
 55:     _, counts = np.unique(
 56:         list(block_data.blocks.values()),
 57:         return_counts=True
 58:         )
 59:     # All block sizes must be either min_block_size or min_block_size+1
 60:     assert (counts >= min_block_size).all(), \
 61:         (
 62:             "MetisBlockAssigner produced illegal block sizes: "
 63:             f"{sorted(set(counts))}. Expected larger than {min_block_size}."
 64:         )
 65:     # The partition must contain exactly *num_blocks* nonempty blocks.
 66:     assert len(counts) == num_blocks
 67: def test_ProNEKMeans_block_sizes_are_balanced():
 68:     """The ProNEKMeans assigner must also use only *min* and *min+1* sized blocks."""
 69:     num_nodes = 100
 70:     min_block_size = 8
 71:     num_blocks = num_nodes // min_block_size
 72:     edge_p = 0.05
 73:     G = nx.erdos_renyi_graph(
 74:             n=num_nodes,
 75:             p=edge_p,
 76:             seed=1,
 77:             directed=False
 78:         )
 79:     graph_data = gd_from_networkx(G)
 80:     assigner = ProNEAndConstrKMeansAssigner(
 81:         graph_data=graph_data,
 82:         min_block_size=min_block_size,
 83:         rng=np.random.default_rng(42),
 84:     )
 85:     block_data = assigner.compute_assignment()
 86:     # ensure that block_sizes correspond to 
 87:     # Ensure every vertex received exactly one label
 88:     assert len(block_data.blocks) == num_nodes, \
 89:         "ProNEKMeansBlockAssigner did not assign a label to every vertex."
 90:     # ensure that block sizes correspond to the number of blocks
 91:     assert len(block_data.block_sizes) == num_blocks  \
 92:         and len(set(block_data.blocks.values())) == num_blocks, \
 93:         "ProNEKMeansBlockAssigner did not produce the expected number of blocks."
 94:     # Compute blocksize histogram
 95:     _, counts = np.unique(
 96:         list(block_data.blocks.values()),
 97:         return_counts=True
 98:         )
 99:     # All block sizes must be either min_block_size or min_block_size+1
100:     assert (counts >= min_block_size).all(), \
101:         (
102:             "ProNEKMeansBlockAssigner produced illegal block sizes: "
103:             f"{sorted(set(counts))}. Expected larger than {min_block_size}."
104:         )
105:     count_set = set(counts)
106:     # Ensure that the block sizes are either min_block_size or min_block_size + 1
107:     assert count_set.issubset({min_block_size, min_block_size + 1})
108:     # The partition must contain exactly *num_blocks* nonempty blocks.
109:     assert len(counts) == num_blocks

================
File: src/tests/test_edge_delta.py
================
  1: # tests/test_edge_delta_equivalence.py
  2: """
  3: Unit tests that compare behaviour of sbm.edge_delta.EdgeDelta
  4: and its NumPy-accelerated subclass NumpyEdgeDelta.
  5: The tests are written against the public API actually used by
  6: block-change proposers and the likelihood calculator:
  7:      increment(counts, blocks_i, blocks_j)              :contentReference[oaicite:0]{index=0}
  8:      __getitem__, __len__, items                       :contentReference[oaicite:1]{index=1}
  9: """
 10: from __future__ import annotations
 11: import random
 12: from collections import defaultdict
 13: from itertools import combinations
 14: import numpy as np
 15: import pytest
 16: from sbm.edge_delta import EdgeDelta, NumpyEdgeDelta
 17: # --------------------------------------------------------------------------- #
 18: # helpers                                                                     #
 19: # --------------------------------------------------------------------------- #
 20: def _random_updates(
 21:     n_blocks: int,
 22:     n_updates: int,
 23:     *, rng: random.Random
 24: ) -> tuple[list[int], list[int], list[int]]:
 25:     """
 26:     Create a *single* batch of updates without duplicate (i, j) pairs
 27:      this mirrors how `_compute_delta_edge_counts` builds its argument
 28:     lists before calling ``increment`` once per batch.                   :contentReference[oaicite:2]{index=2}
 29:     """
 30:     pairs = random.sample(list(combinations(range(n_blocks), 2)), k=n_updates)
 31:     counts = [rng.randint(-5, 5) for _ in range(n_updates)]
 32:     blocks_i, blocks_j = zip(*pairs)   # already i < j
 33:     return counts, list(blocks_i), list(blocks_j)
 34: def _build_two_deltas(
 35:     n_blocks: int,
 36:     counts: list[int],
 37:     blocks_i: list[int],
 38:     blocks_j: list[int],
 39: ) -> tuple[EdgeDelta, NumpyEdgeDelta]:
 40:     """
 41:     Convenience wrapper: build and *increment once*  just like the
 42:     real code does.                                                      :contentReference[oaicite:3]{index=3}
 43:     """
 44:     d_py  = EdgeDelta(n_blocks)
 45:     d_np  = NumpyEdgeDelta(n_blocks)
 46:     d_py.increment(counts, blocks_i, blocks_j)
 47:     d_np.increment(counts, blocks_i, blocks_j)
 48:     return d_py, d_np
 49: # --------------------------------------------------------------------------- #
 50: # public API parity tests                                                     #
 51: # --------------------------------------------------------------------------- #
 52: @pytest.mark.parametrize("n_blocks, n_updates, seed", [
 53:     (5,  6,  1),
 54:     (7, 10, 42),
 55:     (3,  2, 99),
 56: ])
 57: def test_increment_equivalence(n_blocks: int, n_updates: int, seed: int) -> None:
 58:     """After an identical batch update, both classes hold exactly the same deltas."""
 59:     rng = random.Random(seed)
 60:     counts, bi, bj = _random_updates(n_blocks, n_updates, rng=rng)
 61:     d_py, d_np = _build_two_deltas(n_blocks, counts, bi, bj)
 62:     # compare through the *public* interface  not private storage
 63:     pairs = set(d_py.items()) | set(d_np.items())
 64:     for (i, j), _ in pairs:
 65:         assert d_py[i, j] == d_np[i, j], \
 66:             f"Mismatch on pair {(i, j)}: python={d_py[i, j]}, numpy={d_np[i, j]}"
 67:     assert len(d_py) == len(d_np), \
 68:         f"__len__ diverged: python={len(d_py)}, numpy={len(d_np)}"
 69:     # full dict comparison (order-independent)
 70:     assert dict(d_py.items()) == dict(d_np.items())
 71: def test_getitem_default_zero() -> None:
 72:     """Both classes must return 0 for unseen (i,j) pairs."""
 73:     d_py  = EdgeDelta(4)
 74:     d_np  = NumpyEdgeDelta(4)
 75:     for pair in ((0, 0), (0, 1), (2, 3)):
 76:         assert d_py[pair] == d_np[pair] == 0
 77: def test_negative_and_positive_counts() -> None:
 78:     """Signed counts stay intact and are *not* silently truncated."""
 79:     counts  = [  5, -3,  2]
 80:     blocks_i = [0, 0, 1]
 81:     blocks_j = [1, 2, 2]
 82:     d_py, d_np = _build_two_deltas(3, counts, blocks_i, blocks_j)
 83:     assert dict(d_py.items()) == { (0, 1): 5, (0, 2): -3, (1, 2): 2 }
 84:     assert dict(d_py.items()) == dict(d_np.items())
 85: # --------------------------------------------------------------------------- #
 86: # integration smoke test  reproduces the exact public call-sequence used
 87: # by `_compute_delta_edge_counts`                                            #
 88: # --------------------------------------------------------------------------- #
 89: def test_two_step_update_matches() -> None:
 90:     """
 91:     `_compute_delta_edge_counts` issues *two* successive ``increment`` calls
 92:     on the *same* EdgeDelta instance.  Here we reproduce that pattern and make
 93:     sure the NumPy implementation yields identical final deltas after both
 94:     steps.                                                                   :contentReference[oaicite:4]{index=4}
 95:     """
 96:     n_blocks = 4
 97:     # step-1: neighbour blocks
 98:     counts1  = [ 2, -1]
 99:     blocks1a = [0, 1]
100:     blocks1b = [2, 2]
101:     # step-2: intra / inter old blocks
102:     counts2  = [ 7, -4, -3]
103:     blocks2a = [0, 0, 1]
104:     blocks2b = [1, 0, 1]
105:     py = EdgeDelta(n_blocks)
106:     npd = NumpyEdgeDelta(n_blocks)
107:     py.increment(counts1, blocks1a, blocks1b)
108:     py.increment(counts2, blocks2a, blocks2b)
109:     npd.increment(counts1, blocks1a, blocks1b)
110:     npd.increment(counts2, blocks2a, blocks2b)
111:     assert dict(py.items()) == dict(npd.items())

================
File: src/tests/test_io.py
================
  1: # tests/test_io.py
  2: import json
  3: from pathlib import Path
  4: import numpy as np
  5: import scipy.sparse as sp
  6: from scipy.io import mmwrite
  7: import networkx as nx
  8: import pytest
  9: from sbm.io import SBMFit, SBMWriter, GraphLoader
 10: # ---------------------------------------------------------------------
 11: # helpers
 12: # ---------------------------------------------------------------------
 13: def _simple_adj(undirected: bool = True) -> sp.csr_array:
 14:     """
 15:     3-node graph:
 16:         0  1   and  (optionally) 1  2
 17:     """
 18:     rows, cols = [0, 1], [1, 0]            # 01 edge
 19:     if not undirected:
 20:         rows.append(1); cols.append(2)     # add 12 (makes it directed)
 21:     data = np.ones(len(rows), dtype=np.int8)
 22:     return sp.csr_array(sp.coo_matrix((data, (rows, cols)), shape=(3, 3)))
 23: def _assert_same_csr(a: sp.csr_array, b: sp.csr_array):
 24:     a.sort_indices()
 25:     b.sort_indices()
 26:     assert np.array_equal(a.data, b.data), f'Data arrays differ: {a.data} != {b.data}'
 27:     assert np.array_equal(a.indices, b.indices), f'Indices differ: {a.indices} != {b.indices}'
 28:     assert a.shape == b.shape, f'Shape differs: {a.shape} != {b.shape}'
 29: # ---------------------------------------------------------------------
 30: # 1. SBMWriter round-trip
 31: # ---------------------------------------------------------------------
 32: def test_sbmwriter_roundtrip(tmp_path: Path):
 33:     # --- build a tiny SBMFit ----------------------------------------
 34:     #adj = _simple_adj()
 35:     #blocks = {0: 0, 1: 0, 2: 1}
 36:     fit = SBMFit(
 37:         block_sizes   = [2, 1],
 38:         block_conn    = sp.csr_array([[1, .2],[.2, .1]]),
 39:         directed_graph= False,
 40:         neg_loglike   = -12.34,
 41:         metadata      = {"foo": "bar"},
 42:     )
 43:     # --- save & load ------------------------------------------------
 44:     SBMWriter.save(tmp_path, fit)
 45:     fit2 = SBMWriter.load(tmp_path)
 46:     # basic checks
 47:     assert fit2.block_sizes == [2, 1], f"Block sizes do not match: {fit2.block_sizes} != [2, 1]"
 48:     _assert_same_csr(fit.block_conn, fit2.block_conn)
 49:     assert fit2.neg_loglike == pytest.approx(fit.neg_loglike), "Negative log-likelihood does not match"
 50:     assert fit2.metadata["foo"] == "bar", "Metadata does not match"
 51: # ---------------------------------------------------------------------
 52: # 2. GraphLoader built-in formats
 53: # ---------------------------------------------------------------------
 54: @pytest.mark.parametrize("undirected", [True, False])
 55: def test_graphloader_npz(tmp_path: Path, undirected: bool):
 56:     adj = _simple_adj(undirected)
 57:     f = tmp_path / "g.npz"
 58:     sp.save_npz(f, adj)
 59:     g = GraphLoader.load(f)
 60:     _assert_same_csr(adj, g.adjacency)
 61:     assert g.directed == (not undirected)
 62: def test_graphloader_edges(tmp_path: Path):
 63:     # plain edge list (space-sep)
 64:     f = tmp_path / "toy.edges"
 65:     f.write_text("0 1\n1 2\n")  # unsymmetrised  directed
 66:     g = GraphLoader.load(f)
 67:     assert g.directed
 68:     assert g.num_nodes == 3
 69:     assert g.adjacency[1, 2] == 1
 70: def test_graphloader_mtx(tmp_path: Path):
 71:     adj = _simple_adj()
 72:     f = tmp_path / "toy.mtx"
 73:     mmwrite(str(f), adj)
 74:     g = GraphLoader.load(f)
 75:     _assert_same_csr(adj, g.adjacency)
 76:     assert not g.directed
 77: def test_graphloader_gml(tmp_path: Path):
 78:     # build with networkx
 79:     G = nx.Graph()
 80:     G.add_edge(0, 1); G.add_edge(1, 2)
 81:     f = tmp_path / "toy.gml"
 82:     nx.write_gml(G, f)
 83:     g = GraphLoader.load(f)
 84:     assert not g.directed
 85:     assert g.adjacency.nnz == 4      # undirected  2 edges 2
 86: # ---------------------------------------------------------------------
 87: # 3. Registry decorator sanity check
 88: # ---------------------------------------------------------------------
 89: def test_register_new_loader(tmp_path: Path):
 90:     # create a fake extension ".foo"
 91:     ext = ".foo"
 92:     @GraphLoader.register(ext)
 93:     def _load_foo(path: Path):
 94:         # loader that ignores content, returns 2-node edge
 95:         rows, cols = [0], [1]
 96:         adj = sp.coo_matrix((np.ones(1, int), (rows, cols)), shape=(2, 2)).tocsr()
 97:         return adj, True
 98:     # create dummy file and load
 99:     f = tmp_path / f"dummy{ext}"
100:     f.write_text("ignored")
101:     g = GraphLoader.load(f)
102:     assert g.directed
103:     assert g.adjacency[0, 1] == 1
104:     assert f.suffix.lower() in GraphLoader.registry

================
File: src/tests/test_sampling.py
================
  1: import numpy as np
  2: import scipy.sparse as sp
  3: import pytest
  4: from sbm.sampling import (
  5:     sample_adjacency_matrix,
  6:     sample_sbm_graph_from_fit,
  7: )
  8: from sbm.io import SBMFit
  9: from sbm.graph_data import GraphData
 10: @pytest.fixture(scope="module")
 11: def rng():
 12:     return np.random.default_rng(12345)
 13: # --------------------------------------------------------------------
 14: # helpers
 15: # --------------------------------------------------------------------
 16: def csr_edges_between(adj: sp.csr_array, idx_a, idx_b, directed:bool = False):
 17:     """number of non-zero entries with row in A and col in B"""
 18:     sub = adj[idx_a][:, idx_b] # type: ignore
 19:     if (idx_a == idx_b) and not directed:
 20:         # self-edges, count only upper triangle
 21:         return sub.count_nonzero() // 2 # type: ignore
 22:     if directed:
 23:         # directed, count all edges
 24:         print('')
 25:         print(sub.toarray().tolist())
 26:         print(adj.toarray().tolist())
 27:         print('')
 28:     return sub.sum() # type: ignore
 29: def complete_block_edges(n, directed):
 30:     return n * (n - 1) if directed else n * (n - 1) // 2
 31: # --------------------------------------------------------------------
 32: # 1. full connectivity should yield a complete bipartite/clique
 33: # --------------------------------------------------------------------
 34: @pytest.mark.parametrize("directed", [False, True])
 35: def test_full_connectivity(rng, directed):
 36:     n1, n2 = 3, 4
 37:     sizes = [n1, n2]
 38:     # maximum possible edges
 39:     B = 2
 40:     conn = sp.csr_array((B, B), dtype=int)
 41:     conn[0, 0] = complete_block_edges(n1, directed)
 42:     conn[1, 1] = complete_block_edges(n2, directed)
 43:     conn[0, 1] = conn[1, 0] = n1 * n2
 44:     adj = sample_adjacency_matrix(sizes, conn, directed=directed, rng=rng)
 45:     idx0 = slice(0, n1)
 46:     idx1 = slice(n1, n1 + n2)
 47:     # --- within-block ------------------------------------------------
 48:     assert csr_edges_between(adj, idx0, idx0, directed) == conn[0, 0], \
 49:         (
 50:             f"expected {conn[0, 0]} edges within block 0. Got {csr_edges_between(adj, idx0, idx0)}. "
 51:             f"sizes: {sizes}, conn: {conn.toarray().flatten()}, directed: {directed}"
 52:         )
 53:     assert csr_edges_between(adj, idx1, idx1, directed) == conn[1, 1], \
 54:         (
 55:             f"expected {conn[1, 1]} edges within block 1"
 56:             f"sizes: {sizes}, conn: {conn}, directed: {directed}"
 57:         )
 58:     # --- between blocks ---------------------------------------------
 59:     expect = conn[0, 1]
 60:     assert csr_edges_between(adj, idx0, idx1, directed) == expect ,\
 61:         (
 62:             f"expected {expect} edges between blocks 0 and 1. Got {csr_edges_between(adj, idx0, idx1)}. "
 63:             f"sizes: {sizes}, conn: {conn.toarray().flatten()}, directed: {directed}"
 64:         )
 65:     assert csr_edges_between(adj, idx1, idx0, directed) == expect, \
 66:         (
 67:             f"expected {expect} edges between blocks 1 and 0. Got {csr_edges_between(adj, idx1, idx0)}. "
 68:             f"sizes: {sizes}, conn: {conn.toarray().flatten()}, directed: {directed}"
 69:         )
 70:     if directed:
 71:         # both directions filled
 72:         assert csr_edges_between(adj, idx1, idx0, directed) == expect, \
 73:                 f"expected {expect} edges between blocks 1 and 0. Got {csr_edges_between(adj, idx1, idx0)}. "
 74:     # --- no self-loops ----------------------------------------------
 75:     assert adj.diagonal().sum() == 0, \
 76:                 "expected no self-loops in the adjacency matrix"
 77: # --------------------------------------------------------------------
 78: # 2. zero connectivity must yield zero edges between blocks
 79: # --------------------------------------------------------------------
 80: def test_zero_connectivity(rng):
 81:     n1, n2 = 5, 6
 82:     sizes = [n1, n2]
 83:     conn = sp.csr_array([[10, 0],
 84:                          [0, 15]], dtype=int)
 85:     adj = sample_adjacency_matrix(sizes, conn, directed=False, rng=rng)
 86:     idx0 = slice(0, n1)
 87:     idx1 = slice(n1, n1 + n2)
 88:     assert csr_edges_between(adj, idx0, idx1) == 0
 89:     assert csr_edges_between(adj, idx1, idx0) == 0
 90: # --------------------------------------------------------------------
 91: # 3. large probabilistic block matches expected count 3
 92: # --------------------------------------------------------------------
 93: def test_statistical_match(rng):
 94:     n1, n2 = 100, 200
 95:     sizes = [n1, n2]
 96:     p = 0.15
 97:     m = int(p * n1 * n2)
 98:     conn = sp.csr_array((2, 2), dtype=int)
 99:     conn[0, 1] = conn[1, 0] = m
100:     trials = 10
101:     errs = []
102:     for _ in range(trials):
103:         adj = sample_adjacency_matrix(sizes, conn, directed=False, rng=rng)
104:         idx0 = slice(0, n1)
105:         idx1 = slice(n1, n1 + n2)
106:         observed = csr_edges_between(adj, idx0, idx1)
107:         errs.append(observed - m)
108:     std = np.sqrt(n1 * n2 * p * (1 - p))
109:     assert max(map(abs, errs)) < 3 * std, \
110:         (
111:             f"expected observed edge counts to match {m}  3. Got {errs}. "
112:         )
113: # --------------------------------------------------------------------
114: # 4. directed vs undirected symmetry
115: # --------------------------------------------------------------------
116: def test_directed_flag(rng):
117:     sizes = [10, 10]
118:     B = 2
119:     conn = sp.csr_array((B, B), dtype=int)
120:     conn[0, 1] = conn[1, 0] = 10 * 10 / 2   # p = 0.5
121:     adj_d = sample_adjacency_matrix(sizes, conn, directed=True, rng=rng)
122:     assert (adj_d != adj_d.T).nnz > 0, \
123:         "expected directed graph to be asymmetric"
124:     adj_u = sample_adjacency_matrix(sizes, conn, directed=False, rng=rng)
125:     assert (adj_u != adj_u.T).nnz == 0
126: # --------------------------------------------------------------------
127: # 5. sampling via SBMFit wrapper
128: # --------------------------------------------------------------------
129: def test_sample_from_fit(rng):
130:     sizes = [2, 2]
131:     conn = sp.csr_array([[1, 2],
132:                          [2, 1]], dtype=int)
133:     fit = SBMFit(
134:         block_sizes    = sizes,
135:         block_conn     = conn,
136:         directed_graph = False,
137:         neg_loglike    = -1.0,
138:         metadata       = {},
139:     )
140:     g = sample_sbm_graph_from_fit(fit, rng)
141:     assert isinstance(g, GraphData)
142:     assert g.adjacency.shape == (4, 4)

================
File: src/tests/test_swaps.py
================
 1: # 
 2: # tests/test_swap_move.py
 3: # 
 4: import networkx as nx
 5: import numpy as np
 6: import pytest
 7: from sbm.block_assigner import MetisBlockAssigner
 8: from sbm.block_change_proposers import NodeSwapProposer
 9: from sbm.likelihood import LikelihoodCalculator
10: from sbm.mcmc import MCMCAlgorithm
11: from sbm.graph_data import gd_from_networkx
12: from sbm.block_data import BlockData
13: def _sizes_from_block_data(block_data: BlockData, num_blocks):
14:     """Helper used in both reference and postmove checks."""
15:     sizes = np.zeros(num_blocks, dtype=int)
16:     for bid, nodes in block_data.block_members.items():
17:         if bid < num_blocks:
18:             sizes[bid] = len(nodes)
19:     return sizes
20: @pytest.mark.parametrize(
21:     "num_nodes,num_blocks,min_block_size,iterations,edge_p",
22:     [
23:         (80, 8, 8, 250, 0.05),
24:         (30, 6, 4, 100, 0.25),
25:         (10, 5, 2, 100, 0.25),
26:     ],
27: )
28: def test_swap_move_preserves_block_sizes(num_nodes, num_blocks, min_block_size, iterations, edge_p):
29:     """After *every* accepted SWAP move, blocksize vector must be unchanged."""
30:     rng = np.random.default_rng(42)
31:     # old version of networkx can't take rng so use seed instead
32:     G = nx.erdos_renyi_graph(num_nodes, edge_p, seed=42, directed=False)
33:     graph_data = gd_from_networkx(G)
34:     #  Build initial state 
35:     block_data = MetisBlockAssigner(
36:         graph_data=graph_data,
37:         num_blocks=num_blocks,
38:         min_block_size=min_block_size,
39:         rng=rng,
40:     ).compute_assignment()
41:     likelihood_calculator = LikelihoodCalculator(block_data=block_data)
42:     swap_proposer = NodeSwapProposer(block_data=block_data, rng=rng)
43:     mcmc = MCMCAlgorithm(
44:         block_data=block_data,
45:         likelihood_calculator=likelihood_calculator,
46:         change_proposer={"swap": swap_proposer},
47:         rng=rng,
48:     )
49:     reference_sizes = _sizes_from_block_data(block_data, num_blocks)
50:     #  Run many candidate swap moves 
51:     for iter in range(iterations):
52:         _delta_ll, accepted = mcmc._attempt_move(move_type="swap", temperature=1.0)
53:         if accepted:
54:             current_sizes = _sizes_from_block_data(mcmc.block_data, num_blocks)
55:             assert np.array_equal(reference_sizes, current_sizes), (
56:                 f"SWAP move {iter} changed block sizes:", reference_sizes, "", current_sizes
57:             )
58:     # Final safeguard: after *all* moves sizes are still identical.
59:     final_sizes = _sizes_from_block_data(mcmc.block_data, num_blocks)
60:     assert np.array_equal(reference_sizes, final_sizes)

================
File: env_backup.yml
================
  1: name: anon_sbm
  2: channels:
  3:   - conda-forge
  4:   - defaults
  5: dependencies:
  6:   - bzip2=1.0.8
  7:   - ca-certificates=2024.9.24
  8:   - libexpat=2.6.4
  9:   - libffi=3.4.4
 10:   - libmpdec=4.0.0
 11:   - libsqlite=3.47.0
 12:   - libzlib=1.3.1
 13:   - ncurses=6.5
 14:   - openssl=3.4.0
 15:   - pip=24.3.1
 16:   - python=3.13.0
 17:   - python_abi=3.13
 18:   - readline=8.2
 19:   - tk=8.6.13
 20:   - xz=5.4.6
 21:   - pip:
 22:     - absl-py==2.3.0
 23:     - anon-sbm==0.1.0
 24:     - anyio==4.6.2.post1
 25:     - appnope==0.1.4
 26:     - argon2-cffi==23.1.0
 27:     - argon2-cffi-bindings==21.2.0
 28:     - arrow==1.3.0
 29:     - asttokens==2.4.1
 30:     - async-lru==2.0.4
 31:     - attrs==24.2.0
 32:     - babel==2.16.0
 33:     - beautifulsoup4==4.12.3
 34:     - bleach==6.2.0
 35:     - certifi==2024.8.30
 36:     - cffi==1.17.1
 37:     - charset-normalizer==3.4.0
 38:     - comm==0.2.2
 39:     - contourpy==1.3.1
 40:     - cycler==0.12.1
 41:     - debugpy==1.8.9
 42:     - decorator==5.1.1
 43:     - defusedxml==0.7.1
 44:     - executing==2.1.0
 45:     - fastjsonschema==2.20.0
 46:     - fonttools==4.55.0
 47:     - fqdn==1.5.1
 48:     - h11==0.14.0
 49:     - httpcore==1.0.7
 50:     - httpx==0.27.2
 51:     - idna==3.10
 52:     - immutabledict==4.2.1
 53:     - iniconfig==2.0.0
 54:     - ipykernel==6.29.5
 55:     - ipython==8.29.0
 56:     - ipywidgets==8.1.5
 57:     - isoduration==20.11.0
 58:     - jedi==0.19.2
 59:     - jinja2==3.1.4
 60:     - joblib==1.5.1
 61:     - json5==0.9.28
 62:     - jsonpointer==3.0.0
 63:     - jsonschema==4.23.0
 64:     - jsonschema-specifications==2024.10.1
 65:     - jupyter==1.1.1
 66:     - jupyter-client==8.6.3
 67:     - jupyter-console==6.6.3
 68:     - jupyter-core==5.7.2
 69:     - jupyter-events==0.10.0
 70:     - jupyter-lsp==2.2.5
 71:     - jupyter-server==2.14.2
 72:     - jupyter-server-terminals==0.5.3
 73:     - jupyterlab==4.2.6
 74:     - jupyterlab-pygments==0.3.0
 75:     - jupyterlab-server==2.27.3
 76:     - jupyterlab-widgets==3.0.13
 77:     - k-means-constrained==0.7.3
 78:     - kiwisolver==1.4.7
 79:     - markupsafe==3.0.2
 80:     - matplotlib==3.9.2
 81:     - matplotlib-inline==0.1.7
 82:     - mistune==3.0.2
 83:     - nbclient==0.10.0
 84:     - nbconvert==7.16.4
 85:     - nbformat==5.10.4
 86:     - nest-asyncio==1.6.0
 87:     - networkx==3.4.2
 88:     - notebook==7.2.2
 89:     - notebook-shim==0.2.4
 90:     - numpy==1.26.4
 91:     - ortools==9.14.6206
 92:     - overrides==7.7.0
 93:     - packaging==24.2
 94:     - pandas==2.3.0
 95:     - pandocfilters==1.5.1
 96:     - parso==0.8.4
 97:     - pathlib==1.0.1
 98:     - pexpect==4.9.0
 99:     - pillow==11.0.0
100:     - platformdirs==4.3.6
101:     - pluggy==1.5.0
102:     - prometheus-client==0.21.0
103:     - prompt-toolkit==3.0.48
104:     - protobuf==6.31.1
105:     - psutil==6.1.0
106:     - ptyprocess==0.7.0
107:     - pure-eval==0.2.3
108:     - pycparser==2.22
109:     - pygments==2.18.0
110:     - pymetis==2025.1.1
111:     - pyparsing==3.2.0
112:     - pytest==8.3.4
113:     - python-dateutil==2.9.0.post0
114:     - python-json-logger==2.0.7
115:     - pytz==2025.2
116:     - pyyaml==6.0.2
117:     - pyzmq==26.2.0
118:     - referencing==0.35.1
119:     - requests==2.32.3
120:     - rfc3339-validator==0.1.4
121:     - rfc3986-validator==0.1.1
122:     - rpds-py==0.21.0
123:     - scikit-learn==1.7.0
124:     - scipy==1.14.1
125:     - send2trash==1.8.3
126:     - setuptools==75.6.0
127:     - six==1.16.0
128:     - sniffio==1.3.1
129:     - soupsieve==2.6
130:     - stack-data==0.6.3
131:     - terminado==0.18.1
132:     - threadpoolctl==3.6.0
133:     - tinycss2==1.4.0
134:     - tornado==6.4.2
135:     - tqdm==4.67.1
136:     - traitlets==5.14.3
137:     - types-python-dateutil==2.9.0.20241003
138:     - typing-extensions==4.14.0
139:     - tzdata==2025.2
140:     - uri-template==1.3.0
141:     - urllib3==2.2.3
142:     - wcwidth==0.2.13
143:     - webcolors==24.11.1
144:     - webencodings==0.5.1
145:     - websocket-client==1.8.0
146:     - widgetsnbextension==4.0.13
147: prefix: /opt/anaconda3/envs/anon_sbm

================
File: pyproject.toml
================
1: [build-system]
2: requires = ["setuptools", "wheel"]
3: build-backend = "setuptools.build_meta"

================
File: README.md
================
1: # anon_sbm

================
File: requirements.txt
================
 1: pytest
 2: numpy==1.26.4
 3: scipy==1.12.0
 4: networkx
 5: metis
 6: ortools
 7: tqdm
 8: pyyaml
 9: nodevectors
10: scikit-learn
11: k-means-constrained

================
File: tmp_test.py
================
 1: import numpy as np
 2: import scipy.sparse as sp
 3: import pytest
 4: from sbm.sampling import (
 5:     sample_adjacency_matrix,
 6:     sample_sbm_graph_from_fit,
 7: )
 8: from sbm.io import SBMFit
 9: from sbm.graph_data import GraphData
10: # --------------------------------------------------------------------
11: # helpers
12: # --------------------------------------------------------------------
13: def csr_edges_between(adj: sp.csr_array, idx_a, idx_b, directed:bool = False):
14:     """number of non-zero entries with row in A and col in B"""
15:     sub = adj[idx_a][:, idx_b] # type: ignore
16:     if idx_a == idx_b and not directed:
17:         # self-edges, count only upper triangle
18:         return sub.count_nonzero() // 2 # type: ignore
19:     elif not directed:
20:         # undirected, count both directions
21:         return sub.count_nonzero() // 2 + sub[idx_a][:, idx_b].T.count_nonzero() // 2 # type: ignore
22:     else:
23:         return sub.count_nonzero() # type: ignore
24: def complete_block_edges(n, directed):
25:     return n * (n - 1) if directed else n * (n - 1) // 2
26: # --------------------------------------------------------------------
27: # 1. full connectivity should yield a complete bipartite/clique
28: # --------------------------------------------------------------------
29: def test_full_connectivity(rng, directed):
30:     n1, n2 = 3, 4
31:     sizes = [n1, n2]
32:     # maximum possible edges
33:     B = 2
34:     conn = sp.csr_array((B, B), dtype=int)
35:     conn[0, 0] = complete_block_edges(n1, directed)
36:     conn[1, 1] = complete_block_edges(n2, directed)
37:     conn[0, 1] = conn[1, 0] = n1 * n2
38:     adj = sample_adjacency_matrix(sizes, conn, directed=directed, rng=rng)
39:     idx0 = slice(0, n1)
40:     idx1 = slice(n1, n1 + n2)
41:     # --- within-block ------------------------------------------------
42:     assert csr_edges_between(adj, idx0, idx0, directed) == conn[0, 0], \
43:         (
44:             f"expected {conn[0, 0]} edges within block 0. Got {csr_edges_between(adj, idx0, idx0)}. "
45:             f"sizes: {sizes}, conn: {conn.toarray().flatten()}, directed: {directed}"
46:         )
47:     assert csr_edges_between(adj, idx1, idx1) == conn[1, 1], \
48:         (
49:             f"expected {conn[1, 1]} edges within block 1"
50:             f"sizes: {sizes}, conn: {conn}, directed: {directed}"
51:         )
52:     # --- between blocks ---------------------------------------------
53:     expect = conn[0, 1]
54:     assert csr_edges_between(adj, idx0, idx1) == expect,\
55:         (
56:             f"expected {expect} edges between blocks 0 and 1. Got {csr_edges_between(adj, idx0, idx1)}. "
57:             f"sizes: {sizes}, conn: {conn.toarray().flatten()}, directed: {directed}"
58:         )
59:     assert csr_edges_between(adj, idx1, idx0) == expect, \
60:         (
61:             f"expected {expect} edges between blocks 1 and 0. Got {csr_edges_between(adj, idx1, idx0)}. "
62:             f"sizes: {sizes}, conn: {conn.toarray().flatten()}, directed: {directed}"
63:         )
64:     if directed:
65:         # both directions filled
66:         assert csr_edges_between(adj, idx1, idx0) == expect, \
67:                 f"expected {expect} edges between blocks 1 and 0. Got {csr_edges_between(adj, idx1, idx0)}"
68:     # --- no self-loops ----------------------------------------------
69:     assert adj.diagonal().sum() == 0, \
70:                 "expected no self-loops in the adjacency matrix"
71: if __name__ == "__main__":
72:     rng = np.random.default_rng(42)  # For reproducibility
73:     for directed in [False, True]:
74:         test_full_connectivity(rng, directed)
75:         print(f"Test for {'directed' if directed else 'undirected'} graph passed.")

================
File: configs/sbm_fit_block_size_experiments.yml
================
 1: # -------------------------------------------------------------------
 2: #  Global defaults
 3: # -------------------------------------------------------------------
 4: seed: 42
 5: # -------------------------------------------------------------------
 6: #  Configuration for the SBM models fitting as list of dicts
 7: # Each item needs:
 8: #    min_block_size: minimum size of the blocks
 9: #    n_iter: number of iterations for the fitting
10: #    temperature: initial temperature for the simulated annealing
11: #    cooling_rate: cooling rate for the simulated annealing
12: #    force_undirected: whether to treat the graph as undirected
13: # -------------------------------------------------------------------
14: sbm:
15:   - min_block_size: 3
16:     max_n_iter: 1_000_000_000
17:     temperature: 1.0
18:     cooling_rate: 0.9999
19:     force_undirected: true
20:     init_method: "ProneKMeans"
21:     patience: 1000
22:   #- min_block_size: 6
23:   #  max_n_iter: 10_000
24:   #  temperature: 1.0
25:   #  cooling_rate: 0.9999
26:   #  force_undirected: true
27:   #  init_method: "ProneKMeans"
28:   #  patience: 1000
29:   #- min_block_size: 12
30:   #  max_n_iter: 10_000
31:   #  temperature: 1.0
32:   #  cooling_rate: 0.9999
33:   #  force_undirected: true
34:   #  init_method: "ProneKMeans"
35:   #  patience: 1000
36:   #- min_block_size: 25
37:   #  max_n_iter: 10_000
38:   #  temperature: 1.0
39:   #  cooling_rate: 0.9999
40:   #  force_undirected: true
41:   #  init_method: "ProneKMeans"
42:   #  patience: 1000
43: # -------------------------------------------------------------------
44: #  Configuration for the logging
45: #  - logging_folder: folder to save the logs
46: #  - overwirte: set true to ignore cached results
47: #  - log_every: how often to log the results (in number of iterations)
48: # -------------------------------------------------------------------
49: logging:
50:   - logging_folder: "./logs/"
51:     overwrite: true           # set true to ignore cached results
52:     log_every: 1_000
53: # -------------------------------------------------------------------
54: #  List of empirical graphs to process
55: #  Each item needs:
56: #    name : label used for output folder (models/sbm/<name>/)
57: #    path : relative or absolute path to the processed graph file
58: # -------------------------------------------------------------------
59: datasets:
60: # small datasets (< 1000 nodes)
61:   - name: congress_twitter
62:     path: data/processed/congress_twitter.edgelist # undirected GML
63:   - name: caltech_fb 
64:     path: data/processed/caltech_fb.edgelist # undirected GML
65:   - name: eu_email
66:     path: data/processed/eu_email.edgelist # undirected GML
67: # medium datasets (1000 - 10_000 nodes):
68:   #- name: lastfm_asia
69:   #  path: data/processed/lastfm_asia.edgelist # undirected GML
70:   #- name: wiki_vote
71:   #  path: data/processed/wiki_vote.edgelist # undirected GML
72: # large datasets (10_000-100_000 nodes):
73:   #- name: enron_email 
74:   #  path: data/processed/enron_email.edgelist # undirected GML

================
File: notebooks/sbm_block_sizes_26-06-2025.ipynb
================
  1: {
  2:  "cells": [
  3:   {
  4:    "cell_type": "markdown",
  5:    "id": "09dbb184",
  6:    "metadata": {},
  7:    "source": [
  8:     "# Investigate SBM block sizes\n",
  9:     "We are attempting to learn SBM representations with a min-block size constraint.\n",
 10:     "\n",
 11:     "Optimally, we would like all blocks to have minimum size (gives smallest expected reconstruction error).\n",
 12:     "\n",
 13:     "The current implementation (Metis asigner) creates initial blocks, and their sizes never change. However, these initial blocks are not all minimum block size.\n",
 14:     "\n",
 15:     "Here we plot the actual block-size distributions and compare with pre-specified min-block-size."
 16:    ]
 17:   },
 18:   {
 19:    "cell_type": "code",
 20:    "execution_count": 1,
 21:    "id": "7097892b",
 22:    "metadata": {},
 23:    "outputs": [],
 24:    "source": [
 25:     "from pathlib import Path\n",
 26:     "import numpy as np\n",
 27:     "import pandas as pd\n",
 28:     "import matplotlib.pyplot as plt"
 29:    ]
 30:   },
 31:   {
 32:    "cell_type": "code",
 33:    "execution_count": 2,
 34:    "id": "8cb75b7b",
 35:    "metadata": {},
 36:    "outputs": [],
 37:    "source": [
 38:     "def get_min_block_size(string):\n",
 39:     "    # find index of substring 'min_block_size'\n",
 40:     "    index = string.find('min_block_size')\n",
 41:     "\n",
 42:     "    tail_string = string[index + len('min_block_size_'):]\n",
 43:     "    block_size = tail_string.split(\"_\")[0]\n",
 44:     "\n",
 45:     "    return int(block_size)"
 46:    ]
 47:   },
 48:   {
 49:    "cell_type": "code",
 50:    "execution_count": 4,
 51:    "id": "968e6b67",
 52:    "metadata": {},
 53:    "outputs": [
 54:     {
 55:      "name": "stdout",
 56:      "output_type": "stream",
 57:      "text": [
 58:       "Loading fit from /Users/lmmi/anon_sbm/data/sbm_fits/sbm_fit_congress_twitter_cooling_rate_0_999_force_undirected_True_init_method_ProneKMeans_max_n_iter_10000_min_block_size_3_patience_1000_temperature_1_0\n"
 59:      ]
 60:     },
 61:     {
 62:      "ename": "FileNotFoundError",
 63:      "evalue": "[Errno 2] No such file or directory: '/Users/lmmi/anon_sbm/data/sbm_fits/sbm_fit_congress_twitter_cooling_rate_0_999_force_undirected_True_init_method_ProneKMeans_max_n_iter_10000_min_block_size_3_patience_1000_temperature_1_0/block_sizes.json'",
 64:      "output_type": "error",
 65:      "traceback": [
 66:       "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
 67:       "\u001b[31mFileNotFoundError\u001b[39m                         Traceback (most recent call last)",
 68:       "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[4]\u001b[39m\u001b[32m, line 21\u001b[39m\n\u001b[32m     19\u001b[39m \u001b[38;5;28mprint\u001b[39m(\u001b[33mf\u001b[39m\u001b[33m\"\u001b[39m\u001b[33mLoading fit from \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mfit_folder_path\u001b[38;5;132;01m}\u001b[39;00m\u001b[33m\"\u001b[39m)\n\u001b[32m     20\u001b[39m min_block_size = get_min_block_size(\u001b[38;5;28mstr\u001b[39m(fit_folder_path))\n\u001b[32m---> \u001b[39m\u001b[32m21\u001b[39m sbm_fit = \u001b[43mSBMWriter\u001b[49m\u001b[43m.\u001b[49m\u001b[43mload\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfit_folder_path\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43msilence\u001b[49m\u001b[43m=\u001b[49m\u001b[38;5;28;43;01mTrue\u001b[39;49;00m\u001b[43m)\u001b[49m\n\u001b[32m     23\u001b[39m min_block_sizes.append([min_block_size] * \u001b[38;5;28mlen\u001b[39m(sbm_fit.block_sizes))\n\u001b[32m     24\u001b[39m block_sizes.append(sbm_fit.block_sizes)\n",
 69:       "\u001b[36mFile \u001b[39m\u001b[32m~/anon_sbm/src/sbm/io.py:51\u001b[39m, in \u001b[36mSBMWriter.load\u001b[39m\u001b[34m(path, silence)\u001b[39m\n\u001b[32m     48\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m silence:\n\u001b[32m     49\u001b[39m     \u001b[38;5;28mprint\u001b[39m(\u001b[33mf\u001b[39m\u001b[33m\"\u001b[39m\u001b[33mLoading SBM fit from \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mpath\u001b[38;5;132;01m}\u001b[39;00m\u001b[33m\"\u001b[39m)\n\u001b[32m---> \u001b[39m\u001b[32m51\u001b[39m \u001b[38;5;28;01mwith\u001b[39;00m \u001b[38;5;28;43mopen\u001b[39;49m\u001b[43m(\u001b[49m\u001b[43mpath\u001b[49m\u001b[43m \u001b[49m\u001b[43m/\u001b[49m\u001b[43m \u001b[49m\u001b[33;43m\"\u001b[39;49m\u001b[33;43mblock_sizes.json\u001b[39;49m\u001b[33;43m\"\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[33;43m'\u001b[39;49m\u001b[33;43mr\u001b[39;49m\u001b[33;43m'\u001b[39;49m\u001b[43m)\u001b[49m \u001b[38;5;28;01mas\u001b[39;00m sizes_file:\n\u001b[32m     52\u001b[39m     block_sizes = json.load(sizes_file)\n\u001b[32m     53\u001b[39m block_sizes = [\u001b[38;5;28mint\u001b[39m(size) \u001b[38;5;28;01mfor\u001b[39;00m size \u001b[38;5;129;01min\u001b[39;00m block_sizes]\n",
 70:       "\u001b[31mFileNotFoundError\u001b[39m: [Errno 2] No such file or directory: '/Users/lmmi/anon_sbm/data/sbm_fits/sbm_fit_congress_twitter_cooling_rate_0_999_force_undirected_True_init_method_ProneKMeans_max_n_iter_10000_min_block_size_3_patience_1000_temperature_1_0/block_sizes.json'"
 71:      ]
 72:     }
 73:    ],
 74:    "source": [
 75:     "import yaml\n",
 76:     "from sbm.utils.pipeline_utils import sbmfit_folderpath\n",
 77:     "from sbm.io import SBMWriter\n",
 78:     "\n",
 79:     "fit_config = yaml.safe_load(Path(\"/Users/lmmi/anon_sbm/configs/sbm_fit_block_size_experiments.yml\").read_text())\n",
 80:     "data_config = fit_config[\"datasets\"] # type: ignore\n",
 81:     "\n",
 82:     "min_block_sizes = []\n",
 83:     "block_sizes = []\n",
 84:     "for sbm_config in fit_config[\"sbm\"]:\n",
 85:     "    for ds in data_config:\n",
 86:     "\n",
 87:     "        # load fitted model\n",
 88:     "        fit_folder_path = sbmfit_folderpath(\n",
 89:     "            base_dir=Path(\"/Users/lmmi/anon_sbm/data/sbm_fits\"),\n",
 90:     "            sbm_config=sbm_config,# type: ignore\n",
 91:     "            data_spec=ds,\n",
 92:     "        )\n",
 93:     "        print(f\"Loading fit from {fit_folder_path}\")\n",
 94:     "        min_block_size = get_min_block_size(str(fit_folder_path))\n",
 95:     "        sbm_fit = SBMWriter.load(fit_folder_path, silence=True)\n",
 96:     "\n",
 97:     "        min_block_sizes.append([min_block_size] * len(sbm_fit.block_sizes))\n",
 98:     "        block_sizes.append(sbm_fit.block_sizes)\n"
 99:    ]
100:   },
101:   {
102:    "cell_type": "code",
103:    "execution_count": 35,
104:    "id": "7d83487f",
105:    "metadata": {},
106:    "outputs": [],
107:    "source": [
108:     "# flatten the lists\n",
109:     "min_block_sizes = np.array([ item for sublist in min_block_sizes for item in sublist ])\n",
110:     "block_sizes = np.array([ item for sublist in block_sizes for item in sublist ])"
111:    ]
112:   },
113:   {
114:    "cell_type": "code",
115:    "execution_count": 36,
116:    "id": "545352fa",
117:    "metadata": {},
118:    "outputs": [
119:     {
120:      "name": "stderr",
121:      "output_type": "stream",
122:      "text": [
123:       "/var/folders/y6/j9fbqcvx6lb5l99614n30y4c0000gn/T/ipykernel_92149/2968653449.py:7: UserWarning: FigureCanvasAgg is non-interactive, and thus cannot be shown\n",
124:       "  fig.show()\n"
125:      ]
126:     },
127:     {
128:      "data": {
129:       "image/png": "iVBORw0KGgoAAAANSUhEUgAAA0kAAAINCAYAAADrxzSOAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjMsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvZiW1igAAAAlwSFlzAAAPYQAAD2EBqD+naQAAVt9JREFUeJzt3Xt8zvX/x/HntWEHbMxpxjDnyClJEhE5pZxSSKGiRDmFnM/NKaSEkkMHdBLfDnSSlFD55lAhND9zGEXbbGxm+/z+eH/Nlo2N69rn2rXH/Xa7bt+9X9fnurzsd/3Wnt7vz/vtsCzLEgAAAABAkuRldwMAAAAA4E4ISQAAAACQBiEJAAAAANIgJAEAAABAGoQkAAAAAEiDkAQAAAAAaRCSAAAAACANQhIAAAAApJHP7gZcLSUlRcePH1fhwoXlcDjsbgcAAACATSzL0tmzZxUSEiIvr8znizw+JB0/flyhoaF2twEAAADATURGRqps2bKZPu/xIalw4cKSzDciICDA5m4AAAAA2CU2NlahoaGpGSEzHh+SLi2xCwgIICQBAAAAuOZtOGzcAAAAAABpEJIAAAAAIA1CEgAAAACkQUgCAAAAgDQISQAAAACQBiEJAAAAANIgJAEAAABAGoQkAAAAAEiDkAQAAAAAaRCSAAAAACANQhIAAAAApEFIAgAAAIA0CEkAAAAAkAYhCQAAAIBL/PWXFBYmFSpk/vevv+zuKGvy2d0AAAAAAM9TpIgUE3N5HB8vlSwpBQZK0dF2dZU1zCQBAAAAcKp/B6S0YmLM8+6MkAQAAADAaf76K/OAdElMjHsvvSMkAQAAAHCa225z7nV2ICQBAAAAcJqszhAxkwQAAAAgTyhRwrnX2YGQBAAAAMBpfvzRudfZgZAEAAAAwGlKlDDbfF9NYCAzSQAAAADykOjozIMS5yQBAAAAyJOio6U777w8rlBBOnXK/QOSJOWzuwEAAAAAnsnH5/LXERH29ZFdzCQBAAAAQBqEJAAAAABIg5AEAAAAAGkQkgAAAAAgDUISAAAAAJc4duzy1w6H9NFH9vWSHexuBwAAAMDpHI4ra507m/+1rJztJbuYSQIAAADgVBkFpOw8bzdCEgAAAACnyeqSOndeekdIAgAAAOA0l5bUOes6OxCSAAAAACANQhIAAAAApEFIAgAAAOA0a9Y49zo7EJIAAAAAOE2nTs69zg6EJAAAAABOda1zkDgnCQAAAECeY1lS9erpa2vWuH9AkqR8djcAAAAAwDOVKSPt22e+zg3h6BJmkgAAAAAgDUISAAAAAKRBSAIAAACANAhJAAAAAJAGIQkAAACAS/z44+WvHQ5p5Ej7eskOW0NSeHi4GjRooMKFC6tkyZLq2LGj9u/fn+6aZs2ayeFwpHs89dRTNnUMAAAAICscDuns2fS1mTNN3d3ZGpK+/fZbDRgwQNu2bdOXX36ppKQktWrVSvHx8emu69u3r06cOJH6mDlzpk0dAwAAALiWawUhdw9Ktp6TtGHDhnTj5cuXq2TJktqxY4eaNm2aWvf391dwcHBOtwcAAAAgm7K6pG7kSGnGDNf2cr3c6p6kmJgYSVJQUFC6+jvvvKPixYvr5ptv1qhRo3Tu3LlM3yMxMVGxsbHpHgAAAAByRlYXfbnz4jBbZ5LSSklJ0eDBg9W4cWPdfPPNqfUePXqofPnyCgkJ0e7duzVy5Ejt379fa9asyfB9wsPDNWnSpJxqGwAAAICHcViWZdndhCT1799f69ev1/fff6+yZctmet3GjRvVokULHTx4UJUqVbri+cTERCUmJqaOY2NjFRoaqpiYGAUEBLikdwAAACCv+/tvadas7M0Q5XQSiY2NVWBg4DWzgVvMJA0cOFCffPKJNm/efNWAJEkNGzaUpExDko+Pj3x8fFzSJwAAAID0Tp+WXnxRevllKS4u668bMcJ1Pd0oW+9JsixLAwcO1EcffaSNGzcqLCzsmq/ZuXOnJKl06dIu7g4AAABAZs6ckcaOlcLCpPBwE5Dq1ZPWrcva69110wbJ5pmkAQMGaOXKlVq3bp0KFy6sqKgoSVJgYKD8/Px06NAhrVy5Uu3atVOxYsW0e/duDRkyRE2bNlXt2rXtbB0AAADIk/75R5o7V3rpJenSHml16kgTJ0odOpjtvS3r6tt8u8cNP5mz9Z4kRybfuWXLlql3796KjIxUz5499euvvyo+Pl6hoaHq1KmTxo4dm+X7i7K67hAAAABA5mJipHnzTED636bUqlXLhKOOHSWvDNaoBQSkP1B2xAh7Z5ByxT1J18pnoaGh+vbbb3OoGwAAAAD/FhtrZo3mzJGio02tZk0Tjjp3zjgcXXLbbdLXX5uv3X32KC232LgBAAAAgHs5e1aaP99syvDPP6Z2003ShAlS165XD0e5HSEJAAAAQKq4OLNT3ezZZnMGSapWzYSjBx+UvL3t7S8nEJIAAAAAKD5eWrDAnHX099+mVrWqNH681K1b3ghHlxCSAAAAgDzs3Dnp1VfNIbB//WVqlSubcNS9u5QvDyaGPPhXBgAAAHDunLRokdlt7tQpU6tYURo3TurZM2+Go0vy8F8dAAAAyHvOn5dee02aPl363zGlqlDBhKNHHpHy57e1PbdASAIAAADygIQE6fXXpfBw6cQJUytfXho7VurVi3CUFiEJAAAA8GCJidKSJSYcHTtmauXKSWPGSL17SwUK2NqeWyIkAQAAAB4oMVFaulR64QXp6FFTK1vWhKM+fSQfH3v7c2eEJAAAAMCDXLggLVsmTZsmRUaaWkiINHq09MQThKOsICQBAAAAHiApSVqxQpo6Vfq//zO10qWlUaOkvn0lX197+8tNCEkAAABALpaUJL31lglHERGmFhwsPf+81K+f5Odnb3+5ESEJAAAAyIUuXpTefluaMkX6809TK1nShKMnn5T8/e3tLzcjJAEAAAC5yMWL0sqVJhwdPGhqJUpII0ZI/ftLBQva258nICQBAAAAuUBysrR6tTR5svTHH6ZWrJgJRwMGEI6ciZAEAAAAuLHkZOm990w42rfP1IKCpOHDpYEDpUKF7O3PExGSAAAAADeUkiK9/740aZK0d6+pFS0qDRsmPfOMFBBgb3+ejJAEAAAAuJGUFOnDD004+u03UytSRBo6VHr2WSkw0Nb28gRCEgAAAOAGUlKktWuliROlPXtMLTBQGjJEGjTIBCXkDEISAAAAYCPLktatM+Fo1y5TK1xYGjzYBKSiRe3sLm8iJAEAAAA2sCzp449NOPrlF1MrVMjMGg0dajZngD0ISQAAAEAOsizp009NONqxw9QKFjT3Gw0bZrb1hr0ISQAAAEAOsCxpwwZpwgTpp59Mzd/f7FT33HNS8eL29ofLCEkAAACAC1mW9MUXJhxt325qfn7mANjhw6WSJe3tD1ciJAEAAAAuYFnSV1+ZcLR1q6n5+kpPPy2NGCGVKmVvf8gcIQkAAABwIsuSNm409xx9/72p+fpKTz0ljRwpBQfb2h6ygJAEAAAAOMmmTWbmaPNmM/bxkZ58Unr+eal0aVtbQzYQkgAAAIAbtHmzCUebNplxgQJS377SqFFSmTK2tobrQEgCAAAArtP335twtHGjGefPLz3xhAlHoaH29obrR0gCAAAAsmnrVhOOvvzSjPPnlx57TBo9WipXzt7ecOMISQAAAEAWbd9uwtHnn5txvnxSnz7SmDFS+fL29gbnISQBAAAA1/DTTyYcrV9vxt7eUq9e0tixUliYvb3B+QhJAAAAQCZ27DDh6NNPzdjbW3rkEROOKlWytze4DiEJAAAA+JdffjHnHP3nP2bs5SX17CmNGydVrmxra8gBhCQAAADgf3btMuFo7Voz9vKSevQw4ahqVTs7Q04iJAEAACDP27PHhKM1a8zY4ZC6dZPGj5eqV7e1NdiAkAQAAIA869dfpUmTpA8+MGOHQ3rwQROOatSwtzfYh5AEAACAPOf336XJk6X33pMsy9S6djXh6Oab7e0N9iMkAQAAIM/Yt8+Eo9WrL4ejzp3NDna1a9vbG9wHIQkAAAAe748/TDhatUpKSTG1jh1NOKpb187O4I4ISQAAAPBYBw5IU6ZI77xzORzdf7/ZpKFePVtbgxsjJAEAAMDjHDokTZ0qvfWWlJxsau3bm3BUv76trSEXICQBAADAY0REmHC0YsXlcNSunQlHDRrY2hpyEUISAAAAcr3Dh6Vp06Tly6WLF02tdWuzvXfDhnZ2htyIkAQAAIBc68gRE46WLZOSkkztnntMOGrUyN7ekHsRkgAAAJDrHD0qvfCCtGTJ5XDUooUJR40b29sbcj9CEgAAAHKNY8ek8HDp9delCxdMrXlzc89R06a2tgYPQkgCAACA2zt+XJo+XXrtNSkx0dSaNjUzR82a2doaPBAhCQAAAG4rKsqEo8WLpYQEU7vzThOOmjeXHA57+4NnIiQBAADA7Zw8Kc2cKb366uVwdMcdJhy1aEE4gmsRkgAAAOA2Tp2SZs2SFiyQzp83tYYNTThq1YpwhJxBSAIAAIDt/v7bhKNXXpHOnTO1Bg1MOGrThnCEnEVIAgAAgG1On5Zmz5ZeflmKjze1+vVNOGrXjnAEexCSAAAAkOPOnJHmzJFeekmKizO1evVMOGrfnnAEexGSAAAAkGP++UeaO9eEo9hYU6tTx5xz1KED4QjugZAEAAAAl4uOlubNM4+YGFOrVcuEo44dJS8v21oDrkBIAgAAgMvExppZozlzTFCSpJo1TTjq3JlwBPdESAIAAIDTnT0rzZ8vvfiiWWInSTVqSBMmSA88QDiCeyMkAQAAwGnOnjXbeM+ebTZnkKTq1aXx46UHH5S8ve3tD8gKQhIAAABuWFycOQB21iyzrbckVa1qwlG3boQj5C6EJAAAAFy3+Hhp4UJp5kzpr79MrXJlE466d5fy8dsmciE+tgAAAMi2c+ekRYukGTOkU6dMrWJFE44efphwhNyNjy8AAACy7Px5afFiE46iokwtLEwaO1Z65BEpf357+wOcgZAEAACAa0pIkF5/XQoPl06cMLXy5U046tWLcATPQkgCAABAphITpSVLTDg6dszUypWTxoyReveWChSwtT3AJQhJAAAAuEJiorR0qfTCC9LRo6ZWtqwJR336SD4+9vYHuBIhCQAAAKkuXJCWLZOmTZMiI00tJEQaPVp64gnCEfIGQhIAAACUlCStWCFNnSr93/+ZWunS0qhRUt++kq+vvf0BOYmQBAAAkIclJUlvvWXCUUSEqQUHS88/L/XrJ/n52dsfYAdCEgAAQB508aL09tvSlCnSn3+aWsmSJhw9+aTk729vf4CdvOz8w8PDw9WgQQMVLlxYJUuWVMeOHbV///501yQkJGjAgAEqVqyYChUqpC5duujkyZM2dQwAAJC7XbwovfmmdNNNZgOGP/+USpSQZs0yXw8ZQkACbA1J3377rQYMGKBt27bpyy+/VFJSklq1aqX4+PjUa4YMGaKPP/5Y77//vr799lsdP35cnTt3trFrAACA3Cc5WXrnHalmTXOu0cGDUrFi5lDYiAjpueekggXt7hJwDw7Lsiy7m7jkr7/+UsmSJfXtt9+qadOmiomJUYkSJbRy5Uo98MADkqR9+/bppptu0tatW3X77bdf8z1jY2MVGBiomJgYBQQEuPqvAAAA4FaSk6X33pMmT5b27TO1oCBp+HBp4ECpUCF7+4Nna9lS+vpr87U7pI6sZgO3uicpJiZGkhQUFCRJ2rFjh5KSktSyZcvUa6pXr65y5cplGpISExOVmJiYOo6NjXVx1wAAAO4nJUV6/31p0iRp715TK1pUGjZMeuYZiX87BjJn63K7tFJSUjR48GA1btxYN998syQpKipKBQoUUJEiRdJdW6pUKUVFRWX4PuHh4QoMDEx9hIaGurp1AAAAt3EpHNWuLXXrZgJSkSJmJikiwhwGS0ACrs5tQtKAAQP066+/avXq1Tf0PqNGjVJMTEzqI/LSKWgAAAAeLCVF+vBDqW5d6cEHpd9+kwIDpYkTTTgaN86MAVybWyy3GzhwoD755BNt3rxZZcuWTa0HBwfrwoULio6OTjebdPLkSQUHB2f4Xj4+PvLhKGgAAJBHWJa0bp0JQ7t2mVrhwtLgwWanuqJF7ewOyJ1snUmyLEsDBw7URx99pI0bNyosLCzd8/Xr11f+/Pn19aW7vSTt379fR44cUaNGjXK6XQAAALdhWdJ//iPVry916mQCUqFCZjnd4cNmeR0BCbg+ts4kDRgwQCtXrtS6detUuHDh1PuMAgMD5efnp8DAQD3++OMaOnSogoKCFBAQoGeeeUaNGjXK0s52AAAAnsaypE8/NTNHO3aYWsGC0rPPmk0ZihWztT3AI9gakhYuXChJatasWbr6smXL1Lt3b0nS3Llz5eXlpS5duigxMVGtW7fWq6++msOdAgAA2MuypPXrTTj66SdTK1jQbOP93HNS8eK2tgd4FLc6J8kVOCcJAADkZpYlffGFNGGCtH27qfn7SwMGmLOOSpSwtz/gajgnCQAAAE5jWdJXX5lwtHWrqfn5Sf37SyNGSKVK2dsf4MkISQAAAG7EsqSNG0042rLF1Hx9paeekkaOlDLZ4BeAExGSAAAA3MSmTSYcbd5sxj4+0pNPSs8/L5UubWtrQJ5CSAIAALDZ5s0mHG3aZMYFCkj9+plwVKaMra0BeRIhCQAAwCbff2/C0caNZpw/v/TEE9KoUVJoqL29AXkZIQkAACCH/fCDCUdffWXG+fNLjz0mjR4tlStnb28ACEkAAAA5Zvt2E44+/9yM8+WT+vSRxoyRype3tzcAlxGSAAAAXOynn0w4Wr/ejL29pd69TTgKC7O1NQAZICQBAAC4yI4dJhx9+qkZe3tLjzwijR0rVapkb28AMkdIAgAAcLJffjHh6OOPzdjLS+rZUxo3Tqpc2d7eAFwbIQkAAMBJdu2SJk6U1q41Yy8vqUcPE46qVrWzMwDZQUgCAAC4QXv2mHC0Zo0ZOxxS9+4mHFWvbmtrAK4DIQkAAOA6/fqrNGmS9MEHZuxwSA8+KI0fL9WoYW9vAK4fIQkAACCbfv/dhKP335csy9S6djX3IdWsaW9vAG4cIQkAACCL9u2TJk+WVq++HI66dDHhqFYte3sD4DyEJAAAgGv44w8TjlatklJSTK1jR3MfUp06dnYGwBUISQAAAJk4cECaMkV6553L4ej++004qlfP1tYAuBAhCQAA4F8OHZKmTpXeektKTja19u1NOKpf39bWAOQAQhIAAMD/RESYcLRixeVw1K6dCUcNGtjaGoAcREgCAAB53uHD0rRp0vLl0sWLpta6tdnBrmFDOzsDYAdCEgAAyLOOHDHhaNkyKSnJ1O65x4SjRo3s7Q2AfQhJAAAgzzl6VHrhBWnJksvhqEULE44aN7a3NwD2IyQBAIA849gxKTxcev116cIFU2ve3Nxz1LSpra0BcCOEJAAA4PGOH5emT5dee01KTDS1pk3NzFGzZra2BsANEZIAAIDHiooy4WjxYikhwdTuvNOEo+bNJYfD3v4AuCdCEgAA8DgnT0ozZkgLF14OR3fcYcJRixaEIwBXR0gCAAAe49QpadYsacEC6fx5U2vY0ISjVq0IRwCyhpAEAAByvb//NuHolVekc+dMrUEDE47atCEcAcgeQhIAAMi1Tp+WZs+WXn5Zio83tfr1TThq145wBOD6EJIAAECuc+aM9OKL0vz5UlycqdWrZ8JR+/aEIwA3hpAEAAByjX/+kebOlebNk86eNbU6dcw5Rx06EI4AOAchCQAAuL3oaBOM5s2TYmJMrVYtE446dpS8vGxrDYAHIiQBAAC3FRMjvfSSmT2Kjja1mjVNOOrcmXAEwDUISQAAwO3ExprNGF580Syxk6QaNaQJE6QHHiAcAXAtQhIAAHAbZ8+abbxnzzabM0hS9eomHHXtKnl729sfgLyBkAQAAGwXF2cOgJ01y2zrLUlVq0rjx0vduhGOAOQsQhIAALBNfLy0cKE0Y4Y5EFaSKlc24ah7dykfv6kAsAE/egAAQI47d05atMiEo1OnTK1SJWncOOnhhwlHAOzFjyAAAJBjzp+XFi+Wpk+XTp40tbAwE4569pTy57e3PwCQCEkAACAHJCRIr71mwtGJE6ZWvrw0dqzUqxfhCIB7ISQBAACXSUyUliyRXnhBOn7c1MqVk8aMkXr3lgoUsLU9AMgQIQkAADhdYqK0dKkJR0ePmlrZsiYc9ekj+fjY2x8AXA0hCQAAOM2FC9KyZdK0aVJkpKmFhJhw9PjjhCMAuQMhCQAA3LCkJGn5chOO/u//TK10aWnUKKlvX8nX19b2ACBbCEkAAOC6JSVJb70lTZkiHT5sasHB0vPPS/36SX5+trYHANeFkAQAALLt4kXp7bdNOPrzT1MrWdKEoyeflPz97e0PAG4EIQkAAGTZxYvSypUmHB08aGolSkgjR0r9+xOOAHgGQhIAALim5GRp1SoTjv74w9SKF5eGD5cGDJAKFrS3PwBwJkISAADIVHKy9N570uTJ0r59phYUZMLRwIFSoUL29gcArkBIAgAAV0hJkd5/X5o0Sdq719SKFpWee0565hmpcGF7+wMAVyIkAQCAVCkp0ocfmnD022+mVqSINHSoNGiQFBBga3sAkCMISQAAQCkp0kcfmXC0Z4+pBQZKQ4aYcFSkiK3tAUCOckpIio6OVhF+egIAkOtYlrRunTRxorRrl6kFBEiDB5uAxH/eAeRFXtl9wYwZM/Tuu++mjh988EEVK1ZMZcqU0a5LP10BAIBbsyzpP/+R6teXOnUyAalQIWnMGCkiwswoEZAA5FXZDkmLFi1SaGioJOnLL7/Ul19+qfXr16tt27YaPny40xsEAADOY1nSJ59IDRpIHTpIv/xitu8eNUo6fFiaOtXsXgcAeVm2l9tFRUWlhqRPPvlEDz74oFq1aqUKFSqoYcOGTm8QAADcOMuS1q83y+p++snUChY023g/95w58wgAYGR7Jqlo0aKKjIyUJG3YsEEtW7aUJFmWpeTkZOd2BwAAbohlSRs2SI0aSffeawKSv7855ygiQpo+nYAEAP+W7Zmkzp07q0ePHqpSpYpOnz6ttm3bSpJ++eUXVa5c2ekNAgCA7LMs6auvpAkTpK1bTc3PT+rfXxoxQipVyt7+AMCdZTskzZ07VxUqVFBkZKRmzpypQv87avvEiRN6+umnnd4gAADIOsuSNm404WjLFlPz9ZWeekoaOVIKDra3PwDIDRyWZVl2N+FKsbGxCgwMVExMjAI4AQ8A4ME2bZLGj5e++86MfXykJ5+Unn9eKl3a1tYA5FEtW0pff22+dofUkdVskO17kiTprbfe0p133qmQkBD93//9nyRp3rx5Wrdu3fV1CwAArtvmzVLz5ubx3XdSgQJmQ4ZDh6SXXiIgAUB2ZTskLVy4UEOHDlXbtm0VHR2dullDkSJFNG/ePGf3BwAAMvH991KLFtJdd5lZpPz5zT1HBw9KL78slSljd4cAkDtlOyS9/PLLev311zVmzBh5e3un1m+99Vbt2bPHqc0BAIAr/fCDdM89UpMm5v6j/PnNsrqDB6VXX5X+d1IHAOA6ZXvjhoiICNWrV++Kuo+Pj+Lj453SFAAAuNK2bWZDhi++MON8+aQ+faQxY6Ty5e3tDQA8SbZnksLCwrRz584r6hs2bNBNN93kjJ4AAEAaP/4otWtnzjr64gvJ21t6/HHpjz+k114jIAGAs2V7Jmno0KEaMGCAEhISZFmWfvzxR61atUrh4eFasmSJK3oEACBP2rHDzBx9+qkZe3tLjzwijR0rVapkb28A4MmyHZKeeOIJ+fn5aezYsTp37px69OihkJAQvfTSS+rWrZsregQAIE/573+liROljz82Yy8vqWdPadw4iXPbAcD1sh2SJOnhhx/Www8/rHPnzikuLk4lS5Z0dl8AAOQ5O3eacHTpRA0vL6lHDxOOqla1szMAyFuyfU/S5MmTtXHjRkmSv79/akCKj4/X5MmTndsdAAB5wO7dUpcuUr16JiA5HCYc/fab9NZbBCQAyGnZDkkTJ05U27ZtNWfOnHT1uLg4TZo0KVvvtXnzZt13330KCQmRw+HQ2rVr0z3fu3dvORyOdI82bdpkt2UAANzSr79KXbtKdepIa9aYcPTQQ6b+zjtS9ep2dwgAeVO2Q5Ikvfnmm3rhhRfUp08fXbhw4br/8Pj4eNWpU0cLFizI9Jo2bdroxIkTqY9Vq1Zd958HAIA7+P13E4Zq15Y++MDUunaV9uyRVq+WatSwtz8AyOuu656k5s2ba/v27brvvvvUrFmzK2aAsqpt27Zq27btVa/x8fFRcHDwdb0/AADuZN8+afJkE4Qsy9S6dDE72NWqZW9vAIDLsj2T5HA4JEmVKlXStm3bFBAQoPr16+vnn392enOStGnTJpUsWVLVqlVT//79dfr0aZf8OQAAuMoff5jd6WrWlFatMgGpUyezUcMHHxCQAMDdZHsmybr0T1+SAgIC9Nlnn2nw4MHq2LGjM/uSZJbade7cWWFhYTp06JBGjx6ttm3bauvWrfL29s7wNYmJiUpMTEwdx8bGOr0vAACy4sABacoUc39RSoqp3X+/2cGuXj1bWwMAXEW2Q9KyZcsUGBiYOvby8tL8+fNVr149bd682anNpT13qVatWqpdu7YqVaqkTZs2qUWLFhm+Jjw8PNsbSAAA4EyHDplw9PbbUnKyqbVvb8JR/fq2tgYAyIJsL7fr1auXfHx8rqj36dNHy5Ytc0pTmalYsaKKFy+ugwcPZnrNqFGjFBMTk/qIjIx0aU8AAFwSESE9/rhUrZq0YoUJSO3aST/+aA6GJSABQO6QpZmk+fPnq1+/fvL19dX8+fMzvc7hcOiZZ55xWnP/dvToUZ0+fVqlS5fO9BofH58MQxwAAK5y+LA0bZq0fLl08aKptWljZo4aNrSxMQDAdclSSJo7d64efvhh+fr6au7cuZlel92QFBcXl25WKCIiQjt37lRQUJCCgoI0adIkdenSRcHBwTp06JBGjBihypUrq3Xr1ln+MwAAcJUjR0w4Wrr0cji65x5p0iSpUSN7ewMAXL8shaSIiIgMv75RP//8s5o3b546Hjp0qCSzpG/hwoXavXu3VqxYoejoaIWEhKhVq1aaMmUKM0UAAFtFRkovvCC98YaUlGRqLVqYcNS4sb29AQBu3HWdk5TWxYsXlZCQoEKFCmX7tc2aNUu3W96/ff755zfSGgAATnXsmBQeLr3+unTpLPXmzU04atLE3t4AAM6T5Y0bPv74Yy1fvjxdbdq0aSpUqJCKFCmiVq1a6Z9//nF2fwAA2O74cenZZ6VKlaQFC0xAatpU+uYbaeNGAhIAeJosh6Q5c+YoPj4+dfzDDz9o/PjxGjdunN577z1FRkZqypQpLmkSAAA7REVJgwebcPTyy1JionTnndLXX0ubNknNmtncIADAJbK83O63337TnDlzUscffPCB7rnnHo0ZM0aS5Ovrq0GDBqW7BgCA3OjkSWnGDGnhQikhwdTuuMMsq2vRQnI47O0PAOBaWQ5JZ8+eVbFixVLH33//vbp27Zo6rlmzpo4fP+7c7gAAyEGnTkmzZpkldefPm9rtt5twdM89hCMAyCuyvNyuTJky2rt3rySzdfeuXbt0xx13pD5/+vRp+fv7O79DAABc7O+/pZEjpbAwafZsE5AaNJA++0z64QepVSsCEgDkJVmeSeratasGDx6s0aNH67PPPlNwcLBuv/321Od//vlnVatWzSVNAgDgCqdPm1D08svSpdtu69c3M0ft2hGMACCvynJIGj9+vI4dO6Znn31WwcHBevvtt+Xt7Z36/KpVq3Tfffe5pEkAAJzpzBnpxRel+fOluDhTq1fPhKP27QlHAJDXZTkk+fn56c0338z0+W+++cYpDQEA4Cr//CPNmSO99JJ09qyp1aljwtH99xOOAADGDR8mCwCAu4uOlubNk+bOlWJjTa1WLWniRKljR8kry3foAgDyAkISAMBjxcSYWaO5c01QkqSaNU046tyZcAQAyBghCQDgcWJjzf1Gc+aYJXaSVKOGNGGC9MADhCMAwNURkgAAHuPsWemVV8yOdWfOmFr16iYcde0qpdlvCACATGX739KOHj2a6XPbtm27oWYAALgecXHSjBnmnKPRo01AqlpVevtt6ddfpW7dCEgAgKzLdkhq1aqVzlz657k0tmzZojZt2jilKQAAsiI+Xpo1y4Sj55835x5Vriy9+ab022/Sww8TjgAA2ZftkHT77berVatWOntp71RJmzdvVrt27TRhwgSnNgcAQEbOnTP3G1WsKI0YIf39t1SpkrR8ubR3r/TII1I+FpQDAK5TtkPSkiVLVK5cOd13331KTEzUN998o3vvvVeTJ0/WkCFDXNEjAACSpPPnzVbeFStKw4ZJp06ZWaSlS0046tWLcAQAuHHZDkleXl5avXq18ufPr7vvvlv333+/wsPDNWjQIFf0BwCAEhLMbnWVKklDhkgnT0rly0uvvy7t3y/16SPlz293lwAAT5Glf2/bvXv3FbWJEyeqe/fu6tmzp5o2bZp6Te3atZ3bIQAgz0pIkJYskcLDpePHTa1cOWnMGKl3b6lAAVvbAwB4KIdlWda1LvLy8pLD4VDaS9OOL33tcDiUnJzsum6vQ2xsrAIDAxUTE6OAgAC72wEAZEFiollCN22adOyYqZUta8JRnz6Sj4+9/QEAsqZlS+nrr83X104drpfVbJClmaSIiAinNQYAQGYuXJCWLTPhKDLS1EJCTDh6/HHCEQAgZ2QpJJUvX97VfQAA8rCkJLMz3bRp0v/9n6mVLi2NGiX17Sv5+traHgAgj8n2xg3h4eFaunTpFfWlS5dqxowZTmkKAOA8P/4oORyXHz/+aHdHlyUlSW+8YQ5+7dfPBKTgYLOD3aFD0jPPEJAAADkv2yFp8eLFql69+hX1mjVratGiRU5pCgDgHA6H1LBh+lrDhqZup4sXzcxR9erSE09Ihw9LJUuas4/+/FMaNEjy87O3RwBA3pXt0ySioqJUunTpK+olSpTQiRMnnNIUAODGXSsIORw5fxPtxYvSypXSlCnSwYOmVqKENHKk1L+/5O+fs/0AAJCRbM8khYaGasuWLVfUt2zZopCQEKc0BQC4MVldUpdTS++Sk6W335Zq1DAHvh48KBUvLs2YIUVEmINhCUgAAHeR7Zmkvn37avDgwUpKStLdd98tSfr66681YsQIDRs2zOkNAgCy799L7K52nStnk5KTpXfflSZPNoe+SlJQkDR8uDRwoFSokOv+bAAArle2Q9Lw4cN1+vRpPf3007pw4YIkydfXVyNHjtSoUaOc3iAAIPdJSZHef1+aNEnau9fUihaVnnvObMZQuLC9/QEAcDVZOkw2I3Fxcdq7d6/8/PxUpUoV+bjp4RUcJgsgL8rOxgzOnElKSZE+/NCEo99+M7UiRcxyumeflfgxDAB5i0cfJpuRQoUKpW7g4K4BCQDyqu3bs7bkbvt25/x5KSnSRx+ZcLRnj6kFBkpDhkiDB5uvAQDILbK9cUNKSoomT56swMBAlS9fXuXLl1eRIkU0ZcoUpaSkuKJHAEA23Xabc6/LjGWZcHTLLdIDD5iAFBAgjR9vtvWeMIGABADIfbI9kzRmzBi98cYbmj59uho3bixJ+v777zVx4kQlJCRo2rRpTm8SAJB9lnX1ZXc3suzBsqSPP5YmTpR++cXUChc25xsNGWI2ZwAAILfKdkhasWKFlixZovvvvz+1Vrt2bZUpU0ZPP/00IQkA3IhlmW2+0y692779+meQLEv69FMTjnbsMLVChcxmDMOGScWK3XDLAADYLtsh6cyZM6pevfoV9erVq+vMmTNOaQoA4DxpA1GDBtcXkCxLWr/ehKOffjK1ggXNNt7PPWfOPAIAwFNk+56kOnXq6JVXXrmi/sorr6hOnTpOaQoA4B4sS9qwQWrUSLr3XhOQ/P3NOUcREdL06QQkAIDnyfZM0syZM3Xvvffqq6++UqNGjSRJW7duVWRkpD777DOnNwgAyHmWJX31ldl4YetWU/Pzk55+WhoxQipZ0t7+AABwpWzPJN111136448/1KlTJ0VHRys6OlqdO3fW/v371aRJE1f0CADIIZZlzrNo0kRq1coEJF9fs433n39Ks2cTkAAAnu+6zkkKCQlhgwYA8DCbNpmtu7/7zox9fKQnn5Sef17637F4AADkCVkKSbt3787yG9auXfu6mwEAOF/abcB/+smM027/vXmzWVa3aZMZFygg9etnwlGZMjnaKgAAbiFLIalu3bpyOByyrnGohsPhUHJyslMaAwDcuMzOSXI4zIzRhAnSxo2mlj+/1LevNGqUVLZszvUIAIC7yVJIioiIcHUfAAAnu9pBspK570gy4eixx6TRo6Vy5VzfFwAA7i5LIal8+fKu7gMA4ETXCkhpHTgg8WMeAIDLsr1xw+nTp1Xsf0eqR0ZG6vXXX9f58+d1//33s7sdAORCBCQAANLL8hbge/bsUYUKFVSyZElVr15dO3fuVIMGDTR37ly99tprat68udauXevCVgEAAADA9bIckkaMGKFatWpp8+bNatasmdq3b697771XMTEx+ueff/Tkk09q+vTpruwVAJAF//2v3R0AAJC7OaxrbVn3P8WLF9fGjRtVu3ZtxcXFKSAgQD/99JPq168vSdq3b59uv/12RUdHu7LfbIuNjVVgYKBiYmIUEBBgdzsA4DI7d0oTJ0rr1mXvdVn7rwAAANnXsqU5pFxyj//eZDUbZHkm6cyZMwoODpYkFSpUSAULFlTRokVTny9atKjOnj17Ay0DAK7H7t1Sly5SvXomIDkcUo8eWXutO/wHCwAAd5PlkCSZc5CuNgYA5Jxff5W6dpXq1JHWrDHh6KGHTP2dd64dgAhIAABkLFu72/Xu3Vs+Pj6SpISEBD311FMqWLCgJCkxMdH53QEArvD779KkSdL7718OOl27moNha9ZMf61lZbwdOAEJAIDMZTkk9erVK924Z8+eV1zz6KOP3nhHAIAM7dsnTZ4srV59OeR06WLCUa1amb+OQAQAQPZkOSQtW7bMlX0AADLxxx8mHK1aJaWkmFqnTiYc1aljb28AAHiibB8mCwDIGQcOSFOmmPuLLoWjDh1MOKpXz97eAADwZIQkAHAzhw6ZcPT221Jysqm1b2+29/7fqQsAAMCFCEkA4CYiIqSpU6UVKy6Ho3btTDhq0MDW1gAAyFMISQBgs8OHpWnTpOXLpYsXTa1NGxOOGja0sTEAAPIoQhIA2OTIEROOli69HI5atTLhqFEjW1sDACBPIyQBQA6LjJReeEF64w0pKcnUWrQwZx81bmxvbwAAgJAEADnm2DEpPFx6/XXpwgVTa97chKMmTeztDQAAXEZIAgAXO35cmj5deu01KTHR1Jo2NWcf3XWXvb0BAIArEZIAwEWiokw4WrxYSkgwtTvvNDNHzZtLDoe9/QEAgIwRkgDAyU6elGbMkBYuvByO7rjDhKMWLQhHAAC4O0ISADjJqVPSrFnSggXS+fOmdvvtJhzdcw/hCACA3IKQBAA36O+/TTh65RXp3DlTu+02E45atyYcAQCQ2xCSAOA6nT4tzZ4tvfyyFB9varfeas45ateOcAQAQG5FSAKAbDpzRnrxRWn+fCkuztTq1TMzR+3bE44AAMjtCEkAkEX//CPNnSvNmyedPWtqdeuamaP77yccAQDgKQhJAHAN0dEmGM2bJ8XEmFrt2iYcdeggeXnZ1xsAAHA+QhIAZCImRnrpJTN7FB1tajffbMJRp06EIwAAPBUhCQD+JTbWbMbw4otmiZ0k1aghTZggPfAA4QgAAE9HSAKA/zl71mzjPXu22ZxBkqpXN+Goa1fJ29ve/gAAQM4gJAHI8+LizAGws2aZbb0lqVo1afx46aGHCEcAAOQ1ti4a2bx5s+677z6FhITI4XBo7dq16Z63LEvjx49X6dKl5efnp5YtW+rAgQP2NAvA48THm2AUFiY9/7wJSJUrS2+9Jf32m9SjBwEJAIC8yNaQFB8frzp16mjBggUZPj9z5kzNnz9fixYt0vbt21WwYEG1bt1aCQkJOdwpAE9y7pw0Z45UsaI0YoT0999SpUrS8uXS3r1Sz56EIwAA8jJbl9u1bdtWbdu2zfA5y7I0b948jR07Vh06dJAkvfnmmypVqpTWrl2rbt265WSrADzA+fPS4sXS9OnSyZOmFhYmjRsnPfKIlI8FyAAAQDbPJF1NRESEoqKi1LJly9RaYGCgGjZsqK1bt2b6usTERMXGxqZ7AMjbEhKk+fPNbNGQISYgVaggLVki7d8v9elDQAIAAJe5bUiKioqSJJUqVSpdvVSpUqnPZSQ8PFyBgYGpj9DQUJf2CcB9JSSY3eoqVZIGDZJOnJDKlZNee82Eo8cfl/Lnt7tLAADgbtw2JF2vUaNGKSYmJvURGRlpd0sAclhiorRwodmE4ZlnpOPHpbJlTe3AAalvX6lAAbu7BAAA7sptF5gEBwdLkk6ePKnSpUun1k+ePKm6detm+jofHx/5+Pi4uj0AbujCBWnZMmnaNOnSv4+UKSONHm1mjfjRAAAAssJtZ5LCwsIUHBysr7/+OrUWGxur7du3q1GjRjZ2BsDdJCVJr78uVa0qPfWUCUghIdLLL0sHD0pPP01AAgAAWWfrTFJcXJwOHjyYOo6IiNDOnTsVFBSkcuXKafDgwZo6daqqVKmisLAwjRs3TiEhIerYsaN9TQNwG0lJ0ptvSlOnSocPm1pwsDRqlNSvn+Tra2t7AAAgl7I1JP38889q3rx56njo0KGSpF69emn58uUaMWKE4uPj1a9fP0VHR+vOO+/Uhg0b5MtvPkCedvGi9Pbb0pQp0p9/mlqpUtLIkWYmyc/P3v4AAEDu5rAsy7K7CVeKjY1VYGCgYmJiFBAQYHc7AG7AxYvSypUmHF2ahC5RwoSj/v0lf397+wMAAOm1bCldunvGHVJHVrOB227cAACXJCdLq1ZJkyeb3ekkqXhxacQIc79RwYL29gcAADwLIQmA20pOlt5914Sj/ftNrVgxafhwacAAqVAhe/sDAACeiZAEwO2kpEjvvy9NmiTt3WtqRYtKzz1nzj0qXNje/gAAgGcjJAFwGykp0ocfmnD022+mVqSINGyY9OyzErcVAgCAnEBIAmC7lBTpo49MONqzx9QCA6WhQ6VBg8zXAAAAOYWQBMA2liWtXWvC0a5dphYQIA0eLA0ZYmaRAAAAchohCUCOsyzp44+liROlX34xtcKFzazR0KHm/iMAAAC7EJIA5BjLkj791ISjHTtMrVAhc7/R0KFm5zoAAAC7EZIAuJxlSevXm3D000+mVrCg2alu2DBz5hEAAIC7ICQBcBnLkj7/3ISj7dtNzd/fnHE0fLhUooSt7QEAAGSIkATA6SxL+uoracIEaetWU/Pzk55+WhoxQipZ0t7+AAAAroaQBMBpLEvauNGEoy1bTM3XV+rf34Sj4GB7+wMAAMgKQhIAp9i0SRo/XvruOzP28ZGeekoaOVIqXdrW1gAAALKFkATghmzebGaONm0y4wIFpH79pOefl8qUsbU1AACA60JIAnBdvv/ehKONG824QAHpiSekUaOksmXt7Q0AAOBGEJIAZMsPP5hw9NVXZpw/v/T449Lo0VJoqL29AQAAOAMhCUCWbNtmwtEXX5hxvnzSY4+ZcFS+vL29AQAAOBMhCcBV/fijOedo/Xoz9vaWeveWxoyRwsLs7AwAAMA1CEkAMrRjh5k5+vRTM/b2lh59VBo7VqpY0d7eAAAAXImQBCCd//7XzBx9/LEZe3lJjzxiwlHlyra2BgAAkCMISQAkSTt3mnC0bp0Ze3lJDz8sjRsnValiZ2cAAAA5i5AE5HG7d0uTJklr1pixwyH16GHCUbVq9vYGAABgB0ISkEf9+qsJRx98YMYOh/TQQ9L48dJNN9nbGwAAgJ0ISUAe8/vvJhy9/75kWab24IMmHNWsaW9vAAAA7oCQBOQR+/ZJkydLq1dfDkcPPGB2sLv5Znt7AwAAcCeEJMDD/fGHCUerVkkpKabWqZPZpKF2bVtbAwAAcEuEJMBDHTggTZkivfPO5XDUoYMJR3Xr2tkZAACAeyMkAR7m0CETjt5+W0pONrX77jPh6JZbbG0NAAAgVyAkAR4iIkKaOlVaseJyOLr3XhOObr3V1tYAAAByFUISkMsdPixNmyYtXy5dvGhqbdqYHexuu83OzgAAAHInQhKQSx05YsLR0qWXw1GrVmbmqFEjW1sDAADI1QhJQC4TGSm98IL0xhtSUpKptWxpZo7uuMPe3gAAADwBIQnIJY4dk8LDpddfly5cMLW77zYzR02a2NoaAACARyEkAW7u+HFp+nTptdekxERTu+suM3N011329gYAAOCJCEmAm4qKMuFo8WIpIcHUmjQx4ah5c3t7AwAA8GSEJMDNnDwpzZghLVx4ORw1bmzC0d13Sw6Hvf0BAAB4OkIS4CZOnZJmzZIWLJDOnze1Ro1MOGrZknAEAACQU7zsbiCvOHhQKlDA/KJboIAZI+fcfrv53l963H673R1d9vff0siRUliYNHu2CUi33SatXy9t2SLdcw8BCQAAICcxk5QDvLwky7o8TkqSqlQxv/impNjXV16RUcDYvt3U0/7fJaedPm1C0csvS/HxpnbrrWbmqG1bghEAAIBdCEku9u+AlJZlmecJSq5zraBhR1A6c0Z68UVp/nwpLs7UbrnFhKN77yUcAQAA2I3ldi508OC1fwG3LJbeuUpWl9Tl1NK7f/6Rxo+XKlQwh8HGxUl160rr1kk//yy1b09AAgAAcAfMJLlQjRpZv+7S4aBwnu3bnXvd9YqOlubNM4+YGFOrXdscAtuxI8EIAADA3RCSXCgpybnXIXeJiZFeekmaO9cEJUm6+WYTjjp1MkstAQAA4H4ISS6UP3/WAlD+/K7vBTknNtZsxvDii2aJnSTVrClNmCB16UI4AgAAcHf8uuZCv//u3OuQPQ0bOve6azl7VgoPN1t5jx1rAtJNN0mrV0u7d0tduxKQAAAAcgNmklyocuVr757mcJjr4HzbtmXtfp9t227sz4mLMwfAzppltvWWpGrVzCYNDz0keXvf2PsDAAAgZxGSXCwlJfNtwDknyfUs6+pB6Ua2/46Pl159VZo50xwIK5nzr8aPl7p3JxwBAADkViz+yQEpKdKBA5fH3t5mTEDKGZZ15ZK6hg2vPyCdOyfNmSNVrCiNGGECUqVK0ooVZulkz54EJAAAgNyMkJRD0i6pe/ttltjltLRL6iZNur4ldufPm228K1aUhg2TTp0y9x8tWybt2yc9+qiUj7lZAACAXI9f6YBrSEiQXntNmj5dOnHC1CpUMJszPPoouxMCAAB4GkISkImEBGnJErNj3fHjplaunAlHvXpJBQrY2x8AAABcg5AE/EtiorR0qTRtmnTsmKmFhkpjxkh9+hCOAAAAPB0hCfifCxfM/UXTpkmRkaZWtqw0erT02GOSj4+9/QEAACBnsHFDDkm7DXX37lk7vwfOk/b7PWFC+nFSkvT661LVqtJTT5mAFBIivfKKdPCg1L8/AQkAACAvYSYpB2QWiK510Cyc42rf/yVLpKlTpcOHTS04WBo1SurXT/L1zbEWAQAA4EYISS52rRkjgpJrXev7/8QT5n9LlZKef1568knJz8/1fQEAAMB9EZJcKKtL6ghKrpGdJY1//in5+7uuFwAAAOQe3JMEiIAEAACAywhJAAAAAJAGy+3gcVJSpPfft7sLAAAA5FbMJMFjXApHtWtL3brZ3Q0AAAByK0KSC2V1MwY2bbgxKSnShx9KdetKDz4o/fabVKSINHly1l7P9x8AAABpEZJc7Fq/gPML+vWzLGntWumWW6QHHpD27JECAsxhsRER0rhxfP8BAACQfdyTlAMsK+PtqPkF/fpYlvTxx9LEidIvv5ha4cLS4MHSkCFS0aJXXs/3HwAAAFnFTFIOSfsL+Zgx/IJ+PSxL+uQTqUEDqUMHE5AKFTLfz8OHzfK6fwektK+9ZNIkvv8AAADIHDNJcHuWJa1fb2aOfvrJ1AoWlJ55Rho2TCpe3Nb2AAAA4GEISXBbliV98YW5x2j7dlPz95cGDpSee04qUcLe/gAAAOCZCElwO5YlffWVCUdbt5qan580YIA0fLhUsqS9/QEAAMCzEZLgNixL2rjRhKMtW0zN11d6+mlpxAipVCl7+wMAAEDewMYNOSTt7mrTpmW821petmmT1KyZ1LKlCUg+PtKgQdKff0ovvkhAAgAAQM5x65A0ceJEORyOdI/q1avb3Va2ZRaICErS5s1S8+bmsXmzCUfPPGPC0bx5UunSdncIAACAvMbtl9vVrFlTX331Veo4Xz63bzmdawUhhyNvbkf9/fdmWd3GjWZcoIDUt680apRUpoy9vQEAACBvc/vEkS9fPgUHB9vdxnXJ6kxRXgpKP/xgwtGl3Js/v/TEEyYchYba2xsAAAAguflyO0k6cOCAQkJCVLFiRT388MM6cuTIVa9PTExUbGxsugfst3271KaN1LixCUj58kn9+kkHDkivvkpAAgAAgPtw65DUsGFDLV++XBs2bNDChQsVERGhJk2a6OzZs5m+Jjw8XIGBgamPUH77ttVPP0nt2km33y59/rkJR088YcLR4sVS+fJ2dwgAAACk59YhqW3bturatatq166t1q1b67PPPlN0dLTee++9TF8zatQoxcTEpD4iIyNzsGNcsmOH1L69dNtt0vr1kre39Nhj0v790uuvSxUq2N0hAAAAkDG3vycprSJFiqhq1ao6ePBgptf4+PjIx8cnB7tCWr/8Yu45+vhjM/bykh59VBo7VqpUyd7eAAAAgKxw65mkf4uLi9OhQ4dUOpfsC53VzRg8YdOGXbukTp2kW24xAcnLS3rkEWnfPmnZMgISAAAAcg+3DknPPfecvv32Wx0+fFg//PCDOnXqJG9vb3Xv3t3u1rLsWgEotwek3bulLl2kunWltWvNTn0PPyz9/rv05ptSlSp2dwgAAABkj1svtzt69Ki6d++u06dPq0SJErrzzju1bds2lShRwu7WssWyMt4OPDcHpF9/lSZNkj74wIwdDqlbN2n8eCkXnvcLAAAApHLrkLR69Wq7W3CatEFpzBhp6lR7+7lev/9uwtH771/+O3Xtau5DqlHD7u4AAACAG+fWIQnuY98+afJkafXqyzNgDzxgwtHNN9vbGwAAAOBMhCRc1R9/mHC0apWUkmJqnTubcFS7tr29AQAAAK5ASEKGDhyQpkyR3nnncjjq2NGEo7p17ewMAAAAcC1CEtI5dMiEo7fflpKTTe3++6WJE6V69WxtDQAAAMgRbr0FuCd58snLX0+bln7sDiIipMcfl6pVk1asMAHp3nuln36S1q0jIAEAACDvYCYpB2S0/fdrr5mH3duAHz5sQtvy5dLFi6bWtq2ZObrtNhsbAwAAAGxCSHKxjALSv5+3IygdOWLC0dKll8NR69YmHN1+e873AwAAALgLltu5UFaX1OXk0rvISKl/f6lyZTOTdfGidM890pYt0oYNBCQAAACAkORCr73m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xxQQEHDN1xQrVkxdu3ZV165d9cILL6hevXqaPXu2VqxYkeH1v//+u7p166bp06erVatWqfW4uDiVLl1amzZtuuI1RYoUuWYfAJAXMZMEAHlAmzZtdOHCBSUlJal169Z2t5NOiRIldOLEidRxbGysIiIicuzP9/b2lqR0OwBeEhAQoJCQEG3ZsiVdfcuWLapRo4YkM8O1c+fOq97f4+fnp08++US+vr5q3bq1zp49m60eCxQooEqVKqXubvdvf//9t+677z516dJFQ4YMSffcLbfcoqioKOXLl0+VK1dO98jqjCIA5DWEJADIA7y9vbV37179/vvvqaHAXdx9991666239N1332nPnj3q1auXS3uMjo5WVFSUjh8/rm+//VaTJ09W1apVddNNN2V4/fDhwzVjxgy9++672r9/v55//nnt3LlTgwYNkiR1795dwcHB6tixo7Zs2aI///xTH374obZu3ZrufQoWLKhPP/1U+fLlU9u2bRUXF5fhn/fJJ5+oZ8+eqUsB9+/fr9mzZ+uzzz5Thw4dMnxNly5d5O/vr4kTJyoqKir1kZycrJYtW6pRo0bq2LGjvvjiCx0+fFg//PCDxowZo59//vkGvpMA4LlYbgcAeURWlnjZYdSoUYqIiFD79u0VGBioKVOmuHQm6dLOfpfusWratKleeOGFTM97evbZZxUTE6Nhw4bp1KlTqlGjhv7zn/+oSpUqkswszxdffKFhw4apXbt2unjxomrUqJHhssZChQpp/fr1at26te6991599tlnKliwYLpratSoIX9/fw0bNkyRkZHy8fFRlSpVtGTJkkzvndq8ebMkqXz58unqERERqlChgj777DONGTNGffr00V9//ZX69750bxcAID2H9e+F4AAAAACQh7HcDgAAAADSICQBAAAAQBqEJAAAAABIg5AEAAAAAGkQkgAAAAAgDUISAAAAAKRBSAIAAACANAhJAAAAAJAGIQkAAAAA0iAkAQAAAEAahCQAAAAASIOQBAAAAABp/D9dke2IkjFNNAAAAABJRU5ErkJggg==",
130:       "text/plain": [
131:        "<Figure size 1000x600 with 1 Axes>"
132:       ]
133:      },
134:      "metadata": {},
135:      "output_type": "display_data"
136:     }
137:    ],
138:    "source": [
139:     "fig, ax = plt.subplots(figsize=(10, 6))\n",
140:     "\n",
141:     "ax.plot(min_block_sizes, block_sizes, marker='o', linestyle='-', color='b')\n",
142:     "ax.set_xlabel(\"Minimum Block Size\")\n",
143:     "ax.set_ylabel(\"Block Sizes\")\n",
144:     "\n",
145:     "fig.show()\n"
146:    ]
147:   },
148:   {
149:    "cell_type": "code",
150:    "execution_count": 49,
151:    "id": "879ee57b",
152:    "metadata": {},
153:    "outputs": [
154:     {
155:      "data": {
156:       "text/plain": [
157:        "<matplotlib.legend.Legend at 0x11ffcd6d0>"
158:       ]
159:      },
160:      "execution_count": 49,
161:      "metadata": {},
162:      "output_type": "execute_result"
163:     },
164:     {
165:      "data": {
166:       "image/png": "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XFxsDhw44NituLjYFBYWmurq6pC/tz/96U9GUoNbZGSkWbRoUYPxkkxubq7/68mTJ5uIiAizfft2/7J9+/aZ6Oho86Uvfcm/bO7cuUaS+fvf/95gm7ZtG2OMefXVV40k89xzz5kjR46Yiy66yPTs2dN88MEHp/0+rrjiCjNkyJCgvtedO3c2en9xcbHp27evOffcc015ebkxxpg33njDSDJ//etf641dsWJFo8sDqa6uNi+88IKZPHmyCQ8PN16v11x++eXm73//u6mqqgpqG3X1T5gwwf+YGWPMmDFjjGVZ5pZbbvEvq6mpMX369DEXXXRRvW2c+vzl5uYaSebGG2+sN+7KK680PXr0OG1NF110kZFkfv7zn/uXVVZWmhEjRpjExET/97Zz504jyfzpT3/yj6sbc+DAAf+y//3vf8bj8ZipU6f6l02dOtV4PB7z3nvvNdh/3eNQ99i89957Zv/+/WbIkCEmMzPT5Ofnn/Z7GD58uPnKV77S5Ji6xymQrVu3mtjYWHPppZeampoaY4wxf/7zn43H4zFvvPFGvbELFy40ksx///vfgNsL9J5zMtpaAADowBYsWKBVq1Zp1apV+stf/qKLL75YN910k/7+978HXMfn82nlypWaPHmyMjMz/ct79+6tb33rW3rzzTdVVlYmSfrb3/6m4cOH68orr2ywnVPbckpLSzV+/Hht2rRJa9as0YgRI05bf1xcnPbs2aP33nsvyO+44fdy7bXX6siRI1q2bJm6desmSXruuecUGxurSy+9VCUlJf7byJEj1b17d7366qtBbT8sLExf+9rXtGzZMu3Zs0ePPvqoPvvsM1111VXq06ePfvCDHzR5qfaTzZgxo95jlpWVJWOMZsyY4V/m9Xo1atQo7dixI6ht3nLLLfW+HjdunA4cOOB//k73vc2cOdP/dUREhGbOnKmioiKtW7eu0XX279+vDRs26IYbblBCQoJ/+bBhw3TppZfq5ZdfllR79Hn58uWaNGlSvXMi6pz6s7Nnzx5ddNFFqq6u1uuvv65+/fqdtv64uDh98skn2rp162nHNqaiokJXXnml4uPj9fTTT/vPa3juuec0ePBgDRo0qN7Pzv/93/9JUtA/O4EQzgEA6MBGjx6t7OxsZWdn67rrrtNLL72kc845R7fddlvAvt7i4mIdPXpUZ599doP7Bg8eLNu2tXv3bknS9u3bg5oPW5LuvPNOvffee3rllVc0ZMiQoNb54Q9/qO7du2v06NE666yzNGvWLP33v/8Nal2pdjaO//znP1qyZEm9FoitW7eqtLRUiYmJ6tWrV71beXm5ioqKgt5HncTERH3ve9/TW2+9pZtuuklFRUX62c9+poqKiqDW79u3b72vY2NjJUlpaWkNlgfTF9/YNutOYA1m/ZSUFP+HmToDBw6UpIBzyn/22WeSFPBnp6SkRBUVFSouLlZZWVnQPzvXX3+9ioqK9NprrwXdNvTggw/q8OHDGjhwoM4991z94Ac/0IcffhjUupJ08803a/v27Vq2bJl69OjhX75161Z98sknDX5u6h6b5vzsnIxwDgBAJ+LxeHTxxRdr//79zT6i2FxXXHGFjDF65JFHgp6/ffDgwdq8ebOeeeYZXXjhhfrb3/6mCy+8ULm5uaddd/ny5Xr00Uf14IMP6rLLLqt3n23bSkxM9P9V4dTbgw8+GNL3ZozRq6++quuvv17Jycn6wx/+oEsuuURPP/20YmJigtpGoBlnGltugjwBNdA2g13fLa666iodPnxYv/zlL4Ne50tf+pK2b9+uP/7xjxo6dKh+//vf6/zzz9fvf//70677y1/+Uk8//bSeeuqpBn/hsW1b5557bsCfne9+97uhfnv1cEIoAACdTE1NjaTakzkb06tXL3Xt2rXRmTA2bdokj8fjP5rbv39/ffzxx0Htd/LkyRo/frxuuOEGRUdH67e//W1Q63Xr1k1TpkzRlClTVFVVpauuuko/+clPNGfOnIBTCG7ZskXTpk3T5MmTde+99za4v3///nrllVc0duxYdenSJag6GpOfn6/Fixdr0aJFys/PV58+ffS9731PM2bM8J/42F7t27dPFRUV9Y6eb9myRZICfm917SaBfnZ69uypbt26qUuXLoqJiQn6Z2f27NkaMGCA5s6dq9jY2KDnJk9ISND06dM1ffp0lZeX60tf+pIeeOAB3XTTTQHXeeONN/T9739fd955p6677roG9/fv31//+9//dMkll7TKjEocOQcAoBOprq7WypUrFRERocGDBzc6xuv1avz48XrhhRfqtS8UFhZqyZIluvDCC/1Hg6+++mr973//07Jlyxpsp7Gjs1OnTtWvfvUrLVy4UD/84Q9PW++BAwfqfR0REaFzzjlHxpiAvdzl5eW68sorlZqaqsWLFzcaoK655hr5fD79+Mc/bnBfTU2NDh8+3GRdH330kbKzs5WZmamf/OQnOu+88/TSSy8pPz9fP/7xj9t9MJdqH4cnn3zS/3VVVZWefPJJ9erVSyNHjmx0nd69e2vEiBFavHhxvcfw448/1sqVK3X55ZdLqv0LzuTJk/WPf/xD77//foPtNPazc//99+v73/++5syZE9QHu1N/drp3764BAwY0Od3h/v37dc011+jCCy/UY4891uiYa665Rnv37tVTTz3V4L5jx44F3cYUCEfOAQDowP71r39p06ZNkmp7YZcsWaKtW7fqnnvuabLd4qGHHtKqVat04YUX6rvf/a7CwsL05JNPqrKyUj/96U/9437wgx/o+eef1ze+8Q3deOONGjlypA4ePKgXX3xRCxcu1PDhwxts+7bbblNZWZl+9KMfKTY2ttEj23XGjx+v5ORkjR07VklJSdq4caOeeOIJfeUrX1F0dHSj68ybN0+ffvqp7rvvPr3wwgv17uvfv7/GjBmjiy66SDNnzlReXp42bNig8ePHKzw8XFu3btVzzz2nX/7yl/r6178esK5169b5TwCdNm1avSkaO4qUlBQ9+uijys/P18CBA7V06VJt2LBBv/vd75qcZvKxxx7TxIkTNWbMGM2YMcM/lWJsbGy9ucIffvhhrVy5UhdddJF/SsL9+/frueee05tvvqm4uLhGt11aWqpZs2YpOjq6ySlBzznnHH35y1/WyJEjlZCQoPfff1/PP/+8brvttoDr3H777SouLtbdd9+tZ555pt59w4YN07Bhw3T99dfr2Wef1S233KJXX31VY8eOlc/n06ZNm/Tss8/q3//+d6MnuQaLcA4AQADGmKB7o1tr/2dq7ty5/v9HRUVp0KBB+u1vf1tvFo7GDBkyRG+88YbmzJmjvLw82batrKws/eUvf/HPcS7VHo184403lJubq2XLlmnx4sVKTEzUJZdcoj59+gTc/r333qvS0lJ/QJ81a1aj42bOnKm//vWvevzxx1VeXq4+ffro9ttv13333Rdw28XFxZJqP2Ccatq0aRozZowkaeHChRo5cqSefPJJ3XvvvQoLC1N6erq+/e1va+zYsU0+Pt/4xjfqXdCoI4qPj9fixYs1e/ZsPfXUU0pKStITTzyhm2++ucn1srOztWLFCuXm5mru3LkKDw/XRRddpEcf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++236/zzz1dCQoLeeustzZkzR/v379fjjz/udGmdTklJiXw+n5KSkuotT0pK0qZNmxyqCnWysrK0aNEinX322dq/f7/mzZuncePG6eOPP1Z0dLTT5eEUBQUFktTo66nuPjjrsssu01VXXaWMjAxt375d9957ryZOnKi1a9fK6/U6XV6nYtu27rzzTo0dO1ZDhw6VVPsaioiIUFxcXL2xvIbgRq4P5/fcc48effTRJsds3LhRgwYNUk5Ojn/ZsGHDFBERoZkzZyovL4/L9gInmThxov//w4YNU1ZWlvr166dnn31WM2bMcLAyoH365je/6f//ueeeq2HDhql///5as2aNLrnkEgcr63xmzZqljz/+mPNo0G65Ppx/73vf0w033NDkmMzMzEaXZ2VlqaamRvn5+Tr77LNboToE0rNnT3m93gZnwhcWFio5OdmhqhBIXFycBg4cqG3btjldChpR95opLCxU7969/csLCws1YsQIh6pCUzIzM9WzZ09t27aNcN6GbrvtNv3zn//U66+/rj59+viXJycnq6qqSocPH6539JzfSXAj1/ec9+rVS4MGDWryFhER0ei6GzZskMfjUWJiYhtXjYiICI0cOVKrV6/2L7NtW6tXr9aYMWMcrAyNKS8v1/bt2+sFP7hHRkaGkpOT672eysrK9M477/B6cqk9e/bowIEDvKbaiDFGt912m5YtW6b//Oc/ysjIqHf/yJEjFR4eXu81tHnzZu3atYvXEFzH9UfOg7V27Vq98847uvjiixUdHa21a9fqrrvu0re//W3Fx8c7XV6nlJOTo2nTpmnUqFEaPXq05s+fr4qKCk2fPt3p0jq973//+5o0aZL69eunffv2KTc3V16vV9dee63TpXVa5eXl9f5ysXPnTm3YsEEJCQnq27ev7rzzTj300EM666yzlJGRofvvv18pKSmaPHmyc0V3Ik09PwkJCZo3b56uvvpqJScna/v27br77rs1YMAATZgwwcGqO49Zs2ZpyZIleuGFFxQdHe3vI4+NjVWXLl0UGxurGTNmKCcnRwkJCYqJidHs2bM1ZswYfeELX3C4euAUTk8X01LWrVtnsrKyTGxsrImKijKDBw82Dz/8sDl+/LjTpXVqv/71r03fvn1NRESEGT16tHn77bedLgnGmClTppjevXubiIgIk5qaaqZMmWK2bdvmdFmd2quvvmokNbhNmzbNGFM7neL9999vkpKSTGRkpLnkkkvM5s2bnS26E2nq+Tl69KgZP3686dWrlwkPDzf9+vUzN998sykoKHC67E6jsedGkvnTn/7kH3Ps2DHz3e9+18THx5uuXbuaK6+80uzfv9+5ooEALGOMafuPBAAAAABO5fqecwAAAKCzIJwDAAAALkE4BwAAAFyCcA4AAAC4BOEcAAAAcAnCOQAAAOAShHMAAADAJQjnAAAAgEsQzgEAAACXIJwDAAAALkE4BwAAAFyCcA4AAAC4xP8H9LjNs4014Q4AAAAASUVORK5CYII=",
167:       "text/plain": [
168:        "<Figure size 800x500 with 1 Axes>"
169:       ]
170:      },
171:      "metadata": {},
172:      "output_type": "display_data"
173:     }
174:    ],
175:    "source": [
176:     "fig, ax = plt.subplots(figsize=(8, 5))\n",
177:     "\n",
178:     "values, counts  = np.unique(min_block_sizes - block_sizes, return_counts=True)\n",
179:     "\n",
180:     "ax.plot(values, counts/counts.sum(), marker='o', linestyle='-', color='salmon')\n",
181:     "\n",
182:     "ax.fill_betweenx(y=[0, 1], x1=min(values), x2=0, color='#dddddd', alpha=0.5, label='Block size > min block size')\n",
183:     "\n",
184:     "fig.legend(fontsize=12)\n",
185:     "\n",
186:     "\n"
187:    ]
188:   },
189:   {
190:    "cell_type": "code",
191:    "execution_count": null,
192:    "id": "b8a60bad",
193:    "metadata": {},
194:    "outputs": [],
195:    "source": []
196:   },
197:   {
198:    "cell_type": "code",
199:    "execution_count": null,
200:    "id": "ec731210",
201:    "metadata": {},
202:    "outputs": [],
203:    "source": []
204:   },
205:   {
206:    "cell_type": "code",
207:    "execution_count": null,
208:    "id": "8198ec2d",
209:    "metadata": {},
210:    "outputs": [],
211:    "source": []
212:   },
213:   {
214:    "cell_type": "code",
215:    "execution_count": 1,
216:    "id": "fbbae561",
217:    "metadata": {},
218:    "outputs": [],
219:    "source": [
220:     "import numpy as np"
221:    ]
222:   },
223:   {
224:    "cell_type": "code",
225:    "execution_count": 2,
226:    "id": "995a8d86",
227:    "metadata": {},
228:    "outputs": [],
229:    "source": [
230:     "def fun(B, delta=0.05, Delta=10**3):\n",
231:     "    return np.log((B+B**2)/delta)*Delta"
232:    ]
233:   },
234:   {
235:    "cell_type": "code",
236:    "execution_count": null,
237:    "id": "17749985",
238:    "metadata": {},
239:    "outputs": [
240:     {
241:      "data": {
242:       "text/plain": [
243:        "np.float64(14615.015756511137)"
244:       ]
245:      },
246:      "execution_count": 3,
247:      "metadata": {},
248:      "output_type": "execute_result"
249:     }
250:    ],
251:    "source": [
252:     "fun()"
253:    ]
254:   },
255:   {
256:    "cell_type": "code",
257:    "execution_count": 4,
258:    "id": "e6fc7922",
259:    "metadata": {},
260:    "outputs": [
261:     {
262:      "data": {
263:       "text/plain": [
264:        "333"
265:       ]
266:      },
267:      "execution_count": 4,
268:      "metadata": {},
269:      "output_type": "execute_result"
270:     }
271:    ],
272:    "source": [
273:     "1000//3"
274:    ]
275:   },
276:   {
277:    "cell_type": "code",
278:    "execution_count": null,
279:    "id": "509dda70",
280:    "metadata": {},
281:    "outputs": [],
282:    "source": []
283:   }
284:  ],
285:  "metadata": {
286:   "kernelspec": {
287:    "display_name": "anon_sbm_notebook",
288:    "language": "python",
289:    "name": "python3"
290:   },
291:   "language_info": {
292:    "codemirror_mode": {
293:     "name": "ipython",
294:     "version": 3
295:    },
296:    "file_extension": ".py",
297:    "mimetype": "text/x-python",
298:    "name": "python",
299:    "nbconvert_exporter": "python",
300:    "pygments_lexer": "ipython3",
301:    "version": "3.13.5"
302:   }
303:  },
304:  "nbformat": 4,
305:  "nbformat_minor": 5
306: }

================
File: src/data_processing/process_all.py
================
 1: # src/data_processing/process_all.py
 2: """ 
 3: Script to run all processing steps of all datasets.
 4: """
 5: import subprocess
 6: import sys
 7: def run(cmd):
 8:     print(">>", " ".join(cmd))
 9:     subprocess.check_call(cmd)
10: datasets = [
11:     "data_processing.process_congress_twitter",
12:     "data_processing.process_email_eu",
13:     "data_processing.process_caltech",
14:     "data_processing.process_wiki_vote",
15:     "data_processing.process_enron_email",
16:     "data_processing.process_lastfm_asia",
17: ]
18: if __name__ == "__main__":
19:     python = sys.executable
20:     for dataset in datasets:
21:         run([python, "-m", dataset])

================
File: src/metrics/clustering.py
================
 1: """ 
 2: Implementation of the clustering coefficient distance metric.
 3: This module computes the absolute difference in the clustering coefficients
 4: between two graphs represented by their adjacency matrices.
 5: """
 6: # metrics/clustering.py
 7: from typing import Optional
 8: import numpy as np
 9: import networkx as nx
10: from scipy.sparse import csr_array
11: def clustering_distance(
12:         emp_adj: csr_array,
13:         sur_adj: csr_array,
14:         directed: Optional[bool] = False,
15:         rng: np.random.Generator = np.random.default_rng(1)
16:     ) -> float:
17:     """ 
18:     Compute absolute 
19:     Parameters
20:     ----------
21:     emp_adj, sur_adj : scipy.sparse.csr_matrix
22:         Adjacency of empirical and surrogate graphs (directed or undirected).
23:     directed : bool, optional
24:         If True, compute directed degree distribution.
25:         If False, compute undirected degree distribution.
26:     rng : np.random.Generator, optional
27:         Random number generator for sampling (default: np.random.default_rng(1)).
28:     Returns
29:     -------
30:     float
31:         Distance (lower = more similar).
32:     """
33:     if directed:
34:         raise NotImplementedError(
35:             "Directed clustering coefficient is not implemented yet."
36:         )
37:     else:
38:         # Undirected clustering coefficient
39:         emp_graph = nx.from_scipy_sparse_matrix(emp_adj)
40:         sur_graph = nx.from_scipy_sparse_matrix(sur_adj)
41:         emp_clustering = nx.average_clustering(emp_graph)
42:         sur_clustering = nx.average_clustering(sur_graph)
43:         return abs(emp_clustering - sur_clustering)

================
File: src/metrics/degree.py
================
 1: """ 
 2: Implementation of the degree distribution distance metric.
 3: This module computes the Earth-mover distance (1-D Wasserstein distance)
 4: between the degree distributions in two graphs represented by
 5: their adjacency matrices.
 6: """
 7: # metrics/degree.py
 8: from typing import Optional
 9: import numpy as np
10: from scipy.stats import wasserstein_distance #  1-D EMD
11: from scipy.sparse import csr_array
12: def degree_distance(
13:         emp_adj: csr_array,
14:         sur_adj: csr_array,
15:         directed: Optional[bool] = False,
16:         in_degree: Optional[bool] = False,
17:         out_degree: Optional[bool] = False,
18:         rng: np.random.Generator = np.random.default_rng(1)
19:     ) -> float:
20:     """ 
21:     Earth-mover (1-D Wasserstein) distance between the degree distributions
22:     of two graphs.
23:     Parameters
24:     ----------
25:     emp_adj, sur_adj : scipy.sparse.csr_matrix
26:         Adjacency of empirical and surrogate graphs (directed or undirected).
27:     directed : bool, optional
28:         If True, compute directed degree distribution.
29:         If False, compute undirected degree distribution.
30:     in_degree : bool, optional
31:         If True, compute in-degree distribution (for directed graphs).
32:         Ignored if `directed` is False.
33:     out_degree : bool, optional
34:         If True, compute out-degree distribution (for directed graphs).
35:         Ignored if `directed` is False.
36:     rng : np.random.Generator, optional
37:         Random number generator for sampling (default: np.random.default_rng(1)).
38:     Returns
39:     -------
40:     float
41:         Distance (lower = more similar).
42:     """
43:     if directed:
44:         raise NotImplementedError(
45:             "Directed degree distribution is not implemented yet."
46:         )
47:     else:
48:         if in_degree or out_degree:
49:             raise Warning(
50:                 "in_degree and out_degree are ignored for undirected graphs."
51:             )
52:         # Undirected degree distribution
53:         emp_degrees = np.asarray(emp_adj.sum(axis=0)).flatten()
54:         sur_degrees = np.asarray(sur_adj.sum(axis=0)).flatten()
55:         emp_dist = np.bincount(emp_degrees)
56:         sur_dist = np.bincount(sur_degrees)
57:         # Normalize distributions
58:         emp_dist = emp_dist / emp_dist.sum()
59:         sur_dist = sur_dist / sur_dist.sum()
60:         # Compute Earth-mover distance
61:         distance = wasserstein_distance(emp_dist, sur_dist)
62:         return distance

================
File: src/metrics/shortest_path.py
================
  1: """ 
  2: Implementation of the shortest path distribution distance metric.
  3: This module computes the Earth-mover distance (1-D Wasserstein distance)
  4: between the distributions of all-pairs shortest-path lengths
  5: in two graphs represented by their adjacency matrices.
  6: """
  7: # metrics/shortest_path.py
  8: from typing import Optional
  9: import numpy as np
 10: import networkx as nx
 11: from scipy.stats import wasserstein_distance #  1-D EMD
 12: from scipy.sparse import csr_array
 13: from scipy.sparse.csgraph import shortest_path
 14: from sbm.utils.util import restrict_to_lcc
 15: import networkx as nx
 16: from typing import Iterable, Hashable, List, Union
 17: Number = Union[int, float]
 18: def all_unique_shortest_distances(
 19:     G: nx.Graph,
 20:     weight: str | None = None,
 21:     cutoff: Number | None = None
 22: ) -> List[Number]:
 23:     """
 24:     Return a list containing the length of every unique shortest path in *G*.
 25:     Parameters
 26:     ----------
 27:     G : networkx.Graph
 28:         The input graph (directed or undirected, weighted or unweighted).
 29:     weight : str or None, default=None
 30:         Edge-attribute key to use as weight.  ``None``  treat edges as unit-weight.
 31:     cutoff : int | float | None, default=None
 32:         Ignore paths longer than *cutoff* (same semantics as NetworkX).
 33:     Returns
 34:     -------
 35:     distances : list[Number]
 36:         One entry per unordered, connected node pair.  
 37:         Unreachable pairs are silently skipped.
 38:     """
 39:     # 1.  Choose the correct all-pairs iterator
 40:     if weight is None:
 41:         # Unweighted  multi-source breadth-first search
 42:         iterator = nx.all_pairs_shortest_path_length(G, cutoff=cutoff)  # :contentReference[oaicite:0]{index=0}
 43:     else:
 44:         # Weighted  repeated Dijkstra
 45:         iterator = nx.all_pairs_dijkstra_path_length(G, cutoff=cutoff, weight=weight)  # :contentReference[oaicite:1]{index=1}
 46:     # 2.  Collect unique unordered pairs
 47:     seen: set[frozenset[Hashable]] = set()
 48:     distances: List[Number] = []
 49:     for u, length_dict in iterator:
 50:         for v, d in length_dict.items():
 51:             if u == v:                       # skip self-loops (distance 0)
 52:                 continue
 53:             pair = frozenset((u, v))         # unordered representation
 54:             if pair in seen:                 # already counted via (v, u)
 55:                 continue
 56:             seen.add(pair)
 57:             distances.append(d)
 58:     return distances
 59: def shortest_path_distance(
 60:         emp_adj: csr_array,
 61:         sur_adj: csr_array,
 62:         n_samples: Optional[int]=10_000,
 63:         rng:np.random.Generator = np.random.default_rng(1)
 64:     ) -> float:
 65:     """
 66:     Earth-mover (1-D Wasserstein) distance between the distributions
 67:     of all-pairs shortest-path lengths.
 68:     Parameters
 69:     ----------
 70:     emp_adj, sur_adj : scipy.sparse.csr_matrix
 71:         Adjacency of empirical and surrogate graphs (undirected).
 72:     n_samples : int, optional
 73:         Number of samples to use for the distributions.
 74:         If None, all pairs are used.
 75:     Returns
 76:     -------
 77:     float
 78:         Distance (lower = more similar).
 79:     """
 80:     emp_adj = restrict_to_lcc(emp_adj, directed=False)
 81:     sur_adj = restrict_to_lcc(sur_adj, directed=False)
 82:     emp_graph_size = emp_adj.shape[0] # type: ignore
 83:     sur_graph_size = emp_adj.shape[0] # type: ignore
 84:     if n_samples is None:
 85:         # Use all pairs if n_samples is None, generated using networkx (returns iterator)
 86:         x = all_unique_shortest_distances(
 87:             nx.from_scipy_sparse_matrix(emp_adj),
 88:             weight=None,
 89:             cutoff=None
 90:         )
 91:         y = all_unique_shortest_distances(
 92:             nx.from_scipy_sparse_matrix(sur_adj),
 93:             weight=None,
 94:             cutoff=None
 95:         )
 96:     else:
 97:         n_samples_emp = int(min(
 98:             n_samples,
 99:             emp_graph_size * (emp_graph_size - 1) // 2,
100:         ))
101:         n_samples_sur = int(min(
102:             n_samples,
103:             sur_graph_size * (sur_graph_size - 1) // 2,
104:         ))
105:         emp_pair_part_1 = rng.choice(emp_graph_size, size=n_samples_emp, replace=True)
106:         emp_pair_part_2 = rng.choice(emp_graph_size-1, size=n_samples_emp, replace=True)
107:         emp_pair_part_2[emp_pair_part_2 >= emp_pair_part_1] += 1
108:         emp_pairs = np.column_stack((emp_pair_part_1, emp_pair_part_2))
109:         sur_pair_part_1 = rng.choice(sur_graph_size, size=n_samples_sur, replace=True)
110:         sur_pair_part_2 = rng.choice(sur_graph_size-1, size=n_samples_sur, replace=True)
111:         sur_pair_part_2[sur_pair_part_2 >= sur_pair_part_1] += 1
112:         sur_pairs = np.column_stack((sur_pair_part_1, sur_pair_part_2))
113:         def sample_shortest_paths(adj, pairs):
114:             G = nx.from_scipy_sparse_matrix(adj)
115:             return np.array([nx.shortest_path_length(G, source=u, target=v) for u, v in pairs])
116:         x = sample_shortest_paths(emp_adj, emp_pairs)
117:         y = sample_shortest_paths(sur_adj, sur_pairs)
118:     return wasserstein_distance(x, y)

================
File: src/pipelines/evaluate_surrogates.py
================
 1: import argparse, yaml, csv
 2: from pathlib import Path
 3: import numpy as np
 4: import scipy.sparse as sp
 5: from metrics import REGISTRY
 6: from sbm.io import GraphLoader
 7: from sbm.utils.pipeline_utils import load_csr_npz
 8: def main(cfg):
 9:     cfg = yaml.safe_load(Path(cfg).read_text())
10:     for ds in cfg["datasets"]:
11:         results = []
12:         emp = GraphLoader.load(Path(ds["graph"])).adjacency
13:         surr_dir = Path("data/surrogates") / ds["name"]
14:         for surr_file in sorted(surr_dir.glob("surr_*.npz")):
15:             surr = load_csr_npz(surr_file)
16:             row = {"dataset": ds["name"], "surrogate": surr_file.stem}
17:             for m in cfg["metrics"]:
18:                 row[m] = REGISTRY[m](emp, surr)
19:             results.append(row)
20:             print("evaluated", surr_file)
21:         out = Path("results") / f"surrogate_metrics.csv"
22:         out.parent.mkdir(exist_ok=True)
23:         with out.open("w", newline="") as f:
24:             w = csv.DictWriter(f, fieldnames=results[0].keys())
25:             w.writeheader(); w.writerows(results)
26:         print("saved", out)
27: if __name__ == "__main__":
28:     p = argparse.ArgumentParser(); p.add_argument("cfg"); main(p.parse_args().cfg)

================
File: src/pipelines/run_all.py
================
 1: """ 
 2: Script to run fitting, generation, and evaluation pipelines in sequence.
 3: """
 4: import subprocess
 5: import sys
 6: def run(cmd):
 7:     print(">>", " ".join(cmd))
 8:     subprocess.check_call(cmd)
 9: CFG_FIT = "configs/sbm_fit_block_size_experiments.yml"
10: CFG_EVAL = "configs/surrogate_eval.yml"
11: if __name__ == "__main__":
12:     python = sys.executable
13:     run([
14:         python, "-m",
15:         "pipelines.fit_sbm",
16:         "--fit_config", CFG_FIT
17:     ])
18:     run([
19:         python, "-m",
20:         "pipelines.generate_and_evaluate_surrogates",
21:         "--fit_config", CFG_FIT,
22:         "--eval_config", CFG_EVAL,
23:     ])

================
File: src/sbm/utils/util.py
================
 1: import numpy as np
 2: from scipy.sparse.csgraph import connected_components
 3: from scipy.sparse import csr_array
 4: def set_random_seed(seed: int):
 5:     return np.random.default_rng(seed)
 6: def restrict_to_lcc(adj: csr_array, directed:bool) -> csr_array:
 7:     """ 
 8:     resricts adjacency matrix to the largest connected component (LCC).
 9:     """
10:     if directed:
11:         n_components, labels = connected_components(adj, directed=True)
12:     else:
13:         n_components, labels = connected_components(adj, directed=False)
14:     if n_components == 1:
15:         return adj
16:     largest_component = np.argmax(np.bincount(labels))
17:     mask = labels == largest_component
18:     adj_lcc = csr_array(adj[mask][:, mask]) # type: ignore
19:     return adj_lcc

================
File: src/sbm/block_change_proposers.py
================
  1: from typing import List, Optional, Tuple, DefaultDict, Literal
  2: from collections import defaultdict, Counter
  3: import numpy as np
  4: from sbm.block_data import BlockData
  5: from sbm.edge_delta import EdgeDelta, NumpyEdgeDelta
  6: ### Aliases 
  7: CombinationDelta= DefaultDict[Tuple[int, int], int] # changes in possible pairs between blocks
  8: ProposedValidChanges = List[Tuple[int, int]]  # list of proposed node-block pairs
  9: ChangeProposerName = Literal["uniform_swap", "edge_based_swap", "triadic_swap"]
 10: ChangeProposers = Literal["NodeSwapProposer", "EdgeBasedSwapProposer", "TriadicSwapProposer"]
 11: ### ChangeProposer classes for proposing block changes in the SBM
 12: # These classes handle the logic of proposing valid changes to the block assignments
 13: # and computing the resulting edge deltas for the block connectivity matrix.
 14: class ChangeProposer:
 15:     """ 
 16:     Class to propose block-assignment changes for the MCMC algorithm.
 17:     Handles min block size constraints. All functions return None
 18:     if a  and ensures valid moves.
 19:     Proposers shoudl always change block-id to block-adjacency idx before
 20:     computing deltas.
 21:     """
 22:     def __init__(self,
 23:                  block_data: BlockData,
 24:                  rng: np.random.Generator=np.random.default_rng(1),
 25:                  use_numpy: bool = False,
 26:                  ):
 27:         self.block_data = block_data
 28:         self.rng = rng
 29:         self.min_block_size = 1
 30:         self.use_numpy = use_numpy
 31:         # Direct CSR pointers for O(1) edge sampling
 32:         self._indptr = self.block_data.graph_data.adjacency.indptr
 33:         self._indices = self.block_data.graph_data.adjacency.indices
 34:     def propose_change(self,
 35:         changes: Optional[ProposedValidChanges] = None,
 36:         )-> Tuple[ProposedValidChanges, EdgeDelta, CombinationDelta]:
 37:         raise NotImplementedError("This method should be overridden by subclasses.")
 38:     def _compute_delta_edge_counts(self, proposed_changes: ProposedValidChanges) -> EdgeDelta:
 39:         """
 40:         Compute the edge deltas for the proposed change.
 41:         :param change: Proposed change as a list of (node, target_block) tuples.
 42:         :return: EdgeDelta containing the changes in edge counts between blocks.
 43:         """
 44:         raise NotImplementedError("This method should be overridden by subclasses.")
 45:     # -----------------------------------------------------------------------------
 46:     def _compute_edge_counts_between_node_and_blocks(self,
 47:                                                node: int,
 48:                                                ) -> Counter[int]:
 49:         """
 50:         Compute the number of edges between a node and each affected block.
 51:         :param node: The node to move.
 52:         :param affected_blocks: The blocks affected by the move.
 53:         :return: A dictionary mapping block IDs to edge counts with the node.
 54:         k_i: Counter[int]: number of edges between node and each affected block.
 55:         returns a Counter object where keys are block IDs and values are edge counts.
 56:         """
 57:         if self.block_data.directed:
 58:             raise NotImplementedError("Directed graphs are not supported yet.")
 59:         else:
 60:             #neighbors = self.block_data.graph_data.adjacency[:, [node]].indices  # type: ignore
 61:             neighbors = self.block_data.graph_data.adjacency[[node], :].indices  # type: ignore
 62:             blocks_among_neighbors = [
 63:                 self.block_data.block_indices[
 64:                     self.block_data.blocks[neighbor]
 65:                 ] for neighbor in neighbors
 66:             ]
 67:             k_i = Counter(blocks_among_neighbors)
 68:             return k_i
 69: class NodeSwapProposer(ChangeProposer):
 70:     def propose_change(self,
 71:         changes: Optional[ProposedValidChanges] = None,
 72:     ) -> Tuple[ProposedValidChanges, EdgeDelta, CombinationDelta]:
 73:         """
 74:         Propose swapping two nodes between different blocks.
 75:         :return: Tuple of (node1, node2) or None if no valid swap.
 76:         """
 77:         if changes is not None:
 78:             if len(changes) != 2:
 79:                 raise ValueError("NodeSwapProposer requires exactly two nodes to swap.")
 80:             proposed_changes = changes
 81:         else:
 82:             # Select two different blocks
 83:             block1, block2 = self.rng.choice(
 84:                 self.block_data.block_connectivity.shape[0],
 85:                 #list(self.block_data.block_sizes.keys()),
 86:                 size=2,
 87:                 replace=False
 88:             )
 89:             # Select one node from each block
 90:             # Note: changing to list is inefficient for large blocks.
 91:             # However, having memberships being lists allow for fast 
 92:             # membership updates.
 93:             # Change if large blocks are common.
 94:             node1 = self.rng.choice(
 95:                 list(self.block_data.block_members[block1])
 96:             )
 97:             node2 = self.rng.choice(
 98:                 list(self.block_data.block_members[block2])
 99:             )
100:             proposed_changes :ProposedValidChanges = [(node1, block2), (node2, block1)]
101:         delta_e: EdgeDelta = self._compute_delta_edge_counts(
102:                 proposed_changes=proposed_changes,
103:                 use_numpy=self.use_numpy,
104:             )
105:         delta_n: CombinationDelta = defaultdict(int)
106:         return proposed_changes, delta_e, delta_n
107:     def _compute_delta_edge_counts(self,
108:             proposed_changes: ProposedValidChanges,
109:             use_numpy: bool = False,
110:         )-> EdgeDelta:
111:         """
112:         Compute the changes in edge counts between blocks due to swapping
113:         node i and node j.
114:         :param i: The index of the first node being swapped.
115:         :param j: The index of the second node being swapped.
116:         :param k_i: The edges between the moving node and its neighbor blocks.
117:         :param source_block: The block from which the node is moved.
118:         :param target_block: The block to which the node is moved.
119:         :return: A Counter mapping block pairs to changes in edge counts.
120:         """
121:         if self.block_data.directed:
122:             raise NotImplementedError("Directed graphs are not supported yet.")
123:         (i, old_block_j), (j, old_block_i) = proposed_changes
124:         if use_numpy:
125:             delta_e = NumpyEdgeDelta(
126:                 n_blocks=len(self.block_data.block_sizes)
127:             )
128:         else:
129:             delta_e = EdgeDelta(
130:                 n_blocks=len(self.block_data.block_sizes)
131:             )
132:         # compute the edge counts for the blocks of i and j
133:         # on block-adjacency idx level
134:         k_i = self._compute_edge_counts_between_node_and_blocks(i)
135:         k_j = self._compute_edge_counts_between_node_and_blocks(j)
136:         affected_blocks = set(k_i.keys()) | set(k_j.keys())
137:         # new implementation with combined increment function
138:         neighbor_blocks = affected_blocks - {old_block_i, old_block_j}
139:         # build increment lists for neighbor blocks
140:         counts = [
141:             -k_i[t] + k_j[t] for t in neighbor_blocks
142:         ] + [
143:             -k_j[t] + k_i[t] for t in neighbor_blocks
144:         ]
145:         blocks_i = [old_block_i] * len(neighbor_blocks) + [old_block_j] * len(neighbor_blocks)
146:         block_j = list(neighbor_blocks) + list(neighbor_blocks)
147:         delta_e.increment(
148:             counts = counts,
149:             blocks_i = blocks_i,
150:             blocks_j = block_j,
151:         ) 
152:         # Add the changes for the old blocks of i and j
153:         has_edge_ij = bool(self.block_data.graph_data.adjacency[i, j])
154:         delta_e.increment(
155:             counts=[
156:                 k_i[old_block_i] - k_i[old_block_j] + k_j[old_block_j] - k_j[old_block_i] + 2 * has_edge_ij,
157:                 k_j[old_block_i] - k_i[old_block_i] - has_edge_ij,
158:                 k_i[old_block_j] - k_j[old_block_j] - has_edge_ij
159:             ],
160:             blocks_i=[old_block_i, old_block_i, old_block_j],
161:             blocks_j=[old_block_j, old_block_i, old_block_j]
162:         )
163:         return delta_e
164: # -----------------------------------------------------------------------------
165: #  Edgebased swap proposer
166: # -----------------------------------------------------------------------------
167: class EdgeBasedSwapProposer(NodeSwapProposer):
168:     """A Peixotostyle *edgeconditioned* twovertex swap.
169:     1. Pick a **crossblock edge** ``(i,j)`` uniformly at random.
170:     2. Swap the block labels of its endpoints.
171:     The proposal is *symmetric* (uniform over edges), so the Metropolis
172:     Hastings acceptance probability is simply ``min(1, exp(/T))``.
173:     """
174:     def __init__(
175:         self,
176:         block_data,
177:         rng: np.random.Generator = np.random.default_rng(1),
178:         use_numpy: bool = True,
179:         max_trials: int = 128,
180:     ) -> None:
181:         super().__init__(block_data=block_data, rng=rng, use_numpy=use_numpy)
182:         self.max_trials = max_trials
183:         # Direct CSR pointers for O(1) edge sampling
184:         self._indptr = self.block_data.graph_data.adjacency.indptr
185:         self._indices = self.block_data.graph_data.adjacency.indices
186:     # ------------------------------------------------------------------
187:     def propose_change(
188:         self,
189:         changes: Optional[ProposedValidChanges] = None,
190:     ) -> Tuple[ProposedValidChanges, EdgeDelta, CombinationDelta]:
191:         if changes is not None:
192:             return super().propose_change(changes=changes)
193:         n = self.block_data.graph_data.num_nodes  # type: ignore[attr-defined]
194:         blocks = self.block_data.blocks
195:         for _ in range(self.max_trials):
196:             i = int(self.rng.integers(n))
197:             # get i's neighbor index-range (adj is csr format)
198:             istart, iend = self._indptr[i], self._indptr[i + 1]
199:             if iend == istart:
200:                 continue  # isolated vertex
201:             # pick a random neighbor j
202:             j = int(self.rng.choice(self._indices[istart:iend]))
203:             bi, bj = blocks[i], blocks[j]
204:             if bi == bj:
205:                 continue  # need a crossblock edge
206:             proposed_changes: ProposedValidChanges = [(i, bj), (j, bi)]
207:             break
208:         else:  # all trials failed  fall back to uniform swap
209:             return super().propose_change(changes=None)
210:         delta_e = self._compute_delta_edge_counts(
211:             proposed_changes=proposed_changes,
212:             use_numpy=self.use_numpy,
213:         )
214:         delta_n: CombinationDelta = defaultdict(int)  # block sizes unchanged
215:         return proposed_changes, delta_e, delta_n
216: # -----------------------------------------------------------------------------
217: #  Triadic informed swap   (new implementation)
218: # -----------------------------------------------------------------------------
219: class TriadicSwapProposer(NodeSwapProposer):
220:     """A *threevertex* informed swap.
221:     Strategy
222:     --------
223:     1. Pick a random vertex ``i`` (block *A*).
224:     2. Choose a random neighbour ``j`` with ``block(j) = B \neq A``.
225:     3. Search in block *B* for a vertex ``l \ne j`` that has **at least one**
226:        neighbour in block *A*.
227:     4. Swap the block labels of ``i`` and ``l``.
228:     Swapping these two vertices reduces the expected number of *cross* edges by
229:     converting:
230:     * all edges from ``i`` into *B* to *internal*, and
231:     * all edges from `l``` into *A* to *internal*,
232:     while typically adding fewer new cross edges because ``i`` and ``j'`` were
233:     originally boundary vertices.
234:     The proposal distribution is still *symmetric* because every triad is
235:     selected with the same probability in either direction, so the usual MH
236:     acceptance rule applies.
237:     """
238:     def __init__(
239:         self,
240:         block_data,
241:         rng: np.random.Generator = np.random.default_rng(1),
242:         use_numpy: bool = False,
243:         max_trials: int = 128,
244:         candidate_trials: int = 64,
245:     ) -> None:
246:         super().__init__(block_data=block_data, rng=rng, use_numpy=use_numpy)
247:         self.max_trials = max_trials            # attempts to find (i,j)
248:         self.candidate_trials = candidate_trials  # attempts to find j per (i,j)
249:         self._indptr = self.block_data.graph_data.adjacency.indptr
250:         self._indices = self.block_data.graph_data.adjacency.indices
251:     # ------------------------------------------------------------------
252:     def propose_change(
253:         self,
254:         changes: Optional[ProposedValidChanges] = None,
255:     ) -> Tuple[ProposedValidChanges, EdgeDelta, CombinationDelta]:
256:         # Explicitchanges path used in unit tests
257:         if changes is not None:
258:             return super().propose_change(changes=changes)
259:         n = self.block_data.graph_data.num_nodes  # type: ignore[attr-defined]
260:         blocks = self.block_data.blocks
261:         for _ in range(self.max_trials):
262:             # ---- step 1: pick i ------------------------------------------------
263:             i = int(self.rng.integers(n))
264:             # find i's neighbour index-range (adj is csr format)
265:             istart, iend = self._indptr[i], self._indptr[i + 1]
266:             if iend == istart:
267:                 continue  # isolated  try another
268:             # ---- step 2: pick neighbour j in a *different* block --------------
269:             neighs_i = self._indices[istart:iend]
270:             j = int(self.rng.choice(neighs_i))
271:             a, b = blocks[i], blocks[j]
272:             if a == b:
273:                 continue  # need a cross edge ij
274:             # ---- step 3: find j in block b that touches block a --------------
275:             block_b_members = self.block_data.block_members[b]
276:             # change to list and randomlize order
277:             block_b_members = list(block_b_members)
278:             self.rng.shuffle(block_b_members)
279:             for l in block_b_members[:self.candidate_trials]:
280:                 if l in (i, j):
281:                     continue
282:                 # find neighbors of l in block a
283:                 lstart, lend = self._indptr[l], self._indptr[l + 1]
284:                 l_neighbors = self._indices[lstart:lend]
285:                 l_neighbor_in_block_a = any(
286:                     blocks[neighbor] == a for neighbor in l_neighbors
287:                 )
288:                 if not l_neighbor_in_block_a:
289:                     continue  # l must touch block a
290:                 proposed_changes: ProposedValidChanges = [(i, b), (l, a)]
291:                 delta_e = self._compute_delta_edge_counts(
292:                     proposed_changes=proposed_changes,
293:                     use_numpy=self.use_numpy,
294:                 )
295:                 delta_n: CombinationDelta = defaultdict(int)
296:                 return proposed_changes, delta_e, delta_n
297:             # could not find j  back to outer loop
298:             continue
299:         # ---- fallback --------------------------------------------------------
300:         # If every attempt failed (e.g. almost perfect partition), fall back to
301:         # a plain uniform swap to keep the chain ergodic.
302:         return super().propose_change(changes=None)

================
File: src/sbm/model.py
================
  1: from typing import Dict, Optional
  2: import numpy as np
  3: from scipy.sparse import csr_array
  4: from sbm.block_data import BlockData
  5: from sbm.likelihood import (
  6:     LikelihoodCalculator,
  7:     LikelihoodType,
  8: )
  9: from sbm.block_change_proposers import (
 10:     NodeSwapProposer,
 11:     EdgeBasedSwapProposer,
 12:     ChangeProposerName,
 13: )
 14: from sbm.node_mover import NodeMover
 15: from sbm.mcmc import MCMCAlgorithm
 16: from sbm.io import SBMFit
 17: from sbm.utils.logger import CSVLogger
 18: class SBMModel:
 19:     def __init__(self,
 20:                 initial_blocks: BlockData,
 21:                 rng: np.random.Generator,
 22:                 likelihood_type: LikelihoodType = "bernoulli",
 23:                 log: bool = True,
 24:                 change_freq = { # probabilities of trying each move type
 25:                     "uniform_swap": 1.0,
 26:                 }
 27:         ):
 28:         self._best_block_assignment = None
 29:         self._best_block_conn = None
 30:         self.block_data = initial_blocks
 31:         self.rng = rng
 32:         self.likelihood_calculator = LikelihoodCalculator(
 33:             block_data=self.block_data,
 34:             likelihood_type=likelihood_type
 35:             )
 36:         self.move_executor = NodeMover(
 37:             block_data=self.block_data,
 38:             )
 39:         change_proposer = {
 40:             "uniform_swap": NodeSwapProposer(
 41:                         block_data=self.block_data,
 42:                         rng=self.rng,
 43:                         use_numpy=True,
 44:                     ),
 45:             "edge_based_swap": EdgeBasedSwapProposer(
 46:                         block_data=self.block_data,
 47:                         rng=self.rng,
 48:                         use_numpy=False,
 49:                     ),
 50:             "triadic_swap": EdgeBasedSwapProposer(
 51:                         block_data=self.block_data,
 52:                         rng=self.rng,
 53:                         use_numpy=True,
 54:                     ),
 55:         }
 56:         self.mcmc_algorithm = MCMCAlgorithm(
 57:             block_data = self.block_data,
 58:             likelihood_calculator = self.likelihood_calculator,
 59:             change_proposer = change_proposer, # type: ignore
 60:             change_freq = change_freq, # type: ignore
 61:             rng = self.rng,
 62:             log=log
 63:         )
 64:     def fit(self,
 65:         max_num_iterations: int,
 66:         min_block_size: int,
 67:         initial_temperature: float,
 68:         cooling_rate: float,
 69:         max_blocks: Optional[int] = None,
 70:         logger: Optional[CSVLogger] = None,
 71:         patience: Optional[int] = None,
 72:         return_ll: bool = False
 73:         ):
 74:         ll = self.mcmc_algorithm.fit(
 75:             max_num_iterations=max_num_iterations,
 76:             min_block_size=min_block_size,
 77:             initial_temperature=initial_temperature,
 78:             cooling_rate=cooling_rate,
 79:             max_blocks=max_blocks,
 80:             logger=logger,
 81:             patience=patience,
 82:         )
 83:         if return_ll:
 84:             return ll
 85:     def get_block_assignments(self, best:bool=True) -> Dict[int, int]:
 86:         if best:
 87:             return self.mcmc_algorithm._best_block_assignment
 88:         else:
 89:             return self.block_data.blocks
 90:     def to_sbmfit(self, metadata: Optional[Dict] = None, best:bool=True) -> SBMFit:
 91:         """ 
 92:         Convert the fitted SBM model to an SBMFit object for serialization. 
 93:         """
 94:         if metadata is None:
 95:             metadata = {}
 96:         if best:
 97:             blocks = self.mcmc_algorithm._best_block_assignment
 98:             block_sizes = np.unique(list(blocks.values()), return_counts=True)[1].tolist()
 99:             block_conn = self.mcmc_algorithm._best_block_conn
100:             ll = self.mcmc_algorithm.best_ll
101:         else:
102:             blocks = self.block_data.blocks
103:             block_sizes = list(self.block_data.block_sizes.values())
104:             block_conn = self.block_data.block_connectivity
105:             ll = self.mcmc_algorithm.current_ll
106:         return SBMFit(
107:             block_sizes=block_sizes,
108:             block_conn=csr_array(block_conn),
109:             directed_graph=self.block_data.graph_data.directed,
110:             neg_loglike=ll,
111:             metadata=metadata
112:         )

================
File: src/sbm/node_mover.py
================
 1: from typing import List, Tuple
 2: import scipy.sparse as sp
 3: import numpy as np
 4: from sbm.block_data import BlockData, _BlockDataUpdater
 5: from line_profiler import profile
 6: from sbm.block_change_proposers import (
 7:     ProposedValidChanges,
 8:     EdgeDelta,
 9: )
10: class NodeMover:
11:     """
12:     Class to move nodes between block assignment in the Stochastic Block Model (SBM).
13:     When performing a change, it updates the block sizes, connectivity matrix,
14:     block indices, and inverse block indices accordingly.
15:     All changes are performed in-place on the BlockData object by the _BlockDataUpdater.
16:     """
17:     def __init__(self, block_data: BlockData):
18:         self.block_data_updater = _BlockDataUpdater(block_data)
19:     def perform_change(self,
20:             proposed_changes: ProposedValidChanges,
21:             delta_e: EdgeDelta,
22:             ):
23:         """ 
24:         Change the block assignments of nodes according to the proposed change.
25:         Update:
26:         - block sizes
27:         - block connectivity matrix (edge counts between blocks)
28:         - block indices (node to block assignment)
29:         - inverse block indices (nodes in each block)
30:         Rely on increment_edge_count from BlockData to update edge counts.
31:         :param change: A list of tuples where each tuple contains a node and their new block.
32:         """
33:         (node_i, new_block_i), (node_j, new_block_j) = proposed_changes
34:         # update the block assignments, sizes, and memberships
35:         self.block_data_updater._move_node_to_block(node_i, new_block_i)
36:         self.block_data_updater._move_node_to_block(node_j, new_block_j)
37:         # update the edge counts between the blocks
38:         for (r, s), e_delta in delta_e.items():
39:             self.block_data_updater._increment_edge_count(r, s, e_delta)

================
File: src/tests/likelihood_test.py
================
  1: # tests/test_likelihood.py
  2: """
  3: End-to-end tests for the Bernoulli likelihood calculators.
  4:  * We create a tiny 4-node undirected graph with two blocks.
  5:  * We compare every  returned by the incremental code against the
  6:    ground-truth global likelihood difference.
  7: """
  8: from __future__ import annotations
  9: from collections import Counter
 10: from typing import Tuple, Dict
 11: import numpy as np
 12: #np.float_ = np.float64  # ensure float64 is used
 13: import pytest
 14: from scipy.sparse import csr_array
 15: from sbm.likelihood import (
 16:     compute_global_bernoulli_ll,
 17:     LikelihoodCalculator
 18: )
 19: from sbm.block_data import BlockData
 20: from sbm.graph_data import GraphData
 21: from sbm.block_change_proposers import NodeSwapProposer 
 22: ##############################################################################
 23: # Fixtures
 24: ##############################################################################
 25: @pytest.fixture(scope="module")
 26: def four_node_example() -> Tuple[BlockData, GraphData, Dict[int, int]]:
 27:     """
 28:     Graph:
 29:         01   Block 0: {0,1}      Edges: (0,1)
 30:              Block 1: {2,3}              (2,3)
 31:         23                              (0,2) (1,3)
 32:     The matrix is symmetrical (undirected, no loops).
 33:     """
 34:     adj = np.zeros((4, 4), dtype=int)
 35:     edges = [(0, 1), (2, 3), (0, 2), (1, 3)]
 36:     for u, v in edges:
 37:         adj[u, v] = 1
 38:         adj[v, u] = 1  # symmetric
 39:     adjacency = csr_array(adj)
 40:     blocks = {0: 0, 1: 0, 2: 1, 3: 1}  # Node to block mapping
 41:     graph_data: GraphData = GraphData(adjacency_matrix=adjacency, directed=False)
 42:     return BlockData(graph_data=graph_data, initial_blocks=blocks), graph_data, blocks
 43: ##############################################################################
 44: # Tests
 45: ##############################################################################
 46: def test_edge_counter(four_node_example):
 47:     """`_compute_edge_counts_between_node_and_blocks` returns correct counts."""
 48:     block_data, *_ = four_node_example
 49:     change_proposer = NodeSwapProposer(block_data)
 50:     counts = change_proposer._compute_edge_counts_between_node_and_blocks(node=0)
 51:     # Node 0 is linked to node-1 (block-0) and node-2 (block-1)  {0:1, 1:1}
 52:     assert counts == Counter({0: 1, 1: 1})
 53: def test_swap_same_block_zero_delta(four_node_example):
 54:     """
 55:     Swapping two nodes that are *already* in the same block must leave the
 56:     likelihood unchanged.
 57:     """
 58:     block_data, *_ = four_node_example
 59:     swap_proposer = NodeSwapProposer(block_data)
 60:     calc = LikelihoodCalculator(block_data)
 61:     # attempt to swap nodes 0 and 2
 62:     swap = [(0, block_data.blocks[1]), (1, block_data.blocks[0])]
 63:     swap, delta_e, delta_n = swap_proposer.propose_change(swap)
 64:     delta = calc.compute_delta_ll(delta_e=delta_e, delta_n=delta_n)
 65:     assert delta == pytest.approx(0.0, abs=1e-6)
 66: def test_delta_ll_matches_global_recompute(four_node_example):
 67:     """
 68:     delta ll from the incremental calculator must equal the brute-force recomputed
 69:     likelihood difference after the swap (0  2).
 70:     """
 71:     block_data_old, graph_data, blocks_old = four_node_example
 72:     adjacency = graph_data.adjacency
 73:     swap_proposer = NodeSwapProposer(block_data_old)
 74:     calc = LikelihoodCalculator(block_data_old)
 75:     # ---------- perform swap 0  2 -----------------------------------------
 76:     blocks_new = blocks_old.copy()
 77:     blocks_new[0], blocks_new[2] = blocks_new[2], blocks_new[0]
 78:     block_data_new = BlockData(
 79:         graph_data=GraphData(adjacency_matrix=adjacency, directed=False),
 80:         initial_blocks=blocks_new
 81:     )
 82:     ll_old = compute_global_bernoulli_ll(block_data_old)
 83:     ll_new = compute_global_bernoulli_ll(block_data_new)
 84:     expected_delta = ll_new - ll_old
 85:     swap = [(0, block_data_old.blocks[2]), (2, block_data_old.blocks[0])]
 86:     swap, delta_e, delta_n = swap_proposer.propose_change(swap)
 87:     delta_calc = calc.compute_delta_ll(delta_e=delta_e, delta_n=delta_n)
 88:     msg = (
 89:         f"Failed on swap (0  2) with blocks {blocks_old}  {blocks_new}\n"
 90:         f"delta_e: {delta_e}\n"
 91:     )
 92:     assert delta_calc == pytest.approx(expected_delta, rel=1e-6, abs=1e-6), msg
 93: def test_delta_edge_counts_consistency(four_node_example):
 94:     """
 95:     The raw `delta_e` returned by `_compute_delta_edge_counts_swap` should turn
 96:     the old connectivity into the new one *exactly* on every affected (r,s).
 97:     """
 98:     block_data_old, graph_data, blocks_old = four_node_example
 99:     adjacency = graph_data.adjacency
100:     swap_proposer = NodeSwapProposer(block_data_old)
101:     calc = LikelihoodCalculator(block_data_old)
102:     i, j = 0, 2  # the same swap as above
103:     proposed_changes = [(i, block_data_old.blocks[j]), (j, block_data_old.blocks[i])]
104:     delta_e = swap_proposer._compute_delta_edge_counts(
105:         proposed_changes= proposed_changes
106:     )
107:     conn_expected = block_data_old.block_connectivity.copy()
108:     for (r, s), de in delta_e.items():
109:         conn_expected[r, s] += de
110:     # Ground-truth connectivity after the swap
111:     blocks_new = blocks_old.copy()
112:     blocks_new[i], blocks_new[j] = blocks_new[j], blocks_new[i]
113:     block_data_new = BlockData(
114:         graph_data=GraphData(adjacency_matrix=adjacency, directed=False),
115:         initial_blocks=blocks_new
116:     )
117:     for (r, s), de in delta_e.items():
118:         assert (
119:             conn_expected[r, s] == block_data_new.block_connectivity[r, s]
120:         ), f"Mismatch on block pair ({r},{s})"
121: ###################################################
122: ### Randomized tests
123: ###################################################
124: def _er_graph_csr(n: int, p: float, *, seed: int) -> csr_array:
125:     """Undirected G(n,p) without self-loops, returned as CSR matrix."""
126:     rng = np.random.default_rng(seed)
127:     upper = rng.random((n, n)) < p                           # boolean mask
128:     upper = np.triu(upper, k=1)                              # keep strict upper
129:     adj = upper | upper.T                                    # symmetrise
130:     return csr_array(adj.astype(np.int8))
131: def _random_equal_blocks(n: int, block_size: int, *, seed: int) -> dict[int, int]:
132:     """Random permutation of vertices into equal-size blocks."""
133:     rng = np.random.default_rng(seed)
134:     perm = rng.permutation(n)
135:     blocks: dict[int, int] = {}
136:     for b in range(n // block_size):
137:         for v in perm[b * block_size : (b + 1) * block_size]:
138:             blocks[v] = b
139:     return blocks
140: def _pick_two_different_blocks(rng: np.random.Generator, blocks: dict[int, int]):
141:     n = len(blocks)
142:     i = rng.choice(n, size=1)[0]
143:     j = rng.choice(n-1, size=1)[0]
144:     if j >= i:
145:         j += 1
146:     return i, j
147: def _single_swap_calc_vs_bruteforce(
148:     graph_data: GraphData,
149:     blocks: dict[int, int],
150:     rng: np.random.Generator,
151:     tol: float = 1e-6,
152:     experiment_index: int = 0
153: ):
154:     """One random swap and check incremental delta ll against brute force."""
155:     # choose vertices in different blocks
156:     i, j = _pick_two_different_blocks(rng, blocks)
157:     # incremental path -------------------------------------------------
158:     block_data = BlockData(graph_data=graph_data, initial_blocks=blocks)
159:     print(block_data.blocks)
160:     swap_proposer = NodeSwapProposer(block_data)
161:     calc = LikelihoodCalculator(block_data)
162:     swap_instr = [(i, blocks[j]), (j, blocks[i])]
163:     _, delta_e, delta_n = swap_proposer.propose_change(swap_instr)
164:     delta_ll = calc.compute_delta_ll(delta_e=delta_e, delta_n=delta_n)
165:     # brute-force path -------------------------------------------------
166:     ll_before = compute_global_bernoulli_ll(block_data)
167:     new_blocks = blocks.copy()
168:     new_blocks[i], new_blocks[j] = new_blocks[j], new_blocks[i]
169:     block_data_after = BlockData(graph_data=graph_data, initial_blocks=new_blocks)
170:     ll_after = compute_global_bernoulli_ll(block_data_after)
171:     delta_brute = ll_after - ll_before
172:     # compute the delta_e in the brute-force way
173:     # only storing non-zero deltas in upper triangular matrix
174:     delta_e_brute = block_data_after.block_connectivity - block_data.block_connectivity
175:     delta_e_brute = {
176:         (r, s): de for (r, s), de in zip(
177:             np.argwhere(delta_e_brute != 0),
178:             delta_e_brute[delta_e_brute != 0]
179:         )
180:         if r <= s
181:     }
182:     # comparison and print informatino in case of failure
183:     msg = (
184:         f"Failed on experiment {experiment_index}"
185:         f"\nGraph: {graph_data.adjacency.toarray()}"
186:         f"\nBlocks: {blocks}"
187:         f"\nswap:         {i} <-> {j} (blocks {blocks[i]} <-> {blocks[j]})"
188:         f"\ndelta_e:   {delta_e}"
189:         f"\ndelta_e_brute:   {delta_e_brute}"
190:         f"\ndelta_inc:    {delta_ll:.12g}"
191:         f"\ndelta_brute:  {delta_brute:.12g}"
192:     )
193:     assert delta_ll == pytest.approx(delta_brute, rel=tol, abs=tol), msg
194: def test_delta_ll_random_swaps_er():
195:     """100 random swaps on independent ER-20 graph must all match brute force delta ll."""
196:     for index in range(100):
197:         n, p, b = 20, 0.1, 2
198:         rng = np.random.default_rng(1)
199:         adj = _er_graph_csr(n, p, seed=42)
200:         graph = GraphData(adjacency_matrix=adj, directed=False)
201:         blocks = _random_equal_blocks(n, block_size=b, seed=2)
202:         _single_swap_calc_vs_bruteforce(graph_data=graph,
203:                                         blocks=blocks,
204:                                         rng=rng,
205:                                         experiment_index=index,
206:                                         tol=1e-6
207:                                         )

================
File: src/tests/test_change_proposer_and_mover.py
================
  1: # src/tests/test_change_proposers_and_mover.py
  2: """
  3: Unit-tests for
  4:    sbm.block_change_proposers           (helper + NodeSwapProposer)
  5:    sbm.node_mover                      (NodeMover)
  6: All graphs are 4 undirected vertices:
  7:     01   block 0 = {0,1}
  8:       
  9:     23   block 1 = {2,3}
 10: Edges: (0,1) (2,3)  plus two cross edges (0,2) (1,3).
 11: """
 12: from __future__ import annotations
 13: from collections import defaultdict
 14: from typing import Dict, Tuple
 15: import numpy as np
 16: from numpy.typing import ArrayLike
 17: import pytest
 18: from scipy.sparse import csr_array
 19: from sbm.graph_data import GraphData
 20: from sbm.block_data import BlockData
 21: from sbm.block_change_proposers import (
 22:     NodeSwapProposer,
 23:     ProposedValidChanges,
 24:     EdgeBasedSwapProposer,
 25:     TriadicSwapProposer,
 26: )
 27: from sbm.edge_delta import EdgeDelta
 28: from sbm.node_mover import NodeMover
 29: ###############################################################################
 30: # helpers
 31: ###############################################################################
 32: def _toy_graph() -> Tuple[csr_array, Dict[int, int]]:
 33:     """Return 44 adjacency and initial {node: block} mapping."""
 34:     adj = np.zeros((4, 4), dtype=int)
 35:     edges = [(0, 1), (2, 3), (0, 2), (1, 3)]
 36:     for u, v in edges:
 37:         adj[u, v] = adj[v, u] = 1
 38:     blocks = {0: 0, 1: 0, 2: 1, 3: 1}
 39:     return csr_array(adj), blocks
 40: def _brute_block_connectivity(adj: csr_array, blocks: Dict[int, int]) -> Dict[Tuple[int, int], int]:
 41:     """Return upper-triangle edge counts between blocks."""
 42:     rows, cols = adj.nonzero() # type: ignore
 43:     bc = defaultdict(int)
 44:     for u, v in zip(rows, cols, strict=False):
 45:         if u >= v:  # count each undirected edge once
 46:             continue
 47:         a, b = blocks[u], blocks[v]
 48:         r, s = (a, b) if a <= b else (b, a)
 49:         bc[(r, s)] += 1
 50:     return bc
 51: ###############################################################################
 52: # tests for _increment_delta_e
 53: ###############################################################################
 54: def test_increment_delta_e_uses_sorted_key() -> None:
 55:     e_delta = EdgeDelta(n_blocks=4)
 56:     e_delta.increment(
 57:         counts=[1],
 58:         blocks_i=[3],
 59:         blocks_j=[1],
 60:     )          # block_i > block_j  key (1,3)
 61:     assert ((1, 3), 1) in e_delta.items() and ((3, 1), 1) not in e_delta.items(), \
 62:         f"Key mismatch: delta keys = {list(e_delta.items())}"
 63: def test_increment_delta_e_overwrites_existing() -> None:
 64:     e_delta = EdgeDelta(n_blocks=4)
 65:     e_delta.increment(
 66:         counts = [1],
 67:         blocks_i = [0],
 68:         blocks_j = [2],
 69:     )          # set to 1
 70:     e_delta.increment(
 71:         counts = [3],
 72:         blocks_i = [2],
 73:         blocks_j = [0]
 74:     )          # overwrite same pair
 75:     assert e_delta[(0, 2)] == 3, \
 76:         f"Value not overwritten, got {e_delta[(0, 2)]}, expected 3"
 77: ###############################################################################
 78: # tests for NodeSwapProposer
 79: ###############################################################################
 80: @pytest.fixture(scope="module")
 81: def proposer() -> NodeSwapProposer:
 82:     adj, blocks = _toy_graph()
 83:     bd = BlockData(initial_blocks=blocks, graph_data=GraphData(adj, directed=False))
 84:     return NodeSwapProposer(block_data=bd, rng=np.random.default_rng(0))
 85: def test_compute_delta_edge_counts_matches_brute(proposer: NodeSwapProposer) -> None:
 86:     # swap vertices 0 (block 0) and 2 (block 1)
 87:     changes: ProposedValidChanges = [(0, 1), (2, 0)]
 88:     delta = proposer._compute_delta_edge_counts(changes)          # type: ignore
 89:     before = _brute_block_connectivity(
 90:         proposer.block_data.graph_data.adjacency,
 91:         proposer.block_data.blocks
 92:     )
 93:     # build new blocks mapping
 94:     new_blocks = proposer.block_data.blocks.copy()
 95:     new_blocks[0], new_blocks[2] = new_blocks[2], new_blocks[0]
 96:     after = _brute_block_connectivity(proposer.block_data.graph_data.adjacency,
 97:                                       new_blocks)
 98:     brute_delta = {k: after.get(k, 0) - before.get(k, 0) for k in set(after) | set(before)}
 99:     delta_dict = dict(delta.items())
100:     assert delta_dict == brute_delta, \
101:         f"\nexpected {brute_delta}\ngot      {delta_dict}"
102: def test_propose_change_returns_expected_structure(proposer: NodeSwapProposer) -> None:
103:     changes = [(0, 1), (2, 0)]
104:     new_changes, delta_e, delta_n = proposer.propose_change(changes=changes)
105:     assert new_changes == changes, "proposer changed explicit instruction"
106:     assert all(isinstance(k, tuple) and len(k) == 2 for k in delta_e.items()), "delta_e keys malformed"
107:     # check that all kays of delta_e are accesible in delta_n (not necessarily non-zero)
108:     for (i, j), _ in delta_e.items():
109:         try:
110:             _ = delta_n[(i, j)]
111:         except KeyError:
112:             pytest.fail(f"delta_n missing key ({i}, {j}) from delta_e: {delta_e.items()}")
113: ###############################################################################
114: # tests for NodeMover
115: ###############################################################################
116: def test_node_mover_updates_blocks_and_sizes() -> None:
117:     adj, blocks = _toy_graph()
118:     bd = BlockData(initial_blocks=blocks, graph_data=GraphData(adj, directed=False))
119:     mover = NodeMover(bd)
120:     changes = [(0, 1), (2, 0)]
121:     # reuse proposer to get correct delta_e
122:     prop = NodeSwapProposer(block_data=bd, rng=np.random.default_rng(0))
123:     delta_e = prop._compute_delta_edge_counts(changes)            # type: ignore
124:     mover.perform_change(changes, delta_e)
125:     assert bd.blocks[0] == 1 and bd.blocks[2] == 0, \
126:         f"blocks not swapped: {bd.blocks}"
127:     assert bd.block_sizes[0] == 2 and bd.block_sizes[1] == 2, \
128:         f"block_sizes wrong: {bd.block_sizes}"
129: def test_node_mover_updates_connectivity() -> None:
130:     adj, blocks = _toy_graph()
131:     bd = BlockData(initial_blocks=blocks, graph_data=GraphData(adj, directed=False))
132:     mover = NodeMover(bd)
133:     before = bd.block_connectivity.copy()
134:     changes = [(0, 1), (2, 0)]
135:     prop = NodeSwapProposer(block_data=bd, rng=np.random.default_rng(0))
136:     delta_e = prop._compute_delta_edge_counts(changes)            # type: ignore
137:     mover.perform_change(changes, delta_e)
138:     # brute recompute
139:     after_brute = _brute_block_connectivity(bd.graph_data.adjacency, bd.blocks)
140:     # connectivity matrix stores both triangles  pick upper
141:     after_matrix = {(r, s): int(bd.block_connectivity[r, s]) #type: ignore
142:                     for r, s in after_brute}
143:     msg = (f"\nexpected connectivity {after_brute}"
144:            f"\nobserved  connectivity {after_matrix}"
145:            f"\ndelta_e applied        {delta_e}")
146:     assert after_matrix == after_brute, msg
147: # ---------------------------------------------------------------------------
148: # helpers  minimal blockedge accounting for validation
149: # ---------------------------------------------------------------------------
150: def _block_edge_matrix(adj: csr_array, blocks: np.ndarray, n_blocks: int) -> np.ndarray:
151:     """Return an n_blocksn_blocks symmetric matrix with edge counts."""
152:     mat = np.zeros((n_blocks, n_blocks), dtype=int)
153:     rows, cols = adj.nonzero()
154:     for u, v in zip(rows, cols):
155:         if u >= v:  # undirected  count each unordered pair once
156:             continue
157:         bu, bv = blocks[u], blocks[v]
158:         mat[bu, bv] += 1
159:         if bu != bv:
160:             mat[bv, bu] += 1
161:     return mat
162: def _apply_changes(blocks: np.ndarray, changes):
163:     new_blocks = blocks.copy()
164:     for node, tgt in changes:
165:         new_blocks[node] = tgt
166:     return new_blocks
167: def _assert_delta_matches(delta_e, before, after):
168:     """Check that EdgeDelta equals afterbefore for every block pair."""
169:     n_blocks = before.shape[0]
170:     for r in range(n_blocks):
171:         for s in range(n_blocks):
172:             assert delta_e[r, s] == after[r, s] - before[r, s]
173: # ---------------------------------------------------------------------------
174: # fixtures
175: # ---------------------------------------------------------------------------
176: @pytest.fixture(scope="module")
177: def toy_block_data():
178:     """Simple 6node, 2block undirected graph with both intra and crossedges."""
179:     edges = [
180:         (0, 1), (1, 2), (0, 2),  # block 0 internal triangle
181:         (3, 4), (4, 5), (3, 5),  # block 1 internal triangle
182:         (0, 3), (1, 4), (2, 5),  # three cross edges
183:     ]
184:     n = 6
185:     rows, cols = [], []
186:     for u, v in edges:
187:         rows += [u, v]
188:         cols += [v, u]
189:     data = np.ones(len(rows), dtype=int)
190:     adj = csr_array((data, (rows, cols)), shape=(n, n))
191:     blocks = {0: 0, 1: 0, 2: 0, 3: 1, 4: 1, 5: 1}  # type: ignore[assignment]
192:     bd = BlockData(initial_blocks=blocks, graph_data=GraphData(adj, directed=False))
193:     return bd
194: # ---------------------------------------------------------------------------
195: # tests  EdgeBasedSwapProposer
196: # ---------------------------------------------------------------------------
197: def test_edge_based_swap_valid_move(toy_block_data):
198:     rng = np.random.default_rng(42)
199:     prop = EdgeBasedSwapProposer(toy_block_data, rng=rng)
200:     changes, delta_e, _ = prop.propose_change()
201:     # exactly two tuples returned
202:     assert len(changes) == 2
203:     (i, tgt_i), (j, tgt_j) = changes
204:     blocks = toy_block_data.blocks
205:     # originally different blocks and connected by an edge
206:     assert blocks[i] != blocks[j]
207:     assert toy_block_data.graph_data.adjacency[i, j] == 1  # type: ignore[index]
208:     # swap  semantics: targets are the partner's old blocks
209:     assert tgt_i == blocks[j]
210:     assert tgt_j == blocks[i]
211:     # edgedelta correctness --------------------------------------------------
212:     before = _block_edge_matrix(toy_block_data.graph_data.adjacency, blocks,  # type: ignore[attr-defined]
213:                                 n_blocks=2)
214:     after_blocks = _apply_changes(blocks, changes)
215:     after = _block_edge_matrix(toy_block_data.graph_data.adjacency, after_blocks, 2)
216:     _assert_delta_matches(delta_e, before, after)
217: # ---------------------------------------------------------------------------
218: # tests  TriadicSwapProposer
219: # ---------------------------------------------------------------------------
220: def test_triadic_swap_valid_move(toy_block_data):
221:     rng = np.random.default_rng(7)
222:     prop = TriadicSwapProposer(toy_block_data, rng=rng, candidate_trials=20)
223:     changes, delta_e, _ = prop.propose_change()
224:     # two tuples returned
225:     assert len(changes) == 2
226:     (i, tgt_i), (l, tgt_l) = changes
227:     blocks = toy_block_data.blocks
228:     # i moves to l's block and viceversa
229:     assert tgt_i == blocks[l]
230:     assert tgt_l == blocks[i]
231:     # block sizes preserved ---------------------------------------------------
232:     block_sizes = toy_block_data.block_sizes
233:     after_blocks = _apply_changes(blocks, changes)
234:     new_block_sizes = {
235:         b: sum(1 for v in after_blocks.values() if v == b)
236:         for b in set(after_blocks.values())
237:     }
238:     for block, size in new_block_sizes.items():
239:         assert size == block_sizes[block], \
240:             f"Block {block} size changed: expected {block_sizes[block]}, got {size}"
241:     # deltaedge correctness --------------------------------------------------
242:     before = _block_edge_matrix(toy_block_data.graph_data.adjacency, blocks, 2)  # type: ignore[attr-defined]
243:     after = _block_edge_matrix(toy_block_data.graph_data.adjacency, after_blocks, 2)
244:     _assert_delta_matches(delta_e, before, after)

================
File: src/tests/test_metrics.py
================
 1: import numpy as np, scipy.sparse as sp
 2: from scipy.sparse import csr_array
 3: from metrics import (
 4:     shortest_path_distance,
 5:     degree_distance,
 6:     clustering_distance
 7: )
 8: ### Helper functions to create graphs
 9: def _line_graph(n=6) -> csr_array:
10:     rows = np.arange(n-1); cols = rows + 1
11:     A = sp.coo_matrix((np.ones(n-1), (rows, cols)), shape=(n, n))
12:     A = A + A.T
13:     A = csr_array(A, dtype=np.int8)
14:     return A
15: def _er_graph(n: int=10, p: float=0.1, *, seed: int=1) -> csr_array:
16:     """Undirected G(n,p) without self-loops, returned as CSR matrix."""
17:     rng = np.random.default_rng(seed)
18:     upper = rng.random((n, n)) < p                           # boolean mask
19:     upper = np.triu(upper, k=1)                              # keep strict upper
20:     adj = upper | upper.T                                    # symmetrise
21:     return csr_array(adj.astype(np.int8))
22: #### test functions
23: def test_shortest_path_identical_line():
24:     A = _line_graph()
25:     print(A.toarray())
26:     assert shortest_path_distance(A, A, n_samples=None) == 0.0
27: def test_degree_identical_line():
28:     A = _line_graph()
29:     assert degree_distance(A, A) == 0.0
30: def test_clustering_identical_line():
31:     A = _line_graph()
32:     assert clustering_distance(A, A) == 0.0
33: def test_shortest_path_different_line():
34:     A = _line_graph(n=20)
35:     B = _line_graph(n=200)
36:     assert shortest_path_distance(A, B, n_samples=100) != 0.0
37: def test_degree_different_line():
38:     A = _line_graph(n=20)
39:     A = _line_graph(n=200)
40:     assert degree_distance(A, A) == 0.0
41: def test_clustering_identical_er():
42:     A = _er_graph(n=100)
43:     assert clustering_distance(A, A) == 0.0
44: def test_shortest_path_identical_er():
45:     A = _er_graph(p=0.9)
46:     assert shortest_path_distance(A, A, n_samples=None) == 0.0
47: def test_shortest_path_different_er():
48:     A = _er_graph(n=20, p=0.9)
49:     B = _er_graph(n=200, p=0.1)
50:     assert shortest_path_distance(A, B, n_samples=100) != 0.0
51: def test_degree_different_er():
52:     A = _er_graph()
53:     assert degree_distance(A, A) == 0.0
54: def test_clustering_different_er():
55:     A = _er_graph()
56:     assert clustering_distance(A, A) == 0.0

================
File: .gitignore
================
 1: # --------------------------------------------------------------------
 2: #  Python byte-code / build artefacts
 3: # --------------------------------------------------------------------
 4: __pycache__/
 5: *.py[cod]
 6: *.pyo
 7: *.so
 8: *.dylib
 9: *.egg-info/
10: build/
11: dist/
12: 
13: # --------------------------------------------------------------------
14: #  Virtual-envs
15: # --------------------------------------------------------------------
16: .venv/
17: .env/
18: .mamba/
19: *.conda_env/
20: 
21: # --------------------------------------------------------------------
22: #  Data & model artefacts  (generated by pipeline)
23: # --------------------------------------------------------------------
24: data/
25: models/
26: logs/
27: reports/
28: figures/
29: results/
30: 
31: # --------------------------------------------------------------------
32: #  Large numpy / scipy files anywhere but src/tests
33: # --------------------------------------------------------------------
34: *.npz
35: *.npy
36: *.pkl
37: *.h5
38: *.parquet
39: 
40: # --------------------------------------------------------------------
41: #  Jupyter checkpoints
42: # --------------------------------------------------------------------
43: .ipynb_checkpoints/
44: 
45: # --------------------------------------------------------------------
46: #  IDE / OS metadata
47: # --------------------------------------------------------------------
48: .idea/
49: .vscode/
50: *.swp
51: .DS_Store
52: Thumbs.db
53: 
54: # --------------------------------------------------------------------
55: #  Misc
56: # --------------------------------------------------------------------
57: *.bak
58: *.tmp
59: repomix-output.txt
60: *.lprof

================
File: configs/surrogate_eval.yml
================
1: # ---------------------------------------------------------------
2: n_surrogates: 20 # graphs to sample per dataset
3: overwrite: true # set true to ignore cached results
4: # which similarity metrics to compute
5: metrics:
6:   - shortest_path
7:   - degree
8:   - clustering

================
File: src/pipelines/fit_sbm.py
================
 1: # src/pipelines/fit_sbm.py
 2: import yaml
 3: import argparse
 4: from pathlib import Path
 5: from itertools import product
 6: from line_profiler import profile
 7: from time import time
 8: import numpy as np
 9: from tqdm import tqdm
10: from sbm.io import GraphLoader, SBMWriter
11: from sbm.block_assigner import AssignerConstructor
12: from sbm.model import SBMModel
13: from sbm.utils.logger import CSVLogger
14: from sbm.utils.pipeline_utils import (
15:     sbmfit_folderpath,
16:     FitConfig,
17: )
18: @profile
19: def main(fit_config: str): # type: ignore
20:     fit_config: FitConfig = yaml.safe_load(Path(fit_config).read_text())
21:     logging_config = fit_config["logging"][0] # type: ignore
22:     data_config = fit_config["datasets"] # type: ignore
23:     seed = fit_config['seed']
24:     rng = np.random.default_rng(seed)
25:     config_pairs = product(
26:         fit_config['sbm'], # type: ignore
27:         fit_config['datasets'], # type: ignore
28:     )
29:     iterator = tqdm(
30:         config_pairs,
31:         desc="Fitting SBM models",
32:         total=len(fit_config['sbm']) * len(fit_config['datasets'])
33:     )
34:     for sbm_config, ds in iterator:
35:         # prepare SBM model
36:         g = GraphLoader.load(
37:             Path(ds["path"]),
38:             force_undirected=bool(sbm_config["force_undirected"]), # type: ignore
39:             )
40:         assigner_const = AssignerConstructor(rng=rng)
41:         assigner = assigner_const.create_assigner(
42:             graph_data=g,
43:             min_block_size=int(sbm_config["min_block_size"]), # type: ignore
44:             init_method=sbm_config["init_method"], # type: ignore
45:             )
46:         block_data = assigner.compute_assignment()
47:         # check block sizes
48:         model = SBMModel(
49:             initial_blocks=block_data,
50:             rng=rng)
51:         # fit SBM model
52:         name = ds["name"] + "_".join(
53:             f"{k}_{v}" for k, v in sbm_config.items() # type: ignore
54:         )
55:         log_path = Path(logging_config['logging_folder']) / f"{name}.csv"
56:         tic = time()
57:         with CSVLogger(log_path, log_every=logging_config['log_every']) as logger:
58:             model.fit(
59:                 max_num_iterations=sbm_config["max_n_iter"], # type: ignore
60:                 min_block_size=sbm_config["min_block_size"], # type: ignore
61:                 initial_temperature=sbm_config["temperature"], # type: ignore
62:                 cooling_rate=sbm_config["cooling_rate"], # type: ignore
63:                 logger=logger,
64:                 patience=sbm_config.get("patience", None), # type: ignore
65:             )
66:         # save the fitted model
67:         fit = model.to_sbmfit()
68:         toc = time()
69:         print(f"Fitting {ds['name']} took {toc - tic:.2f} seconds")
70:         tic = time()
71:         fit_configs = sbm_config.copy() # type: ignore
72:         out_dir = sbmfit_folderpath(
73:             base_dir=Path("results/sbm_fits"),
74:             sbm_config=fit_configs,
75:             data_spec=ds, 
76:         )
77:         print(f'Out directory: {out_dir}')
78:         out_dir.mkdir(parents=True, exist_ok=True)
79:         SBMWriter.save(out_dir, fit)
80:         toc = time()
81:         print(f"Saving {ds['name']} took {toc - tic:.2f} seconds, nll = {fit.neg_loglike:.2f}")
82: if __name__ == "__main__":
83:     p = argparse.ArgumentParser()
84:     p.add_argument("--fit_config", type=str, help="Path to the configuration file.")
85:     args = p.parse_args()
86:     main(fit_config=args.fit_config)

================
File: src/sbm/block_assigner.py
================
  1: """ 
  2:     Functions and classes for computing initial block assignment 
  3:     used in the Stochastic Block Model (SBM). These are later updated
  4:     using the MCMC algorithm.
  5: """
  6: from __future__ import annotations
  7: from typing import List, Dict, Optional, Tuple, Iterable, TypeAlias, Set
  8: from collections import defaultdict, Counter
  9: from time import time
 10: import metis
 11: import scipy.sparse as sp
 12: from scipy.sparse import csr_array
 13: import numpy as np
 14: from k_means_constrained import KMeansConstrained
 15: from nodevectors import ProNE
 16: from sbm.block_data import BlockData
 17: from sbm.graph_data import GraphData
 18: from sbm.utils.pipeline_utils import InitMethodName
 19: from ortools.sat.python import cp_model  # type: ignore
 20: # ---------------------------------------------------------------------------
 21: #  helper ---------------------------------------------------------------
 22: # ---------------------------------------------------------------------------
 23: def _block_sizes(blocks: Dict[int, int]) -> Dict[int, int]:
 24:     sizes = defaultdict(int)
 25:     for b in blocks.values():
 26:         sizes[b] += 1
 27:     return sizes
 28: def _boundary_vertices(block: int, members: Set[int], blocks: Dict[int, int],
 29:                        indptr: np.ndarray, indices: np.ndarray) -> List[int]:
 30:     """Return vertices in *block* that touch at least one different block."""
 31:     out = []
 32:     for v in members:
 33:         row = slice(indptr[v], indptr[v + 1])
 34:         if any(blocks[u] != block for u in indices[row]):
 35:             out.append(v)
 36:     return out
 37: def _movable_vertex(src: int, dst_set: Set[int], *, rng: np.random.Generator,
 38:                     blocks: Dict[int, int], members: Dict[int, Set[int]],
 39:                     indptr: np.ndarray, indices: np.ndarray) -> Tuple[int, int] | None:
 40:     """Pick (vertex, dst) with vertex in *src* boundary and dst in dst_set."""
 41:     boundary = _boundary_vertices(src, members[src], blocks, indptr, indices)
 42:     rng.shuffle(boundary)
 43:     for v in boundary:
 44:         row = slice(indptr[v], indptr[v + 1])
 45:         neigh_blks = {blocks[u] for u in indices[row] if blocks[u] in dst_set}
 46:         if neigh_blks:
 47:             return v, rng.choice(list(neigh_blks))
 48:     return None
 49: def _move(v: int, src: int, dst: int, *, blocks: Dict[int, int],
 50:           members: Dict[int, Set[int]], sizes: Counter
 51:     ):
 52:     """Execute the move and update bookkeeping structures."""
 53:     blocks[v] = dst
 54:     members[src].remove(v)
 55:     members[dst].add(v)
 56:     sizes[src] -= 1
 57:     sizes[dst] += 1
 58:     if sizes[src] == 0:
 59:         # remove empty block
 60:         del members[src]
 61:         del sizes[src]
 62:         del blocks[v]
 63: def move_node_to_under(
 64:         under: Set[int], # blocks of size < k
 65:         over1: Set[int], # blocks of size k+1
 66:         over2: Set[int], # blocks of size > k+1
 67:         rng: np.random.Generator,
 68:         sizes: Counter[int],
 69:         k: int,
 70:         members: Dict[int, Set[int]],
 71:         blocks: Dict[int, int],
 72:         indptr: np.ndarray,
 73:         indices: np.ndarray
 74:     ) -> None:
 75:     """ 
 76:     Move a node from an oversize block to an undersize block.
 77:     """
 78:     if len(under) == 0:
 79:         # no undersize blocks available, skip
 80:         return
 81:     donors = list(over2 | over1) or list(b for b, s in sizes.items() if s > k)
 82:     rng.shuffle(donors)
 83:     moved = False
 84:     if len(under) > 0:
 85:         for b_src in donors:
 86:             mv = _movable_vertex(b_src, under, rng=rng, blocks=blocks,
 87:                                     members=members, indptr=indptr, indices=indices)
 88:             if mv is not None:
 89:                 v, b_dst = mv
 90:                 _move(v, b_src, b_dst, blocks=blocks, members=members, sizes=sizes)
 91:                 moved = True
 92:                 return
 93:     # If we reach here no boundary move could be found. Relax: pick random.
 94:     if len(donors) == 0:
 95:         # no oversize blocks available, pick random from all
 96:         donors = list(blocks.keys())
 97:     b_src = rng.choice(donors)
 98:     if len(members[b_src]) == 0:
 99:         # no members in the source block, skip
100:         return
101:     v = rng.choice(list(members[b_src]))
102:     b_dst = rng.choice(tuple(under))
103:     _move(v, b_src, b_dst, blocks=blocks, members=members, sizes=sizes)
104:     return
105: def move_node_from_over(
106:     under: Set[int], # blocks of size < k
107:     over1: Set[int], # blocks of size k+1
108:     over2: Set[int], # blocks of size > k+1
109:     rng: np.random.Generator,
110:     sizes: Counter[int],
111:     k: int,
112:     members: Dict[int, Set[int]],
113:     blocks: Dict[int, int],
114:     indptr: np.ndarray,
115:     indices: np.ndarray,
116:     r_target: int,
117: ) -> None:
118:     """ 
119:         Nodes are moved from block with size > k to block with size either
120:         < k or <=k if there are fewer than r_target blocks with size k+1.
121:     """
122:     if len(over2) == 0:
123:         # no oversize blocks available, skip
124:         return
125:     b_src = rng.choice(tuple(over2))
126:     dests = under.copy()
127:     if len(over1) > r_target:
128:         dests |= {b for b, s in sizes.items() if s == k}
129:     if not dests:
130:         # no eligible destination respecting klowerbound  skip
131:         return
132:     mv = _movable_vertex(b_src, dests, rng=rng, blocks=blocks,
133:                             members=members, indptr=indptr, indices=indices)
134:     if mv is None:
135:         v = rng.choice(_boundary_vertices(b_src, members[b_src], blocks, indptr, indices))
136:         b_dst = rng.choice(tuple(dests))
137:     else:
138:         v, b_dst = mv
139:     _move(v, b_src, b_dst, blocks=blocks, members=members, sizes=sizes)
140:     return
141: def balance_k_plus_1_blocks(
142:     over1: Set[int], # blocks of size k+1
143:     over2: Set[int], # blocks of size >k+1
144:     rng: np.random.Generator,
145:     sizes: Counter[int],
146:     k: int,
147:     members: Dict[int, Set[int]],
148:     blocks: Dict[int, int],
149:     indptr: np.ndarray,
150:     indices: np.ndarray,
151:     r_target: int,
152: ) -> None:
153:     """ 
154:     Balance the number of blocks with size k+1.
155:     If there are too many blocks with size k+1, shrink one of them
156:     by moving a vertex to a block with size k or smaller.
157:     If there are too few blocks with size k+1, enlarge one of the blocks
158:     with size k by moving a vertex from a block with size larger than k+1
159:     or smaller than k+1
160:     """
161:     if len(over1) == r_target:
162:         # already balanced, nothing to do
163:         return
164:     elif len(over1) > r_target: # need fewer k+1 blocks
165:         # shrink a k+1 block
166:         b_src = rng.choice(tuple(over1))
167:         dests = {b for b, s in sizes.items() if s <= k}
168:     else:  # need more k+1 blocks
169:         # enlarge a k block
170:         #dests = set()
171:         b_src = rng.choice(tuple(over2))
172:         dests = {b for b, s in sizes.items() if s == k}
173:     if len(dests) == 0:
174:         # no eligible destination respecting kupperbound  skip
175:         return
176:     # shrink case
177:     mv = None
178:     for b_dst in dests:
179:         mv = _movable_vertex(b_src, {b_dst}, rng=rng, blocks=blocks,
180:                                 members=members, indptr=indptr, indices=indices)
181:         if mv is not None:
182:             v, _ = mv
183:             _move(v, b_src, b_dst, blocks=blocks, members=members, sizes=sizes)
184:             return
185:     return
186: def categorize(
187:     sizes: Dict[int, int],
188:     k: int,
189: ) -> Tuple[Set[int], Set[int], Set[int]]:
190:     """Return (oversize>k+1, oversize==k+1, undersize<k)."""
191:     over2 = {b for b, s in sizes.items() if s > k + 1}
192:     over1 = {b for b, s in sizes.items() if s == k + 1}
193:     under = {b for b, s in sizes.items() if s < k}
194:     return over2, over1, under
195: # ---------------------------------------------------------------------------
196: # Improved greedy balancer (split into helpers)
197: # ---------------------------------------------------------------------------
198: def _rebalance_to_min_size(
199:     blocks: Dict[int, int],
200:     adjacency: csr_array,
201:     k: int,
202:     rng: np.random.Generator | None = None,
203:     max_iter: int | None = None,
204: ) -> Dict[int, int]:
205:     """Greedy boundaryonly balancing.
206:     Guarantees **no block ends smaller than *k***; tries to respect the stricter
207:     goal (sizes  {k,k+1} & exactly *r* oversized) but will *sacrifice* that goal
208:     rather than leave an undersized block.
209:     """
210:     if rng is None:
211:         rng = np.random.default_rng(1)
212:     n = adjacency.shape[0]
213:     indptr, indices = adjacency.indptr, adjacency.indices
214:     sizes: Counter[int] = Counter(blocks.values())
215:     members: Dict[int, Set[int]] = defaultdict(set)
216:     for v, b in blocks.items():
217:         members[b].add(v)
218:     B = len(sizes)
219:     r_target = n - k * B  # blocks that *should* have k+1
220:     iter_limit = max_iter or 5 * n
221:     while iter_limit:
222:         iter_limit -= 1
223:         over2, over1, under = categorize(sizes=sizes, k=k)
224:         if len(under)==0 and len(over2)==0 and len(over1)==r_target:
225:             break  # fully balanced by strict rules
226:         # 1) fix undersized first ------------------------------------------------
227:         if len(under) > 0:
228:             move_node_to_under(
229:                 under=under,
230:                 over1=over1,
231:                 over2=over2,
232:                 rng=rng,
233:                 sizes=sizes,
234:                 k=k,
235:                 members=members,
236:                 blocks=blocks,
237:                 indptr=indptr,
238:                 indices=indices
239:             )
240:             continue
241:         # 2) shrink blocks > k+1 --------------------------------------------------
242:         if len(over2) > 0 :
243:             move_node_from_over(
244:                 under=under,
245:                 over1=over1,
246:                 over2=over2,
247:                 rng=rng,
248:                 sizes=sizes,
249:                 k=k,
250:                 members=members,
251:                 blocks=blocks,
252:                 indptr=indptr,
253:                 indices=indices,
254:                 r_target=r_target
255:             )
256:             continue
257:         # 3) adjust number of k+1 blocks -----------------------------------------
258:         if len(over1) != r_target:
259:             balance_k_plus_1_blocks(
260:                 over1=over1,
261:                 over2=over2,
262:                 rng=rng,
263:                 sizes=sizes,
264:                 k=k,
265:                 members=members,
266:                 blocks=blocks,
267:                 indptr=indptr,
268:                 indices=indices,
269:                 r_target=r_target
270:             )
271:             continue
272:     # ---------------- final safety pass: remove any undersized ---------------
273:     over_blocks = [b for b, s in sizes.items() if s > k]
274:     under_blocks = [b for b, s in sizes.items() if s < k]
275:     for b_dst in under_blocks:
276:         while sizes[b_dst] < k and len(over_blocks) > 0:
277:             b_src = over_blocks[-1]  # take from the end for efficiency
278:             if sizes[b_src] == k: # have we taken all we can?
279:                 over_blocks.pop() # discount this block from further consideration
280:                 continue
281:             # move arbitrary boundary or any vertex as last resort
282:             mv = _movable_vertex(b_src, {b_dst}, rng=rng, blocks=blocks,
283:                                   members=members, indptr=indptr, indices=indices)
284:             if mv is None:
285:                 v = rng.choice(tuple(members[b_src]))
286:             else:
287:                 v, _ = mv
288:             _move(v, b_src, b_dst, blocks=blocks, members=members, sizes=sizes)
289:         # if there are no over_blocks left, spread nodes from under_block randomly among other blocks
290:         if len(over_blocks) == 0:
291:             # assign all nodes in under_block to a random block
292:             for v in members[b_dst]:
293:                 new_block = rng.choice(tuple(blocks.values()))
294:                 blocks[v] = new_block
295:                 members[new_block].add(v)
296:             del sizes[b_dst]
297:     # final check
298:     _, _, under = categorize(sizes=sizes, k=k)
299:     assert len(under) == 0, \
300:         f"Rebalance failed: {len(under)} blocks are still undersized (<{k})."
301:     return blocks
302: ### Base class for BlockAssigner
303: class BlockAssigner:
304:     """
305:     Base class for assigning nodes to blocks in the Stochastic Block Model (SBM).
306:     This class is intended to be subclassed for specific block assignment strategies.
307:     """
308:     def __init__(self,
309:                  graph_data: GraphData,
310:                  rng: np.random.Generator,
311:                  num_blocks: Optional[int] = None,
312:                  min_block_size: Optional[int] = None,
313:                  max_block_size: Optional[int] = None,
314:                  ):
315:         self.graph_data = graph_data
316:         # check if there exist a valid assignment
317:         # given num_blocks, min_block_size, max_block_size
318:         if num_blocks is not None and min_block_size is not None:
319:             if num_blocks * min_block_size > graph_data.num_nodes:
320:                 raise ValueError("Invalid parameters: num_blocks * min_block_size exceeds total number of nodes.")
321:         if max_block_size is not None and min_block_size is not None:
322:             if max_block_size < min_block_size:
323:                 raise ValueError("Invalid parameters: max_block_size cannot be less than min_block_size.")
324:         self.num_blocks = num_blocks
325:         self.min_block_size = min_block_size
326:         self.max_block_size = max_block_size
327:         self.rng = rng
328:     def reindex_blocks(self, blocks: Dict[int, int]) -> Dict[int, int]:
329:         """ 
330:         Reindex block IDs to be consecutive integers starting from 0.
331:         """
332:         unique_blocks = sorted(set(blocks.values()))
333:         block_mapping = {old_id: new_id for new_id, old_id in enumerate(unique_blocks)}
334:         return {node: block_mapping[block_id] for node, block_id in blocks.items()}
335:     def _compute_assignment(self) -> Dict[int, int]:
336:         raise NotImplementedError(
337:             "compute_assignment must be implemented by subclasses of BlockAssigner."
338:         )
339:     def compute_assignment(self) -> BlockData:
340:         raise NotImplementedError(
341:             "compute_assignment must be implemented by subclasses of BlockAssigner."
342:         )
343: class UniformSmallBlockAssigner(BlockAssigner):
344:     """ 
345:     Assigns nodes to blocks of size min_block_size uniformly at random. 
346:     Ignore num_blocks and max_block_size.
347:     """
348:     def _compute_assignment(self) -> Dict[int, int]:
349:         """
350:         Assign nodes to blocks uniformly at random, ensuring each block has at least min_block_size nodes.
351:         """
352:         if self.min_block_size is None:
353:             raise ValueError("min_block_size must be specified for UniformSmallBlockAssigner.")
354:         if self.min_block_size <= 0:
355:             raise ValueError("min_block_size must be a positive integer.")
356:         if self.max_block_size is not None:
357:             Warning("max_block_size is ignored in UniformSmallBlockAssigner.")
358:         if self.num_blocks is not None:
359:             Warning("num_blocks is ignored in UniformSmallBlockAssigner.")
360:         num_nodes = self.graph_data.num_nodes
361:         # create list of nodes in random order
362:         node_list = self.rng.permutation(np.arange(num_nodes))
363:         # assign nodes to blocks
364:         block_assignments = {
365:             node: node // self.min_block_size for node in node_list
366:         }
367:         return block_assignments
368:     # -----------------------------------------------------------------
369:     def compute_assignment(self) -> BlockData:
370:         """
371:         Compute a block assignment based on the proposed assignment.
372:         Currently, this method only performs a min_size balancing step.
373:         """
374:         if self.min_block_size is None:
375:             raise ValueError("min_block_size must be specified for UniformSmallBlockAssigner.")
376:         assignment = self._compute_assignment()
377:         assignment= _rebalance_to_min_size(
378:             blocks=assignment,
379:             adjacency=self.graph_data.adjacency,
380:             k=self.min_block_size,
381:             rng=self.rng,
382:             max_iter=None,  # data-driven max_iter (10*num_nodes)
383:         )
384:         reindexed_assignment = self.reindex_blocks(assignment)
385:         return BlockData(
386:             initial_blocks=reindexed_assignment,
387:             graph_data=self.graph_data
388:         )
389: class MetisBlockAssigner(BlockAssigner):
390:     """
391:     Use Metis to obtain a *balanced* `num_blocks`-way partition of the
392:     (undirected) graph.
393:     Parameters
394:     ----------
395:     graph_data : GraphData
396:         Graph wrapper holding the (sparse) adjacency matrix.
397:     num_blocks : int
398:         Desired number of blocks ( N // k where k is target block size).
399:     seed : int, optional
400:         Random seed forwarded to METIS.  If None, METIS uses its own seed.
401:     """
402:     def __init__(
403:         self,
404:         graph_data: GraphData,
405:         rng: np.random.Generator,
406:         num_blocks: Optional[int] = None,
407:         min_block_size: Optional[int] = None,
408:         max_block_size: Optional[int] = None,
409:     ) -> None:
410:         super().__init__(
411:             graph_data=graph_data,
412:             rng=rng,
413:             num_blocks=num_blocks,
414:             min_block_size=min_block_size,
415:             max_block_size=max_block_size,
416:             )
417:         if graph_data.directed:
418:             raise NotImplementedError(
419:                 "MetisBlockAssigner currently supports undirected graphs only."
420:             )
421:         if num_blocks is None and min_block_size is None:
422:             raise ValueError("Either num_blocks or min_block_size must be specified for MetisBlockAssigner.")
423:         if num_blocks is None:
424:             num_blocks = max(
425:                 1, graph_data.num_nodes // min_block_size
426:             )
427:         self.num_blocks = int(num_blocks)
428:         self.seed = rng.integers(2**32)
429:     # -----------------------------------------------------------------
430:     # Utilities
431:     # -----------------------------------------------------------------
432:     @staticmethod
433:     def _to_adj_lists(adj: sp.csr_array) -> list[list[int]]:
434:         """
435:         Convert a CSR adjacency matrix to the adjacency-list format Metis
436:         expects (no self-loops, undirected symmetry).
437:         """
438:         n = adj.shape[0] # type: ignore
439:         rows, cols = adj.nonzero() # type: ignore
440:         neigh = [[] for _ in range(n)]
441:         for u, v in zip(rows, cols):
442:             if u == v:
443:                 continue  # ignore self-loops
444:             neigh[u].append(v)
445:         return neigh
446:     # -----------------------------------------------------------------
447:     # Public API
448:     # -----------------------------------------------------------------
449:     def _compute_metis_assignment(self) -> Dict[int, int]:
450:         """
451:         Run METIS and return a BlockData with the resulting assignment.
452:         May results in blocks of size < min_block_size or > max_block_size.
453:         """
454:         n = self.graph_data.num_nodes
455:         adj_lists = self._to_adj_lists(self.graph_data.adjacency)
456:         # PyMetis returns (edgecuts, membership-array)
457:         _, parts = metis.part_graph(
458:             graph=adj_lists,
459:             nparts = self.num_blocks,
460:             ufactor = 30, # aggresively balance block
461:             tpwgts = [1/self.num_blocks]*self.num_blocks, # equal weights for each block
462:             ubvec = [1+0.05], # 5% imbalance allowed
463:             recursive=True
464:         )
465:         # PyMetis guarantees |parts| == n
466:         blocks: Dict[int, int] = {node: part for node, part in enumerate(parts)}
467:         # Wrap in BlockData so downstream code can use it directly
468:         return blocks
469:     # -----------------------------------------------------------------
470:     def compute_assignment(self) -> BlockData:
471:         """
472:         Compute a balanced block assignment based on the proposed assignment.
473:         Currently, this method only performs a min_size balancing step.
474:         """
475:         if self.min_block_size is None:
476:             raise ValueError("min_block_size must be specified for MetisBlockAssigner.")
477:         assignment = self._compute_metis_assignment()
478:         assignment = _rebalance_to_min_size(
479:             blocks=assignment,
480:             adjacency=self.graph_data.adjacency,
481:             k=self.min_block_size,
482:             rng=self.rng,
483:             max_iter=None,  # data-driven max_iter (10*num_nodes)
484:         )
485:         assignment = self.reindex_blocks(assignment)
486:         return BlockData(
487:             initial_blocks=assignment,
488:             graph_data=self.graph_data
489:         )
490: class RefinedMetisBlockAssigner(MetisBlockAssigner):
491:     """PyMETIS seed  improved greedy rebalance  optional CPSAT polish."""
492:     def __init__(
493:         self,
494:         graph_data: GraphData,
495:         rng: np.random.Generator,
496:         num_blocks: int | None = None,
497:         min_block_size: int | None = None,
498:         max_block_size: int | None = None,
499:         cpsat_time_limit: int | None = 5,
500:     ) -> None:
501:         super().__init__(
502:             graph_data=graph_data,
503:             rng=rng,
504:             num_blocks=num_blocks,
505:             min_block_size=min_block_size,
506:             max_block_size=max_block_size,
507:         )
508:         self._rng = rng
509:         self._cpsat_limit = cpsat_time_limit
510:     # -----------------------------------------------------------------
511:     def compute_assignment(self) -> BlockData:  # noqa: D401  keep signature
512:         # unbalanced
513:         if self.min_block_size is None:
514:             raise ValueError("min_block_size must be specified for RefinedMetisBlockAssigner.")
515:         blocks = super()._compute_metis_assignment()
516:         blocks = _rebalance_to_min_size(
517:             blocks,
518:             self.graph_data.adjacency,
519:             self.min_block_size,
520:             rng=self._rng,
521:         )
522:         # polish with CPSAT
523:         blocks = self._cpsat_polish(blocks)
524:         return BlockData(initial_blocks=self.reindex_blocks(blocks),
525:                          graph_data=self.graph_data)
526:     # -----------------------------------------------------------------
527:     def _compute_metis_assignment(self) -> Dict[int, int]:  # noqa:D401   keep name
528:         return super()._compute_metis_assignment()
529:     # -----------------------------------------------------------------
530:     def _block_members(self, blk: int, blocks: Dict[int, int]) -> List[int]:
531:         return [v for v, b in blocks.items() if b == blk]
532:     # -----------------------------------------------------------------
533:     def _cpsat_polish(self, blocks: Dict[int, int]) -> Dict[int, int]:
534:         """ 
535:         Polish the block assignment to decrease the edge cut while ensuring
536:         block sizes are within min_block_size and min_block_size + 1.
537:         """
538:         if self.min_block_size is None:
539:             return blocks
540:         k = self.min_block_size
541:         sizes = _block_sizes(blocks)
542:         wrong = {b for b, s in sizes.items() if not (k <= s <= k + 1)}
543:         if not wrong:
544:             return blocks  # already good
545:         # collect *boundary* nodes of wrong blocks + their neighbours
546:         boundary: Set[int] = set()
547:         adj = self.graph_data.adjacency
548:         indptr, indices = adj.indptr, adj.indices
549:         for b in wrong:
550:             for v in self._block_members(b, blocks):
551:                 row = slice(indptr[v], indptr[v + 1])
552:                 if any(blocks[u] != b for u in indices[row]):
553:                     boundary.add(v)
554:                     boundary.update(indices[row])
555:         sub_nodes = sorted(boundary)
556:         idx_of: Dict[int, int] = {v: i for i, v in enumerate(sub_nodes)}
557:         sub_adj = adj[sub_nodes][:, sub_nodes]  # type: ignore[index]
558:         # blocks involved
559:         blks_sub = {blocks[v] for v in sub_nodes}
560:         # ------- build CPSAT model ----------------------------------
561:         model = cp_model.CpModel()
562:         x = {}
563:         for v in sub_nodes:
564:             for b in blks_sub:
565:                 x[v, b] = model.NewBoolVar(f"x_{v}_{b}")
566:             # each vertex exactly one block (in subproblem)
567:             model.Add(sum(x[v, b] for b in blks_sub) == 1)
568:         # blocksize constraints & t_b variables
569:         t = {}
570:         r_target = (len(sub_nodes) + sum(sizes[b] for b in blks_sub) - k * len(blks_sub))  # local oversize quota
571:         for b in blks_sub:
572:             t[b] = model.NewBoolVar(f"t_{b}")
573:             size_expr = sum(x[v, b] for v in sub_nodes) + (sizes[b] - sum(blocks[v] == b for v in sub_nodes))
574:             model.Add(size_expr == k + t[b])
575:         model.Add(sum(t[b] for b in blks_sub) == r_target)
576:         # edgecut objective (linearised y/z eliminated  constant perimeter suffices in subgraph)
577:         rows, cols = sub_adj.nonzero()
578:         z = {}
579:         for v, u in zip(rows, cols):
580:             if v >= u:
581:                 continue  # undirected upper triangle
582:             i, j = sub_nodes[v], sub_nodes[u]
583:             z[(i, j)] = model.NewBoolVar(f"z_{i}_{j}")
584:             # z = 1 if endpoints differ
585:             for b in blks_sub:
586:                 model.AddBoolAnd([x[i, b], x[j, b]]).OnlyEnforceIf(z[(i, j)].Not())
587:             # if all sameblock conjunctions false  z=1
588:         model.Minimize(sum(z.values()))
589:         # solve
590:         solver = cp_model.CpSolver()
591:         if self._cpsat_limit:
592:             solver.parameters.max_time_in_seconds = float(self._cpsat_limit)
593:         status = solver.Solve(model)
594:         if status in (cp_model.OPTIMAL, cp_model.FEASIBLE):
595:             for v in sub_nodes:
596:                 for b in blks_sub:
597:                     if solver.BooleanValue(x[v, b]):
598:                         blocks[v] = b
599:                         break
600:         return blocks
601: class EmbedAndConstrKMeansAssigner(BlockAssigner):
602:     """
603:     Assign nodes to blocks using a two-step process:
604:     1. use embed nodes into a low-dimensional space,
605:     2. use constrained KMeans to assign nodes to blocks of prespecified sizes.
606:     """ 
607:     def __init__(
608:         self,
609:         graph_data: GraphData,
610:         rng: np.random.Generator,
611:         num_blocks: Optional[int] = None,
612:         min_block_size: Optional[int] = None,
613:         max_block_size: Optional[int] = None,
614:     ) -> None:
615:         super().__init__(
616:             graph_data=graph_data,
617:             rng=rng,
618:             num_blocks=num_blocks,
619:             min_block_size=min_block_size,
620:             max_block_size=max_block_size,
621:         )
622:         if min_block_size is None:
623:             raise ValueError("num_blocks and min_block_size must be specified for ProneAndConstrKMeansAssigner.")
624:         if num_blocks is not None:
625:             Warning("num_blocks is ignored in ProneAndConstrKMeansAssigner. Only min_block_size is used.")
626:         if max_block_size is not None:
627:             Warning("max_block_size is ignored in ProneAndConstrKMeansAssigner. Only min_block_size is used.")
628:     def embed_nodes(self, adjacency:sp.csr_array, n_dimensions:int=128)->np.ndarray:
629:         """ 
630:         Method to perform node embedding. Subclasses should implement this method
631:         """
632:         raise NotImplementedError("This method should be overwritten by subclasses to provide specific embedding logic.")
633:     def _compute_assignment(self) -> Dict[int, int]:
634:         """
635:         Compute block assignments using constrained KMeans after embedding with Prone.
636:         """
637:         if self.graph_data.num_nodes < self.min_block_size:
638:             raise ValueError("Number of nodes in the graph is less than min_block_size.")
639:         if self.min_block_size is None:
640:             raise ValueError("min_block_size must be specified for ProneAndConstrKMeansAssigner.")
641:         # Step 1: Embed nodes using Prone
642:         embeddings = self.embed_nodes(
643:             adjacency=self.graph_data.adjacency,
644:             n_dimensions=128  # default embedding dimension
645:         )
646:         # compute how many blocks we need to only have blocks of
647:         #   size min_block_size and min_block_size+1
648:         number_of_clusters = self.graph_data.num_nodes // self.min_block_size
649:         # Step 2: Use constrained KMeans to assign nodes to blocks
650:         kmeans = KMeansConstrained(
651:                     n_clusters=number_of_clusters,
652:                     size_min=self.min_block_size,
653:                     size_max=self.min_block_size+1, # 
654:                     init='k-means++',
655:                     n_init=1,
656:                     max_iter=10,
657:                     tol=1e-3,
658:                     verbose=False,
659:                     random_state=self.rng.choice(2**32), 
660:                     copy_x=False, # perform centering
661:                     # use all available CPU cores
662:                     n_jobs=-1
663:                 )
664:         tic = time()
665:         labels = kmeans.fit_predict(embeddings)
666:         toc = time()
667:         print(f"KMeans with constraints took {toc - tic:.2f} seconds for {self.graph_data.num_nodes} nodes.")
668:         # Create a mapping from node index to block ID
669:         blocks = {node: label for node, label in enumerate(labels)} # type: ignore
670:         return blocks
671:     def compute_assignment(self) -> BlockData:
672:         """
673:         Compute a block assignment based on the proposed assignment.
674:         Currently, this method only performs a min_size balancing step.
675:         """
676:         balanced_assignment = self._compute_assignment() # balanced from k-means w. size constraints
677:         reindexed_assignment = self.reindex_blocks(balanced_assignment)
678:         return BlockData(
679:             initial_blocks=reindexed_assignment,
680:             graph_data=self.graph_data
681:         )
682: class ProNEAndConstrKMeansAssigner(EmbedAndConstrKMeansAssigner):
683:     """
684:     Assign nodes to blocks using ProNE embedding followed by constrained KMeans.
685:     """
686:     def embed_nodes(self, adjacency: sp.csr_array, n_dimensions: int = 128) -> np.ndarray:
687:         """
688:         Embed nodes using ProNE.
689:         """
690:         if n_dimensions <= 0:
691:             raise ValueError("n_dimensions must be a positive integer.")
692:         # Create a ProNE instance and fit it to the adjacency matrix
693:         model = ProNE(
694:                     n_components=n_dimensions,
695:                     step=10,
696:                     mu=0.2,
697:                     theta=0.5, 
698:                     exponent=0.75,
699:                     verbose=False
700:                 )
701:         tic = time()
702:         embeddings = model.fit_transform(
703:             sp.csr_matrix(adjacency) # nodevectors expect a CSR matrix, and not array
704:             )
705:         toc = time()
706:         print(f"ProNE embedding took {toc - tic:.2f} seconds for {adjacency.shape[0]} nodes.") # type: ignore
707:         return embeddings
708: class AssignerConstructor:
709:     """ 
710:     Factory class to construct block assigners based on configuration parameters. 
711:     """
712:     def __init__(self, rng: np.random.Generator):
713:         self.rng = rng
714:     def create_assigner(self,
715:                         graph_data: GraphData,
716:                         init_method: InitMethodName = "metis", 
717:                         min_block_size: Optional[int] = None,
718:                         max_block_size: Optional[int] = None,
719:                         num_blocks: Optional[int] = None,
720:                     ) -> BlockAssigner:
721:         if init_method == "uniform":
722:             return UniformSmallBlockAssigner(
723:                 graph_data=graph_data,
724:                 rng=self.rng,
725:                 min_block_size=min_block_size,
726:                 max_block_size=max_block_size,
727:                 num_blocks=num_blocks,
728:             )
729:         elif init_method == "prone_and_kmeans":
730:             return ProNEAndConstrKMeansAssigner(
731:                 graph_data=graph_data,
732:                 rng=self.rng,
733:                 min_block_size=min_block_size,
734:                 max_block_size=max_block_size,
735:                 num_blocks=num_blocks,
736:             )
737:         elif init_method == "metis":
738:             return MetisBlockAssigner(
739:                 graph_data=graph_data,
740:                 rng=self.rng,
741:                 num_blocks=num_blocks,
742:                 min_block_size=min_block_size,
743:                 max_block_size=max_block_size,
744:             )
745:         elif init_method == "metis_refine":
746:             return RefinedMetisBlockAssigner(
747:                 graph_data=graph_data,
748:                 rng=self.rng,
749:                 min_block_size=min_block_size,
750:                 max_block_size=max_block_size,
751:                 num_blocks=num_blocks,
752:                 cpsat_time_limit=10
753:             )
754:         else:
755:             raise ValueError(f"Unknown initialization method: {init_method}. "
756:                 "Available methods: 'metis', 'uniform', 'prone_and_kmeans', 'metis_refine'."
757:                 )

================
File: src/sbm/graph_data.py
================
 1: from scipy.sparse import csr_array
 2: import networkx as nx
 3: class GraphData:
 4:     def __init__(self, adjacency_matrix: csr_array, directed=False):
 5:         if not isinstance(adjacency_matrix, csr_array):
 6:             raise ValueError("Adjacency matrix must be a scipy.sparse.csr_array")
 7:         self.adjacency = adjacency_matrix.astype(int)
 8:         self.directed: bool= directed
 9:         self.num_nodes = self.adjacency.shape[0] # type: ignore
10:         if directed:
11:             self.total_edges = int(self.adjacency.sum())
12:         else:
13:             self.total_edges = int(self.adjacency.sum() / 2)  # For undirected graphs
14:         def __len__(self):
15:             return self.num_nodes
16: def gd_from_networkx(G: nx.Graph) -> GraphData:
17:     """
18:     Create a GraphData instance from a NetworkX graph.
19:     """
20:     if not hasattr(G, 'adjacency'):
21:         raise ValueError("The provided graph must have an adjacency matrix.")
22:     # for new version of networkx
23:     #adj = nx.to_scipy_sparse_matrix(G)
24:     # for old version of networkx
25:     adj = nx.to_scipy_sparse_matrix(G)
26:     adj = csr_array(adj)
27:     return GraphData(adj, directed=G.is_directed())

================
File: src/sbm/io.py
================
  1: from typing import Dict, Callable, Iterable, Tuple, Optional
  2: from pathlib import Path
  3: from dataclasses import dataclass
  4: import json
  5: import gzip
  6: import numpy as np
  7: from scipy.sparse import csr_array, csr_array, load_npz, coo_matrix
  8: from scipy.io import mmread
  9: import networkx as nx                                # light dep
 10: import numpy as np
 11: from scipy.sparse import load_npz, save_npz
 12: from scipy.sparse import csr_array
 13: from sbm.graph_data import GraphData
 14: # src/sbm/io.py
 15: @dataclass
 16: class SBMFit:
 17:     block_sizes: list[int]
 18:     block_conn: csr_array
 19:     directed_graph: bool # if undirected, only upper triangle is stored
 20:     neg_loglike: float
 21:     metadata: dict
 22: class SBMWriter:
 23:     @staticmethod
 24:     def save(path: Path, fit: SBMFit) -> None:
 25:         """ save SBM fit to file """
 26:         path.mkdir(parents=True, exist_ok=True)
 27:         clean_sizes  = [int(s) for s in fit.block_sizes]
 28:         (path / "block_sizes.json").write_text(json.dumps(clean_sizes))
 29:         # save sparce block connectivity matrix using scipy
 30:         with open(path / "block_connectivity.npz", 'wb') as file:
 31:             save_npz(file, fit.block_conn, compressed=True)
 32:         (path / "directed_graph.txt").write_text(str(fit.directed_graph))
 33:         (path / "neg_loglike.txt").write_text(str(fit.neg_loglike))
 34:         with open(path / "metadata.json", 'w') as f:
 35:             json.dump(fit.metadata, f)
 36:     @staticmethod
 37:     def load(path: Path, silence:bool=False) -> SBMFit:
 38:         if not silence:
 39:             print(f"Loading SBM fit from {path}")
 40:         with open(path / "block_sizes.json", 'r') as sizes_file:
 41:             block_sizes = json.load(sizes_file)
 42:         block_sizes = [int(size) for size in block_sizes]
 43:         with open(path / "block_connectivity.npz", 'rb') as conn_file:
 44:             block_conn = load_npz(conn_file)
 45:         directed_graph = path / "directed_graph.txt"
 46:         directed_graph = (path / "directed_graph.txt").read_text().strip().lower() == 'true'
 47:         neg_loglike = float((path / "neg_loglike.txt").read_text().strip())
 48:         with open(path / "metadata.json", 'r') as f:
 49:             metadata = json.load(f)
 50:         return SBMFit(
 51:             #blocks=blocks,
 52:             block_sizes=block_sizes,
 53:             block_conn=csr_array(block_conn),
 54:             directed_graph=directed_graph,
 55:             neg_loglike=neg_loglike,
 56:             metadata=metadata
 57:         )
 58: # ---------------------------------------------------------------------
 59: #  GraphLoader
 60: # ---------------------------------------------------------------------
 61: class GraphLoader:
 62:     """
 63:     Factory that maps a file *extension* to a loader function and returns
 64:     a `GraphData` object (CSR adjacency + directed flag).
 65:     Register new loaders with the `@GraphLoader.register('.ext')`
 66:     decorator.
 67:     """
 68:     # maps extension (lower-case, incl. leading dot) -> callable
 69:     registry: Dict[str, Callable[[Path], Tuple[csr_array, bool]]] = {}
 70:     # ----------------------- decorator -------------------------------
 71:     @classmethod
 72:     def register(cls, *exts: str):
 73:         """
 74:         Use as::
 75:             @GraphLoader.register('.gml', '.graphml')
 76:             def _load_graphml(path): ...
 77:         """
 78:         def decorator(fn: Callable[[Path], Tuple[csr_array, bool]]):
 79:             for ext in exts:
 80:                 cls.registry[ext.lower()] = fn
 81:             return fn
 82:         return decorator
 83:     # ----------------------- public API ------------------------------
 84:     @staticmethod
 85:     def load(
 86:         path: Path,
 87:         *,
 88:         directed: Optional[bool] = None,
 89:         force_undirected: Optional[bool] = None
 90:     ) -> GraphData:
 91:         """Load graph at *path* and return GraphData."""
 92:         ext = path.suffix.lower()
 93:         if ext not in GraphLoader.registry:
 94:             raise ValueError(
 95:                 f"GraphLoader: no loader registered for extension '{ext}'."
 96:             )
 97:         adj, is_directed = GraphLoader.registry[ext](path)
 98:         # allow caller to override detection
 99:         if directed is not None:
100:             is_directed = bool(directed)
101:         # if caller wants undirected, symmetrise the adjacency matrix
102:         if force_undirected:
103:             if is_directed:
104:                 adj = adj.maximum(adj.T)
105:             is_directed = False
106:         adj = csr_array(adj, dtype=np.int8)  # ensure type is int8
107:         return GraphData(adjacency_matrix=adj, directed=is_directed)
108:     # ---------------- default loaders -------------------------------
109: # 1. compressed / plain .npz containing a CSR adjacency ----------------
110: @GraphLoader.register(".npz")
111: def _load_npz(path: Path) -> Tuple[csr_array, bool]:
112:     adj = load_npz(path)
113:     directed = _is_directed(adj)
114:     return adj.tocsr(), directed
115: # 2. Matrix Market -----------------------------------------------------
116: @GraphLoader.register(".mtx")
117: def _load_mtx(path: Path) -> Tuple[csr_array, bool]:
118:     adj = mmread(str(path))
119:     adj = csr_array(adj, dtype=np.int8)
120:     directed = _is_directed(adj)
121:     return adj, directed
122: # 3. Plain edge list (.edges, .edgelist, .txt, optional .gz) -----------
123: @GraphLoader.register(".edges", ".edgelist", ".txt", ".gz")
124: def _load_edgelist(path: Path) -> Tuple[csr_array, bool]:
125:     opener = gzip.open if path.suffix == ".gz" else open
126:     rows, cols = [], []
127:     if not path.exists():
128:         raise FileNotFoundError(f"GraphLoader: file {path} does not exist.")
129:     with opener(path, "rt") as f:
130:         for line in f:
131:             if not line.strip() or line.startswith("#"):
132:                 continue
133:             u, v = map(int, line.split()[:2])
134:             rows.append(u)
135:             cols.append(v)
136:     n = max(rows + cols) + 1
137:     data = np.ones(len(rows), dtype=np.int8)
138:     adj = coo_matrix((data, (rows, cols)), shape=(n, n)).tocsr()
139:     directed = _is_directed(adj)
140:     if not directed:            # symmetrise if undirected
141:         adj = adj.maximum(adj.T)
142:     adj = csr_array(adj, dtype=np.int8)  # ensure type is int8
143:     return adj, directed
144: # 4. GML / GraphML via NetworkX ---------------------------------------
145: @GraphLoader.register(".gml", ".graphml")
146: def _load_graphml(path: Path) -> Tuple[csr_array, bool]:
147:     G = nx.read_gml(path) if path.suffix == ".gml" else nx.read_graphml(path)
148:     directed = G.is_directed()
149:     # new version of networkx
150:     #adj = nx.to_scipy_sparse_array(G, format="csr", dtype=np.int8)
151:     # old version of networkx
152:     adj = nx.to_scipy_sparse_matrix(G, format="csr", dtype=np.int8)
153:     if not directed:
154:         adj = adj.maximum(adj.T)
155:     return adj, directed
156: # ---------------- helper ----------------------------------------------
157: def _is_directed(adj:  csr_array, tol: int = 0) -> bool:
158:     """
159:     Quick symmetric test for an unweighted adjacency.
160:     `tol` is an integer threshold: if more than `tol` entries differ,
161:     we declare the graph directed.
162:     """
163:     diff = adj - adj.T
164:     return diff.count_nonzero() > tol

================
File: src/sbm/mcmc.py
================
  1: from typing import Optional, Tuple, Dict, Optional, List
  2: import numpy as np
  3: #from line_profiler import profile
  4: from numba import jit
  5: #from src.sbm.graph_data import GraphData
  6: from sbm.block_data import BlockData
  7: from sbm.likelihood import LikelihoodCalculator
  8: from sbm.block_change_proposers import ChangeProposer
  9: from sbm.node_mover import NodeMover
 10: from sbm.utils.logger import CSVLogger
 11: from sbm.block_change_proposers import ChangeProposer, ChangeProposerName
 12: #### Aliases
 13: ChangeProposerDict = Dict[ChangeProposerName, ChangeProposer] 
 14: ChangeFreqDict = Dict[ChangeProposerName, float]
 15: class MCMCAlgorithm:
 16:     def __init__(self,
 17:                  block_data: BlockData,
 18:                  likelihood_calculator: LikelihoodCalculator,
 19:                  change_proposer: ChangeProposerDict,
 20:                  rng: np.random.Generator,
 21:                  log: bool = True,
 22:                  change_freq: Optional[ChangeFreqDict] = None,
 23:                  ):
 24:         self.block_data = block_data
 25:         self.likelihood_calculator = likelihood_calculator
 26:         self.change_proposers = change_proposer
 27:         self.change_freq = change_freq if change_freq is not None else { "uniform_swap": 1.0 }
 28:         self.node_mover = NodeMover(block_data=block_data)
 29:         self.rng = rng
 30:         self.current_ll = self.likelihood_calculator.ll
 31:         self.log = log # True if logging is enabled, False otherwise.
 32:         # store the best block assignment and likelihood
 33:         self._best_block_assignment = block_data.blocks.copy()
 34:         self._best_block_conn = block_data.block_connectivity.copy()
 35:         self.best_ll = self.likelihood_calculator.ll
 36:     def fit(self,
 37:             max_num_iterations: int,
 38:             initial_temperature: float = 1,
 39:             cooling_rate: float = 0.99,
 40:             min_block_size: Optional[int] = None,
 41:             max_blocks: Optional[int] = None,
 42:             logger: Optional[CSVLogger] = None,
 43:             patience: Optional[int] = 10_000
 44:         ) -> List[float]:
 45:         """
 46:         Run the adaptive MCMC algorithm to fit the SBM to the network data.
 47:         :param max_num_iterations: max number of MCMC iterations to run.
 48:         :param min_block_size: Minimum allowed size for any block.
 49:         :param initial_temperature: Starting temperature for simulated annealing.
 50:         :param cooling_rate: Rate at which temperature decreases.
 51:         :param target_acceptance_rate: Desired acceptance rate for adaptive adjustments (default 25%).
 52:         :param max_blocks: Optional maximum number of blocks allowed.
 53:         """
 54:         temperature = initial_temperature
 55:         current_ll = self.likelihood_calculator.ll
 56:         acceptance_rate = 0 # acceptance rate of moves between logging
 57:         ll_list = [current_ll]
 58:         if logger:
 59:             logger.log(0, current_ll, acceptance_rate, temperature)
 60:         n_steps_declined = 0
 61:         for iteration in range(1, max_num_iterations + 1):
 62:             move_type = self._select_move_type()
 63:             delta_ll, move_accepted = self._attempt_move(
 64:                 move_type=move_type,
 65:                 min_block_size=min_block_size,
 66:                 temperature=temperature,
 67:                 max_blocks=max_blocks
 68:                 )
 69:             # update likelihood and best assignment so far
 70:             if move_accepted :
 71:                 self.current_ll += delta_ll
 72:                 n_steps_declined = 0
 73:                 if logger:
 74:                     acceptance_rate += 1
 75:                 if self.current_ll < self.best_ll:
 76:                     self.best_ll = current_ll
 77:                     self._best_block_assignment = self.block_data.blocks.copy()
 78:                     self._best_block_conn = self.block_data.block_connectivity.copy()
 79:             else:
 80:                 n_steps_declined += 1
 81:             ll_list.append(self.current_ll)
 82:             temperature = self._update_temperature(temperature, cooling_rate)
 83:             if logger and iteration % logger.log_every == 0:
 84:                 acceptance_rate = acceptance_rate / logger.log_every
 85:                 logger.log(iteration, self.current_ll, acceptance_rate, temperature)
 86:                 acceptance_rate = 0
 87:             if patience is not None and n_steps_declined >= patience:
 88:                 print(f"Stopping early after {iteration} iterations due to patience limit.")
 89:                 break
 90:         return ll_list 
 91:     def _select_move_type(self) -> ChangeProposerName:
 92:         """
 93:         Select a move type based on the current proposal probabilities.
 94:         :return: The selected move type.
 95:         """
 96:         if len(self.change_freq) == 1:
 97:             # Only one move type available, return it directly
 98:             move_type = self.change_freq.popitem()[0]  # type: ignore
 99:         else:
100:             # Select a move type based on the defined probabilities
101:             move_type = self.rng.choice(
102:                 tuple(self.change_freq.keys()),
103:                 p=tuple(self.change_freq.values())
104:             )
105:         return move_type # type: ignore
106:     def _attempt_move(self,
107:                       move_type: ChangeProposerName,
108:                       temperature: float,
109:                       max_blocks: Optional[int] = None,
110:                       min_block_size: Optional[int] = None,
111:         ) -> Tuple[float, bool]:
112:         """
113:         Attempt a move of the specified type.
114:         :param move_type: The type of move to attempt ('swap').
115:         :param min_block_size: Minimum allowed size for any block.
116:         :param temperature: Current temperature for simulated annealing.
117:         :param max_blocks: Optional maximum number of blocks allowed.
118:         :return: Tuple of (delta_ll, move_accepted)
119:         """
120:         delta_ll, move_accepted = 0.0, False
121:         proposed_change, proposed_delta_e, proposed_delta_n = \
122:             self.change_proposers[move_type].propose_change()
123:         # Compute change in log-likelihood and accept/reject move
124:         delta_ll = self.likelihood_calculator.compute_delta_ll(
125:             delta_e=proposed_delta_e,
126:             delta_n=proposed_delta_n
127:             )
128:         move_accepted = self._accept_move(delta_ll, temperature)
129:         if move_accepted:
130:             self.node_mover.perform_change(proposed_change, proposed_delta_e)
131:         return delta_ll, move_accepted
132:     def _accept_move(self, delta_ll: float, temperature: float, eps:float=1e-6) -> bool:
133:         """
134:         Determine whether to accept a proposed move based on likelihood change and temperature.
135:         :param delta_ll: Change in log-likelihood resulting from the proposed move.
136:         :param temperature: Current temperature for simulated annealing.
137:         :return: True if move is accepted, False otherwise.
138:         """
139:         if delta_ll < 0:
140:             return True
141:         temperature = max(temperature, eps)  # Avoid division by zero
142:         z = min(delta_ll / temperature, 700) # clip to avoid overflow in exp
143:         return self.rng.uniform() > np.exp(z)
144:     def _update_temperature(self, current_temperature: float, cooling_rate: float) -> float:
145:         """
146:         Update the temperature according to the cooling schedule.
147:         :param current_temperature: The current temperature.
148:         :param cooling_rate: The cooling rate.
149:         :return: The updated temperature.
150:         """
151:         return current_temperature * cooling_rate

================
File: setup.cfg
================
 1: [metadata]
 2: name = anon-sbm
 3: version = 0.1.0
 4: author = Lasse Mohr
 5: author_email = lmmi@dtu.dk
 6: description = Package for SBM with minimum group-size constraints
 7: long_description = file: README.md
 8: long_description_content_type = text/markdown
 9: classifiers =
10:     Programming Language :: Python :: 3
11:     License :: OSI Approved :: MIT License
12:     Operating System :: OS Independent
13: 
14: [options]
15: package_dir =
16:     =src
17: packages = find:
18: python_requires = >=3.12.0
19: install_requires =
20:     numpy
21:     scipy
22:     networkx
23:     metis
24:     k-means-constrained
25:     nodevectors
26:     tqdm
27:     scikit-learn
28:     pytest
29:     line_profiler
30: 
31: [options.packages.find]
32: where = src

================
File: src/sbm/block_data.py
================
  1: from typing import Dict, Set, Optional
  2: from dataclasses import dataclass
  3: import numpy as np
  4: import scipy.sparse as sp
  5: from sbm.graph_data import GraphData
  6: from sbm.sampling import sample_sbm_graph
  7: BlockConn = sp.dok_array
  8: BlockMembership = Dict[int, Set[int]]  # Block ID to set of node indices
  9: class _BlockDataUpdater:
 10:     """
 11:     Helper class to update edge counts and possible pairs in the block data.
 12:     This class is used to hide bookkeeping of handling directed vs undirected graphs.
 13:     Parameters
 14:     ----------
 15:     bd : BlockData
 16:     """
 17:     def __init__(self, block_data: "BlockData"):
 18:         self.block_data = block_data # B  B integer matrix
 19:     # block memberships
 20:     def _move_node_to_block(self, node: int, block_id: int, update_sizes=True) -> None:
 21:         # update block assignment
 22:         old_block = self.block_data.blocks[node] # type: ignore
 23:         if update_sizes: 
 24:             # update block sizes
 25:             self.block_data.block_sizes[block_id] += 1
 26:             self.block_data.block_sizes[old_block] -= 1
 27:         self.block_data.blocks[node] = block_id # type: ignore
 28:         # update block membersets
 29:         if block_id not in self.block_data.block_members:
 30:             self.block_data.block_members[block_id] = set()
 31:         self.block_data.block_members[block_id].add(node)
 32:         self.block_data.block_members[old_block].remove(node)
 33:     # ----- edge counts --------------------------------------------------
 34:     def _increment_edge_count(self, idx_a: int, idx_b: int, e_delta: int) -> None:
 35:         """ 
 36:         Increment the edge count between two blocks.
 37:         If the graph is undirected, increment both directions.
 38:         e_delta can be negative to decrement the edge count.
 39:         idx_a and idx_b are indices in the block_connectivity matrix.
 40:         """
 41:         self.block_data.block_connectivity[idx_a, idx_b] += e_delta
 42:         if not self.block_data.directed and idx_a != idx_b:
 43:             self.block_data.block_connectivity[idx_b, idx_a] += e_delta
 44: class BlockData:
 45:     """ 
 46:     Class to store block data for the SBM.
 47:     There are two ways to initialize this class:
 48:     Attributes:
 49:         graph_data: The graph data object.
 50:         blocks: A dictionary mapping node indices to block indices.
 51:         block_members: A dictionary mapping block indices to lists of node indices.
 52:         block_sizes: A dictionary mapping block indices to the number of nodes in each block.
 53:         directed: A boolean indicating whether the graph is directed or not.
 54:         block_indices: A dictionary mapping block IDs to indices used in matrices.
 55:         inverse_block_indices: A dictionary mapping indices used in matrices to block IDs.
 56:         block_connectivity: A sparse matrix representing the block connectivity matrix.
 57:     """
 58:     def __init__(self,
 59:                  initial_blocks: Dict[int, int],
 60:                  graph_data: GraphData,
 61:         ):
 62:         self.blocks: Dict[int, int] = initial_blocks # Node to block mapping
 63:         self.block_updater = _BlockDataUpdater(self)
 64:         self.graph_data = graph_data
 65:         self.directed = graph_data.directed
 66:         self.block_members = self._initialize_block_members()
 67:         self.block_sizes = {block: len(nodes) for block, nodes in self.block_members.items()}
 68:         self._update_block_indices()
 69:         self.block_connectivity: BlockConn = self._compute_block_connectivity()
 70:         # Recompute block connectivity based on the new graph data
 71:         self.block_connectivity = self._compute_block_connectivity()
 72:     def increment_edge_count(self, block_a: int, block_b: int, e_delta: int) -> None:
 73:         """ 
 74:         Increment the edge count between two blocks.
 75:         If the graph is undirected, increment both directions.
 76:         e_delta can be negative to decrement the edge count.
 77:         """
 78:         idx_a = self.block_indices[block_a]
 79:         idx_b = self.block_indices[block_b]
 80:         self.block_updater._increment_edge_count(idx_a, idx_b, e_delta)
 81:     def get_possible_pairs(self, block_a: int, block_b:int ) -> int:
 82:         """ 
 83:         Compute the possible number of edges between two blocks.
 84:         """
 85:         if block_a == block_b:
 86:             # If the same block, return the number of pairs within the block
 87:             return self.block_sizes[block_a] * (self.block_sizes[block_a] - 1) // 2
 88:         # If different blocks, return the product of their sizes
 89:         return self.block_sizes[block_a] * self.block_sizes[block_b]
 90:     def _initialize_block_members(self) -> BlockMembership:
 91:         """
 92:         Initialize block members from the blocks mapping.
 93:         :return: A dictionary mapping block indices to lists of node indices.
 94:         """
 95:         if self.blocks is None:
 96:             raise ValueError("Blocks mapping is not provided to initialize block members.")
 97:         block_members: BlockMembership = {}
 98:         for node, block in self.blocks.items():
 99:             if block not in block_members:
100:                 block_members[block] = set()
101:             # Add node to the corresponding block
102:             block_members[block].add(node)
103:         return block_members
104:     def _update_block_indices(self):
105:         """
106:         Update mappings between block IDs and indices used in matrices.
107:         """
108:         # Sort block IDs to ensure consistent ordering
109:         sorted_block_ids = sorted(self.block_members.keys())
110:         self.block_indices = {
111:             block_id: idx for idx, block_id in enumerate(sorted_block_ids)
112:             }
113:         self.inverse_block_indices = {
114:             idx: block_id for block_id, idx in self.block_indices.items()
115:             }
116:     def _compute_block_connectivity(self) -> BlockConn:
117:         """
118:         Compute the block connectivity matrix.
119:         This matrix is a sparse matrix where the entry at (i, j) is number of edges 
120:         between block i and block j. If the graph is undirected, the matrix is symmetric.
121:         """
122:         if self.graph_data is None:
123:             raise ValueError("Graph data is not set. Cannot compute block connectivity.")
124:         if self.block_members is None:
125:             raise ValueError("Block members are not initialized. Cannot compute block connectivity.")
126:         num_blocks = len(self.block_members)
127:         self._update_block_indices()
128:         block_connectivity_dok = sp.dok_array((num_blocks, num_blocks), dtype=np.int64)
129:         if self.directed:
130:             raise ValueError("Block connectivity computation is not implemented for directed graphs.")
131:         else:
132:             for i_block_id, nodes_i in self.block_members.items():
133:                 idx_i = self.block_indices[i_block_id]
134:                 nodes_i = list(nodes_i)
135:                 sub_adj_i = self.graph_data.adjacency[nodes_i]  # type: ignore
136:                 for j_block_id, nodes_j in self.block_members.items():
137:                     idx_j = self.block_indices[j_block_id]
138:                     nodes_j = list(nodes_j)
139:                     # Sum of weights between block i and block j
140:                     weight = sub_adj_i[:, nodes_j].sum() # type: ignore
141:                     # If the blocks are the same, we only count pairs
142:                     if i_block_id == j_block_id:
143:                         weight = weight // 2
144:                     block_connectivity_dok[idx_i, idx_j] = weight
145:             return block_connectivity_dok
146:     def _remove_block_index(self, block_id: int):
147:         """
148:         Remove a block from block_indices and inverse_block_indices.
149:         Do not use directly, call remove_block instead.
150:         :param block_id: The block ID to remove.
151:         """
152:         idx = self.block_indices.pop(block_id)
153:         self.inverse_block_indices.pop(idx)
154:         # Adjust indices of remaining blocks
155:         for b_id, index in self.block_indices.items():
156:             if index > idx:
157:                 self.block_indices[b_id] -= 1
158:                 self.inverse_block_indices[self.block_indices[b_id]] = b_id
159:     def _remove_block_from_connectivity(self, block_id: int):
160:         """
161:         Remove the block's row and column from the block connectivity matrix.
162:         Do not use directly, call remove_block instead.
163:         :param block_id: The block ID to remove.
164:         """
165:         idx = self.block_indices[block_id]
166:         # Remove the row and column corresponding to idx
167:         slicable_array = self.block_connectivity.tocsr()
168:         non_slice_idx = np.arange(self.block_connectivity.shape[1]) != idx # type: ignore
169:         self.block_connectivity = slicable_array[:, non_slice_idx][non_slice_idx, :].todok()
170:     def remove_block(self, block_id: int):
171:         """
172:         Remove a block from the block data.
173:         Do not use directly, call remove_block instead.
174:         :param block_id: The block ID to remove.
175:         """
176:         del self.block_sizes[block_id]
177:         del self.block_members[block_id]
178:         self._remove_block_from_connectivity(block_id)
179:         self._remove_block_index(block_id)
180:     def _add_block_index(self, block_id: int):
181:         """
182:         Add a new block index for a new block.
183:         Do not use directly, call add_block instead.
184:         :param block_id: The block ID to add.
185:         """
186:         new_idx = len(self.block_indices)
187:         self.block_indices[block_id] = new_idx
188:         self.inverse_block_indices[new_idx] = block_id
189:     def _add_block_to_connectivity(self):
190:         """
191:         Add a new block to the block connectivity matrix.
192:         Do not use directly, call add_block instead.
193:         :param block_id: The block ID to add.
194:         """
195:         num_blocks = len(self.block_indices)
196:         connectivity_lil = sp.lil_matrix(self.block_connectivity)
197:         connectivity_lil.resize((num_blocks, num_blocks))
198:         self.block_connectivity = connectivity_lil.todok()
199:     def add_block(self, block_id: int, nodes=[]):
200:         """
201:         Add a new block to the block data.
202:         :param block_id: The block ID to add.
203:         """
204:         if self.blocks is None:
205:             raise ValueError("Blocks mapping is not initialized. Cannot add a block.")
206:         self.block_sizes[block_id] = len(nodes)
207:         self.block_members[block_id] = nodes
208:         for node in nodes:
209:             self.blocks[node] = block_id
210:         self._add_block_index(block_id)
211:         self._add_block_to_connectivity()

================
File: src/sbm/likelihood.py
================
  1: from typing import (
  2:     Dict,
  3:     Tuple,
  4:     Literal,
  5: )
  6: from numba import jit
  7: from scipy.sparse import coo_array
  8: import numpy as np
  9: from sbm.block_data import BlockData
 10: from sbm.block_change_proposers import (
 11:     EdgeDelta,
 12:     CombinationDelta,
 13: )
 14: #### aliases ######
 15: LikelihoodType = Literal['bernoulli']
 16: # Bernoulli functions
 17: @jit(nopython=True, cache=True, fastmath=True)
 18: def _bernoulli_ll_block_pair(e: int, n: int, eps:float= 1e-6) -> float:
 19:     """
 20:     Profile log-likelihood for one block pair (constants dropped).
 21:     e: number of edges between block pair.
 22:     n: number of possible pairs between block pair.
 23:     """
 24:     if e == 0: # 0  log 0 := 0   (limit)
 25:         return 0.0
 26:     elif n <= 0:
 27:         raise ValueError("Number of possible pairs (n) must be greater than 0.")
 28:     # clip to avoid overflow in lo
 29:     pos = max(e/n, eps)
 30:     neg = max(1 - e/n, eps)
 31:     return e * np.log(pos) - (n-e) * np.log(neg)
 32: @jit(fastmath=True, cache=True)
 33: def _delta_ll_bernoulli_block_pair(
 34:         e_old: int, e_new: int,
 35:         n_old: int, n_new: int,
 36:         eps: float = 1e-6
 37:         ) -> float:
 38:     """ for a single block pair.
 39:     e_new: new number of edges between block pair.
 40:     e_old: old number of edges between block pair.
 41:     n_new: new number of possible pairs between block pair.
 42:     n_old: old number of possible pairs between block pair.
 43:     """
 44:     new_ll = _bernoulli_ll_block_pair(e=e_new, n=n_new, eps=eps)
 45:     old_ll = _bernoulli_ll_block_pair(e=e_old, n=n_old, eps=eps)
 46:     return new_ll - old_ll
 47: def compute_delta_ll_from_change_bernoulli(
 48:         delta_e: EdgeDelta,
 49:         delta_n: CombinationDelta,
 50:         block_data: BlockData) -> float:
 51:     """
 52:     Incremental change in Bernoulli log-likelihood after a node-swap or move.
 53:     Only the pairs present in `delta_e` or `delta_n` need to be visited.
 54:     delta_e: changes in edge counts between affected blocks.
 55:     delta_n: changes in possible pairs between affected blocks.
 56:     block_data: BlockData object containing edge counts and possible pairs.
 57:     :return: Tuple of (change in log-likelihood, edge counts changes of move delta).
 58:     """
 59:     upper_triangle_only = not block_data.directed
 60:     delta_ll = 0.0
 61:     for (r, s), delta in delta_e.items():
 62:         if upper_triangle_only and s < r:
 63:             continue
 64:         e_old = int(block_data.block_connectivity[r, s]) # type: ignore
 65:         n_old = block_data.get_possible_pairs(r, s)
 66:         e_new = e_old + delta
 67:         n_new = n_old + delta_n[r, s]
 68:         delta_ll += _delta_ll_bernoulli_block_pair(
 69:             e_old=e_old,
 70:             e_new=e_new,
 71:             n_old=n_old,
 72:             n_new=n_new
 73:         )
 74:     return delta_ll
 75: # 
 76: ### Helpter function to vectorise the LL global computation
 77: # 
 78: @jit(nopython=True, cache=True, fastmath=True)   # remove decorator if you dislike Numba
 79: def _ll_vec(edges: np.ndarray, pairs: np.ndarray, eps: float = 1e-6) -> np.ndarray:
 80:     """
 81:     edges  : e_rs   (int  0)
 82:     pairs  : n_rs   (int  1)
 83:     returns: _rs   (float)
 84:     """
 85:     p = edges / pairs
 86:     p = np.where(p < eps, eps, p)
 87:     p = np.where(p > 1.0 - eps, 1.0 - eps, p)
 88:     return edges * np.log(p) - (pairs - edges) * np.log1p(-p)
 89: def compute_global_bernoulli_ll_fast(block_data:BlockData) -> float:
 90:     """
 91:     Same semantics as the original `compute_global_bernoulli_ll`, but
 92:     **O(nnz)** instead of O(B).
 93:     The trick: only block pairs with at least one edge (e_rs > 0) can
 94:     change the profiled Bernoulli LL once the constants are dropped.
 95:     """
 96:     conn: coo_array = coo_array(block_data.block_connectivity)
 97:     rows, cols, e = conn.row, conn.col, conn.data.astype(np.int64)
 98:     # Undirected graphs: keep only upper-triangle to avoid double count
 99:     if not block_data.directed:
100:         keep = rows <= cols
101:         rows, cols, e = rows[keep], cols[keep], e[keep]
102:     # Block sizes in matrix-index order
103:     sizes = np.fromiter(
104:         (block_data.block_sizes[block_data.inverse_block_indices[i]]
105:          for i in range(len(block_data.block_sizes))),
106:         dtype=np.int64,
107:         count=len(block_data.block_sizes)
108:     )
109:     # Possible pair counts n_rs (vectorised)
110:     n = np.where(
111:         rows == cols,
112:         sizes[rows] * (sizes[rows] - 1) // 2,   # diagonal blocks
113:         sizes[rows] * sizes[cols]               # off-diagonal
114:     )
115:     # Safety: skip singleton blocks (n = 0) to avoid /0 in n==1 corner
116:     valid = n > 0
117:     if not valid.all():
118:         rows, cols, e, n = rows[valid], cols[valid], e[valid], n[valid]
119:     # Vectorised LL and reduction
120:     return float(_ll_vec(e, n).sum())
121: def compute_global_bernoulli_ll(
122:         block_data: BlockData,
123: ) -> float:
124:     """
125:     Compute the global log-likelihood of the SBM using Bernoulli likelihood.
126:     :param block_data: The BlockData object containing block connectivity and sizes.
127:     :param upper_triangle_only: If True, only compute for upper triangle of the connectivity matrix.
128:     :return: The global log-likelihood.
129:     """
130:     upper_triangle_only = not block_data.directed
131:     ll = 0.0
132:     for r in range(len(block_data.block_sizes)):
133:         # if block has less than 2 nodes, skip it: no possible pairs
134:         size_r = block_data.block_sizes[ block_data.inverse_block_indices[r] ]
135:         if size_r <= 1:
136:             continue 
137:         for s in range(r if upper_triangle_only else 0, len(block_data.block_sizes)):
138:             e = block_data.block_connectivity[r, s]
139:             #n = block_data.get_possible_pairs(r, s)
140:             if r == s:
141:                 # If the same block, return the number of pairs within the block
142:                 n = block_data.block_sizes[r] * (block_data.block_sizes[r] - 1) // 2
143:             # If different blocks, return the product of their sizes
144:             else:
145:                 n = block_data.block_sizes[r] * block_data.block_sizes[s]
146:             if e < 0 or n < 0:
147:                 raise ValueError(f"Invalid edge count {e} or possible pairs {n} for block pair ({r}, {s}).")
148:             if e > n:
149:                 raise ValueError(f"Edge count {e} cannot be greater than possible pairs {n} for block pair ({r}, {s}).")
150:             ll += _bernoulli_ll_block_pair(e, n) # type: ignore
151:     return ll
152: #### LikelihoodCalculator class ######
153: class LikelihoodCalculator:
154:     def __init__(self,
155:                  block_data: BlockData,
156:                  likelihood_type: LikelihoodType = 'bernoulli',
157:                  ):
158:         self.block_data = block_data
159:         self.likelihood_type: LikelihoodType = 'bernoulli'
160:         self.ll = self.compute_likelihood()
161:     def compute_likelihood(self) -> float:
162:         """
163:         Compute the likelihood of the network given the current partition.
164:         :return: The log-likelihood of the SBM.
165:         """
166:         if self.likelihood_type.lower() == 'bernoulli':
167:             return compute_global_bernoulli_ll_fast(block_data=self.block_data)
168:         else:
169:             raise NotImplementedError("Only Bernoulli likelihood is implemented.")
170:     def _compute_delta_ll_from_changes(self,
171:                                        delta_e: EdgeDelta,
172:                                        delta_n: CombinationDelta,
173:     ) ->float:
174:         """
175:         efficeintly compute the change in log-likelihood from changes in edge counts and possible pairs.
176:         :param delta_e: Changes in edge counts between blocks.
177:         :param delta_n: Changes in possible pairs between blocks.
178:         :param total_edges: Total number of edges in the graph.
179:         :return: The change in log-likelihood.
180:         """
181:         if self.likelihood_type.lower() == 'bernoulli':
182:             return compute_delta_ll_from_change_bernoulli(
183:                 delta_e=delta_e,
184:                 delta_n=delta_n,
185:                 block_data=self.block_data
186:             )
187:         else:
188:             raise NotImplementedError("Only Bernoulli likelihood is implemented.")
189:     def compute_delta_ll(self,
190:                         delta_e: EdgeDelta,
191:                         delta_n: CombinationDelta,
192:         ) -> float:
193:         """
194:         Compute the change in log-likelihood for a proposed swap of two nodes.
195:         :param proposed_moves: A list of tuples (node_i, node_j) representing the nodes to swap.
196:         :return: The change in log-likelihood.
197:         """
198:         return self._compute_delta_ll_from_changes(
199:             delta_e=delta_e,
200:             delta_n=delta_n
201:             )




================================================================
End of Codebase
================================================================
