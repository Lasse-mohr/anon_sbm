This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
.repomix/
  bundles.json
configs/
  sbm_fit_k10.yml
  surrogate_eval.yml
notebooks/
  likelihood_test.ipynb
  sbm_visualize.ipynb
planted_partitions/
  undirected_planted_partitions.py
src/
  metrics/
    __init__.py
    clustering.py
    degree.py
    shortest_path.py
  pipelines/
    evaluate_surrogate.py
    fit_sbm.py
    generate_surrogate.py
    run_all.py
  sbm/
    utils/
      logger.py
      util.py
    block_assigner.py
    block_change_proposers.py
    block_data.py
    graph_data.py
    initial_partition.py
    io.py
    likelihood.py
    mcmc.py
    model.py
    node_mover.py
    sampling.py
  tests/
    likelihood_test.py
    planted_partition_tests.py
    test_change_proposer_and_mover.py
    test_io.py
    test_metrics.py
.gitignore
pyproject.toml
README.md
setup.cfg

================================================================
Files
================================================================

================
File: .repomix/bundles.json
================
{
  "bundles": {}
}

================
File: configs/sbm_fit_k10.yml
================
# -------------------------------------------------------------------
#  Global defaults
# -------------------------------------------------------------------
seed: 42                 # RNG seed forwarded to NumPy & Metis
min_block_size: 10       # target k
n_iter: 5_000             # total MCMC iterations
temperature: 1.0         # initial annealing temperature
cooling_rate: 0.999
force_undirected: true   # force undirected graphs to be undirected
logging_folder: "./logs/"
log_every: 1000

# -------------------------------------------------------------------
#  List of empirical graphs to process
#  Each item needs:
#    name : label used for output folder (models/sbm/<name>/)
#    path : relative or absolute path to the processed graph file
# -------------------------------------------------------------------
datasets:
  - name: congress_twitter
    path: data/processed/congress.edgelist # undirected GML

================
File: configs/surrogate_eval.yml
================
# ---------------------------------------------------------------
seed: 1
min_block_size: 10
n_surrogates: 3                  # graphs to sample per dataset
overwrite: false                  # set true to ignore cached results

# which similarity metrics to compute
metrics:
  - shortest_path
  - degree
  - clustering

# list of empirical datasets (must exist under data/processed and models/sbm)
datasets:
  - name: congress_twitter
    graph: data/processed/congress.edgelist
    sbm_model: models/sbm/congress_twitter

================
File: notebooks/sbm_visualize.ipynb
================
{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Collecting networkx\n",
      "  Using cached networkx-3.4.2-py3-none-any.whl.metadata (6.3 kB)\n",
      "Using cached networkx-3.4.2-py3-none-any.whl (1.7 MB)\n",
      "Installing collected packages: networkx\n",
      "Successfully installed networkx-3.4.2\n"
     ]
    }
   ],
   "source": [
    "!pip install networkx\n",
    "!pip install matplotlib\n",
    "!pip install numpy"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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f/9qwwGzsrLYs2cP8+bNq/e9koWFBTNnzjTcX6xZswZPT0/D/eCPPXhPWFxcTEZGBgMGDACoduweZfjw4TXuNeryxhtvEBAQwKJFi3j++ecZPnw4v/rVr+q9LSGE+ZCEknii9e3bl61bt5KdnU10dDR//OMfycvLY/r06YYkRV3S09MpLCykW7duNV7r3r07er3eMFb/1q1bDx1W9yAvL69q37dp0wagWlLo7t27LF68GCcnJ+zs7HB2dmb48OEA5ObmAqDRaPjnP//Jnj17cHV1ZdiwYbz99tu1PjmkPqp6ENV3P2oTGBhIaGgooaGhzJw5k9WrVzNhwgReeeUV0tPT61zuzp07dR7nqterYuzWrVu9ejK99dZbfPPNN2zevLlaH4eGmDt3rmEI4TfffMPcuXPrjB+odR/8/PwMr1f926VLlxrz/XjZGzdukJubi4uLC87OztW+8vPzSUtLa9Q+CSGEEFUqKipYv349I0eOJD4+nps3b3Lz5k369+9PamoqkZGRhnnv3LlTr+tXXVatWkVQUBBarZa2bdvi7OzMrl27DPc1UHmd79ChQ7UhZT9248YNFEWhS5cuNa6PV65cqXF99PDwqJHsadOmTbX7rvreXyxcuJDjx48bruebNm2irKyMBQsW1OsYVJk7dy5xcXFcvHiRtWvXMnv27DoTUllZWbz44ou4urpiY2ODs7Mzvr6+ANWO3aNULVMf1tbWfPnll8THx5OXl8eKFSvqnTATQpgX6aEkBJUXxr59+9K3b1+6du3KkiVL2LRpU62fgDW3usaeK4oCVN7cjR49mqysLP7whz/g5+eHra0tSUlJLF68uFrzy1//+tdMnDiRb775hn379vHnP/+Zt956i4MHD9KrV6/Hsj+PMmrUKHbu3El0dPRjfTpaWFgYe/fu5e2332bEiBGNehTv008/jUajYdGiRZSUlDBz5sxmiLR2er0eFxeXOhujPtgXQQghhGiMgwcPkpyczPr161m/fn2N19esWdPgCt/arF69msWLFzN58mR+97vf4eLigoWFBW+99dZDH6pRG71ej0qlYs+ePbXeU9nZ2VX7/lH3XQ0xe/ZsXnrpJdasWcP//M//sHr1avr06VPvpFqV/v3706lTJ379618THx9f5wdWADNnzuTEiRP87ne/o2fPntjZ2aHX6xk7dmytDdHrUp9eVw/a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4cIF9e/fXydOnPB5FgD41XjkDQAAAEBAKSoqUmJiouLi4txrCQkJqqys9DivsrJSVqtVZrNZ8fHx+vHjhxwOh/uRt5qaGjmdTvf5SUlJamhoUFBQkGJiYv72/1utVlmtVi1evFgzZsxQaWmpJk2a5NN7BIBfjR1KAAAAAALKoEGDlJOTo507d7rXlixZovLycq1fv16PHj3S/v37tXv3bi1dulSSFBcXp3HjxmnevHm6fv26HA6HcnNzFRwc7L6GzWZTamqqJk6cqPPnz+vp06e6evWqVq1apVu3bunz58/Ky8tTRUWFnj17psrKSt28edPjPUwA8LugUAIAAAAQcNatW6fW1lb330lJSTp69KiOHDmigQMHavXq1Vq3bp3sdrv7nNLSUkVHR2vUqFGaPHmy5s6dq8jISPdxk8mkM2fOKD09XbNnz5bValV2draePXumqKgomc1mNTU1aebMmbJarZo+fbqysrK0du3atrx1APAJk8vlchkdAgAAAAAAAL8PdigBAAAAAADAKxRKAAAAAAAA8AqFEgAAAAAAALxCoQQAAAAAAACvUCgBAAAAAADAKxRKAAAAAAAA8AqFEgAAAAAAALxCoQQAAAAAAACvUCgBAAAAAADAKxRKAAAAAAAA8AqFEgAAAAAAALxCoQQAAAAAAACv/AEHVFK5QMppQAAAAABJRU5ErkJggg==",
      "text/plain": [
       "<Figure size 1200x500 with 3 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "import networkx as nx\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "\n",
    "def plot_sbm_graph(block_sizes, p_matrix):\n",
    "    # Validate the connectivity matrix\n",
    "    n_blocks = len(block_sizes)\n",
    "    if p_matrix.shape != (n_blocks, n_blocks):\n",
    "        raise ValueError(\"The connectivity matrix dimensions must match the number of blocks.\")\n",
    "    if np.any(p_matrix < 0) or np.any(p_matrix > 1):\n",
    "        raise ValueError(\"All probabilities in the connectivity matrix must be between 0 and 1.\")\n",
    "\n",
    "    # Generate Stochastic Block Model graph\n",
    "    G = nx.stochastic_block_model(block_sizes, p_matrix)\n",
    "\n",
    "    # Get adjacency matrix\n",
    "    adj_matrix = nx.to_numpy_array(G)\n",
    "\n",
    "    # Assign colors based on block membership\n",
    "    colors = [G.nodes[node]['block'] for node in G.nodes]\n",
    "\n",
    "    # Plotting the graph\n",
    "    pos = nx.spring_layout(G, seed=42)  # For consistent layout\n",
    "    plt.figure(figsize=(12, 5))\n",
    "\n",
    "    # Subplot 1: SBM graph\n",
    "    plt.subplot(1, 2, 1)\n",
    "    nx.draw(G, pos, node_color=colors, cmap=plt.cm.tab10, with_labels=False,\n",
    "            node_size=100, edge_color='gray')\n",
    "    plt.title('Stochastic Block Model')\n",
    "\n",
    "    # Subplot 2: Adjacency matrix with visible block structure\n",
    "    plt.subplot(1, 2, 2)\n",
    "    plt.imshow(adj_matrix, cmap='Greys', interpolation='none')\n",
    "    plt.colorbar(label='Edge Weight')\n",
    "    plt.title('Adjacency Matrix')\n",
    "    plt.xlabel('Nodes')\n",
    "    plt.ylabel('Nodes')\n",
    "\n",
    "    # Overlay block boundaries for visual separation\n",
    "    block_boundaries = np.cumsum([0] + block_sizes)\n",
    "    for boundary in block_boundaries:\n",
    "        plt.axhline(boundary - 0.5, color='red', linestyle='--', linewidth=0.5)\n",
    "        plt.axvline(boundary - 0.5, color='red', linestyle='--', linewidth=0.5)\n",
    "\n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "\n",
    "# Example usage\n",
    "block_sizes = [5, 8, 10]  # Sizes of each block\n",
    "p_matrix = np.array([[0, 0.1, 0.5],\n",
    "                     [0.1, 0.6, 0.1],\n",
    "                     [0.5, 0.1, 0.8]])  # Full inter-block connectivity matrix\n",
    "\n",
    "plot_sbm_graph(block_sizes, p_matrix)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "anon_sbm",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}

================
File: planted_partitions/undirected_planted_partitions.py
================
#!/usr/bin/env python3
"""
undirected_planted_partition.py
--------------------------------
Simple smoke-test for the swap-only MCMC implementation.

For each of 100 independent repetitions we

1.  Draw an undirected 100-node SBM with
         B = 10 blocks of size 10
         p_in  = 0.30   (within-block connection probability)
         p_out = 0.05   (between-block probability)

2.  Build an initial *random* equal-size partition with
        UniformSmallBlockAssigner(min_block_size=10)             (code in block_assigner.py)

3.  Run the adaptive swap-only MCMC for `n_iter` iterations.

4.  Compute the Jaccard index between
         the set of node pairs co-clustered in the *final* state, and
         the same set for the planted partition.

The script prints the mean, standard deviation and a histogram
of the 100 Jaccard scores so you can eyeball whether the sampler
typically finds the planted structure.

Dependencies
------------
Only `numpy`, `scipy` and the local `sbm` package (already required by
your project).

Author: Von Ngenmand
"""

from typing import Sequence, Hashable
from collections.abc import Sequence
import numpy as np
from scipy.sparse import csr_array
from scipy.optimize import linear_sum_assignment
from sklearn.metrics import (
    adjusted_rand_score,
    normalized_mutual_info_score,
)
from tqdm import tqdm

from sbm.graph_data import GraphData
from sbm.block_assigner import (
    UniformSmallBlockAssigner,
    MetisBlockAssigner,
)
from sbm.model import SBMModel




###############################################################################
# utility helpers
###############################################################################
def planted_blocks(n_nodes: int, block_size: int, rng) -> dict[int, int]:
    """Random planted partition: block 0  nodes 09, block 1  1019, """

    random_nodes = rng.permutation(n_nodes)
    # generate a random list of blocks for the nodes ensuring the correct block size
    random_blocks = np.arange(n_nodes) // block_size
    random_blocks = rng.permutation(random_blocks)

    return {v: block for (v, block) in zip(random_nodes, random_blocks)}


def sample_sbm(rng: np.random.Generator,
               blocks: dict[int, int],
               p_in: float,
               p_out: float) -> csr_array:
    """Generate an undirected loop-free adjacency matrix for a binary SBM."""
    n = len(blocks)
    adj = np.zeros((n, n), dtype=np.int8)

    # probability matrix look-up
    for u in range(n):
        for v in range(u + 1, n):          # u < v  strict upper triangle
            p = p_in if blocks[u] == blocks[v] else p_out
            if rng.random() < p:
                adj[u, v] = adj[v, u] = 1  # symmetrise

    return csr_array(adj)                 # sparse CSR


def misclassification_rate(
    true_labels: Sequence[Hashable],
    est_labels: Sequence[Hashable],
) -> float:
    """
    Percentage of vertices whose community label is wrong *after*
    optimally permuting the estimated labels to match the true ones.

    Parameters
    ----------
    true_labels : sequence
        Ground-truth block labels  length N.
    est_labels  : sequence
        Estimated block labels   length N.

    Returns
    -------
    float
        Mis-classification rate in the interval [0, 1].

    Notes
    -----
    * Label sets may use arbitrary hashables (str, int, ) and need not
      have the same cardinality.  Any surplus estimated or true blocks
      are matched to dummy columns/rows filled with zeros.
    * Uses the Hungarian algorithm (via `scipy.optimize.linear_sum_assignment`)
      to maximise the number of correctly matched vertices.
    """
    true = np.asarray(true_labels)
    est  = np.asarray(est_labels)

    if true.shape != est.shape:
        raise ValueError("true_labels and est_labels must have the same length")

    # Map arbitrary labels to contiguous integers 0..T-1 and 0..E-1
    true_ids,  true_inv  = np.unique(true, return_inverse=True)
    est_ids,   est_inv   = np.unique(est,  return_inverse=True)

    T, E = len(true_ids), len(est_ids)
    N    = len(true)

    # Build contingency matrix C[e, t] = |{ i : est_i=e and true_i=t }|
    C = np.zeros((E, T), dtype=int)
    np.add.at(C, (est_inv, true_inv), 1)

    # Pad to square (Hungarian implementation needs it or we need to
    # maximise on rectangles by padding zeros).
    if E != T:
        dim = max(E, T)
        C_padded = np.zeros((dim, dim), dtype=int)
        C_padded[:E, :T] = C
        C = C_padded

    # Maximise trace(C[perm])    minimise C for Hungarian
    row_ind, col_ind = linear_sum_assignment(-C)
    matched = C[row_ind, col_ind].sum()

    return 1.0 - matched / N


###############################################################################
# main loop
###############################################################################

def main(
    n_nodes = 100,
    block_size = 10,
    p_in = 0.30,
    p_out = 0.05,
    n_experiments = 10,
    n_iter = 3_000,
    rng_master = np.random.default_rng(42),
    temperature: float = 1
):
    init_scores = []
    final_scores = []

    for rep in tqdm(range(n_experiments)):
        rng = np.random.default_rng(rng_master.integers(2**32))

        # --- 1. plant graph -----------------------------------------------------
        planted = planted_blocks(n_nodes, block_size, rng)
        adj     = sample_sbm(rng, planted, p_in, p_out)

        # --- 2. initial random partition ---------------------------------------
        gdata    = GraphData(adjacency_matrix=adj, directed=False)
        assigner = MetisBlockAssigner(graph_data=gdata,
                                            rng=rng,
                                            min_block_size=block_size
                                        )
        init_blocks = assigner.compute_assignment()

        init_scores.append(
            misclassification_rate(
                true_labels=list(planted.values()),
                est_labels=list(init_blocks.blocks.values())
            )
        )

        sbm = SBMModel(
                initial_blocks=init_blocks,
                rng=rng,
                log=True,  # no logging
            )
        print(f"Initial ll {sbm.likelihood_calculator.ll:.3f}")

        sbm.fit(num_iterations=n_iter,
                min_block_size=block_size,
                initial_temperature=temperature,
                cooling_rate=0.999)

        final_blocks = sbm.get_block_assignments()

        # --- 4. score -----------------------------------------------------------
        final_scores.append(
            misclassification_rate(
                true_labels=list(planted.values()),
                est_labels=list(final_blocks.values())
            )
        )

    # --- print results ----------------------------------------------------------
    print(f"Initial misclassification rate: {np.mean(init_scores):.3f}  {np.std(init_scores):.3f}")
    print(f"Final misclassification rate:   {np.mean(final_scores):.3f}  {np.std(final_scores):.3f}")


if __name__ == "__main__":
    main(
        n_nodes=300,
        block_size=3,
        p_in=0.5,
        p_out=0.01,
        n_experiments=1,
        n_iter=5_000,
        rng_master=np.random.default_rng(42),
        temperature=1e-2
    )

================
File: src/metrics/__init__.py
================
from .shortest_path import shortest_path_distance
from .degree import degree_distance
from .clustering import clustering_distance

# registry maps a short name -> call-able
REGISTRY = {
    "shortest_path": shortest_path_distance,
    "degree": degree_distance,
    "clustering": clustering_distance,
}

================
File: src/metrics/clustering.py
================
""" 
Implementation of the clustering coefficient distance metric.
This module computes the absolute difference in the clustering coefficients
between two graphs represented by their adjacency matrices.
"""

# metrics/clustering.py
from typing import Optional
import numpy as np
import networkx as nx
from scipy.sparse import csr_array

def clustering_distance(
        emp_adj: csr_array,
        sur_adj: csr_array,
        directed: Optional[bool] = False,
        rng: np.random.Generator = np.random.default_rng(1)
    ) -> float:

    """ 
    Compute absolute 
    
    Parameters
    ----------
    emp_adj, sur_adj : scipy.sparse.csr_matrix
        Adjacency of empirical and surrogate graphs (directed or undirected).
    directed : bool, optional
        If True, compute directed degree distribution.
        If False, compute undirected degree distribution.
    rng : np.random.Generator, optional
        Random number generator for sampling (default: np.random.default_rng(1)).
    Returns
    -------
    float
        Distance (lower = more similar).
    """

    if directed:
        raise NotImplementedError(
            "Directed clustering coefficient is not implemented yet."
        )
    else:
        # Undirected clustering coefficient
        emp_graph = nx.from_scipy_sparse_array(emp_adj)
        sur_graph = nx.from_scipy_sparse_array(sur_adj)

        emp_clustering = nx.average_clustering(emp_graph)
        sur_clustering = nx.average_clustering(sur_graph)

        return abs(emp_clustering - sur_clustering)

================
File: src/metrics/degree.py
================
""" 
Implementation of the degree distribution distance metric.
This module computes the Earth-mover distance (1-D Wasserstein distance)
between the degree distributions in two graphs represented by
their adjacency matrices.
"""
# metrics/degree.py
from typing import Optional
import numpy as np
import networkx as nx
from scipy.stats import wasserstein_distance #  1-D EMD
from scipy.sparse import csr_array

def degree_distance(
        emp_adj: csr_array,
        sur_adj: csr_array,
        directed: Optional[bool] = False,
        in_degree: Optional[bool] = False,
        out_degree: Optional[bool] = False,
        rng: np.random.Generator = np.random.default_rng(1)
    ) -> float:
    """ 
    Earth-mover (1-D Wasserstein) distance between the degree distributions
    of two graphs.

    Parameters
    ----------
    emp_adj, sur_adj : scipy.sparse.csr_matrix
        Adjacency of empirical and surrogate graphs (directed or undirected).
    directed : bool, optional
        If True, compute directed degree distribution.
        If False, compute undirected degree distribution.
    in_degree : bool, optional
        If True, compute in-degree distribution (for directed graphs).
        Ignored if `directed` is False.
    out_degree : bool, optional
        If True, compute out-degree distribution (for directed graphs).
        Ignored if `directed` is False.
    rng : np.random.Generator, optional
        Random number generator for sampling (default: np.random.default_rng(1)).
    Returns
    -------
    float
        Distance (lower = more similar).
    """

    if directed:
        raise NotImplementedError(
            "Directed degree distribution is not implemented yet."
        )
    else:
        if in_degree or out_degree:
            raise Warning(
                "in_degree and out_degree are ignored for undirected graphs."
            )
        # Undirected degree distribution
        emp_degrees = np.asarray(emp_adj.sum(axis=0)).flatten()
        sur_degrees = np.asarray(sur_adj.sum(axis=0)).flatten()

        emp_dist = np.bincount(emp_degrees)
        sur_dist = np.bincount(sur_degrees)

        # Normalize distributions
        emp_dist = emp_dist / emp_dist.sum()
        sur_dist = sur_dist / sur_dist.sum()

        # Compute Earth-mover distance
        distance = wasserstein_distance(emp_dist, sur_dist)
        return distance

================
File: src/metrics/shortest_path.py
================
""" 
Implementation of the shortest path distribution distance metric.
This module computes the Earth-mover distance (1-D Wasserstein distance)
between the distributions of all-pairs shortest-path lengths
in two graphs represented by their adjacency matrices.
"""
# metrics/shortest_path.py
from typing import Optional
import numpy as np
import networkx as nx
from scipy.stats import wasserstein_distance #  1-D EMD
from scipy.sparse import csr_array
from scipy.sparse.csgraph import shortest_path

def shortest_path_distance(
        emp_adj: csr_array,
        sur_adj: csr_array,
        n_samples: Optional[int]=None,
        rng:np.random.Generator = np.random.default_rng(1)
    ) -> float:
    """
    Earth-mover (1-D Wasserstein) distance between the distributions
    of all-pairs shortest-path lengths.

    Parameters
    ----------
    emp_adj, sur_adj : scipy.sparse.csr_matrix
        Adjacency of empirical and surrogate graphs (undirected).
    n_samples : int, optional
        Number of samples to use for the distributions.
        If None, all pairs are used.

    Returns
    -------
    float
        Distance (lower = more similar).
    """

    emp_graph_size = emp_adj.shape[0] # type: ignore
    sur_graph_size = emp_adj.shape[0] # type: ignore

    if (emp_graph_size > 1000) or (sur_graph_size > 100) and (n_samples is not None):
        raise Warning(
            "Graph sizes large (>1000 nodes), "
            "consider setting n_samples=None to use all pairs."
        )

    if n_samples is None:
        G_emp = nx.from_scipy_sparse_array(emp_adj)
        G_sur = nx.from_scipy_sparse_array(sur_adj)

        def sp_hist(G) -> np.ndarray:
            lengths = dict(nx.all_pairs_shortest_path_length(G))
            vals = [d for lengths_u in lengths.values() for d in lengths_u.values()]
            return np.array(vals)

        x = sp_hist(G_emp)
        y = sp_hist(G_sur)

    else: # sample pairs and compute distances
        if n_samples > (emp_graph_size * (emp_graph_size - 1) / 2) \
            or n_samples > (sur_graph_size * (sur_graph_size - 1) / 2):
            raise ValueError(
                "n_samples exceeds the number of unique pairs in the graph."
            )
        emp_pair_part_1 = rng.choice(emp_graph_size, size=n_samples, replace=True)
        emp_pair_part_2 = rng.choice(emp_graph_size-1, size=n_samples, replace=True)
        emp_pair_part_2[emp_pair_part_2 >= emp_pair_part_1] += 1
        emp_pairs = np.column_stack((emp_pair_part_1, emp_pair_part_2))

        sur_pair_part_1 = rng.choice(sur_graph_size, size=n_samples, replace=True)
        sur_pair_part_2 = rng.choice(sur_graph_size-1, size=n_samples, replace=True)
        sur_pair_part_2[sur_pair_part_2 >= sur_pair_part_1] += 1
        sur_pairs = np.column_stack((sur_pair_part_1, sur_pair_part_2))

        def sample_shortest_paths(adj, pairs):
            G = nx.from_scipy_sparse_array(adj)
            return np.array([nx.shortest_path_length(G, source=u, target=v) for u, v in pairs])

        x = sample_shortest_paths(emp_adj, emp_pairs)
        y = sample_shortest_paths(sur_adj, sur_pairs)

    return wasserstein_distance(x, y)

================
File: src/pipelines/evaluate_surrogate.py
================
import argparse, yaml, csv
from pathlib import Path
import numpy as np
import scipy.sparse as sp

from metrics import REGISTRY
from sbm.io import GraphLoader

def load_csr_npz(fn: Path):
    with np.load(fn) as z:
        return sp.csr_matrix(
            (z["data"], z["indices"], z["indptr"]),
            shape=z["shape"]
        )


def main(cfg):
    cfg = yaml.safe_load(Path(cfg).read_text())
    results = []

    for ds in cfg["datasets"]:
        emp = GraphLoader.load(Path(ds["graph"])).adjacency
        surr_dir = Path("data/surrogates") / ds["name"]

        for surr_file in sorted(surr_dir.glob("surr_*.npz")):
            surr = load_csr_npz(surr_file)
            row = {"dataset": ds["name"], "surrogate": surr_file.stem}
            for m in cfg["metrics"]:
                row[m] = REGISTRY[m](emp, surr)
            results.append(row)
            print("evaluated", surr_file)

    out = Path("results") / "surrogate_metrics.csv"
    out.parent.mkdir(exist_ok=True)
    with out.open("w", newline="") as f:
        w = csv.DictWriter(f, fieldnames=results[0].keys())
        w.writeheader(); w.writerows(results)
    print("saved", out)

if __name__ == "__main__":
    p = argparse.ArgumentParser(); p.add_argument("cfg"); main(p.parse_args().cfg)

================
File: src/pipelines/fit_sbm.py
================
# src/pipelines/fit_sbm.py
import yaml
import argparse
import time
from pathlib import Path

import numpy as np

from sbm.io import GraphLoader, SBMWriter
from sbm.block_assigner import MetisBlockAssigner
from sbm.model import SBMModel
from sbm.utils.logger import CSVLogger

def main(cfg_path: str):
    cfg = yaml.safe_load(Path(cfg_path).read_text())
    for ds in cfg["datasets"]:
        seed = cfg['seed']
        rng = np.random.default_rng(seed)

        # prepare SBM model
        g = GraphLoader.load(
            Path(ds["path"]),
            force_undirected=cfg["force_undirected"],
            )
        assigner = MetisBlockAssigner(
            graph_data=g,
            min_block_size=cfg["min_block_size"],
            rng=rng,
            )

        block_data = assigner.compute_assignment()
        model = SBMModel(block_data, rng=rng)

        # fit SBM model

        name = (
            f"{ds["name"]}_"
            f"{cfg['n_iter']}_iter_"
            f"{cfg['min_block_size']}_minbs_"
        )
        log_path = Path(cfg['logging_folder']) / f"{name}.csv"

        tic = time.time()
        with CSVLogger(log_path, log_every=cfg['log_every']) as logger:
            model.fit(num_iterations=cfg["n_iter"],
                      min_block_size=cfg["min_block_size"],
                      initial_temperature=cfg["temperature"],
                      cooling_rate=cfg["cooling_rate"],
                      logger=logger,
                      )
        toc = time.time()

        # save the fitted model
        fit = model.to_sbmfit({"dataset": ds["name"], "fit_seconds": toc-tic})
        out_dir = Path("models/sbm")/ds["name"]
        out_dir.mkdir(parents=True, exist_ok=True)
        SBMWriter.save(out_dir, fit)
        print(f"{ds['name']} completed, nll = {fit.neg_loglike:.2f}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("cfg", help="YAML config")
    main(parser.parse_args().cfg)

================
File: src/pipelines/generate_surrogate.py
================
import argparse, yaml
from pathlib import Path
import numpy as np

from sbm.io import SBMWriter
from sbm.sampling import sample_sbm_graph_from_fit

def main(cfg):
    cfg = yaml.safe_load(Path(cfg).read_text())
    rng = np.random.default_rng(cfg["seed"])

    for ds in cfg["datasets"]:
        sbm_fit = SBMWriter.load(Path(ds["sbm_model"]))
        out_dir = Path("data/surrogates") / ds["name"]
        out_dir.mkdir(parents=True, exist_ok=True)

        for i in range(cfg["n_surrogates"]):
            fn = out_dir / f"surr_{i:03d}.npz"
            if fn.exists() and not cfg["overwrite"]:
                continue

            sur_graph_data = sample_sbm_graph_from_fit(
                sbm_fit=sbm_fit,
                rng=rng,
            )

            adj = sur_graph_data.adjacency
            np.savez_compressed(fn,
                                data=adj.data,
                                indices=adj.indices,
                                indptr=adj.indptr,
                                shape=adj.shape, # type: ignore
                            )
            print("generated", fn)

if __name__ == "__main__":
    p = argparse.ArgumentParser()
    p.add_argument("cfg")
    main(p.parse_args().cfg)

================
File: src/pipelines/run_all.py
================
import subprocess, sys

def run(cmd):
    print(">>", " ".join(cmd)); subprocess.check_call(cmd)

CFG_FIT = "configs/sbm_fit_k10.yml"
CFG_EVAL = "configs/surrogate_eval.yml"

if __name__ == "__main__":
    python = sys.executable
    run([python, "-m", "pipelines.fit_sbm",   CFG_FIT])
    run([python, "-m", "pipelines.generate_surrogates", CFG_EVAL])
    run([python, "-m", "pipelines.evaluate_surrogates", CFG_EVAL])

================
File: src/sbm/utils/logger.py
================
# sbm/utils/logger.py

import csv
import time
from pathlib import Path
from typing import Union, TextIO


class CSVLogger:
    """
    Minimal CSV logger for long-running SBM fits.

    Each row contains:
        iteration, elapsed_seconds, neg_log_likelihood,
        accept_rate_window, temperature

    Parameters
    ----------
    file : str | pathlib.Path | TextIO
        Where to write.  If a path is given and the file does not yet
        exist, a header row is written automatically.
    log_every : int
        Only rows for which ``iteration % log_every == 0`` are written.
    """

    header = [
        "iteration",
        "elapsed_seconds",
        "neg_log_likelihood",
        "accept_rate_window",
        "temperature",
    ]

    def __init__(self,
                 file: Union[str, Path, TextIO],
                 *,
                 log_every: int = 1000,
                 ):
        self.log_every = int(log_every)
        self._start = time.time()

        # if prior log file exists, delete
        if isinstance(file, (str, Path)):
            file = Path(file)
            if file.exists():
                file.unlink()

        # open the handle
        if isinstance(file, (str, Path)):
            self._own_handle = True
            path = Path(file)
            path.parent.mkdir(parents=True, exist_ok=True)
            first = not path.exists()
            self._fh = path.open("a", newline="")
            self._writer = csv.writer(self._fh)
            if first:
                self._writer.writerow(self.header)
        else:                                  # file-like object supplied
            self._own_handle = False
            self._fh: TextIO = file
            self._writer = csv.writer(self._fh)
            # assume caller already wrote header

    # -----------------------------------------------------------------
    def log(self,
            iteration: int,
            neg_loglike: float,
            accept_rate_window: float,
            temperature: float,
            ) -> None:
        """
        Append a row
        """
        elapsed = time.time() - self._start
        self._writer.writerow([
            iteration,
            f"{elapsed:.3f}",
            f"{neg_loglike:.6f}",
            f"{accept_rate_window:.6f}",
            f"{temperature:.6f}",
        ])
        self._fh.flush()

    # -----------------------------------------------------------------
    def close(self):
        if self._own_handle:
            self._fh.close()

    # allow usage as a context manager -------------------------------
    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc, tb):
        self.close()

================
File: src/sbm/utils/util.py
================
import numpy as np

def set_random_seed(seed: int):
    return np.random.default_rng(seed)

================
File: src/sbm/block_assigner.py
================
""" 
    Functions and classes for computing initial block assignment 
    used in the Stochastic Block Model (SBM). These are later updated
    using the MCMC algorithm.
"""
from typing import List, Dict, Optional, Tuple, Iterable
from collections import defaultdict
import pymetis
import scipy.sparse as sp
import numpy as np

from sbm.block_data import BlockData
from sbm.graph_data import GraphData

#  helper ---------------------------------------------------------------
def _block_sizes(blocks: Dict[int, int]) -> Dict[int, int]:
    sizes = defaultdict(int)
    for b in blocks.values():
        sizes[b] += 1
    return sizes

#  Mixin  functions for balancing block sizes of proposed block partition --
def rebalance_to_min_size(
    blocks: Dict[int, int],
    adjacency: sp.csr_array,
    min_block_size: Optional[int],
) -> Dict[int, int]:
    """
    Post-process a *proposed* partition so that every block has
    size `min_block_size` or `min_block_size+1`.

    The algorithm:

    1.  Collect all nodes that currently belong to a block of size
        ``< min_block_size``.
    2.  Carve out as many **new** full blocks of size
        ``min_block_size`` as possible from this pool.
    3.  For the *left-over* nodes (< `min_block_size`)  
        a) try to move a node to a neighboring block that is still
           of exact size ``min_block_size``;  
        b) if no such neighbour exists, pick a random block that
           is still at size ``min_block_size``.  
        Each block may accept **at most one** such extra node,
        reaching ``min_block_size+1``.
    4.  Return the new `node  block` mapping.

    Parameters
    ----------
    blocks : dict {node: block_id}
        Preliminary assignment.
    adjacency : scipy.sparse.csr_array
        Undirected adjacency for neighbourhood look-ups.
    min_block_size : int
        Target base size *k*.

    Returns
    -------
    dict
        Balanced `node  block` mapping.
    """
    if min_block_size is None:
        return blocks

    sizes = _block_sizes(blocks)
    undersized = {b for b, sz in sizes.items() if sz < min_block_size}
    if not undersized:
        return blocks  # already balanced

    # -----------------------------------------------------------------
    # 1. pool all nodes from undersized blocks
    # -----------------------------------------------------------------
    pool: List[int] = [v for v, b in blocks.items() if b in undersized]

    # remove those undersized blocks entirely
    for b in undersized:
        sizes.pop(b, None)

    # current max label so we can create fresh block IDs
    next_block_id = max(sizes.keys(), default=-1) + 1

    # -----------------------------------------------------------------
    # 2. carve as many full blocks (size == k) as possible
    # -----------------------------------------------------------------
    while len(pool) >= min_block_size:
        new_nodes = [pool.pop() for _ in range(min_block_size)]
        for v in new_nodes:
            blocks[v] = next_block_id
        sizes[next_block_id] = min_block_size
        next_block_id += 1

    # -----------------------------------------------------------------
    # 3. distribute remaining ( < k ) nodes
    # -----------------------------------------------------------------
    # keep a fast lookup of which *existing* blocks can still accept 1
    acceptors = {b for b, sz in sizes.items() if sz == min_block_size}

    rng = np.random.default_rng(42)  # deterministic for tests

    for v in pool:
        # 3a. neighbour heuristic
        neigh_blocks = {
            blocks[u]
            for u in adjacency.indices[adjacency.indptr[v] : adjacency.indptr[v + 1]]
            if sizes.get(blocks[u], 0) == min_block_size
        }
        target = None
        if neigh_blocks:
            target = rng.choice(list(neigh_blocks))
        elif acceptors:
            # 3b. random among remaining acceptors
            target = rng.choice(list(acceptors))
        else:
            raise RuntimeError("No available block can accept extra nodes")

        # assign
        blocks[v] = target
        sizes[target] += 1
        if sizes[target] == min_block_size + 1:
            acceptors.discard(target)

    return blocks


### Base class for BlockAssigner
class BlockAssigner:
    """
    Base class for assigning nodes to blocks in the Stochastic Block Model (SBM).
    This class is intended to be subclassed for specific block assignment strategies.
    """
    def __init__(self,
                 graph_data: GraphData,
                 rng: np.random.Generator,
                 num_blocks: Optional[int] = None,
                 min_block_size: Optional[int] = None,
                 max_block_size: Optional[int] = None,
                 ):
        self.graph_data = graph_data

        # check if there exist a valid assignment
        # given num_blocks, min_block_size, max_block_size
        if num_blocks is not None and min_block_size is not None:
            if num_blocks * min_block_size > graph_data.num_nodes:
                raise ValueError("Invalid parameters: num_blocks * min_block_size exceeds total number of nodes.")
        if max_block_size is not None and min_block_size is not None:
            if max_block_size < min_block_size:
                raise ValueError("Invalid parameters: max_block_size cannot be less than min_block_size.")

        self.num_blocks = num_blocks
        self.min_block_size = min_block_size
        self.max_block_size = max_block_size
        self.rng = rng
        self.min_size_balancers = rebalance_to_min_size

    def reindex_blocks(self, blocks: Dict[int, int]) -> Dict[int, int]:
        """ 
        Reindex block IDs to be consecutive integers starting from 0.
        """
        unique_blocks = sorted(set(blocks.values()))
        block_mapping = {old_id: new_id for new_id, old_id in enumerate(unique_blocks)}
        return {node: block_mapping[block_id] for node, block_id in blocks.items()}


    def _compute_assignment(self) -> Dict[int, int]:
        raise NotImplementedError(
            "compute_assignment must be implemented by subclasses of BlockAssigner."
        )

    def compute_assignment(self) -> BlockData:
        """
        Compute a balanced block assignment based on the proposed assignment.

        Currently, this method only performs a min_size balancing step.
        """
        proposed_assignment = self._compute_assignment()
        balanced_assignment = self.min_size_balancers(
            blocks=proposed_assignment,
            adjacency=self.graph_data.adjacency,
            min_block_size=self.min_block_size,
        )
        reindexed_assignment = self.reindex_blocks(balanced_assignment)

        return BlockData(
            initial_blocks=reindexed_assignment,
            graph_data=self.graph_data
        )


class UniformSmallBlockAssigner(BlockAssigner):
    """ 
    Assigns nodes to blocks of size min_block_size uniformly at random. 
    Ignore num_blocks and max_block_size.
    """

    def _compute_assignment(self) -> Dict[int, int]:
        """
        Assign nodes to blocks uniformly at random, ensuring each block has at least min_block_size nodes.
        """
        if self.min_block_size is None:
            raise ValueError("min_block_size must be specified for UniformSmallBlockAssigner.")
        if self.min_block_size <= 0:
            raise ValueError("min_block_size must be a positive integer.")

        if self.max_block_size is not None:
            Warning("max_block_size is ignored in UniformSmallBlockAssigner.")
        if self.num_blocks is not None:
            Warning("num_blocks is ignored in UniformSmallBlockAssigner.")

        num_nodes = self.graph_data.num_nodes

        # create list of nodes in random order
        node_list = self.rng.permutation(np.arange(num_nodes))
        # assign nodes to blocks
        block_assignments = {
            node: node // self.min_block_size for node in node_list
        }

        return block_assignments


class MetisBlockAssigner(BlockAssigner):
    """
    Use PyMetis to obtain a *balanced* `num_blocks`-way partition of the
    (undirected) graph.

    Parameters
    ----------
    graph_data : GraphData
        Graph wrapper holding the (sparse) adjacency matrix.
    num_blocks : int
        Desired number of blocks ( N // k where k is target block size).
    seed : int, optional
        Random seed forwarded to METIS.  If None, METIS uses its own seed.
    """

    def __init__(
        self,
        graph_data: GraphData,
        rng: np.random.Generator,
        num_blocks: Optional[int] = None,
        min_block_size: Optional[int] = None,
        max_block_size: Optional[int] = None,
    ) -> None:
        super().__init__(
            graph_data=graph_data,
            rng=rng,
            num_blocks=num_blocks,
            min_block_size=min_block_size,
            max_block_size=max_block_size,
            )

        if graph_data.directed:
            raise NotImplementedError(
                "MetisBlockAssigner currently supports undirected graphs only."
            )

        if num_blocks is None and min_block_size is None:
            raise ValueError("Either num_blocks or min_block_size must be specified for MetisBlockAssigner.")
        
        if num_blocks is None:
            num_blocks = max(
                1, graph_data.num_nodes // min_block_size
            )

        self.num_blocks = int(num_blocks)
        self.seed = rng.integers(2**32)

    # -----------------------------------------------------------------
    # Utilities
    # -----------------------------------------------------------------
    @staticmethod
    def _to_adj_lists(adj: sp.csr_array) -> list[list[int]]:
        """
        Convert a CSR adjacency matrix to the adjacency-list format PyMetis
        expects (no self-loops, undirected symmetry).
        """
        n = adj.shape[0] # type: ignore
        rows, cols = adj.nonzero() # type: ignore
        neigh = [[] for _ in range(n)]
        for u, v in zip(rows, cols):
            if u == v:
                continue  # ignore self-loops
            neigh[u].append(v)
        return neigh

    # -----------------------------------------------------------------
    # Public API
    # -----------------------------------------------------------------
    def _compute_assignment(self) -> Dict[int, int]:
        """Run METIS and return a BlockData with the resulting assignment."""
        n = self.graph_data.num_nodes
        adj_lists = self._to_adj_lists(self.graph_data.adjacency)

        # PyMetis returns (edgecuts, membership-array)
        _, parts = pymetis.part_graph(
            self.num_blocks,
            adjacency=adj_lists,
        )

        # PyMetis guarantees |parts| == n
        blocks: Dict[int, int] = {node: part for node, part in enumerate(parts)}

        # Wrap in BlockData so downstream code can use it directly
        return blocks

================
File: src/sbm/block_change_proposers.py
================
from typing import List, Optional, Tuple, DefaultDict, Literal
from collections import defaultdict, Counter
import numpy as np
from sbm.block_data import BlockData

### Aliases 
EdgeDelta = DefaultDict[Tuple[int, int], int] # edge-count changes between blocks
CombinationDelta= DefaultDict[Tuple[int, int], int] # changes in possible pairs between blocks
ProposedValidChanges = List[Tuple[int, int]]  # list of proposed node-block pairs

ChangeProposerName = Literal["swap"]
ChangeProposers = Literal["NodeSwapProposer"]


#### Helper functions ######
def _increment_delta_e(count: int, block_i: int, block_j: int,
                        delta_e: EdgeDelta) -> EdgeDelta:
    """
    Increment the edge count delta for a pair of blocks.

    :param count: The change in edge count.
    :param block_i: The first block index.
    :param block_j: The second block index.
    :param delta_e: The current edge count delta.
    :return: Updated edge count delta.
    """
    if block_i < block_j:
        delta_e[(block_i, block_j)] = count
    else:
        delta_e[(block_j, block_i)] = count

    return delta_e


### ChangeProposer classes for proposing block changes in the SBM
# These classes handle the logic of proposing valid changes to the block assignments
# and computing the resulting edge deltas for the block connectivity matrix.

class ChangeProposer:
    """ 
    Class to propose block-assignment changes for the MCMC algorithm.

    Handles min block size constraints. All functions return None
    if a  and ensures valid moves.

    Proposers shoudl always change block-id to block-adjacency idx before
    computing deltas.
    """
    def __init__(self,
                 block_data: BlockData,
                 rng: np.random.Generator=np.random.default_rng(1)):

        self.block_data = block_data

        self.rng = rng
        self.min_block_size = 1
    
    def propose_change(self,
        changes: Optional[ProposedValidChanges] = None,
        )-> Tuple[ProposedValidChanges, EdgeDelta, CombinationDelta]:
        raise NotImplementedError("This method should be overridden by subclasses.")

    def _compute_delta_edge_counts(self, proposed_changes: ProposedValidChanges) -> EdgeDelta:
        """
        Compute the edge deltas for the proposed change.

        :param change: Proposed change as a list of (node, target_block) tuples.
        :return: EdgeDelta dictionary with changes in edge counts.
        """
        raise NotImplementedError("This method should be overridden by subclasses.")
    
    def _compute_edge_counts_between_node_and_blocks(self,
                                               node: int,
                                               ) -> Counter[int]:
        """
        Compute the number of edges between a node and each affected block.
    
        :param node: The node to move.
        :param affected_blocks: The blocks affected by the move.
        :return: A dictionary mapping block IDs to edge counts with the node.

        k_i: Counter[int]: number of edges between node and each affected block.

        returns a Counter object where keys are block IDs and values are edge counts.
        """
        if self.block_data.directed:
            raise NotImplementedError("Directed graphs are not supported yet.")
        else:
            #neighbors = self.block_data.graph_data.adjacency[:, [node]].indices  # type: ignore
            neighbors = self.block_data.graph_data.adjacency[[node], :].indices  # type: ignore
            blocks_among_neighbors = [
                self.block_data.block_indices[
                    self.block_data.blocks[neighbor]
                ] for neighbor in neighbors
            ]
            k_i = Counter(blocks_among_neighbors)

            return k_i

class NodeSwapProposer(ChangeProposer):
    def propose_change(self,
        changes: Optional[ProposedValidChanges] = None,
        ) -> Tuple[ProposedValidChanges, EdgeDelta, CombinationDelta]:
        """
        Propose swapping two nodes between different blocks.

        :return: Tuple of (node1, node2) or None if no valid swap.
        """
        if changes is not None:
            if len(changes) != 2:
                raise ValueError("NodeSwapProposer requires exactly two nodes to swap.")
            proposed_changes = changes
        else:
            # Select two different blocks
            block1, block2 = self.rng.choice(
                list(self.block_data.block_sizes.keys()),
                size=2,
                replace=False
            )

            # Select one node from each block
            # Note: changing to list is inefficient for large blocks.
            # However, having memberships being lists allow for fast 
            # membership updates.
            # Change if large blocks are common.
            node1 = self.rng.choice(
                list(self.block_data.block_members[block1])
            )
            node2 = self.rng.choice(
                list(self.block_data.block_members[block2])
            )

            proposed_changes :ProposedValidChanges = [(node1, block2), (node2, block1)]

        delta_e: EdgeDelta = self._compute_delta_edge_counts(
            proposed_changes=proposed_changes
        )

        delta_n: CombinationDelta = defaultdict(int, {key: 0 for key in delta_e.keys()})

        return proposed_changes, delta_e, delta_n
    
    def _compute_delta_edge_counts(self,
                                    proposed_changes: ProposedValidChanges
        )-> EdgeDelta:
        """
        Compute the changes in edge counts between blocks due to swapping
        node i and node j.

        :param i: The index of the first node being swapped.
        :param j: The index of the second node being swapped.
        :param k_i: The edges between the moving node and its neighbor blocks.
        :param source_block: The block from which the node is moved.
        :param target_block: The block to which the node is moved.

        :return: A Counter mapping block pairs to changes in edge counts.
        """
        if self.block_data.directed:
            raise NotImplementedError("Directed graphs are not supported yet.")
        
        (i, old_block_j), (j, old_block_i) = proposed_changes

        delta_e: EdgeDelta = defaultdict(int)
        block_i_idx = self.block_data.block_indices[old_block_i]
        block_j_idx = self.block_data.block_indices[old_block_j]

        # compute the edge counts for the blocks of i and j
        # on block-adjacency idx level
        k_i = self._compute_edge_counts_between_node_and_blocks(i)
        k_j = self._compute_edge_counts_between_node_and_blocks(j)
        affected_blocks = set(k_i.keys()) | set(k_j.keys())

        # add the changes for the neighbor blocks of i and j
        for t in affected_blocks - {block_i_idx, block_j_idx}:
            # m_{r t}
            delta_e = _increment_delta_e(
                count = -k_i[t] + k_j[t],
                block_i = old_block_i,
                block_j = t,
                delta_e = delta_e,
            )
            # m_{s t}
            delta_e = _increment_delta_e(
                count = -k_j[t] + k_i[t],
                block_i = old_block_j,
                block_j = t,
                delta_e = delta_e,
            )
        
        # Add the changes for the old blocks of i and j
        has_edge_ij = bool(self.block_data.graph_data.adjacency[i, j])

        delta_e = _increment_delta_e(
            count = k_i[old_block_i] - k_i[old_block_j] \
                    + k_j[old_block_j] - k_j[old_block_i] \
                    + 2 * has_edge_ij,
            block_i=old_block_i,
            block_j=old_block_j,
            delta_e=delta_e
        )

        delta_e = _increment_delta_e(
            count = k_j[old_block_i] - k_i[old_block_i] - has_edge_ij,
            block_i=old_block_i,
            block_j=old_block_i,
            delta_e=delta_e
        )
        delta_e = _increment_delta_e(
            count = k_i[old_block_j] - k_j[old_block_j] - has_edge_ij,
            block_i=old_block_j,
            block_j=old_block_j,
            delta_e=delta_e
        )

        return delta_e

================
File: src/sbm/io.py
================
from typing import Dict, Callable, Iterable, Tuple, Optional
from pathlib import Path
from dataclasses import dataclass
import json

import gzip

import numpy as np
from scipy.sparse import csr_array, csr_array, load_npz, coo_matrix
from scipy.io import mmread
import networkx as nx                                # light dep

import numpy as np
from scipy.sparse import load_npz, save_npz

from scipy.sparse import csr_array
from sbm.graph_data import GraphData

# src/sbm/io.py
@dataclass
class SBMFit:
    #blocks: dict[int, int]
    block_sizes: list[int]
    block_conn: csr_array
    directed_graph: bool # if undirected, only upper triangle is stored
    neg_loglike: float
    metadata: dict

class SBMWriter:
    @staticmethod
    def save(path: Path, fit: SBMFit) -> None:
        """ save SBM fit to file """
        path.mkdir(parents=True, exist_ok=True)
 
        #clean_blocks = {int(k): int(v) for k, v in fit.blocks.items()}
        clean_sizes  = [int(s) for s in fit.block_sizes]

        #(path / "blocks.json").write_text(json.dumps(clean_blocks))
        (path / "block_sizes.json").write_text(json.dumps(clean_sizes))

        # save sparce block connectivity matrix using scipy
        with open(path / "block_connectivity.npz", 'wb') as file:
            save_npz(file, fit.block_conn, compressed=True)

        (path / "directed_graph.txt").write_text(str(fit.directed_graph))
        (path / "neg_loglike.txt").write_text(str(fit.neg_loglike))
        with open(path / "metadata.json", 'w') as f:
            json.dump(fit.metadata, f)

    @staticmethod
    def load(path: Path) -> SBMFit:
        with open(path / "blocks.json", 'r') as blocks_file:
            blocks = json.load(blocks_file)
        blocks = {int(k): int(v) for k, v in blocks.items()}

        with open(path / "block_sizes.json", 'r') as sizes_file:
            block_sizes = json.load(sizes_file)
        block_sizes = [int(size) for size in block_sizes]

        with open(path / "block_connectivity.npz", 'rb') as conn_file:
            block_conn = load_npz(conn_file)

        directed_graph = path / "directed_graph.txt"
        directed_graph = (path / "directed_graph.txt").read_text().strip().lower() == 'true'
        neg_loglike = float((path / "neg_loglike.txt").read_text().strip())

        with open(path / "metadata.json", 'r') as f:
            metadata = json.load(f)

        return SBMFit(
            #blocks=blocks,
            block_sizes=block_sizes,
            block_conn=block_conn,
            directed_graph=directed_graph,
            neg_loglike=neg_loglike,
            metadata=metadata
        )

# ---------------------------------------------------------------------
#  GraphLoader
# ---------------------------------------------------------------------

class GraphLoader:
    """
    Factory that maps a file *extension* to a loader function and returns
    a `GraphData` object (CSR adjacency + directed flag).

    Register new loaders with the `@GraphLoader.register('.ext')`
    decorator.
    """

    # maps extension (lower-case, incl. leading dot) -> callable
    registry: Dict[str, Callable[[Path], Tuple[csr_array, bool]]] = {}

    # ----------------------- decorator -------------------------------
    @classmethod
    def register(cls, *exts: str):
        """
        Use as::

            @GraphLoader.register('.gml', '.graphml')
            def _load_graphml(path): ...
        """
        def decorator(fn: Callable[[Path], Tuple[csr_array, bool]]):
            for ext in exts:
                cls.registry[ext.lower()] = fn
            return fn
        return decorator

    # ----------------------- public API ------------------------------
    @staticmethod
    def load(
        path: Path,
        *,
        directed: Optional[bool] = None,
        force_undirected: Optional[bool] = None
    ) -> GraphData:
        """Load graph at *path* and return GraphData."""
        ext = path.suffix.lower()
        if ext not in GraphLoader.registry:
            raise ValueError(
                f"GraphLoader: no loader registered for extension '{ext}'."
            )
        adj, is_directed = GraphLoader.registry[ext](path)

        # allow caller to override detection
        if directed is not None:
            is_directed = bool(directed)

        # if caller wants undirected, symmetrise the adjacency matrix
        if force_undirected:
            if is_directed:
                print(f"GraphLoader: forcing undirected graph, symmetrising {path}.")
                adj = adj.maximum(adj.T)
            is_directed = False

        adj = csr_array(adj, dtype=np.int8)  # ensure type is int8
        return GraphData(adjacency_matrix=adj, directed=is_directed)

    # ---------------- default loaders -------------------------------

# 1. compressed / plain .npz containing a CSR adjacency ----------------
@GraphLoader.register(".npz")
def _load_npz(path: Path) -> Tuple[csr_array, bool]:
    adj = load_npz(path)
    directed = _is_directed(adj)
    return adj.tocsr(), directed


# 2. Matrix Market -----------------------------------------------------
@GraphLoader.register(".mtx")
def _load_mtx(path: Path) -> Tuple[csr_array, bool]:
    adj = mmread(str(path))
    adj = csr_array(adj, dtype=np.int8)

    directed = _is_directed(adj)
    return adj, directed


# 3. Plain edge list (.edges, .edgelist, .txt, optional .gz) -----------
@GraphLoader.register(".edges", ".edgelist", ".txt", ".gz")
def _load_edgelist(path: Path) -> Tuple[csr_array, bool]:
    opener = gzip.open if path.suffix == ".gz" else open
    rows, cols = [], []
    with opener(path, "rt") as f:
        for line in f:
            if not line.strip() or line.startswith("#"):
                continue
            u, v = map(int, line.split()[:2])
            rows.append(u)
            cols.append(v)
    n = max(rows + cols) + 1
    data = np.ones(len(rows), dtype=np.int8)
    adj = coo_matrix((data, (rows, cols)), shape=(n, n)).tocsr()

    directed = _is_directed(adj)
    if not directed:            # symmetrise if undirected
        adj = adj.maximum(adj.T)
    adj = csr_array(adj, dtype=np.int8)  # ensure type is int8
    return adj, directed


# 4. GML / GraphML via NetworkX ---------------------------------------
@GraphLoader.register(".gml", ".graphml")
def _load_graphml(path: Path) -> Tuple[csr_array, bool]:
    G = nx.read_gml(path) if path.suffix == ".gml" else nx.read_graphml(path)
    directed = G.is_directed()
    adj = nx.to_scipy_sparse_array(G, format="csr", dtype=np.int8)
    if not directed:
        adj = adj.maximum(adj.T)
    return adj, directed

# ---------------- helper ----------------------------------------------
def _is_directed(adj:  csr_array, tol: int = 0) -> bool:
    """
    Quick symmetric test for an unweighted adjacency.
    `tol` is an integer threshold: if more than `tol` entries differ,
    we declare the graph directed.
    """
    diff = adj - adj.T
    return diff.count_nonzero() > tol

================
File: src/sbm/model.py
================
from typing import Dict, Optional
import numpy as np
from scipy.sparse import csr_array

from sbm.block_data import BlockData
from sbm.likelihood import (
    LikelihoodCalculator,
    LikelihoodType,
)
from sbm.block_change_proposers import NodeSwapProposer
from sbm.node_mover import NodeMover
from sbm.mcmc import MCMCAlgorithm

from sbm.io import SBMFit, SBMWriter
from sbm.utils.logger import CSVLogger

class SBMModel:
    def __init__(self,
                initial_blocks: BlockData,
                rng: np.random.Generator,
                likelihood_type: LikelihoodType = "bernoulli",
                log: bool = True
        ):

        self._best_block_assignment = None
        self._best_block_conn = None

        self.block_data = initial_blocks

        self.rng = rng

        self.likelihood_calculator = LikelihoodCalculator(
            block_data=self.block_data,
            likelihood_type=likelihood_type
            )
        self.move_executor = NodeMover(
            block_data=self.block_data,
            )

        self.mcmc_algorithm = MCMCAlgorithm(
            block_data = self.block_data,
            likelihood_calculator = self.likelihood_calculator,
            change_proposer = {
                "swap": NodeSwapProposer(
                            block_data=self.block_data,
                            rng=self.rng,
                        )
                },
            rng = self.rng,
            log=log
        )

    def fit(self,
            num_iterations: int,
            min_block_size: int,
            initial_temperature: float,
            cooling_rate: float,
            max_blocks: Optional[int] = None,
            logger: Optional[CSVLogger] = None,
            ):

        self.mcmc_algorithm.fit(
            num_iterations=num_iterations,
            min_block_size=min_block_size,
            initial_temperature=initial_temperature,
            cooling_rate=cooling_rate,
            max_blocks=max_blocks,
            logger=logger,
        )

    def get_block_assignments(self, best:bool=True) -> Dict[int, int]:
        if best:
            return self.mcmc_algorithm._best_block_assignment
        else:
            return self.block_data.blocks
    
    def to_sbmfit(self, metadata: Optional[Dict] = None, best:bool=True) -> SBMFit:
        """ 
        Convert the fitted SBM model to an SBMFit object for serialization. 
        """
        if metadata is None:
            metadata = {}
        
        if best:
            blocks = self.mcmc_algorithm._best_block_assignment
            block_sizes = np.unique(list(blocks.values()), return_counts=True)[1].tolist()
            block_conn = self.mcmc_algorithm._best_block_conn
            ll = self.mcmc_algorithm.best_ll
        else:
            blocks = self.block_data.blocks
            block_sizes = list(self.block_data.block_sizes.values())
            block_conn = self.block_data.block_connectivity
            ll = self.mcmc_algorithm.current_ll

        return SBMFit(
            #blocks=blocks,
            block_sizes=block_sizes,
            block_conn=csr_array(block_conn),
            directed_graph=self.block_data.graph_data.directed,
            neg_loglike=ll,
            metadata=metadata
        )

================
File: src/sbm/node_mover.py
================
from typing import List, Tuple
import scipy.sparse as sp
import numpy as np
from sbm.block_data import BlockData, _BlockDataUpdater

from sbm.block_change_proposers import (
    ProposedValidChanges,
    EdgeDelta,
)

class NodeMover:
    """
    Class to move nodes between block assignment in the Stochastic Block Model (SBM).
    When performing a change, it updates the block sizes, connectivity matrix,
    block indices, and inverse block indices accordingly.
    All changes are performed in-place on the BlockData object by the _BlockDataUpdater.
    """
    def __init__(self, block_data: BlockData):
        self.block_data_updater = _BlockDataUpdater(block_data)

    def perform_change(self,
            proposed_changes: ProposedValidChanges,
            delta_e: EdgeDelta,
            ):
        """ 
        Change the block assignments of nodes according to the proposed change.
        Update:
        - block sizes
        - block connectivity matrix (edge counts between blocks)
        - block indices (node to block assignment)
        - inverse block indices (nodes in each block)

        Rely on increment_edge_count from BlockData to update edge counts.

        :param change: A list of tuples where each tuple contains a node and their new block.
        """

        (node_i, new_block_i), (node_j, new_block_j) = proposed_changes
        # update the block assignments, sizes, and memberships
        self.block_data_updater.move_node_to_block(node_i, new_block_i)
        self.block_data_updater.move_node_to_block(node_j, new_block_j)

        # update the edge counts between the blocks
        for (r, s), e_delta in delta_e.items():
            self.block_data_updater.increment_edge_count(r, s, e_delta)

================
File: src/sbm/sampling.py
================
""" 
Functions for sampling graph from SBM model
"""
from typing import List, Optional

import numpy as np
from scipy.sparse import csr_array
from sbm.graph_data import GraphData
from sbm.io import SBMFit

def sample_adjcency_matrix(
        block_sizes: List[int],
        block_connectivity: csr_array,
        directed: bool,
        rng: np.random.Generator
    ) -> csr_array:

    """
    Sample an adjacency matrix from a Stochastic Block Model (SBM) given block sizes and connectivity.    
    """
    adj = csr_array((sum(block_sizes), sum(block_sizes)), dtype=np.int8)

    # sample edges between blocks
    for r in range(len(block_sizes)):
        for s in range(r if not directed else 0, len(block_sizes)):
            e = block_connectivity[r, s]
            n = block_sizes[r] * block_sizes[s]

            if e < 0 or n < 0:
                raise ValueError(f"Invalid edge count {e} or possible pairs {n} for block pair ({r}, {s}).")
            if e > n:
                raise ValueError(f"Edge count {e} cannot be greater than possible pairs {n} for block pair ({r}, {s}).")

            # Sample edges
            if n > 0:
                sampled_edges = rng.choice(a=n, size=int(e), replace=False) # type: ignore

                row_indices = np.repeat(np.arange(block_sizes[r]), block_sizes[s])
                col_indices = np.tile(np.arange(block_sizes[s]), block_sizes[r])

                adj[row_indices[sampled_edges], col_indices[sampled_edges]] = 1

    return adj.tocsr()

def sample_sbm_graph(
            block_sizes: List[int],
            block_connectivity: csr_array,
            directed:bool,
            rng: np.random.Generator,
            metadata: Optional[dict] = None
    )->GraphData:
    """
    Sample a graph from a Stochastic Block Model (SBM) given block sizes and connectivity.
    :param block_sizes: List of sizes for each block.
    :param block_connectivity: Sparse matrix representing connectivity between blocks.
    :param directed: Whether the graph is directed or undirected.
    :param rng: Random number generator for reproducibility.
    :param metadata: Optional metadata to include in the graph data.

    :return: GraphData object containing the sampled graph.
    """

    if metadata is None:
        metadata = {}

    # Validate inputs
    if not isinstance(block_sizes, list) or not all(isinstance(size, int) for size in block_sizes):
        raise ValueError("block_sizes must be a list of integers.")
    if not isinstance(block_connectivity, csr_array):
        raise ValueError("block_connectivity must be a scipy.sparse.csr_array.")
    if len(block_sizes) != block_connectivity.shape[0] or len(block_sizes) != block_connectivity.shape[1]: #type: ignore
        raise ValueError("block_sizes length must match the dimensions of block_connectivity.")
    if not isinstance(directed, bool):
        raise ValueError("directed must be a boolean value.")
    if not isinstance(rng, np.random.Generator):
        raise ValueError("rng must be a numpy random Generator instance.")    

    adj = sample_adjcency_matrix(
        block_sizes=block_sizes,
        block_connectivity=block_connectivity,
        directed=directed,
        rng=rng
    )
    return GraphData(adjacency_matrix=adj, directed=directed)


def sample_sbm_graph_from_fit(sbm_fit: SBMFit, rng: np.random.Generator) -> GraphData:
    """
    Sample a graph from a Stochastic Block Model (SBM) fit.
    
    :param sbm_fit: SBMFit object containing block sizes and connectivity.
    :param rng: Random number generator for reproducibility.
    
    :return: GraphData object containing the sampled graph.
    """
    return sample_sbm_graph(
        block_sizes=sbm_fit.block_sizes,
        block_connectivity=sbm_fit.block_conn,
        directed=sbm_fit.directed_graph,
        rng=rng,
        metadata=sbm_fit.metadata
    )

================
File: src/tests/likelihood_test.py
================
# tests/test_likelihood.py
"""
End-to-end tests for the Bernoulli likelihood calculators.

 * We create a tiny 4-node undirected graph with two blocks.
 * We compare every  returned by the incremental code against the
   ground-truth global likelihood difference.
"""

from __future__ import annotations

from collections import Counter
from typing import Tuple, Dict

import numpy as np
import pytest
from scipy.sparse import csr_array

from sbm.likelihood import (
    compute_global_bernoulli_ll,
    LikelihoodCalculator
)

from sbm.block_data import BlockData
from sbm.graph_data import GraphData
from sbm.block_change_proposers import NodeSwapProposer 

##############################################################################
# Fixtures
##############################################################################


@pytest.fixture(scope="module")
def four_node_example() -> Tuple[BlockData, GraphData, Dict[int, int]]:
    """
    Graph:

        01   Block 0: {0,1}      Edges: (0,1)
             Block 1: {2,3}              (2,3)
        23                              (0,2) (1,3)

    The matrix is symmetrical (undirected, no loops).
    """
    adj = np.zeros((4, 4), dtype=int)
    edges = [(0, 1), (2, 3), (0, 2), (1, 3)]
    for u, v in edges:
        adj[u, v] = 1
        adj[v, u] = 1  # symmetric

    adjacency = csr_array(adj)
    blocks = {0: 0, 1: 0, 2: 1, 3: 1}  # Node to block mapping

    graph_data: GraphData = GraphData(adjacency_matrix=adjacency, directed=False)
    
    return BlockData(graph_data=graph_data, initial_blocks=blocks), graph_data, blocks


##############################################################################
# Tests
##############################################################################


def test_edge_counter(four_node_example):
    """`_compute_edge_counts_between_node_and_blocks` returns correct counts."""
    block_data, *_ = four_node_example
    change_proposer = NodeSwapProposer(block_data)

    counts = change_proposer._compute_edge_counts_between_node_and_blocks(node=0)
    # Node 0 is linked to node-1 (block-0) and node-2 (block-1)  {0:1, 1:1}
    assert counts == Counter({0: 1, 1: 1})


def test_swap_same_block_zero_delta(four_node_example):
    """
    Swapping two nodes that are *already* in the same block must leave the
    likelihood unchanged.
    """
    block_data, *_ = four_node_example
    swap_proposer = NodeSwapProposer(block_data)
    calc = LikelihoodCalculator(block_data)

    # attempt to swap nodes 0 and 2
    swap = [(0, block_data.blocks[1]), (1, block_data.blocks[0])]
    swap, delta_e, delta_n = swap_proposer.propose_change(swap)
    delta = calc.compute_delta_ll(delta_e=delta_e, delta_n=delta_n)

    assert delta == pytest.approx(0.0, abs=1e-6)


def test_delta_ll_matches_global_recompute(four_node_example):
    """
    delta ll from the incremental calculator must equal the brute-force recomputed
    likelihood difference after the swap (0  2).
    """
    block_data_old, graph_data, blocks_old = four_node_example
    adjacency = graph_data.adjacency
    swap_proposer = NodeSwapProposer(block_data_old)
    calc = LikelihoodCalculator(block_data_old)

    # ---------- perform swap 0  2 -----------------------------------------
    blocks_new = blocks_old.copy()
    blocks_new[0], blocks_new[2] = blocks_new[2], blocks_new[0]

    block_data_new = BlockData(
        graph_data=GraphData(adjacency_matrix=adjacency, directed=False),
        initial_blocks=blocks_new
    )

    ll_old = compute_global_bernoulli_ll(block_data_old)
    ll_new = compute_global_bernoulli_ll(block_data_new)
    expected_delta = ll_new - ll_old

    swap = [(0, block_data_old.blocks[2]), (2, block_data_old.blocks[0])]
    swap, delta_e, delta_n = swap_proposer.propose_change(swap)

    delta_calc = calc.compute_delta_ll(delta_e=delta_e, delta_n=delta_n)

    msg = (
        f"Failed on swap (0  2) with blocks {blocks_old}  {blocks_new}\n"
        f"delta_e: {delta_e}\n"
    )

    assert delta_calc == pytest.approx(expected_delta, rel=1e-6, abs=1e-6), msg


def test_delta_edge_counts_consistency(four_node_example):
    """
    The raw `delta_e` returned by `_compute_delta_edge_counts_swap` should turn
    the old connectivity into the new one *exactly* on every affected (r,s).
    """
    block_data_old, graph_data, blocks_old = four_node_example
    adjacency = graph_data.adjacency
    swap_proposer = NodeSwapProposer(block_data_old)
    calc = LikelihoodCalculator(block_data_old)

    i, j = 0, 2  # the same swap as above
    proposed_changes = [(i, block_data_old.blocks[j]), (j, block_data_old.blocks[i])]
    delta_e = swap_proposer._compute_delta_edge_counts(
        proposed_changes= proposed_changes
    )

    conn_expected = block_data_old.block_connectivity.copy()
    for (r, s), de in delta_e.items():
        conn_expected[r, s] += de

    # Ground-truth connectivity after the swap
    blocks_new = blocks_old.copy()
    blocks_new[i], blocks_new[j] = blocks_new[j], blocks_new[i]
    block_data_new = BlockData(
        graph_data=GraphData(adjacency_matrix=adjacency, directed=False),
        initial_blocks=blocks_new
    )

    for (r, s), de in delta_e.items():
        assert (
            conn_expected[r, s] == block_data_new.block_connectivity[r, s]
        ), f"Mismatch on block pair ({r},{s})"

###################################################
### Randomized tests
###################################################

def _er_graph_csr(n: int, p: float, *, seed: int) -> csr_array:
    """Undirected G(n,p) without self-loops, returned as CSR matrix."""
    rng = np.random.default_rng(seed)
    upper = rng.random((n, n)) < p                           # boolean mask
    upper = np.triu(upper, k=1)                              # keep strict upper
    adj = upper | upper.T                                    # symmetrise
    return csr_array(adj.astype(np.int8))

def _random_equal_blocks(n: int, block_size: int, *, seed: int) -> dict[int, int]:
    """Random permutation of vertices into equal-size blocks."""
    rng = np.random.default_rng(seed)
    perm = rng.permutation(n)
    blocks: dict[int, int] = {}
    for b in range(n // block_size):
        for v in perm[b * block_size : (b + 1) * block_size]:
            blocks[v] = b
    return blocks

def _pick_two_different_blocks(rng: np.random.Generator, blocks: dict[int, int]):
    n = len(blocks)
    i = rng.choice(n, size=1)[0]
    j = rng.choice(n-1, size=1)[0]
    if j >= i:
        j += 1
    
    return i, j

def _single_swap_calc_vs_bruteforce(
    graph_data: GraphData,
    blocks: dict[int, int],
    rng: np.random.Generator,
    tol: float = 1e-6,
    experiment_index: int = 0
):
    """One random swap and check incremental delta ll against brute force."""
    # choose vertices in different blocks
    i, j = _pick_two_different_blocks(rng, blocks)

    # incremental path -------------------------------------------------
    block_data = BlockData(graph_data=graph_data, initial_blocks=blocks)
    swap_proposer = NodeSwapProposer(block_data)
    calc = LikelihoodCalculator(block_data)

    swap_instr = [(i, blocks[j]), (j, blocks[i])]
    _, delta_e, delta_n = swap_proposer.propose_change(swap_instr)

    delta_ll = calc.compute_delta_ll(delta_e=delta_e, delta_n=delta_n)

    # brute-force path -------------------------------------------------
    ll_before = compute_global_bernoulli_ll(block_data)

    new_blocks = blocks.copy()
    new_blocks[i], new_blocks[j] = new_blocks[j], new_blocks[i]

    block_data_after = BlockData(graph_data=graph_data, initial_blocks=new_blocks)
    ll_after = compute_global_bernoulli_ll(block_data_after)
    delta_brute = ll_after - ll_before


    # compute the delta_e in the brute-force way
    # only storing non-zero deltas in upper triangular matrix
    delta_e_brute = block_data_after.block_connectivity - block_data.block_connectivity
    delta_e_brute = {
        (r, s): de for (r, s), de in zip(
            np.argwhere(delta_e_brute != 0),
            delta_e_brute[delta_e_brute != 0]
        )
        if r <= s
    }

    # comparison and print informatino in case of failure
    msg = (
        f"Failed on experiment {experiment_index}"
        f"\nGraph: {graph_data.adjacency.toarray()}"
        f"\nBlocks: {blocks}"
        f"\nswap:         {i} <-> {j} (blocks {blocks[i]} <-> {blocks[j]})"
        f"\ndelta_e:   {delta_e}"
        f"\ndelta_e_brute:   {delta_e_brute}"
        f"\ndelta_inc:    {delta_ll:.12g}"
        f"\ndelta_brute:  {delta_brute:.12g}"
    )

    assert delta_ll == pytest.approx(delta_brute, rel=tol, abs=tol), msg

def test_delta_ll_random_swaps_er():
    """100 random swaps on independent ER-20 graph must all match brute force delta ll."""
    for index in range(100):
        n, p, b = 20, 0.1, 2

        rng = np.random.default_rng(1)

        adj = _er_graph_csr(n, p, seed=42)
        graph = GraphData(adjacency_matrix=adj, directed=False)

        blocks = _random_equal_blocks(n, block_size=b, seed=2)

        _single_swap_calc_vs_bruteforce(graph_data=graph,
                                        blocks=blocks,
                                        rng=rng,
                                        experiment_index=index,
                                        tol=1e-6
                                        )

================
File: src/tests/planted_partition_tests.py
================
# src/tests/test_regressions.py
"""
Targeted regression tests for issues uncovered in the plantedpartition script.

* size-1 blocks must not crash likelihood computation
* -dicts must use *matrix indices*, not block-IDs
"""

import numpy as np
import pytest
from scipy.sparse import csr_array

from sbm.block_data import BlockData
from sbm.likelihood import compute_global_bernoulli_ll
from sbm.block_change_proposers import NodeSwapProposer
from sbm.block_data import BlockData
from sbm.graph_data import GraphData


# -------------------------------------------------------------------
# 1. size-1 diagonal must be ignored (or handled gracefully)
# -------------------------------------------------------------------
@pytest.mark.parametrize("singletons", [1, 3])
def test_singleton_blocks_allowed(singletons):
    """
    A partition containing blocks of size 1 must not raise or return NaN.
    """
    n = 6
    # make a path graph (any sparse graph works)
    rows = np.arange(n-1)
    cols = rows + 1
    data = np.ones(n-1, dtype=int)
    A = csr_array((data, (rows, cols)), shape=(n, n))
    A = A + A.T

    # put the first `singletons` nodes into their own blocks
    blocks = {v: v if v < singletons else singletons for v in range(n)}
    bd = BlockData(
        initial_blocks=blocks,
        graph_data=GraphData(adjacency_matrix=A, directed=False)
    )

    ll = compute_global_bernoulli_ll(bd)
    assert np.isfinite(ll), "likelihood should be finite even with size-1 blocks"


# -------------------------------------------------------------------
# 2. -dicts must reference matrix indices, not block-IDs
# -------------------------------------------------------------------
def test_delta_keys_are_matrix_indices():
    """
    When block IDs are non-contiguous (e.g. {0,10}), the delta_e keys
    must still be *matrix indices* (0 or 1), otherwise the likelihood
    updater crashes with an IndexError.
    """
    # two blocks with ids 0 and 10, one edge across
    adj = csr_array([[0,1],[1,0]])
    blocks = {0: 0, 1: 10}
    bd = BlockData(
        initial_blocks=blocks,
        graph_data=GraphData(adjacency_matrix=adj, directed=False)
    )

    proposer = NodeSwapProposer(bd)
    swap = [(0, 10)]  # move node 0 to block 10 -> will create a singleton & trigger 
    _, delta_e, _ = proposer.propose_change(swap)

    # the only valid matrix indices are 0 and 1
    valid = {0,1}
    for (r, s) in delta_e:
        assert r in valid and s in valid, (
            "delta_e must use matrix indices (0..B-1), "
            "not raw block IDs"
        )

================
File: src/tests/test_change_proposer_and_mover.py
================
# src/tests/test_change_proposers_and_mover.py
"""
Unit-tests for
   sbm.block_change_proposers           (helper + NodeSwapProposer)
   sbm.node_mover                      (NodeMover)

All graphs are 4 undirected vertices:

    01   block 0 = {0,1}
      
    23   block 1 = {2,3}

Edges: (0,1) (2,3)  plus two cross edges (0,2) (1,3).
"""

from __future__ import annotations

from collections import defaultdict
from typing import Dict, Tuple

import numpy as np
from numpy.typing import ArrayLike
import pytest
from scipy.sparse import csr_array

from sbm.graph_data import GraphData
from sbm.block_data import BlockData
from sbm.block_change_proposers import (
    _increment_delta_e,
    NodeSwapProposer,
    EdgeDelta,
    ProposedValidChanges,
)
from sbm.node_mover import NodeMover


###############################################################################
# helpers
###############################################################################
def _toy_graph() -> Tuple[csr_array, Dict[int, int]]:
    """Return 44 adjacency and initial {node: block} mapping."""
    adj = np.zeros((4, 4), dtype=int)
    edges = [(0, 1), (2, 3), (0, 2), (1, 3)]
    for u, v in edges:
        adj[u, v] = adj[v, u] = 1
    blocks = {0: 0, 1: 0, 2: 1, 3: 1}
    return csr_array(adj), blocks


def _brute_block_connectivity(adj: csr_array, blocks: Dict[int, int]) -> Dict[Tuple[int, int], int]:
    """Return upper-triangle edge counts between blocks."""
    rows, cols = adj.nonzero() # type: ignore
    bc = defaultdict(int)

    for u, v in zip(rows, cols, strict=False):
        if u >= v:  # count each undirected edge once
            continue
        a, b = blocks[u], blocks[v]
        r, s = (a, b) if a <= b else (b, a)
        bc[(r, s)] += 1
    return bc


###############################################################################
# tests for _increment_delta_e
###############################################################################
def test_increment_delta_e_uses_sorted_key() -> None:
    delta: EdgeDelta = defaultdict(int)
    _increment_delta_e(5, 3, 1, delta)          # block_i > block_j  key (1,3)
    assert (1, 3) in delta and (3, 1) not in delta, \
        f"Key mismatch: delta keys = {list(delta)}"


def test_increment_delta_e_overwrites_existing() -> None:
    delta: EdgeDelta = defaultdict(int)
    _increment_delta_e(1, 0, 2, delta)          # set to 1
    _increment_delta_e(3, 2, 0, delta)          # overwrite same pair
    assert delta[(0, 2)] == 3, \
        f"Value not overwritten, got {delta[(0, 2)]}, expected 3"


###############################################################################
# tests for NodeSwapProposer
###############################################################################
@pytest.fixture(scope="module")
def proposer() -> NodeSwapProposer:
    adj, blocks = _toy_graph()
    bd = BlockData(initial_blocks=blocks, graph_data=GraphData(adj, directed=False))
    return NodeSwapProposer(block_data=bd, rng=np.random.default_rng(0))


def test_compute_delta_edge_counts_matches_brute(proposer: NodeSwapProposer) -> None:
    # swap vertices 0 (block 0) and 2 (block 1)
    changes: ProposedValidChanges = [(0, 1), (2, 0)]
    delta = proposer._compute_delta_edge_counts(changes)          # type: ignore

    before = _brute_block_connectivity(proposer.block_data.graph_data.adjacency,
                                       proposer.block_data.blocks)
    # build new blocks mapping
    new_blocks = proposer.block_data.blocks.copy()
    new_blocks[0], new_blocks[2] = new_blocks[2], new_blocks[0]
    after = _brute_block_connectivity(proposer.block_data.graph_data.adjacency,
                                      new_blocks)

    brute_delta = {k: after.get(k, 0) - before.get(k, 0) for k in set(after) | set(before)}
    assert delta == brute_delta, \
        f"\nexpected {brute_delta}\ngot      {delta}"


def test_propose_change_returns_expected_structure(proposer: NodeSwapProposer) -> None:
    changes = [(0, 1), (2, 0)]
    new_changes, delta_e, delta_n = proposer.propose_change(changes=changes)
    assert new_changes == changes, "proposer changed explicit instruction"
    assert all(isinstance(k, tuple) and len(k) == 2 for k in delta_e), "delta_e keys malformed"
    assert delta_n and set(delta_e) == set(delta_n), "delta_n missing / mismatched"


###############################################################################
# tests for NodeMover
###############################################################################
def test_node_mover_updates_blocks_and_sizes() -> None:
    adj, blocks = _toy_graph()
    bd = BlockData(initial_blocks=blocks, graph_data=GraphData(adj, directed=False))
    mover = NodeMover(bd)

    changes = [(0, 1), (2, 0)]
    # reuse proposer to get correct delta_e
    prop = NodeSwapProposer(block_data=bd, rng=np.random.default_rng(0))
    delta_e = prop._compute_delta_edge_counts(changes)            # type: ignore

    mover.perform_change(changes, delta_e)

    assert bd.blocks[0] == 1 and bd.blocks[2] == 0, \
        f"blocks not swapped: {bd.blocks}"
    assert bd.block_sizes[0] == 2 and bd.block_sizes[1] == 2, \
        f"block_sizes wrong: {bd.block_sizes}"


def test_node_mover_updates_connectivity() -> None:
    adj, blocks = _toy_graph()
    bd = BlockData(initial_blocks=blocks, graph_data=GraphData(adj, directed=False))
    mover = NodeMover(bd)

    before = bd.block_connectivity.copy()
    changes = [(0, 1), (2, 0)]
    prop = NodeSwapProposer(block_data=bd, rng=np.random.default_rng(0))
    delta_e = prop._compute_delta_edge_counts(changes)            # type: ignore
    mover.perform_change(changes, delta_e)

    # brute recompute
    after_brute = _brute_block_connectivity(bd.graph_data.adjacency, bd.blocks)
    # connectivity matrix stores both triangles  pick upper
    after_matrix = {(r, s): int(bd.block_connectivity[r, s]) #type: ignore
                    for r, s in after_brute}

    msg = (f"\nexpected connectivity {after_brute}"
           f"\nobserved  connectivity {after_matrix}"
           f"\ndelta_e applied        {delta_e}")
    assert after_matrix == after_brute, msg

================
File: src/tests/test_io.py
================
# tests/test_io.py
import json
from pathlib import Path

import numpy as np
import scipy.sparse as sp
from scipy.io import mmwrite
import networkx as nx
import pytest

from sbm.io import SBMFit, SBMWriter, GraphLoader


# ---------------------------------------------------------------------
# helpers
# ---------------------------------------------------------------------
def _simple_adj(undirected: bool = True) -> sp.csr_array:
    """
    3-node graph:
        0  1   and  (optionally) 1  2
    """
    rows, cols = [0, 1], [1, 0]            # 01 edge
    if not undirected:
        rows.append(1); cols.append(2)     # add 12 (makes it directed)
    data = np.ones(len(rows), dtype=np.int8)

    return sp.csr_array(sp.coo_matrix((data, (rows, cols)), shape=(3, 3)))


def _assert_same_csr(a: sp.csr_array, b: sp.csr_array):
    a.sort_indices()
    b.sort_indices()

    assert np.array_equal(a.data, b.data), f'Data arrays differ: {a.data} != {b.data}'
    assert np.array_equal(a.indices, b.indices), f'Indices differ: {a.indices} != {b.indices}'
    assert a.shape == b.shape, f'Shape differs: {a.shape} != {b.shape}'

# ---------------------------------------------------------------------
# 1. SBMWriter round-trip
# ---------------------------------------------------------------------
def test_sbmwriter_roundtrip(tmp_path: Path):
    # --- build a tiny SBMFit ----------------------------------------
    adj = _simple_adj()
    blocks = {0: 0, 1: 0, 2: 1}
    fit = SBMFit(
        blocks        = blocks,
        block_sizes   = [2, 1],
        block_conn    = sp.csr_array([[1, .2],[.2, .1]]),
        directed_graph= False,
        neg_loglike   = -12.34,
        metadata      = {"foo": "bar"},
    )

    # --- save & load ------------------------------------------------
    SBMWriter.save(tmp_path, fit)
    fit2 = SBMWriter.load(tmp_path)

    # basic checks
    assert fit2.blocks == blocks, f"Blocks do not match: {fit2.blocks} != {blocks}"
    assert fit2.block_sizes == [2, 1], f"Block sizes do not match: {fit2.block_sizes} != [2, 1]"
    _assert_same_csr(fit.block_conn, fit2.block_conn)
    assert fit2.neg_loglike == pytest.approx(fit.neg_loglike), "Negative log-likelihood does not match"
    assert fit2.metadata["foo"] == "bar", "Metadata does not match"

# ---------------------------------------------------------------------
# 2. GraphLoader built-in formats
# ---------------------------------------------------------------------
@pytest.mark.parametrize("undirected", [True, False])
def test_graphloader_npz(tmp_path: Path, undirected: bool):
    adj = _simple_adj(undirected)
    f = tmp_path / "g.npz"
    sp.save_npz(f, adj)
    g = GraphLoader.load(f)
    _assert_same_csr(adj, g.adjacency)
    assert g.directed == (not undirected)


def test_graphloader_edges(tmp_path: Path):
    # plain edge list (space-sep)
    f = tmp_path / "toy.edges"
    f.write_text("0 1\n1 2\n")  # unsymmetrised  directed
    g = GraphLoader.load(f)
    assert g.directed
    assert g.num_nodes == 3
    assert g.adjacency[1, 2] == 1


def test_graphloader_mtx(tmp_path: Path):
    adj = _simple_adj()
    f = tmp_path / "toy.mtx"
    mmwrite(str(f), adj)
    g = GraphLoader.load(f)
    _assert_same_csr(adj, g.adjacency)
    assert not g.directed


def test_graphloader_gml(tmp_path: Path):
    # build with networkx
    G = nx.Graph()
    G.add_edge(0, 1); G.add_edge(1, 2)
    f = tmp_path / "toy.gml"
    nx.write_gml(G, f)
    g = GraphLoader.load(f)
    assert not g.directed
    assert g.adjacency.nnz == 4      # undirected  2 edges 2


# ---------------------------------------------------------------------
# 3. Registry decorator sanity check
# ---------------------------------------------------------------------
def test_register_new_loader(tmp_path: Path):
    # create a fake extension ".foo"
    ext = ".foo"

    @GraphLoader.register(ext)
    def _load_foo(path: Path):
        # loader that ignores content, returns 2-node edge
        rows, cols = [0], [1]
        adj = sp.coo_matrix((np.ones(1, int), (rows, cols)), shape=(2, 2)).tocsr()
        return adj, True

    # create dummy file and load
    f = tmp_path / f"dummy{ext}"
    f.write_text("ignored")
    g = GraphLoader.load(f)
    assert g.directed
    assert g.adjacency[0, 1] == 1
    assert f.suffix.lower() in GraphLoader.registry

================
File: src/tests/test_metrics.py
================
import numpy as np, scipy.sparse as sp
from scipy.sparse import csr_array
from metrics import (
    shortest_path_distance,
    degree_distance,
    clustering_distance
)
### Helper functions to create graphs
def _line_graph(n=6) -> csr_array:
    rows = np.arange(n-1); cols = rows + 1
    A = sp.coo_matrix((np.ones(n-1), (rows, cols)), shape=(n, n))
    A = A + A.T
    A = csr_array(A, dtype=np.int8)
    return A

def _er_graph(n: int=10, p: float=0.1, *, seed: int=1) -> csr_array:
    """Undirected G(n,p) without self-loops, returned as CSR matrix."""
    rng = np.random.default_rng(seed)
    upper = rng.random((n, n)) < p                           # boolean mask
    upper = np.triu(upper, k=1)                              # keep strict upper
    adj = upper | upper.T                                    # symmetrise
    return csr_array(adj.astype(np.int8))

#### test functions
def test_shortest_path_identical_line():
    A = _line_graph()
    assert shortest_path_distance(A, A) == 0.0

def test_degree_identical_line():
    A = _line_graph()
    assert degree_distance(A, A) == 0.0

def test_clustering_identical_line():
    A = _line_graph()
    assert clustering_distance(A, A) == 0.0

def test_shortest_path_different_line():
    A = _line_graph(n=20)
    B = _line_graph(n=200)

    assert shortest_path_distance(A, B, n_samples=100) != 0.0

def test_degree_different_line():
    A = _line_graph(n=20)
    A = _line_graph(n=200)
    assert degree_distance(A, A) == 0.0

def test_clustering_identical_er():
    A = _er_graph(n=100)
    assert clustering_distance(A, A) == 0.0

def test_shortest_path_identical_er():
    A = _er_graph(p=0.9)
    assert shortest_path_distance(A, A) == 0.0

def test_shortest_path_different_er():
    A = _er_graph(n=20, p=0.9)
    B = _er_graph(n=200, p=0.1)

    assert shortest_path_distance(A, B, n_samples=100) != 0.0

def test_degree_different_er():
    A = _er_graph()
    assert degree_distance(A, A) == 0.0

def test_clustering_different_er():
    A = _er_graph()
    assert clustering_distance(A, A) == 0.0

================
File: pyproject.toml
================
[build-system]
requires = ["setuptools", "wheel"]
build-backend = "setuptools.build_meta"

================
File: setup.cfg
================
[metadata]
name = anon-sbm
version = 0.1.0
author = Lasse Mohr
author_email = lmmi@dtu.dk
description = Package for SBM with minimum group-size constraints
long_description = file: README.md
long_description_content_type = text/markdown
url = https://github.com/your-repo-url
classifiers =
    Programming Language :: Python :: 3
    License :: OSI Approved :: MIT License
    Operating System :: OS Independent

[options]
package_dir =
    =src
packages = find:
python_requires = >=3.7
install_requires =
    numpy
    scipy

[options.packages.find]
where = src

================
File: notebooks/likelihood_test.ipynb
================
{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import scipy.sparse as sp\n",
    "from sbm.sbm import StochasticBlockModel"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [],
   "source": [
    "num_nodes = 1000\n",
    "block_size = 50\n",
    "# Generate a random sparse adjacency matrix\n",
    "adjacency = sp.random(num_nodes, num_nodes, density=0.01, format='csr')\n",
    "adjacency = adjacency + adjacency.T  # Make it symmetric\n",
    "adjacency.data = np.ones_like(adjacency.data)  # Unweighted graph\n",
    "\n",
    "# Create an initial uniform random partition\n",
    "initial_blocks = StochasticBlockModel.create_uniform_partition(num_nodes, block_size)\n",
    "\n",
    "# Initialize the SBM\n",
    "sbm = StochasticBlockModel(adjacency, initial_blocks)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Initial Likelihood: -110207.47925966672\n"
     ]
    }
   ],
   "source": [
    "# Compute the initial likelihood\n",
    "initial_likelihood = sbm.compute_likelihood()\n",
    "print(f\"Initial Likelihood: {initial_likelihood}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True]\n"
     ]
    }
   ],
   "source": [
    "block_0 = sbm.block_members[0]\n",
    "sbm.split_block(0)\n",
    "\n",
    "test = [elem in block_0 for elem in sbm.block_members[0]]\n",
    "print(test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True]\n"
     ]
    }
   ],
   "source": [
    "block_1, block_2 = sbm.block_members[1], sbm.block_members[2]\n",
    "\n",
    "sbm.merge_blocks(1, 2)\n",
    "\n",
    "test = [elem in sbm.block_members[1] for elem in block_1] + [elem in sbm.block_members[1] for elem in block_2]\n",
    "print(test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "metadata": {},
   "outputs": [],
   "source": [
    "sbm.split_block(0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "dict_keys([3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 26])"
      ]
     },
     "execution_count": 63,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sbm.block_members.keys()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{3: [361,\n",
       "  569,\n",
       "  298,\n",
       "  110,\n",
       "  288,\n",
       "  972,\n",
       "  595,\n",
       "  10,\n",
       "  67,\n",
       "  436,\n",
       "  281,\n",
       "  52,\n",
       "  476,\n",
       "  791,\n",
       "  760,\n",
       "  388,\n",
       "  926,\n",
       "  928,\n",
       "  45,\n",
       "  40,\n",
       "  393,\n",
       "  474,\n",
       "  237,\n",
       "  226,\n",
       "  814,\n",
       "  447,\n",
       "  884,\n",
       "  833,\n",
       "  62,\n",
       "  834,\n",
       "  387,\n",
       "  448,\n",
       "  788,\n",
       "  179,\n",
       "  801,\n",
       "  318,\n",
       "  64,\n",
       "  629,\n",
       "  968,\n",
       "  911,\n",
       "  568,\n",
       "  450,\n",
       "  735,\n",
       "  1,\n",
       "  410,\n",
       "  30,\n",
       "  389,\n",
       "  215,\n",
       "  478,\n",
       "  319],\n",
       " 4: [202,\n",
       "  787,\n",
       "  255,\n",
       "  502,\n",
       "  242,\n",
       "  827,\n",
       "  402,\n",
       "  256,\n",
       "  584,\n",
       "  547,\n",
       "  579,\n",
       "  739,\n",
       "  282,\n",
       "  697,\n",
       "  135,\n",
       "  342,\n",
       "  636,\n",
       "  377,\n",
       "  118,\n",
       "  722,\n",
       "  915,\n",
       "  685,\n",
       "  397,\n",
       "  341,\n",
       "  416,\n",
       "  612,\n",
       "  491,\n",
       "  392,\n",
       "  941,\n",
       "  668,\n",
       "  148,\n",
       "  370,\n",
       "  247,\n",
       "  734,\n",
       "  991,\n",
       "  619,\n",
       "  262,\n",
       "  351,\n",
       "  628,\n",
       "  864,\n",
       "  337,\n",
       "  845,\n",
       "  752,\n",
       "  244,\n",
       "  903,\n",
       "  606,\n",
       "  269,\n",
       "  898,\n",
       "  780,\n",
       "  716],\n",
       " 5: [352,\n",
       "  210,\n",
       "  473,\n",
       "  807,\n",
       "  676,\n",
       "  353,\n",
       "  534,\n",
       "  813,\n",
       "  88,\n",
       "  58,\n",
       "  198,\n",
       "  715,\n",
       "  519,\n",
       "  945,\n",
       "  264,\n",
       "  357,\n",
       "  53,\n",
       "  934,\n",
       "  877,\n",
       "  217,\n",
       "  437,\n",
       "  653,\n",
       "  746,\n",
       "  737,\n",
       "  461,\n",
       "  953,\n",
       "  458,\n",
       "  346,\n",
       "  414,\n",
       "  329,\n",
       "  902,\n",
       "  106,\n",
       "  295,\n",
       "  695,\n",
       "  480,\n",
       "  994,\n",
       "  206,\n",
       "  592,\n",
       "  44,\n",
       "  171,\n",
       "  876,\n",
       "  105,\n",
       "  758,\n",
       "  57,\n",
       "  128,\n",
       "  7,\n",
       "  811,\n",
       "  145,\n",
       "  985,\n",
       "  977],\n",
       " 6: [229,\n",
       "  394,\n",
       "  656,\n",
       "  744,\n",
       "  935,\n",
       "  333,\n",
       "  407,\n",
       "  736,\n",
       "  546,\n",
       "  553,\n",
       "  221,\n",
       "  982,\n",
       "  914,\n",
       "  101,\n",
       "  230,\n",
       "  406,\n",
       "  872,\n",
       "  266,\n",
       "  285,\n",
       "  325,\n",
       "  582,\n",
       "  562,\n",
       "  222,\n",
       "  924,\n",
       "  78,\n",
       "  970,\n",
       "  899,\n",
       "  729,\n",
       "  869,\n",
       "  77,\n",
       "  908,\n",
       "  510,\n",
       "  713,\n",
       "  9,\n",
       "  593,\n",
       "  279,\n",
       "  429,\n",
       "  721,\n",
       "  933,\n",
       "  860,\n",
       "  375,\n",
       "  334,\n",
       "  750,\n",
       "  849,\n",
       "  524,\n",
       "  225,\n",
       "  241,\n",
       "  803,\n",
       "  759,\n",
       "  669],\n",
       " 7: [92,\n",
       "  196,\n",
       "  770,\n",
       "  530,\n",
       "  740,\n",
       "  189,\n",
       "  777,\n",
       "  699,\n",
       "  144,\n",
       "  463,\n",
       "  404,\n",
       "  270,\n",
       "  890,\n",
       "  320,\n",
       "  315,\n",
       "  403,\n",
       "  310,\n",
       "  350,\n",
       "  802,\n",
       "  293,\n",
       "  29,\n",
       "  587,\n",
       "  846,\n",
       "  852,\n",
       "  86,\n",
       "  453,\n",
       "  523,\n",
       "  249,\n",
       "  939,\n",
       "  34,\n",
       "  912,\n",
       "  0,\n",
       "  776,\n",
       "  812,\n",
       "  340,\n",
       "  512,\n",
       "  187,\n",
       "  672,\n",
       "  677,\n",
       "  190,\n",
       "  878,\n",
       "  893,\n",
       "  605,\n",
       "  411,\n",
       "  228,\n",
       "  665,\n",
       "  751,\n",
       "  439,\n",
       "  5,\n",
       "  844],\n",
       " 8: [795,\n",
       "  943,\n",
       "  212,\n",
       "  978,\n",
       "  347,\n",
       "  71,\n",
       "  48,\n",
       "  292,\n",
       "  155,\n",
       "  608,\n",
       "  997,\n",
       "  576,\n",
       "  449,\n",
       "  990,\n",
       "  36,\n",
       "  895,\n",
       "  979,\n",
       "  778,\n",
       "  154,\n",
       "  494,\n",
       "  529,\n",
       "  542,\n",
       "  303,\n",
       "  560,\n",
       "  471,\n",
       "  385,\n",
       "  901,\n",
       "  124,\n",
       "  180,\n",
       "  850,\n",
       "  631,\n",
       "  769,\n",
       "  137,\n",
       "  462,\n",
       "  307,\n",
       "  263,\n",
       "  89,\n",
       "  805,\n",
       "  428,\n",
       "  424,\n",
       "  892,\n",
       "  390,\n",
       "  63,\n",
       "  19,\n",
       "  782,\n",
       "  267,\n",
       "  917,\n",
       "  773,\n",
       "  465,\n",
       "  842],\n",
       " 9: [76,\n",
       "  733,\n",
       "  49,\n",
       "  43,\n",
       "  614,\n",
       "  885,\n",
       "  618,\n",
       "  164,\n",
       "  423,\n",
       "  117,\n",
       "  516,\n",
       "  565,\n",
       "  166,\n",
       "  771,\n",
       "  717,\n",
       "  859,\n",
       "  691,\n",
       "  159,\n",
       "  495,\n",
       "  153,\n",
       "  678,\n",
       "  227,\n",
       "  692,\n",
       "  981,\n",
       "  181,\n",
       "  857,\n",
       "  126,\n",
       "  950,\n",
       "  55,\n",
       "  622,\n",
       "  129,\n",
       "  731,\n",
       "  554,\n",
       "  556,\n",
       "  220,\n",
       "  162,\n",
       "  238,\n",
       "  925,\n",
       "  309,\n",
       "  662,\n",
       "  673,\n",
       "  831,\n",
       "  72,\n",
       "  107,\n",
       "  815,\n",
       "  514,\n",
       "  706,\n",
       "  847,\n",
       "  233,\n",
       "  467],\n",
       " 10: [308,\n",
       "  186,\n",
       "  489,\n",
       "  959,\n",
       "  658,\n",
       "  362,\n",
       "  223,\n",
       "  862,\n",
       "  659,\n",
       "  484,\n",
       "  536,\n",
       "  757,\n",
       "  969,\n",
       "  18,\n",
       "  825,\n",
       "  332,\n",
       "  306,\n",
       "  840,\n",
       "  660,\n",
       "  602,\n",
       "  684,\n",
       "  188,\n",
       "  613,\n",
       "  590,\n",
       "  820,\n",
       "  324,\n",
       "  443,\n",
       "  627,\n",
       "  586,\n",
       "  766,\n",
       "  69,\n",
       "  830,\n",
       "  942,\n",
       "  419,\n",
       "  798,\n",
       "  946,\n",
       "  65,\n",
       "  644,\n",
       "  79,\n",
       "  604,\n",
       "  121,\n",
       "  74,\n",
       "  971,\n",
       "  381,\n",
       "  81,\n",
       "  100,\n",
       "  932,\n",
       "  531,\n",
       "  232,\n",
       "  466],\n",
       " 11: [762,\n",
       "  355,\n",
       "  955,\n",
       "  451,\n",
       "  904,\n",
       "  109,\n",
       "  749,\n",
       "  621,\n",
       "  689,\n",
       "  231,\n",
       "  626,\n",
       "  305,\n",
       "  167,\n",
       "  98,\n",
       "  938,\n",
       "  37,\n",
       "  427,\n",
       "  284,\n",
       "  793,\n",
       "  958,\n",
       "  724,\n",
       "  312,\n",
       "  848,\n",
       "  415,\n",
       "  528,\n",
       "  867,\n",
       "  645,\n",
       "  158,\n",
       "  661,\n",
       "  954,\n",
       "  920,\n",
       "  354,\n",
       "  910,\n",
       "  59,\n",
       "  965,\n",
       "  208,\n",
       "  441,\n",
       "  358,\n",
       "  623,\n",
       "  54,\n",
       "  497,\n",
       "  966,\n",
       "  112,\n",
       "  125,\n",
       "  532,\n",
       "  379,\n",
       "  365,\n",
       "  138,\n",
       "  634,\n",
       "  214],\n",
       " 12: [797,\n",
       "  719,\n",
       "  975,\n",
       "  603,\n",
       "  540,\n",
       "  507,\n",
       "  610,\n",
       "  879,\n",
       "  870,\n",
       "  302,\n",
       "  594,\n",
       "  609,\n",
       "  574,\n",
       "  199,\n",
       "  693,\n",
       "  703,\n",
       "  666,\n",
       "  422,\n",
       "  278,\n",
       "  775,\n",
       "  219,\n",
       "  84,\n",
       "  654,\n",
       "  317,\n",
       "  321,\n",
       "  420,\n",
       "  17,\n",
       "  573,\n",
       "  843,\n",
       "  201,\n",
       "  525,\n",
       "  224,\n",
       "  816,\n",
       "  207,\n",
       "  783,\n",
       "  435,\n",
       "  725,\n",
       "  360,\n",
       "  518,\n",
       "  80,\n",
       "  561,\n",
       "  11,\n",
       "  948,\n",
       "  694,\n",
       "  493,\n",
       "  103,\n",
       "  923,\n",
       "  70,\n",
       "  268,\n",
       "  290],\n",
       " 13: [13,\n",
       "  989,\n",
       "  929,\n",
       "  374,\n",
       "  195,\n",
       "  236,\n",
       "  446,\n",
       "  39,\n",
       "  973,\n",
       "  625,\n",
       "  161,\n",
       "  630,\n",
       "  464,\n",
       "  682,\n",
       "  345,\n",
       "  768,\n",
       "  680,\n",
       "  549,\n",
       "  455,\n",
       "  192,\n",
       "  633,\n",
       "  23,\n",
       "  20,\n",
       "  883,\n",
       "  589,\n",
       "  533,\n",
       "  87,\n",
       "  475,\n",
       "  996,\n",
       "  947,\n",
       "  686,\n",
       "  283,\n",
       "  384,\n",
       "  376,\n",
       "  259,\n",
       "  323,\n",
       "  326,\n",
       "  274,\n",
       "  165,\n",
       "  398,\n",
       "  781,\n",
       "  747,\n",
       "  149,\n",
       "  838,\n",
       "  240,\n",
       "  598,\n",
       "  741,\n",
       "  204,\n",
       "  700,\n",
       "  457],\n",
       " 14: [301,\n",
       "  804,\n",
       "  964,\n",
       "  504,\n",
       "  616,\n",
       "  921,\n",
       "  409,\n",
       "  600,\n",
       "  413,\n",
       "  949,\n",
       "  819,\n",
       "  861,\n",
       "  291,\n",
       "  211,\n",
       "  75,\n",
       "  432,\n",
       "  425,\n",
       "  753,\n",
       "  772,\n",
       "  742,\n",
       "  82,\n",
       "  674,\n",
       "  643,\n",
       "  607,\n",
       "  765,\n",
       "  460,\n",
       "  500,\n",
       "  400,\n",
       "  889,\n",
       "  683,\n",
       "  940,\n",
       "  839,\n",
       "  513,\n",
       "  177,\n",
       "  408,\n",
       "  248,\n",
       "  790,\n",
       "  97,\n",
       "  131,\n",
       "  544,\n",
       "  234,\n",
       "  578,\n",
       "  250,\n",
       "  980,\n",
       "  873,\n",
       "  687,\n",
       "  42,\n",
       "  541,\n",
       "  710,\n",
       "  663],\n",
       " 15: [197,\n",
       "  380,\n",
       "  28,\n",
       "  728,\n",
       "  134,\n",
       "  254,\n",
       "  8,\n",
       "  566,\n",
       "  216,\n",
       "  962,\n",
       "  314,\n",
       "  277,\n",
       "  6,\n",
       "  708,\n",
       "  829,\n",
       "  796,\n",
       "  701,\n",
       "  515,\n",
       "  779,\n",
       "  114,\n",
       "  2,\n",
       "  368,\n",
       "  832,\n",
       "  287,\n",
       "  823,\n",
       "  763,\n",
       "  642,\n",
       "  243,\n",
       "  66,\n",
       "  15,\n",
       "  535,\n",
       "  272,\n",
       "  391,\n",
       "  548,\n",
       "  205,\n",
       "  983,\n",
       "  858,\n",
       "  808,\n",
       "  265,\n",
       "  720,\n",
       "  26,\n",
       "  327,\n",
       "  570,\n",
       "  709,\n",
       "  527,\n",
       "  789,\n",
       "  868,\n",
       "  581,\n",
       "  151,\n",
       "  421],\n",
       " 16: [647,\n",
       "  956,\n",
       "  111,\n",
       "  47,\n",
       "  418,\n",
       "  469,\n",
       "  937,\n",
       "  688,\n",
       "  356,\n",
       "  289,\n",
       "  615,\n",
       "  286,\n",
       "  170,\n",
       "  617,\n",
       "  511,\n",
       "  986,\n",
       "  313,\n",
       "  364,\n",
       "  896,\n",
       "  974,\n",
       "  119,\n",
       "  22,\n",
       "  133,\n",
       "  987,\n",
       "  163,\n",
       "  679,\n",
       "  431,\n",
       "  483,\n",
       "  550,\n",
       "  738,\n",
       "  517,\n",
       "  712,\n",
       "  818,\n",
       "  963,\n",
       "  897,\n",
       "  261,\n",
       "  564,\n",
       "  96,\n",
       "  539,\n",
       "  828,\n",
       "  863,\n",
       "  916,\n",
       "  41,\n",
       "  294,\n",
       "  132,\n",
       "  299,\n",
       "  652,\n",
       "  336,\n",
       "  718,\n",
       "  168],\n",
       " 17: [675,\n",
       "  73,\n",
       "  25,\n",
       "  276,\n",
       "  809,\n",
       "  386,\n",
       "  127,\n",
       "  257,\n",
       "  442,\n",
       "  331,\n",
       "  245,\n",
       "  417,\n",
       "  786,\n",
       "  572,\n",
       "  891,\n",
       "  995,\n",
       "  485,\n",
       "  113,\n",
       "  456,\n",
       "  841,\n",
       "  412,\n",
       "  152,\n",
       "  235,\n",
       "  481,\n",
       "  599,\n",
       "  338,\n",
       "  596,\n",
       "  646,\n",
       "  650,\n",
       "  824,\n",
       "  396,\n",
       "  330,\n",
       "  316,\n",
       "  24,\n",
       "  745,\n",
       "  454,\n",
       "  115,\n",
       "  707,\n",
       "  784,\n",
       "  61,\n",
       "  952,\n",
       "  508,\n",
       "  498,\n",
       "  184,\n",
       "  866,\n",
       "  213,\n",
       "  927,\n",
       "  150,\n",
       "  900,\n",
       "  558],\n",
       " 18: [648,\n",
       "  999,\n",
       "  624,\n",
       "  203,\n",
       "  146,\n",
       "  182,\n",
       "  585,\n",
       "  704,\n",
       "  906,\n",
       "  670,\n",
       "  482,\n",
       "  984,\n",
       "  785,\n",
       "  503,\n",
       "  486,\n",
       "  296,\n",
       "  239,\n",
       "  875,\n",
       "  252,\n",
       "  492,\n",
       "  537,\n",
       "  99,\n",
       "  335,\n",
       "  957,\n",
       "  200,\n",
       "  506,\n",
       "  108,\n",
       "  193,\n",
       "  588,\n",
       "  359,\n",
       "  657,\n",
       "  373,\n",
       "  94,\n",
       "  60,\n",
       "  960,\n",
       "  366,\n",
       "  14,\n",
       "  3,\n",
       "  810,\n",
       "  951,\n",
       "  583,\n",
       "  142,\n",
       "  761,\n",
       "  637,\n",
       "  505,\n",
       "  711,\n",
       "  339,\n",
       "  35,\n",
       "  851,\n",
       "  743],\n",
       " 19: [50,\n",
       "  349,\n",
       "  156,\n",
       "  853,\n",
       "  251,\n",
       "  620,\n",
       "  160,\n",
       "  822,\n",
       "  275,\n",
       "  4,\n",
       "  792,\n",
       "  767,\n",
       "  472,\n",
       "  577,\n",
       "  907,\n",
       "  580,\n",
       "  723,\n",
       "  611,\n",
       "  147,\n",
       "  992,\n",
       "  172,\n",
       "  998,\n",
       "  348,\n",
       "  521,\n",
       "  575,\n",
       "  21,\n",
       "  651,\n",
       "  854,\n",
       "  591,\n",
       "  176,\n",
       "  837,\n",
       "  918,\n",
       "  635,\n",
       "  571,\n",
       "  976,\n",
       "  56,\n",
       "  826,\n",
       "  174,\n",
       "  311,\n",
       "  271,\n",
       "  496,\n",
       "  913,\n",
       "  855,\n",
       "  557,\n",
       "  139,\n",
       "  209,\n",
       "  552,\n",
       "  369,\n",
       "  638,\n",
       "  218],\n",
       " 20: [748,\n",
       "  690,\n",
       "  545,\n",
       "  756,\n",
       "  95,\n",
       "  730,\n",
       "  649,\n",
       "  405,\n",
       "  526,\n",
       "  993,\n",
       "  130,\n",
       "  399,\n",
       "  426,\n",
       "  764,\n",
       "  300,\n",
       "  440,\n",
       "  477,\n",
       "  655,\n",
       "  85,\n",
       "  322,\n",
       "  452,\n",
       "  395,\n",
       "  304,\n",
       "  91,\n",
       "  490,\n",
       "  175,\n",
       "  83,\n",
       "  445,\n",
       "  835,\n",
       "  702,\n",
       "  931,\n",
       "  104,\n",
       "  726,\n",
       "  865,\n",
       "  178,\n",
       "  794,\n",
       "  522,\n",
       "  727,\n",
       "  640,\n",
       "  501,\n",
       "  698,\n",
       "  967,\n",
       "  988,\n",
       "  120,\n",
       "  434,\n",
       "  664,\n",
       "  641,\n",
       "  51,\n",
       "  886,\n",
       "  12,\n",
       "  433,\n",
       "  102,\n",
       "  122,\n",
       "  714,\n",
       "  32,\n",
       "  31,\n",
       "  371,\n",
       "  344,\n",
       "  157,\n",
       "  38,\n",
       "  922,\n",
       "  880,\n",
       "  16,\n",
       "  961,\n",
       "  930,\n",
       "  363,\n",
       "  136,\n",
       "  555,\n",
       "  909,\n",
       "  696,\n",
       "  559,\n",
       "  543,\n",
       "  667,\n",
       "  382,\n",
       "  191],\n",
       " 21: [567,\n",
       "  817,\n",
       "  383,\n",
       "  116,\n",
       "  68,\n",
       "  888,\n",
       "  944,\n",
       "  33,\n",
       "  401,\n",
       "  430,\n",
       "  881,\n",
       "  499,\n",
       "  260,\n",
       "  754,\n",
       "  372,\n",
       "  919,\n",
       "  185,\n",
       "  821,\n",
       "  905,\n",
       "  123,\n",
       "  732,\n",
       "  90,\n",
       "  273,\n",
       "  705,\n",
       "  871,\n",
       "  141,\n",
       "  551,\n",
       "  836,\n",
       "  671,\n",
       "  27,\n",
       "  93,\n",
       "  563,\n",
       "  936,\n",
       "  639,\n",
       "  488,\n",
       "  487,\n",
       "  328,\n",
       "  774],\n",
       " 22: [470,\n",
       "  258,\n",
       "  378,\n",
       "  509,\n",
       "  459,\n",
       "  887,\n",
       "  246,\n",
       "  520,\n",
       "  438,\n",
       "  601,\n",
       "  856,\n",
       "  343,\n",
       "  143,\n",
       "  280,\n",
       "  597,\n",
       "  140,\n",
       "  183,\n",
       "  444,\n",
       "  681],\n",
       " 23: [894, 538, 253, 468, 194, 367, 173, 632, 479],\n",
       " 24: [800, 46, 882, 799, 874],\n",
       " 25: [169, 806],\n",
       " 0: [297],\n",
       " 26: [755]}"
      ]
     },
     "execution_count": 64,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sbm.block_members"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [
    {
     "ename": "KeyError",
     "evalue": "2",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mKeyError\u001b[0m                                  Traceback (most recent call last)",
      "Cell \u001b[0;32mIn[36], line 2\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[38;5;66;03m# Perform some partition manipulations\u001b[39;00m\n\u001b[0;32m----> 2\u001b[0m \u001b[43msbm\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mmerge_blocks\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;241;43m1\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m2\u001b[39;49m\u001b[43m)\u001b[49m\n\u001b[1;32m      3\u001b[0m sbm\u001b[38;5;241m.\u001b[39mmove_node(\u001b[38;5;241m10\u001b[39m, \u001b[38;5;241m3\u001b[39m)\n\u001b[1;32m      5\u001b[0m \u001b[38;5;66;03m# Compute the new likelihood\u001b[39;00m\n",
      "File \u001b[0;32m~/anon_sbm/src/sbm/sbm.py:159\u001b[0m, in \u001b[0;36mStochasticBlockModel.merge_blocks\u001b[0;34m(self, block_a, block_b)\u001b[0m\n\u001b[1;32m    157\u001b[0m new_block_idx \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mmin\u001b[39m(block_a, block_b)\n\u001b[1;32m    158\u001b[0m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mblock_members[new_block_idx] \u001b[38;5;241m=\u001b[39m merged_nodes\n\u001b[0;32m--> 159\u001b[0m \u001b[38;5;28;01mdel\u001b[39;00m \u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mblock_members\u001b[49m\u001b[43m[\u001b[49m\u001b[38;5;28;43mmax\u001b[39;49m\u001b[43m(\u001b[49m\u001b[43mblock_a\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mblock_b\u001b[49m\u001b[43m)\u001b[49m\u001b[43m]\u001b[49m\n\u001b[1;32m    161\u001b[0m \u001b[38;5;66;03m# Update blocks mapping\u001b[39;00m\n\u001b[1;32m    162\u001b[0m \u001b[38;5;28;01mfor\u001b[39;00m node \u001b[38;5;129;01min\u001b[39;00m merged_nodes:\n",
      "\u001b[0;31mKeyError\u001b[0m: 2"
     ]
    }
   ],
   "source": [
    "# Perform some partition manipulations\n",
    "sbm.merge_blocks(1, 2)\n",
    "sbm.move_node(10, 3)\n",
    "\n",
    "# Compute the new likelihood\n",
    "new_likelihood = sbm.compute_likelihood()\n",
    "print(f\"New Likelihood: {new_likelihood}\")\n",
    "\n",
    "# Check minimum block size\n",
    "min_size = sbm.min_block_size()\n",
    "print(f\"Minimum Block Size: {min_size}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "anon_sbm",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}

================
File: src/sbm/block_data.py
================
from typing import Dict, Set, Optional

from dataclasses import dataclass

import numpy as np
import scipy.sparse as sp
from sbm.graph_data import GraphData
from sbm.sampling import sample_sbm_graph

BlockConn = sp.dok_array 
BlockMembership = Dict[int, Set[int]]  # Block ID to set of node indices

class _BlockDataUpdater:
    """
    Helper class to update edge counts and possible pairs in the block data.
    This class is used to hide bookkeeping of handling directed vs undirected graphs.

    Parameters
    ----------
    bd : BlockData
    """
    def __init__(self, block_data: "BlockData"):
        self.block_data = block_data # B  B integer matrix
    
    # block memberships
    def move_node_to_block(self, node: int, block_id: int, update_sizes=True) -> None:
        # update block assignment
        self.block_data.blocks[node] = block_id # type: ignore

        # update block membersets
        if block_id not in self.block_data.block_members:
            self.block_data.block_members[block_id] = set()
        self.block_data.block_members[block_id].add(node)

        if update_sizes: 
            old_block = self.block_data.blocks[node] # type: ignore
            # update block sizes
            self.block_data.block_sizes[block_id] += 1
            self.block_data.block_sizes[old_block] -= 1

    # ----- edge counts --------------------------------------------------
    def increment_edge_count(self, idx_a: int, idx_b: int, e_delta: int) -> None:
        """ 
        Increment the edge count between two blocks.
        If the graph is undirected, increment both directions.

        e_delta can be negative to decrement the edge count.
        idx_a and idx_b are indices in the block_connectivity matrix.
        """

        self.block_data.block_connectivity[idx_a, idx_b] += e_delta

        if not self.block_data.directed and idx_a != idx_b:
            self.block_data.block_connectivity[idx_b, idx_a] += e_delta


class BlockData:
    """ 
    Class to store block data for the SBM.

    There are two ways to initialize this class:

    Attributes:
        graph_data: The graph data object.
        blocks: A dictionary mapping node indices to block indices.
        block_members: A dictionary mapping block indices to lists of node indices.
        block_sizes: A dictionary mapping block indices to the number of nodes in each block.
        directed: A boolean indicating whether the graph is directed or not.
        block_indices: A dictionary mapping block IDs to indices used in matrices.
        inverse_block_indices: A dictionary mapping indices used in matrices to block IDs.
        block_connectivity: A sparse matrix representing the block connectivity matrix.
    """

    def __init__(self,
                 block_membership: Dict[int, int],
                 graph_data: GraphData,
        ):

        self.block_updater = _BlockDataUpdater(self)

        self.graph_data = graph_data
        self.directed = graph_data.directed

        self.block_members = self._initialize_block_members()
        self.block_sizes = {block: len(nodes) for block, nodes in self.block_members.items()}

        self._update_block_indices()

        self.block_connectivity: BlockConn = self._compute_block_connectivity()
        self.blocks: Dict[int, int] = block_membership # Node to block mapping

        # Recompute block connectivity based on the new graph data
        self.block_connectivity = self._compute_block_connectivity()
        
    
    def increment_edge_count(self, block_a: int, block_b: int, e_delta: int) -> None:
        """ 
        Increment the edge count between two blocks.
        If the graph is undirected, increment both directions.

        e_delta can be negative to decrement the edge count.
        """
        idx_a = self.block_indices[block_a]
        idx_b = self.block_indices[block_b]
        self.block_updater.increment_edge_count(idx_a, idx_b, e_delta)
    
    def get_possible_pairs(self, block_idx_a: int, block_idx_b:int ) -> int:
        """ 
        Compute the possible number of edges between two blocks.
        """
        block_a = self.inverse_block_indices[block_idx_a]
        block_b = self.inverse_block_indices[block_idx_b]

        if block_a == block_b:
            # If the same block, return the number of pairs within the block
            return self.block_sizes[block_a] * (self.block_sizes[block_a] - 1) // 2

        # If different blocks, return the product of their sizes
        return self.block_sizes[block_a] * self.block_sizes[block_b]

    def _initialize_block_members(self) -> BlockMembership:
        """
        Initialize block members from the blocks mapping.

        :return: A dictionary mapping block indices to lists of node indices.
        """
        if self.blocks is None:
            raise ValueError("Blocks mapping is not provided to initialize block members.")

        block_members: BlockMembership = {}

        for node, block in self.blocks.items():
            if block not in block_members:
                block_members[block] = set()
            # Add node to the corresponding block
            block_members[block].add(node)

        return block_members

    def _update_block_indices(self):
        """
        Update mappings between block IDs and indices used in matrices.
        """
        # Sort block IDs to ensure consistent ordering
        sorted_block_ids = sorted(self.block_members.keys())
        self.block_indices = {
            block_id: idx for idx, block_id in enumerate(sorted_block_ids)
            }
        self.inverse_block_indices = {
            idx: block_id for block_id, idx in self.block_indices.items()
            }

    def _compute_block_connectivity(self) -> BlockConn:
        """
        Compute the block connectivity matrix.

        This matrix is a sparse matrix where the entry at (i, j) is number of edges 
        between block i and block j. If the graph is undirected, the matrix is symmetric.
        """

        if self.graph_data is None:
            raise ValueError("Graph data is not set. Cannot compute block connectivity.")
        if self.block_members is None:
            raise ValueError("Block members are not initialized. Cannot compute block connectivity.")
        
        num_blocks = len(self.block_members)
        self._update_block_indices()
        block_connectivity_dok = sp.dok_array((num_blocks, num_blocks), dtype=np.int64)

        if self.directed:
            raise ValueError("Block connectivity computation is not implemented for directed graphs.")
        else:
            for i_block_id, nodes_i in self.block_members.items():
                idx_i = self.block_indices[i_block_id]
                nodes_i = list(nodes_i)
                sub_adj_i = self.graph_data.adjacency[nodes_i]  # type: ignore

                for j_block_id, nodes_j in self.block_members.items():
                    idx_j = self.block_indices[j_block_id]
                    nodes_j = list(nodes_j)
                    # Sum of weights between block i and block j
                    weight = sub_adj_i[:, nodes_j].sum() # type: ignore

                    # If the blocks are the same, we only count pairs
                    if i_block_id == j_block_id:
                        weight = weight // 2

                    block_connectivity_dok[idx_i, idx_j] = weight

            return block_connectivity_dok

    def _remove_block_index(self, block_id: int):
        """
        Remove a block from block_indices and inverse_block_indices.

        Do not use directly, call remove_block instead.

        :param block_id: The block ID to remove.
        """
        idx = self.block_indices.pop(block_id)
        self.inverse_block_indices.pop(idx)

        # Adjust indices of remaining blocks
        for b_id, index in self.block_indices.items():
            if index > idx:
                self.block_indices[b_id] -= 1
                self.inverse_block_indices[self.block_indices[b_id]] = b_id

    def _remove_block_from_connectivity(self, block_id: int):
        """
        Remove the block's row and column from the block connectivity matrix.

        Do not use directly, call remove_block instead.

        :param block_id: The block ID to remove.
        """
        idx = self.block_indices[block_id]
        # Remove the row and column corresponding to idx

        slicable_array = self.block_connectivity.tocsr()
        non_slice_idx = np.arange(self.block_connectivity.shape[1]) != idx # type: ignore

        self.block_connectivity = slicable_array[:, non_slice_idx][non_slice_idx, :].todok()

    def remove_block(self, block_id: int):
        """
        Remove a block from the block data.
        Do not use directly, call remove_block instead.

        :param block_id: The block ID to remove.
        """
        del self.block_sizes[block_id]
        del self.block_members[block_id]
        self._remove_block_from_connectivity(block_id)
        self._remove_block_index(block_id)

    def _add_block_index(self, block_id: int):
        """
        Add a new block index for a new block.

        Do not use directly, call add_block instead.

        :param block_id: The block ID to add.
        """
        new_idx = len(self.block_indices)
        self.block_indices[block_id] = new_idx
        self.inverse_block_indices[new_idx] = block_id

    def _add_block_to_connectivity(self):
        """
        Add a new block to the block connectivity matrix.

        Do not use directly, call add_block instead.

        :param block_id: The block ID to add.
        """
        num_blocks = len(self.block_indices)
        connectivity_lil = sp.lil_matrix(self.block_connectivity)
        connectivity_lil.resize((num_blocks, num_blocks))
        self.block_connectivity = connectivity_lil.todok()
    
    def add_block(self, block_id: int, nodes=[]):
        """
        Add a new block to the block data.

        :param block_id: The block ID to add.
        """
        if self.blocks is None:
            raise ValueError("Blocks mapping is not initialized. Cannot add a block.")

        self.block_sizes[block_id] = len(nodes)
        self.block_members[block_id] = nodes
        for node in nodes:
            self.blocks[node] = block_id

        self._add_block_index(block_id)
        self._add_block_to_connectivity()

================
File: src/sbm/graph_data.py
================
from scipy.sparse import csr_array

class GraphData:
    def __init__(self, adjacency_matrix: csr_array, directed=False):
        if not isinstance(adjacency_matrix, csr_array):
            raise ValueError("Adjacency matrix must be a scipy.sparse.csr_array")

        self.adjacency = adjacency_matrix.astype(int)
        self.directed: bool= directed
        self.num_nodes = self.adjacency.shape[0] # type: ignore
        
        if directed:
            self.total_edges = int(self.adjacency.sum())
        else:
            self.total_edges = int(self.adjacency.sum() / 2)  # For undirected graphs
        
        def __len__(self):
            return self.num_nodes

================
File: src/sbm/initial_partition.py
================
import numpy as np
import scipy.sparse as sp
from scipy.sparse.linalg import eigsh
from typing import Dict, Optional
from sklearn.cluster import KMeans
from scipy.sparse import csr_matrix


class SpectralPartitioner:
    def __init__(self, adjacency: csr_matrix, seed: Optional[int] = None):
        """
        Initialize the SpectralPartitioner.

        :param adjacency: The adjacency matrix of the network (sparse CSR matrix).
        :param seed: Random seed for reproducibility.
        """
        self.adjacency: csr_matrix = adjacency.tocsr()
        self.num_nodes: int = self.adjacency.shape[0]
        self.rng = np.random.default_rng(seed)
        self.degree_vector = np.array(self.adjacency.sum(axis=1)).flatten()
        self.laplacian = self._compute_normalized_laplacian()

    def _compute_normalized_laplacian(self) -> csr_matrix:
        """
        Compute the normalized Laplacian matrix of the graph.

        :return: The normalized Laplacian matrix (sparse CSR matrix).
        """
        # Avoid division by zero
        with np.errstate(divide='ignore'):
            d_inv_sqrt = np.power(self.degree_vector, -0.5)
            d_inv_sqrt[np.isinf(d_inv_sqrt)] = 0.0

        D_inv_sqrt = sp.diags(d_inv_sqrt)
        L = sp.eye(self.num_nodes) - D_inv_sqrt @ self.adjacency @ D_inv_sqrt
        return L

    def partition(self, num_blocks: int) -> Dict[int, int]:
        """
        Partition the nodes into blocks using spectral clustering.

        :param num_blocks: The desired number of blocks.
        :return: A dictionary mapping node indices to block indices.
        """
        # Compute the first (num_blocks) eigenvectors of the normalized Laplacian
        # Use 'SM' to find eigenvalues closest to zero
        eigenvalues, eigenvectors = eigsh(
            self.laplacian, k=num_blocks, which='SM', tol=1e-6, maxiter=5000
        )

        # Normalize rows to unit length to improve clustering
        embedding = eigenvectors
        row_norms = np.linalg.norm(embedding, axis=1, keepdims=True)
        row_norms[row_norms == 0] = 1e-10  # Avoid division by zero
        embedding_normalized = embedding / row_norms

        # Use k-means clustering on the spectral embeddings
        kmeans = KMeans(n_clusters=num_blocks, random_state=self.rng.integers(1 << 32))
        labels = kmeans.fit_predict(embedding_normalized)

        # Map nodes to blocks
        blocks = {node: int(label) for node, label in enumerate(labels)}
        return blocks

================
File: src/sbm/likelihood.py
================
from typing import (
    Dict,
    Tuple,
    Literal,
)
import numpy as np
from sbm.block_data import BlockData
from sbm.block_change_proposers import (
    EdgeDelta,
    CombinationDelta,
)

#### aliases ######
LikelihoodType = Literal['bernoulli']

# Bernoulli functions
def _bernoulli_ll_block_pair(e: int, n: int, eps:float= 1e-6) -> float:
    """
    Profile log-likelihood for one block pair (constants dropped).
    e: number of edges between block pair.
    n: number of possible pairs between block pair.
    """
    if n <= 0:
        raise ValueError("Number of possible pairs (n) must be greater than 0.")
    if e == 0: # 0  log 0 := 0   (limit)
        return 0.0
    
    # clip to avoid overflow in lo
    pos = max(e/n, eps)
    neg = max(1 - e/n, eps)
    
    return e * np.log(pos) - (n-e) * np.log(neg)

def _delta_ll_bernoulli_block_pair(
        e_old: int, e_new: int,
        n_old: int, n_new: int,
        eps: float = 1e-6
        ) -> float:
    """ for a single block pair.
    e_new: new number of edges between block pair.
    e_old: old number of edges between block pair.
    n_new: new number of possible pairs between block pair.
    n_old: old number of possible pairs between block pair.
    """

    new_ll = _bernoulli_ll_block_pair(e=e_new, n=n_new, eps=eps)
    old_ll = _bernoulli_ll_block_pair(e=e_old, n=n_old, eps=eps)

    return new_ll - old_ll

def compute_delta_ll_from_change_bernoulli(
        delta_e: Dict[Tuple[int, int], int],
        delta_n: Dict[Tuple[int, int], int],
        block_data: BlockData) -> float:
    """
    Incremental change in Bernoulli log-likelihood after a node-swap or move.
    Only the pairs present in `delta_e` or `delta_n` need to be visited.
    delta_e: changes in edge counts between affected blocks.
    delta_n: changes in possible pairs between affected blocks.
    block_data: BlockData object containing edge counts and possible pairs.

    :return: Tuple of (change in log-likelihood, edge counts changes of move delta).
    """
    assert set(delta_e.keys()) == set(delta_n.keys()), \
        "Changes in edge counts and possible edge counts should be passed between identical block set."
    upper_triangle_only = not block_data.directed

    delta_ll = 0.0
    for (r, s) in delta_e.keys() | delta_n.keys():
        if upper_triangle_only and s < r:
            continue
        e_old = int(block_data.block_connectivity[r, s]) # type: ignore
        n_old = block_data.get_possible_pairs(r, s)

        e_new = e_old + delta_e[r, s]
        n_new = n_old + delta_n[r, s]

        delta_ll += _delta_ll_bernoulli_block_pair(
            e_old=e_old,
            e_new=e_new,
            n_old=n_old,
            n_new=n_new
        )

    return delta_ll

def compute_global_bernoulli_ll(
        block_data: BlockData,
) -> float:
    """
    Compute the global log-likelihood of the SBM using Bernoulli likelihood.
    
    :param block_data: The BlockData object containing block connectivity and sizes.
    :param upper_triangle_only: If True, only compute for upper triangle of the connectivity matrix.
    :return: The global log-likelihood.
    """
    upper_triangle_only = not block_data.directed
    ll = 0.0
    for r in range(len(block_data.block_sizes)):

        # if block has less than 2 nodes, skip it: no possible pairs
        size_r = block_data.block_sizes[ block_data.inverse_block_indices[r] ]
        if size_r <= 1:
            continue 

        for s in range(r if upper_triangle_only else 0, len(block_data.block_sizes)):
            e = block_data.block_connectivity[r, s]
            n = block_data.get_possible_pairs(r, s)

            if e < 0 or n < 0:
                raise ValueError(f"Invalid edge count {e} or possible pairs {n} for block pair ({r}, {s}).")
            if e > n:
                raise ValueError(f"Edge count {e} cannot be greater than possible pairs {n} for block pair ({r}, {s}).")

            ll += _bernoulli_ll_block_pair(e, n) # type: ignore

    return ll

#### LikelihoodCalculator class ######
class LikelihoodCalculator:
    def __init__(self,
                 block_data: BlockData,
                 likelihood_type: LikelihoodType = 'bernoulli',
                 ):
        self.block_data = block_data

        self.likelihood_type: LikelihoodType = 'bernoulli'
        self.ll = self.compute_likelihood()

    def compute_likelihood(self) -> float:
        """
        Compute the likelihood of the network given the current partition.

        :return: The log-likelihood of the SBM.
        """
        if self.likelihood_type.lower() == 'bernoulli':
            return compute_global_bernoulli_ll(block_data=self.block_data)
        else:
            raise NotImplementedError("Only Bernoulli likelihood is implemented.")
 
    def _compute_delta_ll_from_changes(self,
                                       delta_e: Dict[Tuple[int, int], int],
                                       delta_n: Dict[Tuple[int, int], int],
    ) ->float:
        """
        efficeintly compute the change in log-likelihood from changes in edge counts and possible pairs.
    
        :param delta_e: Changes in edge counts between blocks.
        :param delta_n: Changes in possible pairs between blocks.
        :param total_edges: Total number of edges in the graph.
        :return: The change in log-likelihood.
        """
        if self.likelihood_type.lower() == 'bernoulli':
            return compute_delta_ll_from_change_bernoulli(
                delta_e=delta_e,
                delta_n=delta_n,
                block_data=self.block_data
            )
        else:
            raise NotImplementedError("Only Bernoulli likelihood is implemented.")

    def compute_delta_ll(self,
                        delta_e: EdgeDelta,
                        delta_n: CombinationDelta,
        ) -> float:
        """
        Compute the change in log-likelihood for a proposed swap of two nodes.

        :param proposed_moves: A list of tuples (node_i, node_j) representing the nodes to swap.
        :return: The change in log-likelihood.
        """
        return self._compute_delta_ll_from_changes(
            delta_e=delta_e,
            delta_n=delta_n
            )

================
File: src/sbm/mcmc.py
================
from typing import Optional, Tuple, Dict
import numpy as np

#from src.sbm.graph_data import GraphData
from sbm.block_data import BlockData
from sbm.likelihood import LikelihoodCalculator
from sbm.block_change_proposers import ChangeProposer
from sbm.node_mover import NodeMover
from sbm.utils.logger import CSVLogger

from sbm.block_change_proposers import ChangeProposer, ChangeProposerName

#### Aliases
ChangeProposerDict = Dict[ChangeProposerName, ChangeProposer] 

class MCMCAlgorithm:
    def __init__(self,
                 block_data: BlockData,
                 likelihood_calculator: LikelihoodCalculator,
                 change_proposer: ChangeProposerDict,
                 rng: np.random.Generator,
                 log: bool = True
                 ):
        self.move_probabilities = { "swap": 1 }

        self.block_data = block_data
        self.likelihood_calculator = likelihood_calculator
        self.change_proposers = change_proposer
        self.node_mover = NodeMover(block_data=block_data)
        self.rng = rng
        self.current_ll = self.likelihood_calculator.ll
        self.log = log # True if logging is enabled, False otherwise.

        # store the best block assignment and likelihood
        self._best_block_assignment = block_data.blocks.copy()
        self._best_block_conn = block_data.block_connectivity.copy()
        self.best_ll = self.likelihood_calculator.ll

    def fit(self,
            num_iterations: int,
            initial_temperature: float = 1,
            cooling_rate: float = 0.99,
            min_block_size: Optional[int] = None,
            max_blocks: Optional[int] = None,
            logger: Optional[CSVLogger] = None,    
        ) -> None:
        """
        Run the adaptive MCMC algorithm to fit the SBM to the network data.

        :param num_iterations: Total number of MCMC iterations to run.
        :param min_block_size: Minimum allowed size for any block.
        :param initial_temperature: Starting temperature for simulated annealing.
        :param cooling_rate: Rate at which temperature decreases.
        :param target_acceptance_rate: Desired acceptance rate for adaptive adjustments (default 25%).
        :param max_blocks: Optional maximum number of blocks allowed.
        """
        temperature = initial_temperature
        current_ll = self.likelihood_calculator.compute_likelihood()
        acceptance_rate = 0 # acceptance rate of moves between logging

        if logger:
            logger.log(0, current_ll, acceptance_rate, temperature)

        for iteration in range(1, num_iterations + 1):
            move_type = self._select_move_type()

            delta_ll, move_accepted = self._attempt_move(
                move_type=move_type,
                min_block_size=min_block_size,
                temperature=temperature,
                max_blocks=max_blocks
                )

            # update likelihood and best assignment so far
            if move_accepted :
                self.current_ll += delta_ll
                if logger:
                    acceptance_rate += 1

                if self.current_ll < self.best_ll:
                    self.best_ll = current_ll
                    self._best_block_assignment = self.block_data.blocks.copy()
                    self._best_block_conn = self.block_data.block_connectivity.copy()

            # Update temperature
            temperature = self._update_temperature(temperature, cooling_rate)

            # Log and adjust proposal probabilities every 100 iterations
            if logger and iteration % logger.log_every == 0:
                acceptance_rate = acceptance_rate / logger.log_every
                logger.log(iteration, self.current_ll, acceptance_rate, temperature)
                acceptance_rate = 0

    def _select_move_type(self) -> str:
        """
        Select a move type based on the current proposal probabilities.

        :return: The selected move type.
        """
        move_type = 'swap'
        return move_type

    def _attempt_move(self,
                      move_type: str,
                      temperature: float,
                      max_blocks: Optional[int] = None,
                      min_block_size: Optional[int] = None,
        ) -> Tuple[float, bool]:
        """
        Attempt a move of the specified type.

        :param move_type: The type of move to attempt ('swap').
        :param min_block_size: Minimum allowed size for any block.
        :param temperature: Current temperature for simulated annealing.
        :param max_blocks: Optional maximum number of blocks allowed.
        :return: Tuple of (delta_ll, move_accepted)
        """
        delta_ll, move_accepted = 0.0, False

        if move_type == 'swap':
            # Propose a swap of two nodes
            proposed_change, proposed_delta_e, proposed_delta_n = \
                self.change_proposers['swap'].propose_change()

            # Compute change in log-likelihood and accept/reject move
            delta_ll = self.likelihood_calculator.compute_delta_ll(
                delta_e=proposed_delta_e,
                delta_n=proposed_delta_n
                )

            move_accepted = self._accept_move(delta_ll, temperature)
            if move_accepted:
                self.node_mover.perform_change(proposed_change, proposed_delta_e)
        else:
            raise ValueError(f"Invalid move type: {move_type}. Only 'swap' is currently supported.")
        
        return delta_ll, move_accepted

    def _accept_move(self, delta_ll: float, temperature: float, eps:float=1e-6) -> bool:
        """
        Determine whether to accept a proposed move based on likelihood change and temperature.

        :param delta_ll: Change in log-likelihood resulting from the proposed move.
        :param temperature: Current temperature for simulated annealing.
        :return: True if move is accepted, False otherwise.
        """
        if delta_ll < 0:
            return True

        temperature = max(temperature, eps)  # Avoid division by zero
        z = min(delta_ll / temperature, 700) # clip to avoid overflow in exp

        return self.rng.uniform() > np.exp(z)

    def _update_temperature(self, current_temperature: float, cooling_rate: float) -> float:
        """
        Update the temperature according to the cooling schedule.

        :param current_temperature: The current temperature.
        :param cooling_rate: The cooling rate.
        :return: The updated temperature.
        """
        return current_temperature * cooling_rate

================
File: .gitignore
================
# --------------------------------------------------------------------
#  Python byte-code / build artefacts
# --------------------------------------------------------------------
__pycache__/
*.py[cod]
*.pyo
*.so
*.dylib
*.egg-info/
build/
dist/

# --------------------------------------------------------------------
#  Virtual-envs
# --------------------------------------------------------------------
.venv/
.env/
.mamba/
*.conda_env/

# --------------------------------------------------------------------
#  Data & model artefacts  (generated by pipeline)
# --------------------------------------------------------------------
data/raw/
data/interim/
data/processed/
models/
logs/
reports/
figures/

# allow a tiny toy graph or sample config if you deliberately commit it
!data/raw/README*
!data/raw/sample_*.*
!configs/**

# --------------------------------------------------------------------
#  Large numpy / scipy files anywhere but src/tests
# --------------------------------------------------------------------
*.npz
*.npy
*.pkl
*.h5
*.parquet

# --------------------------------------------------------------------
#  Jupyter checkpoints
# --------------------------------------------------------------------
.ipynb_checkpoints/

# --------------------------------------------------------------------
#  IDE / OS metadata
# --------------------------------------------------------------------
.idea/
.vscode/
*.swp
.DS_Store
Thumbs.db

# --------------------------------------------------------------------
#  Misc
# --------------------------------------------------------------------
*.bak
*.tmp

================
File: README.md
================
# anon_sbm




================================================================
End of Codebase
================================================================
