This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed, line numbers have been added.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: data/
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Line numbers have been added to the beginning of each line
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
.repomix/
  bundles.json
configs/
  noisy_surrogate_eval.yml
  sbm_fit_block_size_experiments.yml
  surrogate_eval.yml
notebooks/
  block_assigner_comparison_01-07-2025.ipynb
  convergence_figures_25-06-2025.ipynb
  likelihood_test.ipynb
  move_type_comparisons_30-06-2025.ipynb
  noisy_network_sampling_07-07-2025.ipynb
  sbm_block_sizes_26-06-2025.ipynb
  sbm_visualize.ipynb
  surrogate_accuracy_26-06-2025.ipynb
  visualize_generated_networks_08-07-2025.ipynb
planted_partitions/
  undirected_planted_partitions.py
slurm_scripts/
  fit_sbm.sh
src/
  data_processing/
    process_all.py
    process_caltech.py
    process_congress_twitter.py
    process_email_eu.py
    process_enron_email.py
    process_lastfm_asia.py
    process_wiki_vote.py
  metrics/
    __init__.py
    assortativity.py
    clustering.py
    community.py
    degree.py
    embedding.py
    shortest_path.py
    spectral.py
  pipelines/
    evaluate_noisy_surrogates.py
    evaluate_surrogates.py
    fit_sbm.py
    run_all.py
  sbm/
    utils/
      logger.py
      pipeline_utils.py
      util.py
    block_assigner.py
    block_change_proposers.py
    block_data.py
    edge_delta.py
    graph_data.py
    initial_partition.py
    io.py
    likelihood.py
    mcmc_diagnostics.py
    mcmc.py
    model.py
    node_mover.py
    noisy_fit.py
    post_process.py
    sampling.py
    stopping_criteria.py
  tests/
    dp/
      test_noise.py
      test_post_processing.py
    mcmc/
      likelihood_test.py
      planted_partition_tests.py
      test_block_assigner.py
      test_change_proposer_and_mover.py
      test_edge_delta.py
      test_global_ll.py
      test_greedy_assign_helpers.py
      test_swaps.py
    metrics/
      clustering
      conftest.py
      shortest_path.py
      test_assortativity.py
      test_community_metrics.py
      test_eigen_subspace.py
      test_embedding_metrics.py
      test_metrics.py
    sbm/
      test_io.py
      test_sampling.py
.gitignore
env_backup.yml
pyproject.toml
README.md
requirements.txt
setup.cfg
tmp_test.py

================================================================
Files
================================================================

================
File: src/sbm/mcmc_diagnostics.py
================
 1: # sbm/mcmc_diagnostics.py
 2: import numpy as np
 3: import tensorflow_probability as tfp
 4: from typing import Optional
 5: class OnlineDiagnostics:
 6:     """
 7:     Keeps a rolling window of the last `window` draws *per chain* and
 8:     computes
 9:       • R̂  (potential scale‑reduction)  — via tfp.mcmc.potential_scale_reduction
10:       • ESS (effective sample size)     — via tfp.mcmc.effective_sample_size
11:     """
12:     def __init__(self, window: int = 4000, n_chain: int = 1):
13:         self.window   = int(window)
14:         self.n_chain  = int(n_chain)
15:         self._buf:    Optional[np.ndarray] = None   # (chain, window, stat)
16:         self._write   = 0
17:         self._filled  = False
18:     # ------------------------------------------------------------------
19:     def _ensure_buffer(self, n_stat: int):
20:         if self._buf is None:
21:             self._buf = np.empty(
22:                 (self.n_chain, self.window, n_stat), dtype=np.float64)
23:     # ------------------------------------------------------------------
24:     def update(self, logp, m_diag, m_off, chain: int = 0):
25:         """
26:         Parameters
27:         ----------
28:         logp   : float
29:         m_diag : np.ndarray  shape (B,)
30:         m_off  : np.ndarray  shape (P,)
31:         chain  : int         which chain is calling (0 by default)
32:         """
33:         vec = np.concatenate([[logp], m_diag, m_off]).astype(np.float64)
34:         self._ensure_buffer(vec.size)
35:         if self._buf is None:
36:             raise RuntimeError("Buffer not initialized. Call `update` with valid data first.")
37:         self._buf[chain, self._write] = vec
38:         # advance circular pointer only once *all* chains have written
39:         if chain == self.n_chain - 1:
40:             self._write = (self._write + 1) % self.window
41:             if self._write == 0:
42:                 self._filled = True
43:     # ------------------------------------------------------------------
44:     def _ordered_block(self):
45:         """Return draws in chronological order, shape (chain, draw, stat)."""
46:         if self._buf is None:
47:             raise RuntimeError("Buffer not initialized. Call `update` with valid data first.")
48:         if not self._filled:
49:             return self._buf[:, :self._write, :]
50:         a = self._buf[:, self._write:, :]
51:         b = self._buf[:, :self._write, :]
52:         return np.concatenate([a, b], axis=1)
53:     # ------------------------------------------------------------------
54:     def summary(self):
55:         """Return (max‑R̂, min‑ESS).  NaN until buffer is full."""
56:         if not self._filled or self._buf is None:
57:             return np.nan, np.nan
58:         block = self._ordered_block()          # (chain, draw, stat)
59:         rhat = tfp.mcmc.potential_scale_reduction(
60:             block, independent_chain_ndims=1
61:         ).numpy().max()
62:         ess  = tfp.mcmc.effective_sample_size(
63:             block, filter_beyond_positive_pairs=True
64:         ).numpy().min()
65:         return float(rhat), float(ess)

================
File: .repomix/bundles.json
================
1: {
2:   "bundles": {}
3: }

================
File: configs/noisy_surrogate_eval.yml
================
 1: # ---------------------------------------------------------------
 2: n_surrogates: 10 # graphs to sample per dataset
 3: overwrite: true # set true to ignore cached results
 4: # privacy levels
 5: eps: [0.1, 1, 3]
 6: delta: [1e-4]
 7: metrics:
 8:   - shortest_path
 9:   - avg_path_length
10:   - degree
11:   - clustering
12:   - avg_clustering
13:   - eigen_val 
14:   - eigen_centrality
15:   - infomap
16:   - leiden
17:   - assortativity
18:   #- embedding_node2vec
19:   - embedding_prone

================
File: notebooks/convergence_figures_25-06-2025.ipynb
================
  1: {
  2:  "cells": [
  3:   {
  4:    "cell_type": "markdown",
  5:    "id": "af425169",
  6:    "metadata": {},
  7:    "source": [
  8:     "# Notebook for visualizing the convergence of the MCMC algorithm"
  9:    ]
 10:   },
 11:   {
 12:    "cell_type": "code",
 13:    "execution_count": null,
 14:    "id": "828ee0d9",
 15:    "metadata": {},
 16:    "outputs": [],
 17:    "source": [
 18:     "import numpy as np\n",
 19:     "import pandas as pd\n",
 20:     "import matplotlib.pyplot as plt"
 21:    ]
 22:   },
 23:   {
 24:    "cell_type": "code",
 25:    "execution_count": 69,
 26:    "id": "9f091b92",
 27:    "metadata": {},
 28:    "outputs": [],
 29:    "source": [
 30:     "import sys\n",
 31:     "from pathlib import Path\n",
 32:     "logs_path = Path(\"/Users/lmmi/anon_sbm/logs\")\n",
 33:     "\n",
 34:     "# find all log files in the logs directory\n",
 35:     "log_files = list(logs_path.glob(\"*.csv\"))"
 36:    ]
 37:   },
 38:   {
 39:    "cell_type": "code",
 40:    "execution_count": 70,
 41:    "id": "e8adb1d1",
 42:    "metadata": {},
 43:    "outputs": [],
 44:    "source": [
 45:     "def determine_name(file_name, dataset_names):\n",
 46:     "    \"\"\"\n",
 47:     "    Determine the name of the dataset based on the file name.\n",
 48:     "    \"\"\"\n",
 49:     "    for name in dataset_names:\n",
 50:     "        if name in file_name:\n",
 51:     "            return name\n",
 52:     "    return \"unknown\"\n",
 53:     "dataset_names = [ \"congress_twitter\", \"caltech_fb\", \"eu_email\", ]"
 54:    ]
 55:   },
 56:   {
 57:    "cell_type": "code",
 58:    "execution_count": 71,
 59:    "id": "23eabf12",
 60:    "metadata": {},
 61:    "outputs": [],
 62:    "source": [
 63:     "df_list = []\n",
 64:     "\n",
 65:     "for log_file in log_files:\n",
 66:     "    df = pd.read_csv(log_file)\n",
 67:     "    df[\"name\"] = determine_name(log_file.name, dataset_names)\n",
 68:     "\n",
 69:     "    df_list.append(df)\n",
 70:     "\n",
 71:     "df = pd.concat(df_list, ignore_index=True)"
 72:    ]
 73:   },
 74:   {
 75:    "cell_type": "code",
 76:    "execution_count": 72,
 77:    "id": "afc3941c",
 78:    "metadata": {},
 79:    "outputs": [
 80:     {
 81:      "name": "stderr",
 82:      "output_type": "stream",
 83:      "text": [
 84:       "/var/folders/y6/j9fbqcvx6lb5l99614n30y4c0000gn/T/ipykernel_88748/2982452800.py:32: UserWarning: FigureCanvasAgg is non-interactive, and thus cannot be shown\n",
 85:       "  fig.show()\n"
 86:      ]
 87:     },
 88:     {
 89:      "data": {
 90:       "image/png": "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5IGuqKgISUlJGDduHACgadOmcHJyQlJSEvr06QMAuHLlCm7duqXQq0dERERERGRMogt0urh16xYyMzNx69YtFBYWIiUlBQBQq1YtuLu7Y8eOHUhPT0fLli3h6uqKxMRELFiwAFOmTJFfY/To0fjyyy8xdepUDB8+HPv378fmzZuxa9cueZ1JkyZhyJAhaNasGVq0aIHPP/8cubm5GDZsGADA09MT0dHRmDRpEipWrAgPDw+MHz8erVq1UrvCJRERERERkaGsOtDNnj0ba9eulT9+6aWXAAAHDhxA+/bt4eTkhBUrVuDdd9+FIAioVasW/u///g8jRoyQnxMSEoJdu3bh3XffxbJly1ClShV88803iIqKktd54403cO/ePcyePRtpaWkICwvDnj17FBZK+eyzzyCVStGnTx/k5eUhKioKsbGxZngViIiIiIjIXoluDp094xw6IiIiIiLShc1vW0BERERERGSrGOiIiIiIiIisFAMdERERERGRlWKgIyIiIiIislIMdERERERERFaKgY6IiIiIiMhKMdARERERERFZKQY6IiIiIiIiK8VAR0REREREZKUY6IiIiIiIiKwUAx0REREREZGVYqAjIiIiIiKyUgx0REREREREVoqBjoiIiIiIyEox0BEREREREVkpBjoiIiIiIiIrxUBHRERERERkpRjoiIiIiIiIrBQDHRERERERkZVioCMiIiIiIrJSDHRERERERERWioGOiIiIiIjISjHQERERERERWSkGOiIiIiIiIivFQEdERERERGSlGOiIiIiIiIisFAMdERERERGRlWKgIyIiIiIislIMdERERERERFaKgY6IiIiIiMhKMdARERERERFZKUdtKn344Yd6XVwikWDWrFl6nUtERERERESaSQRBEMqqJJUqd+RJJBL5n0teQnZcEARIJBIUFhYao512IScnB56ensjOzoaHh4elm0NERERERCKnVQ/dgQMHlI59+umn2LdvHwYNGoQ2bdrA398f6enpOHToEL7//ntERUVh0qRJRm8wERERERERFdOqh660b775BpMmTUJycjIaNGigVH7u3Dm0bt0ay5Ytw/Dhw43SUHvAHjoiIiIiItKFXoGuUaNGaNWqFb766iu1dUaMGIE///wT586dM6iB9oSBjoiIiIiIdKHXKpdXr15FpUqVNNapVKkS/vnnH70aRURERERERGXTK9D5+vril19+gbrOvaKiIvzyyy/w8fExqHFERERERESknl6B7s0338TZs2fx2muv4cyZMwplKSkpeO2113D+/HkMHDjQKI0kIiIiIiIiZXrNoXv27Blee+01JCUlQSKRoHz58vD19cW9e/eQm5sLQRAQGRmJ7du3w9XV1RTttkmcQ0dERERERLrQq4fO1dUV+/btw7fffot27drB2dkZt27dgrOzM9q3b49vv/0We/fuZZgjIiIiIiIyIb166Mg02ENHRERERES60KuHjoiIiIiIiCzP0ZCTb9y4gfXr1yMlJQU5OTnw8PBAWFgYBg4ciOrVqxupiURERERERKSK3kMuly1bhqlTp6KgoEBp+wInJycsWbIE77zzjlEaaS845JKIiIiIiHSh15DLnTt34t1334Wnpyfmz5+PI0eO4Pr160hOTsaCBQvg6emJSZMmYdeuXcZuLxEREREREf1Lrx66jh074uzZs0hJSUGVKlWUym/fvo2XXnoJTZo0QVJSklEaag/YQ0dERERERLrQq4fu1KlTeOONN1SGOQAIDg5Gv379cPLkSYMaR0REREREROrpFejy8/NRvnx5jXXc3d2Rn5+vV6OIiIiIiIiobHoFujp16mDHjh0oKChQWV5QUICdO3eiTp06BjWOiIiIiIiI1NMr0A0ePBhXrlxBVFSU0rDKEydOoFu3brhy5QqGDBlilEYSERERERGRMr0WRSksLESfPn2wfft2SCQSlCtXDn5+fsjIyMCTJ08gCAL+85//4Mcff4RUyr3LtcVFUYiIiIiISBd6pS0HBwds27YN8fHxaN++PZydnXHr1i04OzujQ4cOWLt2LX766SeGOSIiIiIiIhPSe2NxMj720BERERERkS7YhUZERERERGSlHA05+caNG1i/fj1SUlKQk5MDDw8PhIWFYeDAgahevbqRmkhERERERESq6D3kctmyZZg6dSoKCgpQ+hJOTk5YsmQJ3nnnHaM00l5wyCUREREREelCryGXO3fuxLvvvgtPT0/Mnz8fR44cwfXr15GcnIwFCxbA09MTkyZNwq5du4zdXiIiIiIiIvqXXj10HTt2xNmzZ5GSkoIqVaoold++fRsvvfQSmjRpgqSkJKM01B6wh46IiIiIiHShVw/dqVOn8MYbb6gMcwAQHByMfv36KW06TkRERERERMaj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",
 91:       "text/plain": [
 92:        "<Figure size 1000x600 with 1 Axes>"
 93:       ]
 94:      },
 95:      "metadata": {},
 96:      "output_type": "display_data"
 97:     }
 98:    ],
 99:    "source": [
100:     "marker_styles = {\n",
101:     "    \"congress_twitter\": \"o\",\n",
102:     "    \"caltech_fb\": \"s\",\n",
103:     "    \"eu_email\": \"D\",\n",
104:     "}\n",
105:     "colors = {\n",
106:     "    \"congress_twitter\": \"teal\",\n",
107:     "    \"caltech_fb\": \"salmon\",\n",
108:     "    \"eu_email\": \"black\",\n",
109:     "}\n",
110:     "\n",
111:     "\n",
112:     "fig, ax = plt.subplots(figsize=(10, 6))\n",
113:     "\n",
114:     "for name, group in df.groupby(\"name\"):\n",
115:     "    group = group.sort_values(\"iteration\")\n",
116:     "    ax.plot(\n",
117:     "        group[\"iteration\"],\n",
118:     "        group[\"neg_log_likelihood\"],\n",
119:     "        label=name,\n",
120:     "        linewidth=0,\n",
121:     "        marker=marker_styles[name], # type: ignore\n",
122:     "        )\n",
123:     "\n",
124:     "plt.legend(fontsize=12)\n",
125:     "\n",
126:     "ax.set_ylabel(\"Negative Log Likelihood\", fontsize=14)\n",
127:     "ax.set_xlabel(\"MCMC Iteration\", fontsize=14)\n",
128:     "\n",
129:     "\n",
130:     "ax.spines[['top', 'right']].set_visible(False)\n",
131:     "fig.show()"
132:    ]
133:   },
134:   {
135:    "cell_type": "code",
136:    "execution_count": null,
137:    "id": "666c6cc1",
138:    "metadata": {},
139:    "outputs": [],
140:    "source": []
141:   }
142:  ],
143:  "metadata": {
144:   "kernelspec": {
145:    "display_name": "anon_sbm_notebook",
146:    "language": "python",
147:    "name": "python3"
148:   },
149:   "language_info": {
150:    "codemirror_mode": {
151:     "name": "ipython",
152:     "version": 3
153:    },
154:    "file_extension": ".py",
155:    "mimetype": "text/x-python",
156:    "name": "python",
157:    "nbconvert_exporter": "python",
158:    "pygments_lexer": "ipython3",
159:    "version": "3.13.5"
160:   }
161:  },
162:  "nbformat": 4,
163:  "nbformat_minor": 5
164: }

================
File: notebooks/likelihood_test.ipynb
================
   1: {
   2:  "cells": [
   3:   {
   4:    "cell_type": "code",
   5:    "execution_count": 2,
   6:    "metadata": {},
   7:    "outputs": [],
   8:    "source": [
   9:     "import numpy as np\n",
  10:     "import scipy.sparse as sp\n",
  11:     "from sbm.sbm import StochasticBlockModel"
  12:    ]
  13:   },
  14:   {
  15:    "cell_type": "code",
  16:    "execution_count": 32,
  17:    "metadata": {},
  18:    "outputs": [],
  19:    "source": [
  20:     "num_nodes = 1000\n",
  21:     "block_size = 50\n",
  22:     "# Generate a random sparse adjacency matrix\n",
  23:     "adjacency = sp.random(num_nodes, num_nodes, density=0.01, format='csr')\n",
  24:     "adjacency = adjacency + adjacency.T  # Make it symmetric\n",
  25:     "adjacency.data = np.ones_like(adjacency.data)  # Unweighted graph\n",
  26:     "\n",
  27:     "# Create an initial uniform random partition\n",
  28:     "initial_blocks = StochasticBlockModel.create_uniform_partition(num_nodes, block_size)\n",
  29:     "\n",
  30:     "# Initialize the SBM\n",
  31:     "sbm = StochasticBlockModel(adjacency, initial_blocks)"
  32:    ]
  33:   },
  34:   {
  35:    "cell_type": "code",
  36:    "execution_count": 33,
  37:    "metadata": {},
  38:    "outputs": [
  39:     {
  40:      "name": "stdout",
  41:      "output_type": "stream",
  42:      "text": [
  43:       "Initial Likelihood: -110207.47925966672\n"
  44:      ]
  45:     }
  46:    ],
  47:    "source": [
  48:     "# Compute the initial likelihood\n",
  49:     "initial_likelihood = sbm.compute_likelihood()\n",
  50:     "print(f\"Initial Likelihood: {initial_likelihood}\")"
  51:    ]
  52:   },
  53:   {
  54:    "cell_type": "code",
  55:    "execution_count": 34,
  56:    "metadata": {},
  57:    "outputs": [
  58:     {
  59:      "name": "stdout",
  60:      "output_type": "stream",
  61:      "text": [
  62:       "[True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True]\n"
  63:      ]
  64:     }
  65:    ],
  66:    "source": [
  67:     "block_0 = sbm.block_members[0]\n",
  68:     "sbm.split_block(0)\n",
  69:     "\n",
  70:     "test = [elem in block_0 for elem in sbm.block_members[0]]\n",
  71:     "print(test)"
  72:    ]
  73:   },
  74:   {
  75:    "cell_type": "code",
  76:    "execution_count": 35,
  77:    "metadata": {},
  78:    "outputs": [
  79:     {
  80:      "name": "stdout",
  81:      "output_type": "stream",
  82:      "text": [
  83:       "[True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True]\n"
  84:      ]
  85:     }
  86:    ],
  87:    "source": [
  88:     "block_1, block_2 = sbm.block_members[1], sbm.block_members[2]\n",
  89:     "\n",
  90:     "sbm.merge_blocks(1, 2)\n",
  91:     "\n",
  92:     "test = [elem in sbm.block_members[1] for elem in block_1] + [elem in sbm.block_members[1] for elem in block_2]\n",
  93:     "print(test)"
  94:    ]
  95:   },
  96:   {
  97:    "cell_type": "code",
  98:    "execution_count": 62,
  99:    "metadata": {},
 100:    "outputs": [],
 101:    "source": [
 102:     "sbm.split_block(0)"
 103:    ]
 104:   },
 105:   {
 106:    "cell_type": "code",
 107:    "execution_count": 63,
 108:    "metadata": {},
 109:    "outputs": [
 110:     {
 111:      "data": {
 112:       "text/plain": [
 113:        "dict_keys([3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 26])"
 114:       ]
 115:      },
 116:      "execution_count": 63,
 117:      "metadata": {},
 118:      "output_type": "execute_result"
 119:     }
 120:    ],
 121:    "source": [
 122:     "sbm.block_members.keys()"
 123:    ]
 124:   },
 125:   {
 126:    "cell_type": "code",
 127:    "execution_count": 64,
 128:    "metadata": {},
 129:    "outputs": [
 130:     {
 131:      "data": {
 132:       "text/plain": [
 133:        "{3: [361,\n",
 134:        "  569,\n",
 135:        "  298,\n",
 136:        "  110,\n",
 137:        "  288,\n",
 138:        "  972,\n",
 139:        "  595,\n",
 140:        "  10,\n",
 141:        "  67,\n",
 142:        "  436,\n",
 143:        "  281,\n",
 144:        "  52,\n",
 145:        "  476,\n",
 146:        "  791,\n",
 147:        "  760,\n",
 148:        "  388,\n",
 149:        "  926,\n",
 150:        "  928,\n",
 151:        "  45,\n",
 152:        "  40,\n",
 153:        "  393,\n",
 154:        "  474,\n",
 155:        "  237,\n",
 156:        "  226,\n",
 157:        "  814,\n",
 158:        "  447,\n",
 159:        "  884,\n",
 160:        "  833,\n",
 161:        "  62,\n",
 162:        "  834,\n",
 163:        "  387,\n",
 164:        "  448,\n",
 165:        "  788,\n",
 166:        "  179,\n",
 167:        "  801,\n",
 168:        "  318,\n",
 169:        "  64,\n",
 170:        "  629,\n",
 171:        "  968,\n",
 172:        "  911,\n",
 173:        "  568,\n",
 174:        "  450,\n",
 175:        "  735,\n",
 176:        "  1,\n",
 177:        "  410,\n",
 178:        "  30,\n",
 179:        "  389,\n",
 180:        "  215,\n",
 181:        "  478,\n",
 182:        "  319],\n",
 183:        " 4: [202,\n",
 184:        "  787,\n",
 185:        "  255,\n",
 186:        "  502,\n",
 187:        "  242,\n",
 188:        "  827,\n",
 189:        "  402,\n",
 190:        "  256,\n",
 191:        "  584,\n",
 192:        "  547,\n",
 193:        "  579,\n",
 194:        "  739,\n",
 195:        "  282,\n",
 196:        "  697,\n",
 197:        "  135,\n",
 198:        "  342,\n",
 199:        "  636,\n",
 200:        "  377,\n",
 201:        "  118,\n",
 202:        "  722,\n",
 203:        "  915,\n",
 204:        "  685,\n",
 205:        "  397,\n",
 206:        "  341,\n",
 207:        "  416,\n",
 208:        "  612,\n",
 209:        "  491,\n",
 210:        "  392,\n",
 211:        "  941,\n",
 212:        "  668,\n",
 213:        "  148,\n",
 214:        "  370,\n",
 215:        "  247,\n",
 216:        "  734,\n",
 217:        "  991,\n",
 218:        "  619,\n",
 219:        "  262,\n",
 220:        "  351,\n",
 221:        "  628,\n",
 222:        "  864,\n",
 223:        "  337,\n",
 224:        "  845,\n",
 225:        "  752,\n",
 226:        "  244,\n",
 227:        "  903,\n",
 228:        "  606,\n",
 229:        "  269,\n",
 230:        "  898,\n",
 231:        "  780,\n",
 232:        "  716],\n",
 233:        " 5: [352,\n",
 234:        "  210,\n",
 235:        "  473,\n",
 236:        "  807,\n",
 237:        "  676,\n",
 238:        "  353,\n",
 239:        "  534,\n",
 240:        "  813,\n",
 241:        "  88,\n",
 242:        "  58,\n",
 243:        "  198,\n",
 244:        "  715,\n",
 245:        "  519,\n",
 246:        "  945,\n",
 247:        "  264,\n",
 248:        "  357,\n",
 249:        "  53,\n",
 250:        "  934,\n",
 251:        "  877,\n",
 252:        "  217,\n",
 253:        "  437,\n",
 254:        "  653,\n",
 255:        "  746,\n",
 256:        "  737,\n",
 257:        "  461,\n",
 258:        "  953,\n",
 259:        "  458,\n",
 260:        "  346,\n",
 261:        "  414,\n",
 262:        "  329,\n",
 263:        "  902,\n",
 264:        "  106,\n",
 265:        "  295,\n",
 266:        "  695,\n",
 267:        "  480,\n",
 268:        "  994,\n",
 269:        "  206,\n",
 270:        "  592,\n",
 271:        "  44,\n",
 272:        "  171,\n",
 273:        "  876,\n",
 274:        "  105,\n",
 275:        "  758,\n",
 276:        "  57,\n",
 277:        "  128,\n",
 278:        "  7,\n",
 279:        "  811,\n",
 280:        "  145,\n",
 281:        "  985,\n",
 282:        "  977],\n",
 283:        " 6: [229,\n",
 284:        "  394,\n",
 285:        "  656,\n",
 286:        "  744,\n",
 287:        "  935,\n",
 288:        "  333,\n",
 289:        "  407,\n",
 290:        "  736,\n",
 291:        "  546,\n",
 292:        "  553,\n",
 293:        "  221,\n",
 294:        "  982,\n",
 295:        "  914,\n",
 296:        "  101,\n",
 297:        "  230,\n",
 298:        "  406,\n",
 299:        "  872,\n",
 300:        "  266,\n",
 301:        "  285,\n",
 302:        "  325,\n",
 303:        "  582,\n",
 304:        "  562,\n",
 305:        "  222,\n",
 306:        "  924,\n",
 307:        "  78,\n",
 308:        "  970,\n",
 309:        "  899,\n",
 310:        "  729,\n",
 311:        "  869,\n",
 312:        "  77,\n",
 313:        "  908,\n",
 314:        "  510,\n",
 315:        "  713,\n",
 316:        "  9,\n",
 317:        "  593,\n",
 318:        "  279,\n",
 319:        "  429,\n",
 320:        "  721,\n",
 321:        "  933,\n",
 322:        "  860,\n",
 323:        "  375,\n",
 324:        "  334,\n",
 325:        "  750,\n",
 326:        "  849,\n",
 327:        "  524,\n",
 328:        "  225,\n",
 329:        "  241,\n",
 330:        "  803,\n",
 331:        "  759,\n",
 332:        "  669],\n",
 333:        " 7: [92,\n",
 334:        "  196,\n",
 335:        "  770,\n",
 336:        "  530,\n",
 337:        "  740,\n",
 338:        "  189,\n",
 339:        "  777,\n",
 340:        "  699,\n",
 341:        "  144,\n",
 342:        "  463,\n",
 343:        "  404,\n",
 344:        "  270,\n",
 345:        "  890,\n",
 346:        "  320,\n",
 347:        "  315,\n",
 348:        "  403,\n",
 349:        "  310,\n",
 350:        "  350,\n",
 351:        "  802,\n",
 352:        "  293,\n",
 353:        "  29,\n",
 354:        "  587,\n",
 355:        "  846,\n",
 356:        "  852,\n",
 357:        "  86,\n",
 358:        "  453,\n",
 359:        "  523,\n",
 360:        "  249,\n",
 361:        "  939,\n",
 362:        "  34,\n",
 363:        "  912,\n",
 364:        "  0,\n",
 365:        "  776,\n",
 366:        "  812,\n",
 367:        "  340,\n",
 368:        "  512,\n",
 369:        "  187,\n",
 370:        "  672,\n",
 371:        "  677,\n",
 372:        "  190,\n",
 373:        "  878,\n",
 374:        "  893,\n",
 375:        "  605,\n",
 376:        "  411,\n",
 377:        "  228,\n",
 378:        "  665,\n",
 379:        "  751,\n",
 380:        "  439,\n",
 381:        "  5,\n",
 382:        "  844],\n",
 383:        " 8: [795,\n",
 384:        "  943,\n",
 385:        "  212,\n",
 386:        "  978,\n",
 387:        "  347,\n",
 388:        "  71,\n",
 389:        "  48,\n",
 390:        "  292,\n",
 391:        "  155,\n",
 392:        "  608,\n",
 393:        "  997,\n",
 394:        "  576,\n",
 395:        "  449,\n",
 396:        "  990,\n",
 397:        "  36,\n",
 398:        "  895,\n",
 399:        "  979,\n",
 400:        "  778,\n",
 401:        "  154,\n",
 402:        "  494,\n",
 403:        "  529,\n",
 404:        "  542,\n",
 405:        "  303,\n",
 406:        "  560,\n",
 407:        "  471,\n",
 408:        "  385,\n",
 409:        "  901,\n",
 410:        "  124,\n",
 411:        "  180,\n",
 412:        "  850,\n",
 413:        "  631,\n",
 414:        "  769,\n",
 415:        "  137,\n",
 416:        "  462,\n",
 417:        "  307,\n",
 418:        "  263,\n",
 419:        "  89,\n",
 420:        "  805,\n",
 421:        "  428,\n",
 422:        "  424,\n",
 423:        "  892,\n",
 424:        "  390,\n",
 425:        "  63,\n",
 426:        "  19,\n",
 427:        "  782,\n",
 428:        "  267,\n",
 429:        "  917,\n",
 430:        "  773,\n",
 431:        "  465,\n",
 432:        "  842],\n",
 433:        " 9: [76,\n",
 434:        "  733,\n",
 435:        "  49,\n",
 436:        "  43,\n",
 437:        "  614,\n",
 438:        "  885,\n",
 439:        "  618,\n",
 440:        "  164,\n",
 441:        "  423,\n",
 442:        "  117,\n",
 443:        "  516,\n",
 444:        "  565,\n",
 445:        "  166,\n",
 446:        "  771,\n",
 447:        "  717,\n",
 448:        "  859,\n",
 449:        "  691,\n",
 450:        "  159,\n",
 451:        "  495,\n",
 452:        "  153,\n",
 453:        "  678,\n",
 454:        "  227,\n",
 455:        "  692,\n",
 456:        "  981,\n",
 457:        "  181,\n",
 458:        "  857,\n",
 459:        "  126,\n",
 460:        "  950,\n",
 461:        "  55,\n",
 462:        "  622,\n",
 463:        "  129,\n",
 464:        "  731,\n",
 465:        "  554,\n",
 466:        "  556,\n",
 467:        "  220,\n",
 468:        "  162,\n",
 469:        "  238,\n",
 470:        "  925,\n",
 471:        "  309,\n",
 472:        "  662,\n",
 473:        "  673,\n",
 474:        "  831,\n",
 475:        "  72,\n",
 476:        "  107,\n",
 477:        "  815,\n",
 478:        "  514,\n",
 479:        "  706,\n",
 480:        "  847,\n",
 481:        "  233,\n",
 482:        "  467],\n",
 483:        " 10: [308,\n",
 484:        "  186,\n",
 485:        "  489,\n",
 486:        "  959,\n",
 487:        "  658,\n",
 488:        "  362,\n",
 489:        "  223,\n",
 490:        "  862,\n",
 491:        "  659,\n",
 492:        "  484,\n",
 493:        "  536,\n",
 494:        "  757,\n",
 495:        "  969,\n",
 496:        "  18,\n",
 497:        "  825,\n",
 498:        "  332,\n",
 499:        "  306,\n",
 500:        "  840,\n",
 501:        "  660,\n",
 502:        "  602,\n",
 503:        "  684,\n",
 504:        "  188,\n",
 505:        "  613,\n",
 506:        "  590,\n",
 507:        "  820,\n",
 508:        "  324,\n",
 509:        "  443,\n",
 510:        "  627,\n",
 511:        "  586,\n",
 512:        "  766,\n",
 513:        "  69,\n",
 514:        "  830,\n",
 515:        "  942,\n",
 516:        "  419,\n",
 517:        "  798,\n",
 518:        "  946,\n",
 519:        "  65,\n",
 520:        "  644,\n",
 521:        "  79,\n",
 522:        "  604,\n",
 523:        "  121,\n",
 524:        "  74,\n",
 525:        "  971,\n",
 526:        "  381,\n",
 527:        "  81,\n",
 528:        "  100,\n",
 529:        "  932,\n",
 530:        "  531,\n",
 531:        "  232,\n",
 532:        "  466],\n",
 533:        " 11: [762,\n",
 534:        "  355,\n",
 535:        "  955,\n",
 536:        "  451,\n",
 537:        "  904,\n",
 538:        "  109,\n",
 539:        "  749,\n",
 540:        "  621,\n",
 541:        "  689,\n",
 542:        "  231,\n",
 543:        "  626,\n",
 544:        "  305,\n",
 545:        "  167,\n",
 546:        "  98,\n",
 547:        "  938,\n",
 548:        "  37,\n",
 549:        "  427,\n",
 550:        "  284,\n",
 551:        "  793,\n",
 552:        "  958,\n",
 553:        "  724,\n",
 554:        "  312,\n",
 555:        "  848,\n",
 556:        "  415,\n",
 557:        "  528,\n",
 558:        "  867,\n",
 559:        "  645,\n",
 560:        "  158,\n",
 561:        "  661,\n",
 562:        "  954,\n",
 563:        "  920,\n",
 564:        "  354,\n",
 565:        "  910,\n",
 566:        "  59,\n",
 567:        "  965,\n",
 568:        "  208,\n",
 569:        "  441,\n",
 570:        "  358,\n",
 571:        "  623,\n",
 572:        "  54,\n",
 573:        "  497,\n",
 574:        "  966,\n",
 575:        "  112,\n",
 576:        "  125,\n",
 577:        "  532,\n",
 578:        "  379,\n",
 579:        "  365,\n",
 580:        "  138,\n",
 581:        "  634,\n",
 582:        "  214],\n",
 583:        " 12: [797,\n",
 584:        "  719,\n",
 585:        "  975,\n",
 586:        "  603,\n",
 587:        "  540,\n",
 588:        "  507,\n",
 589:        "  610,\n",
 590:        "  879,\n",
 591:        "  870,\n",
 592:        "  302,\n",
 593:        "  594,\n",
 594:        "  609,\n",
 595:        "  574,\n",
 596:        "  199,\n",
 597:        "  693,\n",
 598:        "  703,\n",
 599:        "  666,\n",
 600:        "  422,\n",
 601:        "  278,\n",
 602:        "  775,\n",
 603:        "  219,\n",
 604:        "  84,\n",
 605:        "  654,\n",
 606:        "  317,\n",
 607:        "  321,\n",
 608:        "  420,\n",
 609:        "  17,\n",
 610:        "  573,\n",
 611:        "  843,\n",
 612:        "  201,\n",
 613:        "  525,\n",
 614:        "  224,\n",
 615:        "  816,\n",
 616:        "  207,\n",
 617:        "  783,\n",
 618:        "  435,\n",
 619:        "  725,\n",
 620:        "  360,\n",
 621:        "  518,\n",
 622:        "  80,\n",
 623:        "  561,\n",
 624:        "  11,\n",
 625:        "  948,\n",
 626:        "  694,\n",
 627:        "  493,\n",
 628:        "  103,\n",
 629:        "  923,\n",
 630:        "  70,\n",
 631:        "  268,\n",
 632:        "  290],\n",
 633:        " 13: [13,\n",
 634:        "  989,\n",
 635:        "  929,\n",
 636:        "  374,\n",
 637:        "  195,\n",
 638:        "  236,\n",
 639:        "  446,\n",
 640:        "  39,\n",
 641:        "  973,\n",
 642:        "  625,\n",
 643:        "  161,\n",
 644:        "  630,\n",
 645:        "  464,\n",
 646:        "  682,\n",
 647:        "  345,\n",
 648:        "  768,\n",
 649:        "  680,\n",
 650:        "  549,\n",
 651:        "  455,\n",
 652:        "  192,\n",
 653:        "  633,\n",
 654:        "  23,\n",
 655:        "  20,\n",
 656:        "  883,\n",
 657:        "  589,\n",
 658:        "  533,\n",
 659:        "  87,\n",
 660:        "  475,\n",
 661:        "  996,\n",
 662:        "  947,\n",
 663:        "  686,\n",
 664:        "  283,\n",
 665:        "  384,\n",
 666:        "  376,\n",
 667:        "  259,\n",
 668:        "  323,\n",
 669:        "  326,\n",
 670:        "  274,\n",
 671:        "  165,\n",
 672:        "  398,\n",
 673:        "  781,\n",
 674:        "  747,\n",
 675:        "  149,\n",
 676:        "  838,\n",
 677:        "  240,\n",
 678:        "  598,\n",
 679:        "  741,\n",
 680:        "  204,\n",
 681:        "  700,\n",
 682:        "  457],\n",
 683:        " 14: [301,\n",
 684:        "  804,\n",
 685:        "  964,\n",
 686:        "  504,\n",
 687:        "  616,\n",
 688:        "  921,\n",
 689:        "  409,\n",
 690:        "  600,\n",
 691:        "  413,\n",
 692:        "  949,\n",
 693:        "  819,\n",
 694:        "  861,\n",
 695:        "  291,\n",
 696:        "  211,\n",
 697:        "  75,\n",
 698:        "  432,\n",
 699:        "  425,\n",
 700:        "  753,\n",
 701:        "  772,\n",
 702:        "  742,\n",
 703:        "  82,\n",
 704:        "  674,\n",
 705:        "  643,\n",
 706:        "  607,\n",
 707:        "  765,\n",
 708:        "  460,\n",
 709:        "  500,\n",
 710:        "  400,\n",
 711:        "  889,\n",
 712:        "  683,\n",
 713:        "  940,\n",
 714:        "  839,\n",
 715:        "  513,\n",
 716:        "  177,\n",
 717:        "  408,\n",
 718:        "  248,\n",
 719:        "  790,\n",
 720:        "  97,\n",
 721:        "  131,\n",
 722:        "  544,\n",
 723:        "  234,\n",
 724:        "  578,\n",
 725:        "  250,\n",
 726:        "  980,\n",
 727:        "  873,\n",
 728:        "  687,\n",
 729:        "  42,\n",
 730:        "  541,\n",
 731:        "  710,\n",
 732:        "  663],\n",
 733:        " 15: [197,\n",
 734:        "  380,\n",
 735:        "  28,\n",
 736:        "  728,\n",
 737:        "  134,\n",
 738:        "  254,\n",
 739:        "  8,\n",
 740:        "  566,\n",
 741:        "  216,\n",
 742:        "  962,\n",
 743:        "  314,\n",
 744:        "  277,\n",
 745:        "  6,\n",
 746:        "  708,\n",
 747:        "  829,\n",
 748:        "  796,\n",
 749:        "  701,\n",
 750:        "  515,\n",
 751:        "  779,\n",
 752:        "  114,\n",
 753:        "  2,\n",
 754:        "  368,\n",
 755:        "  832,\n",
 756:        "  287,\n",
 757:        "  823,\n",
 758:        "  763,\n",
 759:        "  642,\n",
 760:        "  243,\n",
 761:        "  66,\n",
 762:        "  15,\n",
 763:        "  535,\n",
 764:        "  272,\n",
 765:        "  391,\n",
 766:        "  548,\n",
 767:        "  205,\n",
 768:        "  983,\n",
 769:        "  858,\n",
 770:        "  808,\n",
 771:        "  265,\n",
 772:        "  720,\n",
 773:        "  26,\n",
 774:        "  327,\n",
 775:        "  570,\n",
 776:        "  709,\n",
 777:        "  527,\n",
 778:        "  789,\n",
 779:        "  868,\n",
 780:        "  581,\n",
 781:        "  151,\n",
 782:        "  421],\n",
 783:        " 16: [647,\n",
 784:        "  956,\n",
 785:        "  111,\n",
 786:        "  47,\n",
 787:        "  418,\n",
 788:        "  469,\n",
 789:        "  937,\n",
 790:        "  688,\n",
 791:        "  356,\n",
 792:        "  289,\n",
 793:        "  615,\n",
 794:        "  286,\n",
 795:        "  170,\n",
 796:        "  617,\n",
 797:        "  511,\n",
 798:        "  986,\n",
 799:        "  313,\n",
 800:        "  364,\n",
 801:        "  896,\n",
 802:        "  974,\n",
 803:        "  119,\n",
 804:        "  22,\n",
 805:        "  133,\n",
 806:        "  987,\n",
 807:        "  163,\n",
 808:        "  679,\n",
 809:        "  431,\n",
 810:        "  483,\n",
 811:        "  550,\n",
 812:        "  738,\n",
 813:        "  517,\n",
 814:        "  712,\n",
 815:        "  818,\n",
 816:        "  963,\n",
 817:        "  897,\n",
 818:        "  261,\n",
 819:        "  564,\n",
 820:        "  96,\n",
 821:        "  539,\n",
 822:        "  828,\n",
 823:        "  863,\n",
 824:        "  916,\n",
 825:        "  41,\n",
 826:        "  294,\n",
 827:        "  132,\n",
 828:        "  299,\n",
 829:        "  652,\n",
 830:        "  336,\n",
 831:        "  718,\n",
 832:        "  168],\n",
 833:        " 17: [675,\n",
 834:        "  73,\n",
 835:        "  25,\n",
 836:        "  276,\n",
 837:        "  809,\n",
 838:        "  386,\n",
 839:        "  127,\n",
 840:        "  257,\n",
 841:        "  442,\n",
 842:        "  331,\n",
 843:        "  245,\n",
 844:        "  417,\n",
 845:        "  786,\n",
 846:        "  572,\n",
 847:        "  891,\n",
 848:        "  995,\n",
 849:        "  485,\n",
 850:        "  113,\n",
 851:        "  456,\n",
 852:        "  841,\n",
 853:        "  412,\n",
 854:        "  152,\n",
 855:        "  235,\n",
 856:        "  481,\n",
 857:        "  599,\n",
 858:        "  338,\n",
 859:        "  596,\n",
 860:        "  646,\n",
 861:        "  650,\n",
 862:        "  824,\n",
 863:        "  396,\n",
 864:        "  330,\n",
 865:        "  316,\n",
 866:        "  24,\n",
 867:        "  745,\n",
 868:        "  454,\n",
 869:        "  115,\n",
 870:        "  707,\n",
 871:        "  784,\n",
 872:        "  61,\n",
 873:        "  952,\n",
 874:        "  508,\n",
 875:        "  498,\n",
 876:        "  184,\n",
 877:        "  866,\n",
 878:        "  213,\n",
 879:        "  927,\n",
 880:        "  150,\n",
 881:        "  900,\n",
 882:        "  558],\n",
 883:        " 18: [648,\n",
 884:        "  999,\n",
 885:        "  624,\n",
 886:        "  203,\n",
 887:        "  146,\n",
 888:        "  182,\n",
 889:        "  585,\n",
 890:        "  704,\n",
 891:        "  906,\n",
 892:        "  670,\n",
 893:        "  482,\n",
 894:        "  984,\n",
 895:        "  785,\n",
 896:        "  503,\n",
 897:        "  486,\n",
 898:        "  296,\n",
 899:        "  239,\n",
 900:        "  875,\n",
 901:        "  252,\n",
 902:        "  492,\n",
 903:        "  537,\n",
 904:        "  99,\n",
 905:        "  335,\n",
 906:        "  957,\n",
 907:        "  200,\n",
 908:        "  506,\n",
 909:        "  108,\n",
 910:        "  193,\n",
 911:        "  588,\n",
 912:        "  359,\n",
 913:        "  657,\n",
 914:        "  373,\n",
 915:        "  94,\n",
 916:        "  60,\n",
 917:        "  960,\n",
 918:        "  366,\n",
 919:        "  14,\n",
 920:        "  3,\n",
 921:        "  810,\n",
 922:        "  951,\n",
 923:        "  583,\n",
 924:        "  142,\n",
 925:        "  761,\n",
 926:        "  637,\n",
 927:        "  505,\n",
 928:        "  711,\n",
 929:        "  339,\n",
 930:        "  35,\n",
 931:        "  851,\n",
 932:        "  743],\n",
 933:        " 19: [50,\n",
 934:        "  349,\n",
 935:        "  156,\n",
 936:        "  853,\n",
 937:        "  251,\n",
 938:        "  620,\n",
 939:        "  160,\n",
 940:        "  822,\n",
 941:        "  275,\n",
 942:        "  4,\n",
 943:        "  792,\n",
 944:        "  767,\n",
 945:        "  472,\n",
 946:        "  577,\n",
 947:        "  907,\n",
 948:        "  580,\n",
 949:        "  723,\n",
 950:        "  611,\n",
 951:        "  147,\n",
 952:        "  992,\n",
 953:        "  172,\n",
 954:        "  998,\n",
 955:        "  348,\n",
 956:        "  521,\n",
 957:        "  575,\n",
 958:        "  21,\n",
 959:        "  651,\n",
 960:        "  854,\n",
 961:        "  591,\n",
 962:        "  176,\n",
 963:        "  837,\n",
 964:        "  918,\n",
 965:        "  635,\n",
 966:        "  571,\n",
 967:        "  976,\n",
 968:        "  56,\n",
 969:        "  826,\n",
 970:        "  174,\n",
 971:        "  311,\n",
 972:        "  271,\n",
 973:        "  496,\n",
 974:        "  913,\n",
 975:        "  855,\n",
 976:        "  557,\n",
 977:        "  139,\n",
 978:        "  209,\n",
 979:        "  552,\n",
 980:        "  369,\n",
 981:        "  638,\n",
 982:        "  218],\n",
 983:        " 20: [748,\n",
 984:        "  690,\n",
 985:        "  545,\n",
 986:        "  756,\n",
 987:        "  95,\n",
 988:        "  730,\n",
 989:        "  649,\n",
 990:        "  405,\n",
 991:        "  526,\n",
 992:        "  993,\n",
 993:        "  130,\n",
 994:        "  399,\n",
 995:        "  426,\n",
 996:        "  764,\n",
 997:        "  300,\n",
 998:        "  440,\n",
 999:        "  477,\n",
1000:        "  655,\n",
1001:        "  85,\n",
1002:        "  322,\n",
1003:        "  452,\n",
1004:        "  395,\n",
1005:        "  304,\n",
1006:        "  91,\n",
1007:        "  490,\n",
1008:        "  175,\n",
1009:        "  83,\n",
1010:        "  445,\n",
1011:        "  835,\n",
1012:        "  702,\n",
1013:        "  931,\n",
1014:        "  104,\n",
1015:        "  726,\n",
1016:        "  865,\n",
1017:        "  178,\n",
1018:        "  794,\n",
1019:        "  522,\n",
1020:        "  727,\n",
1021:        "  640,\n",
1022:        "  501,\n",
1023:        "  698,\n",
1024:        "  967,\n",
1025:        "  988,\n",
1026:        "  120,\n",
1027:        "  434,\n",
1028:        "  664,\n",
1029:        "  641,\n",
1030:        "  51,\n",
1031:        "  886,\n",
1032:        "  12,\n",
1033:        "  433,\n",
1034:        "  102,\n",
1035:        "  122,\n",
1036:        "  714,\n",
1037:        "  32,\n",
1038:        "  31,\n",
1039:        "  371,\n",
1040:        "  344,\n",
1041:        "  157,\n",
1042:        "  38,\n",
1043:        "  922,\n",
1044:        "  880,\n",
1045:        "  16,\n",
1046:        "  961,\n",
1047:        "  930,\n",
1048:        "  363,\n",
1049:        "  136,\n",
1050:        "  555,\n",
1051:        "  909,\n",
1052:        "  696,\n",
1053:        "  559,\n",
1054:        "  543,\n",
1055:        "  667,\n",
1056:        "  382,\n",
1057:        "  191],\n",
1058:        " 21: [567,\n",
1059:        "  817,\n",
1060:        "  383,\n",
1061:        "  116,\n",
1062:        "  68,\n",
1063:        "  888,\n",
1064:        "  944,\n",
1065:        "  33,\n",
1066:        "  401,\n",
1067:        "  430,\n",
1068:        "  881,\n",
1069:        "  499,\n",
1070:        "  260,\n",
1071:        "  754,\n",
1072:        "  372,\n",
1073:        "  919,\n",
1074:        "  185,\n",
1075:        "  821,\n",
1076:        "  905,\n",
1077:        "  123,\n",
1078:        "  732,\n",
1079:        "  90,\n",
1080:        "  273,\n",
1081:        "  705,\n",
1082:        "  871,\n",
1083:        "  141,\n",
1084:        "  551,\n",
1085:        "  836,\n",
1086:        "  671,\n",
1087:        "  27,\n",
1088:        "  93,\n",
1089:        "  563,\n",
1090:        "  936,\n",
1091:        "  639,\n",
1092:        "  488,\n",
1093:        "  487,\n",
1094:        "  328,\n",
1095:        "  774],\n",
1096:        " 22: [470,\n",
1097:        "  258,\n",
1098:        "  378,\n",
1099:        "  509,\n",
1100:        "  459,\n",
1101:        "  887,\n",
1102:        "  246,\n",
1103:        "  520,\n",
1104:        "  438,\n",
1105:        "  601,\n",
1106:        "  856,\n",
1107:        "  343,\n",
1108:        "  143,\n",
1109:        "  280,\n",
1110:        "  597,\n",
1111:        "  140,\n",
1112:        "  183,\n",
1113:        "  444,\n",
1114:        "  681],\n",
1115:        " 23: [894, 538, 253, 468, 194, 367, 173, 632, 479],\n",
1116:        " 24: [800, 46, 882, 799, 874],\n",
1117:        " 25: [169, 806],\n",
1118:        " 0: [297],\n",
1119:        " 26: [755]}"
1120:       ]
1121:      },
1122:      "execution_count": 64,
1123:      "metadata": {},
1124:      "output_type": "execute_result"
1125:     }
1126:    ],
1127:    "source": [
1128:     "sbm.block_members"
1129:    ]
1130:   },
1131:   {
1132:    "cell_type": "code",
1133:    "execution_count": 36,
1134:    "metadata": {},
1135:    "outputs": [
1136:     {
1137:      "ename": "KeyError",
1138:      "evalue": "2",
1139:      "output_type": "error",
1140:      "traceback": [
1141:       "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
1142:       "\u001b[0;31mKeyError\u001b[0m                                  Traceback (most recent call last)",
1143:       "Cell \u001b[0;32mIn[36], line 2\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[38;5;66;03m# Perform some partition manipulations\u001b[39;00m\n\u001b[0;32m----> 2\u001b[0m \u001b[43msbm\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mmerge_blocks\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;241;43m1\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m2\u001b[39;49m\u001b[43m)\u001b[49m\n\u001b[1;32m      3\u001b[0m sbm\u001b[38;5;241m.\u001b[39mmove_node(\u001b[38;5;241m10\u001b[39m, \u001b[38;5;241m3\u001b[39m)\n\u001b[1;32m      5\u001b[0m \u001b[38;5;66;03m# Compute the new likelihood\u001b[39;00m\n",
1144:       "File \u001b[0;32m~/anon_sbm/src/sbm/sbm.py:159\u001b[0m, in \u001b[0;36mStochasticBlockModel.merge_blocks\u001b[0;34m(self, block_a, block_b)\u001b[0m\n\u001b[1;32m    157\u001b[0m new_block_idx \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mmin\u001b[39m(block_a, block_b)\n\u001b[1;32m    158\u001b[0m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mblock_members[new_block_idx] \u001b[38;5;241m=\u001b[39m merged_nodes\n\u001b[0;32m--> 159\u001b[0m \u001b[38;5;28;01mdel\u001b[39;00m \u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mblock_members\u001b[49m\u001b[43m[\u001b[49m\u001b[38;5;28;43mmax\u001b[39;49m\u001b[43m(\u001b[49m\u001b[43mblock_a\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mblock_b\u001b[49m\u001b[43m)\u001b[49m\u001b[43m]\u001b[49m\n\u001b[1;32m    161\u001b[0m \u001b[38;5;66;03m# Update blocks mapping\u001b[39;00m\n\u001b[1;32m    162\u001b[0m \u001b[38;5;28;01mfor\u001b[39;00m node \u001b[38;5;129;01min\u001b[39;00m merged_nodes:\n",
1145:       "\u001b[0;31mKeyError\u001b[0m: 2"
1146:      ]
1147:     }
1148:    ],
1149:    "source": [
1150:     "# Perform some partition manipulations\n",
1151:     "sbm.merge_blocks(1, 2)\n",
1152:     "sbm.move_node(10, 3)\n",
1153:     "\n",
1154:     "# Compute the new likelihood\n",
1155:     "new_likelihood = sbm.compute_likelihood()\n",
1156:     "print(f\"New Likelihood: {new_likelihood}\")\n",
1157:     "\n",
1158:     "# Check minimum block size\n",
1159:     "min_size = sbm.min_block_size()\n",
1160:     "print(f\"Minimum Block Size: {min_size}\")"
1161:    ]
1162:   },
1163:   {
1164:    "cell_type": "code",
1165:    "execution_count": null,
1166:    "metadata": {},
1167:    "outputs": [],
1168:    "source": []
1169:   }
1170:  ],
1171:  "metadata": {
1172:   "kernelspec": {
1173:    "display_name": "anon_sbm",
1174:    "language": "python",
1175:    "name": "python3"
1176:   },
1177:   "language_info": {
1178:    "codemirror_mode": {
1179:     "name": "ipython",
1180:     "version": 3
1181:    },
1182:    "file_extension": ".py",
1183:    "mimetype": "text/x-python",
1184:    "name": "python",
1185:    "nbconvert_exporter": "python",
1186:    "pygments_lexer": "ipython3",
1187:    "version": "3.13.0"
1188:   }
1189:  },
1190:  "nbformat": 4,
1191:  "nbformat_minor": 2
1192: }

================
File: notebooks/noisy_network_sampling_07-07-2025.ipynb
================
  1: {
  2:  "cells": [
  3:   {
  4:    "cell_type": "markdown",
  5:    "id": "d44396b3",
  6:    "metadata": {},
  7:    "source": [
  8:     "# Test that sampling noisy SBMFit and graph from noisy SBMFit works"
  9:    ]
 10:   },
 11:   {
 12:    "cell_type": "code",
 13:    "execution_count": 1,
 14:    "id": "80082d4e",
 15:    "metadata": {},
 16:    "outputs": [],
 17:    "source": [
 18:     "from pathlib import Path\n",
 19:     "import numpy as np\n",
 20:     "import scipy.sparse as sp\n",
 21:     "from sbm.sampling import sample_sbm_graph_from_fit\n",
 22:     "\n",
 23:     "from sbm.io import SBMFit, SBMWriter\n",
 24:     "from sbm.noisy_fit import create_sbm_noise\n",
 25:     "\n",
 26:     "RNG = np.random.default_rng(0)"
 27:    ]
 28:   },
 29:   {
 30:    "cell_type": "markdown",
 31:    "id": "b7b0346b",
 32:    "metadata": {},
 33:    "source": [
 34:     "# Test for empirical fit"
 35:    ]
 36:   },
 37:   {
 38:    "cell_type": "code",
 39:    "execution_count": 18,
 40:    "id": "52d2519e",
 41:    "metadata": {},
 42:    "outputs": [
 43:     {
 44:      "name": "stdout",
 45:      "output_type": "stream",
 46:      "text": [
 47:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_enron_email_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_3\n"
 48:      ]
 49:     }
 50:    ],
 51:    "source": [
 52:     "sbm = SBMWriter.load(\n",
 53:     "    Path(\"/Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_enron_email_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_3\")\n",
 54:     ")"
 55:    ]
 56:   },
 57:   {
 58:    "cell_type": "code",
 59:    "execution_count": 19,
 60:    "id": "6142e5d8",
 61:    "metadata": {},
 62:    "outputs": [
 63:     {
 64:      "name": "stdout",
 65:      "output_type": "stream",
 66:      "text": [
 67:       "Block-conn array before noise:\n",
 68:       "[[0 4 3 ... 0 0 0]\n",
 69:       " [4 3 2 ... 0 0 0]\n",
 70:       " [3 2 1 ... 0 0 0]\n",
 71:       " ...\n",
 72:       " [0 0 0 ... 1 0 0]\n",
 73:       " [0 0 0 ... 0 2 0]\n",
 74:       " [0 0 0 ... 0 0 1]]\n",
 75:       "max σ_n: 0.017, max σ_e: 0.065\n",
 76:       "[LASSO]    Added 0 edges to previously-zero pairs\n",
 77:       "Block-conn array after noise+post-processing:\n",
 78:       "[[0 4 3 ... 0 0 0]\n",
 79:       " [4 3 2 ... 0 0 0]\n",
 80:       " [3 2 1 ... 0 0 0]\n",
 81:       " ...\n",
 82:       " [0 0 0 ... 1 0 0]\n",
 83:       " [0 0 0 ... 0 2 0]\n",
 84:       " [0 0 0 ... 0 0 1]]\n",
 85:       "[NAIVE]    Added 0 edges to zero pairs.\n",
 86:       "Block-conn array after noise+post-processing:\n",
 87:       "[[0 3 3 ... 0 0 0]\n",
 88:       " [3 2 1 ... 0 0 0]\n",
 89:       " [3 1 0 ... 0 0 0]\n",
 90:       " ...\n",
 91:       " [0 0 0 ... 0 0 0]\n",
 92:       " [0 0 0 ... 0 1 0]\n",
 93:       " [0 0 0 ... 0 0 0]]\n"
 94:      ]
 95:     }
 96:    ],
 97:    "source": [
 98:     "EPS, DELTA, ALPHA = 1, 1e-4, 1-1e-4\n",
 99:     "\n",
100:     "print(f'Block-conn array before noise:\\n{sbm.block_conn.toarray()}')\n",
101:     "noise = create_sbm_noise(sbm, EPS, DELTA, ALPHA, noise_type=\"heterogeneous_gaussian\")\n",
102:     "\n",
103:     "lasso_noisy_fit = noise.sample_sbm_fit(RNG, post='lasso')\n",
104:     "print(f'Block-conn array after noise+post-processing:\\n{lasso_noisy_fit.block_conn.toarray()}')\n",
105:     "naive_noisy_fit = noise.sample_sbm_fit(RNG, post='naive')\n",
106:     "print(f'Block-conn array after noise+post-processing:\\n{naive_noisy_fit.block_conn.toarray()}')"
107:    ]
108:   },
109:   {
110:    "cell_type": "code",
111:    "execution_count": 4,
112:    "id": "0cac595b",
113:    "metadata": {},
114:    "outputs": [],
115:    "source": [
116:     "#graph_data = sample_sbm_graph_from_fit(noisy_fit, rng=RNG)\n",
117:     "#print(f'Sampled adjacency:\\n{graph_data.adjacency.toarray()}')"
118:    ]
119:   },
120:   {
121:    "cell_type": "code",
122:    "execution_count": 14,
123:    "id": "145a2f32",
124:    "metadata": {},
125:    "outputs": [],
126:    "source": [
127:     "value, counts = np.unique(sbm.block_conn.toarray().ravel(), return_counts=True)\n",
128:     "lasso_value, lasso_counts = np.unique(lasso_noisy_fit.block_conn.toarray().ravel(), return_counts=True)\n",
129:     "naive_value, naive_counts = np.unique(naive_noisy_fit.block_conn.toarray().ravel(), return_counts=True)"
130:    ]
131:   },
132:   {
133:    "cell_type": "code",
134:    "execution_count": 15,
135:    "id": "dcebf810",
136:    "metadata": {},
137:    "outputs": [
138:     {
139:      "data": {
140:       "image/png": "iVBORw0KGgoAAAANSUhEUgAAA04AAAFLCAYAAADh8twbAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjMsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvZiW1igAAAAlwSFlzAAAPYQAAD2EBqD+naQAAQ9hJREFUeJzt3QecFPXdx/HfHeVo0qV3QRSVooCCUWKJKMUSo8YYQewGFYIxESOgWDAxKD4GRUTFGow8UkTFQrUgEQgiFgQ8qjTpHbyb5/X9w+yzu+zd3N3ecbu3n/frtdzt7H9m/jO792N/8y+T5nmeZwAAAACAHKXn/BIAAAAAQEicAAAAACAAiRMAAAAABCBxAgAAAIAAJE4AAAAAEIDECQAAAAACkDgBAAAAQAASJwAAAAAIQOIEAAAAAAFInIrI/fffb2lpaQVad+zYsW7dFStWWFHRtrUP7SsvdZk3b17gNn/5y1+6R1FRPW6//fYi234qKOr3CAAAoKQicYry9ddf2+9//3urX7++ZWRkWL169eyaa65xywEAAACkJhKnMG+99ZadeuqpNm3aNOvTp489/fTTdsMNN9iMGTPc8gkTJuR5W/fdd5/t3bu3QPW49tpr3bqNGzcu0PoAAAAAClfpQt5e0lq+fLlLWJo1a2azZ8+2Y489NvRav3797KyzznKvL1q0yJXJye7du61ixYpWunRp9yiIUqVKuQcAAACAxECL02GPPfaY7dmzx0aPHh2RNEnNmjXt2WefdUnR3//+9yPGMX3zzTf2u9/9zqpVq2a/+MUvIl4Lp1akO++8023vmGOOsYsvvtjWrl3ryql8bmOcmjRpYj169LBPPvnEOnbsaOXKlXMJ3Msvvxyxjy1bttif/vQnO+WUU6xSpUpWuXJlu+iii+zLL7+M6/zo3Nxyyy1Wo0YNt81evXrZ1q1bA9fbuHGja7WrXbu2q3ObNm3spZdeOqJcdna2Pfnkk67eKqf34MILLwwcW/XQQw9Zenq6PfXUU4F12bZtm/3xj39051LdMBs0aOCO46effspXff3xYf/4xz/c5+W4445z2+vQoYN98cUXEWWvu+469z7ofb700kvd7zo2vUdZWVm51lfvd05JeqdOnax9+/ah5y+++KKde+65VqtWLVeXVq1a2TPPPFPg8XQzZ850y/Uz3Ny5c937UqVKFatQoYJ16dLFPv3004gyO3futP79+4fOs+r0q1/9yhYsWBBYHwAAgERFi9Nhb7/9tvuip5alWM4++2z3+jvvvHPEa1dccYW1aNHCHnnkEfM8L8d96Ev0v//9b9dydcYZZ9isWbOse/fuea7jsmXL7De/+Y37Yt+7d2974YUX3DZPO+00O+mkk1yZH374wSZOnOjq1LRpU9uwYYNL+vQFVwmexmwVhCZlqFq1qkvwlixZ4r6Ur1y5MvQFOxYlipqIQPXW+qrPm2++6eqsJEYteT4dk77EK8m78cYb7eeff7aPP/7YPv/884gEIbo7pM65ju+mm27Ktf67du1y7+23335r119/vet6qYRp8uTJtmbNGpfM5qe+8vrrr7skQQmlzoGS6l//+tfuPShTpkyonBKkrl272umnn+6SrY8++siGDx/uEq7bbrstxzpfddVVLrFTMqakzKfzrvOiZN+n90OfASXjaunU5/kPf/iDS0j79u1rhWH69Onu/dHnbciQIS5h9RM2vVdK6OXWW2+18ePHu3OoBG7z5s0u4de513kHAABISh68bdu2KdvxLrnkklzLXXzxxa7cjh073PMhQ4a451dfffURZf3XfPPnz3fP+/fvH1Huuuuuc8tV3vfiiy+6ZZmZmaFljRs3dstmz54dWrZx40YvIyPDu+uuu0LL9u3b52VlZUXsQ9tRuaFDh0Ys0/a0r9z4dTnttNO8AwcOhJb//e9/d8snTZoUWtalSxf38I0YMcKVefXVV0PLtI1OnTp5lSpVCp3H6dOnu3J33nnnEfvPzs4O/a4yffv2db/rmNPT072xY8d6eTF48GC3/ltvvZXjPvJaX//c1ahRw9uyZUuorM6Flr/99tuhZb1793bLws+9tGvXzp3T3Gzfvv2I99c/92lpad7KlStDy/bs2XPE+l27dvWaNWsWsSz6PYr1WZMZM2a45frpn6MWLVq4bYa/J9pv06ZNvV/96lehZVWqVAm9TwAAACUFXfUOdy0SdZ/Ljf/6jh07IpbrCnuQqVOnup9qBQh3xx135Lmeunof3iKmLl8tW7Z0LRw+dY1SS4Df0qGr/eoepnLxdJW6+eabI1pR1FKilo133303x3X0Wp06dezqq68OLdM21F1RLUBqcZP//d//dS02asWIFt2apfxJLRnq1vfqq6+6lre80D7U7e6yyy7LcR95rW94i5C6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1LhxY5do6R5iSm40Vf7IkSNzXKd27druRte6zUE03d5B91HTbStkz549rqxmRFV9dHuGM88807WEDRgwoJCOFsDRoluQ6H6FupCiCyAaSqGbu3ft2tXNgOxT8qNbslSrVs2V00UcraN7Pvq0rhIn3dpDF1s0JEPDMxYsWBAqo3scatsbN2505RU3PvvsMxdHdA9RJChNRw4AQCJ78cUXdesM74svvvCWL1/ulS5d2rvzzjtDr3fp0sU76aSTQs/37NlzxDa6du3qNWvWLGKZ1tPD9+yzz7r9fPXVVxHlWrVq5Z177rmh5w8++KBXsWJF7/vvv48od88993ilSpXyVq1aFecRAyiqGBLLzz//7O3fvz9i2datW73atWt7119/fWhZv379vMqVK7vyOWnTpo3XvXv3XOvTtm1br1atWt7mzZtDy7788ksvPT3d69WrVz6ODEcTLU4AgKTSrFkzd9Pr0aNH27p162KW0Q2tfdu3b3c3NFcL0Q8//OCe5+TXv/61666nFibf4sWL7ZtvvrGrrroqtOzNN990XWx01Vnb9h+6SbW6Es6ePbvQjhdA0VOLsj/mUd1tt2zZYj///LO1b98+oqVIXep27959RLe7cCrz9ddf29KlS2O+rrilVqzrrrvOqlevHlreunVrNxb+3XffLdRjQ+FJ6cRJ/7H17NnTDTBW3/WJEyfmexu6f/A//vEPO/74410f9/r169vDDz9cJPUFABxy3333uS81OY11UrcZJTH+2IFjjz3WdduT3BKnmjVr2nnnnRfRXU9JlJIpJVU+fSGaOnWq2274Q/sUdb8BkFx0ixglL/64JP1Nv/POOxExQ11+9Z3voosusgYNGtj111/vYkG4oUOHujGQKqfxT3fffbctWrQo9PrKlSvdz5YtWx5RhxNPPNFdhFFyhsST0omTPpRt2rTJtc97kH79+rk+sUqevvvuO5s8ebJ17NixUOsJADiy1en3v/99zFan5cuXu+RHXz4ef/xx98VHV4f/+Mc/uteDJm/47W9/a99//31oXIOSKG1PSZVP29CVYW031uPyyy8vkuMGUDQ0XlEtQMcdd5w9//zzLhnS37ImmQmPGZpwRrFB3/d0b05NHqEkqnfv3qEyZ599totDL7zwgru/nL4nnnrqqe4nkltKT0euD7oeud0vRAP6/vWvf7krB/rwayCgPwOT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Qyxbtsw6duxoW7ZsSdizy4BMAPHGK+IIgHjiCDEESE6FOjnEnDlzrFy5cnkuP3v2bOvZs6fVq1fP9R2eOHFi4DozZ860U0891TIyMqx58+Y2duzYOGsNIBXlN14BQDTiCJBaCtRV79e//nXEczVarVu3zubNm2eDBg3K83Z2795tbdq0seuvv/6IbcaSmZlp3bt3t1tvvdVee+01mzZtmrubd926da1r164FORQAJVxhxSsAqYs4AqDAiZOal8Olp6dby5YtbejQoXbBBRfkeTsXXXSRe+TVqFGjrGnTpjZ8+HD3/MQTT7RPPvnE9T0mcQJQlPEKQOoijgAocOL04osvFluT+Pnnnx+xTAlT//79c1xn//797hHerxhA6iiMeEUcAVJbvHGEGAKkcOLkmz9/vn377bfu95NOOsnatWtnRWn9+vVWu3btiGV6rgC0d+9eK1++/BHrDBs2zB544IEirReAxBdPvCKOAIgnjhBDgBROnDZu3Gi//e1v3UQNVatWdcu2bdvmbhA3btw4O/bYYy1RDBw40AYMGBB6riSrYcOGxVonAEdPYcQr4giQ2uKNI8QQIIVn1bvjjjts586d9vXXX7spOPXQTeAUCO68804rKnXq1LENGzZELNNzTeUZq7VJNPueXg9/AEgdhRGviCNAaos3jhBDgBRucZo6dap99NFHbnIGX6tWrWzkyJFFOkiyU6dO9u6770Ys+/DDD91yAEikeAWg5CCOAChwi1N2draVKVPmiOVaptfySnfbXrhwoXv4043r91WrVoWatnv16hUqr2nIf/jhB/vzn/9s3333nT399NP273//2/74xz/ybgIo0ngFIHURRwAUOHE699xzrV+/fvbjjz+Glq1du9YlMOedd16et6P7H2hgpT+4Uv1/9fvgwYPdc90jwU+iRFORv/POO66VSfd/0rTkY8aMYSpyAEUerwCkLuIIAEnzdBe3fFq9erVdfPHFrq+vP7hRy04++WSbPHmyNWjQIGHPrvoj634M27dvp48xkAKKIl4RR4DUUthxhBgCpFDiJFpN/X3VZU7U7zf6HkuJiGAFpJ7CjlfEESD1FGYcIYYAKZA4TZ8+3W6//Xb7/PPPj/hD1x9/586dbdSoUXbWWWdZoiJYAamhKOMVcQRIDUUVR4ghQAqMcRoxYoTddNNNMf/IFQBuueUWe/zxxwuz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krKr3tFG8ziAeBFHAMSDGAIkpxI/qx4AAAAAxIvECQAAAAASfYzT0eb3TFQzOYDEoCljk+k+JcQRIPEkUxwhhgDJGUNSLnHS/PrS8PA9fQAUv2Tr508cARJPMsURYgiQnDEk5SaH0H2ifvzxxzxllboSpKC2evXqpAnGBcWxlkzJcqzJdKU4P3EkWc5/YUilY021402WY02mOMJ3kdg41pJpR5IcKy1OMWhq8/zePVhvciK/0YWJYy2ZUulYEzGOpNL5T6VjTbXjTaVjLWp8F8kdx1oyVS4Bx8rkEAAAAAAQgMQJAAAAAAKQOOUiIyPDhgwZ4n6WdBxryZRKx5qIUun8p9KxptrxptKxJqJUOv8ca8mUUYKONeUmhwAAAACA/KLFCQAAAAACkDgBAAAAQAASJwAAAAAIQOIEAAAAAAFInHIwcuRIa9KkiZUrV85OP/10+89//mPJZvbs2dazZ0+rV6+euxPyxIkTI17XvCCDBw+2unXrWvny5e3888+3pUuXRpTZsmWLXXPNNe6GZVWrVrUbbrjBdu3aZYlm2LBh1qFDB3fX51q1atmll15qS5YsiSizb98+69u3r9WoUcMqVapkl19+uW3YsCGizKpVq6x79+5WoUIFt527777bfv75Z0skzzzzjLVu3Tp0I7lOnTrZe++9V+KOsyQgjiRPHEmlGCLEkeRADEmeGJJqceSZVI0hmlUPkcaNG+eVLVvWe+GFF7yvv/7au+mmm7yqVat6GzZs8JLJu+++6/31r3/13nrrLc2c6E2YMCHi9UcffdSrUqWKN3HiRO/LL7/0Lr74Yq9p06be3r17Q2UuvPBCr02bNt7nn3/uffzxx17z5s29q6++2ks0Xbt29V588UVv8eLF3sKFC71u3bp5jRo18nbt2hUqc+utt3oNGzb0pk2b5s2bN88744wzvM6dO4de//nnn72TTz7ZO//8873//ve/7vzVrFnTGzhwoJdIJk+e7L3zzjve999/7y1ZssS79957vTJlyrhjL0nHmeyII8kVR1IphghxJPERQ5IrhqRaHJmcojGExCmGjh07en379g09z8rK8urVq+cNGzbMS1bRwSo7O9urU6eO99hjj4WWbdu2zcvIyPD+9a9/uefffPONW++LL74IlXnvvfe8tLQ0b+3atV4i27hxo6v7rFmzQsemP+g333wzVObbb791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nZ0dKjNy5EivUqVKXlZWlrdjxw4vIyPDe+6552Lu09/exx9/7J133nneL37xC2/btm251vPZZ5/1jjnmGG/z5s0xX+/cubN30003RSy74oorvG7duoWea5/33Xdf6PmuXbvcsvfee889nzFjhnv+0Ucfhcq88847btnevXtj7nfjxo1e6dKlvdmzZ4eWderUyfvLX/6S47F88cUXbps7d+6M2O/WrVvd8yFDhnht2rSJWOeJJ57wGjduHHp+3HHHea+//npEmQcffNDtGziaiCHEECBexBHiSElEi1MJdc4557irLHr85z//sa5du9pFF11kK1eujFleVxU6derkmpJ9Z555prsSoyZsva6rN+edd16u+1VT9+7du+2DDz6wKlWqhJbfeuutVqlSpdBDVLd27dq5pvGc6qQ6hNNzLQ/XunXr0O9qYq9cufIRTdXhZdT0Lzk1Zx977LF2wQUXuKsukpmZaXPmzHFXf3zz58+3nj17uitYaiLX1SrJrStAbnTOli9fbjfccEPEedJVNi0HjjZiCDEEiBdxhDhS0pA4lVD6o1VzuB5q8lZ/Vf1BPPfccwXaXvny5fNUTs3TaqbWH3e4oUOHhoKnP01oXrcZRP19wyng+k3sscr4ATm6TDgFpvHjx7tmcHUDOOWUU9xDdB4V/BUUFdC++OIL15QvBw4ciLm99PT0iOZ20bZ9+k9B9P6Enyd1C/j888/zfC6AwkIMIYYA8SKOEEdKGhKnFKE/UP3B7N27N+brGgSoABP+B/Xpp5+6KxgNGjRwAx0VXDSwMTe33Xab63t88cUXuwGevlq1aoWCpx7+lRf9QUb3AQ6vk+oQTs9btWplRe2SSy6xffv22dSpU12wCr/C891339nmzZvdcaqfsQZO5jYY079ytH79+ojzG36fCfXPVr/lH374IeI86dG0adMiOkog74gh+UMMAY5EHMkf4kgCKu6+giiafsUXXniht27dOvf45ptvvD/84Q9eWlqa6+8aq1/xmjVrvAoVKnh9+/b1vv32W2/ixIlezZo1XX9Y3/333+9Vq1bNe+mll7xly5Z5c+bM8caMGRNze+ozqz7J6meck/3793vHH3+8d9ZZZ3mffPKJt3z5cm/8+PHeZ5995l6fMGGCV6ZMGe/pp5/2vv/+e2/48OGuv7R/DKJ9qly4KlWqeC+++GLM/r2iOmqZ6pyba665xvUF1nlbuXJlRL/jsmXLenfffber86RJk9xxhB9/9H71Hmg7jz76qDt3//znP925DO9XrD7b5cuX95588klvyZIl3qJFi7wXXnjBHTdwNBFDiCFAvIgjxJGSiMSphAYr/aH4Dw167NChgwsEvujgIjNnznTl9IdYp04dNwDx4MGDodc1MPOhhx5yf2AKIo0aNfIeeeSRHLenPzLt+9NPP82xritWrPAuv/xyr3Llyi5Ytm/f3ps7d27odQWqZs2auf0pILz88ssR6xdlsHr33XddubPPPvuI1zRwskmTJm6QqgZMTp48OddgJc8884zXsGFDN0i2V69e3sMPPxwRrOS1117z2rZt694DBTPt+6233sq1nkBhI4YQQ4B4EUeIIyVRmv4p7lYvAAAAAEhkjHECAAAAgAAkTgAAAAAQgMQJAAAAAAKQOAEAAABAABInAAAAAAhA4gQAAAAAAUicAAAAACAAiRMAAAAABCBxAgAAAIAAJE4AAAAAEIDECQAAAAAsd/8HkK+UrfKDHgYAAAAASUVORK5CYII=",
141:       "text/plain": [
142:        "<Figure size 1000x300 with 3 Axes>"
143:       ]
144:      },
145:      "metadata": {},
146:      "output_type": "display_data"
147:     }
148:    ],
149:    "source": [
150:     "import matplotlib.pyplot as plt\n",
151:     "\n",
152:     "fig, ax = plt.subplots(ncols=3, sharex=True, figsize=(10,3), sharey=True)\n",
153:     "ax[0].plot(value, counts, marker='.', linewidth=0, color='teal')\n",
154:     "ax[1].plot(naive_value, naive_counts, marker='.', linewidth=0, color='salmon')\n",
155:     "ax[2].plot(lasso_value, lasso_counts, marker='.', linewidth=0, color='black')\n",
156:     "\n",
157:     "ax[0].set_title('Original block-conn values')\n",
158:     "ax[1].set_title('Naive')\n",
159:     "ax[2].set_title('Lasso')\n",
160:     "\n",
161:     "for axis in ax:\n",
162:     "    axis.set_xlabel('Block-conn value')\n",
163:     "    axis.set_ylabel('Count')\n",
164:     "    #axis.set_yscale('log')\n",
165:     "    # remove the right and top spines\n",
166:     "    axis.spines[['right', 'top']].set_visible(False)\n",
167:     "\n",
168:     "plt.show(fig)"
169:    ]
170:   },
171:   {
172:    "cell_type": "code",
173:    "execution_count": 16,
174:    "id": "df15335a",
175:    "metadata": {},
176:    "outputs": [
177:     {
178:      "data": {
179:       "image/png": "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9OnTR6UUNWYPcYuTJ0+qtJF44Ff/8ssvq5/37NnjTSuKz/bxxx9rmzZt0m655RbLtKJXXnmltmrVKu2bb77R6tat67i0og888IBKj7po0SLtwIED3scvv/ziXQepNpFqdOHChSrVZqtWrdTDnGrzpptuUqlJv/jiC+2iiy5yZKrNIUOGqGw/WVlZ6veG18hS9NVXX8XdZ3WreKlHEqUOSbR6hHWIO7AecVc9kkh1SKLWIwyibHjttdfULx7zMyDFKOYlcKPMzExVYZkf3bt396YWffLJJ7UqVaqoirpdu3Yq17/R0aNHVUVVunRplXayR48eqkJ0EqvPiAfma9ChMn7wwQdV+s2SJUtqt956q6rcjHbv3q117NhRu+CCC9RcBQMHDtTOnj2rOc3999+v1apVS/19osLB702vtOLts7pZPNQjiVKHJFo9wjrEPViPuKceSaQ6JFHrEQ/+iXVrGBERERERkVtwTBQREREREVEIGEQRERERERGFgEEUERERERFRCBhEERERERERhYBBFBERERERUQgYRBEREREREYWAQRQREREREVEIGEQRERERERGFgEEUye7du8Xj8ciGDRscuT+3W7RokTofx48fj3VRiAoM65GCxXqE4h3rkILFOiT6GETFufvuu099afRHxYoV5eabb5ZNmzbFumhE5BKsR4goEqxDKB4xiEoAqKgOHDigHgsWLJAiRYpI586dY10sInIR1iNEFAnWIRRvGEQlgOLFi0vVqlXVo3HjxjJkyBDJzs6WH3/80e82ixcvlubNm6ttq1WrprY5d+6c9/28vDx54YUXpE6dOmqd1NRUee655yz3lZubK/fff79cdtllsnfvXr/H3Ldvn9x1111SoUIFKVWqlDRt2lRWrVrlff/NN9+USy65RIoVKyb16tWTd955x2d73N2aNGmS3HrrrVKyZEmpW7eufPLJJ/maslF5Y99Yp3Xr1rJjxw6/ZcL7jz32mM8ynLeiRYvKkiVL1GuUA/srU6aMOsf/93//J4cPH/a7z6efflr9HozGjh0raWlpPsvwWS6//HIpUaKEOndvvPGG330SFTTWI79jPUIUHtYhv2MdEj8YRCWYU6dOybvvvqsqHDSnW9m/f7906tRJmjVrJhs3blQVxuTJk2X48OHedYYOHSrPP/+8PPnkk7J161Z5//33pUqVKvn2debMGenatavqk7x06VJVwfkr13XXXaeOjcoGxx08eLCqIGH27Nny8MMPy8CBA2Xz5s3St29f6dGjh2RmZvrs55lnnpFu3bqpLgL4DHfffbccO3bMZ53HH39cXnrpJVm7dq26E4ZK1R9s/8EHH4imad5l06dPl+rVq8s111yjXp89e1aeffZZVeY5c+aoftjouhCJ9957T5566in1n8G2bdtkxIgR6lxPmzYtov0SRQPrEdYjRJFgHcI6JC5oFNe6d++uJScna6VKlVIP/MqrVaumrVu3zrtOVlaWWv7f//5Xvf7nP/+p1atXT8vLy/Ou8+9//1srXbq0lpubq504cUIrXry4NnHiRMtj6vtbunSp1q5dO+3qq6/Wjh8/HrCc48eP18qUKaMdPXrU8v3WrVtrvXv39lnWtWtXrVOnTt7XOOYTTzzhfX3q1Cm17PPPP1evMzMz1ev58+d71/n000/Vsl9//dXyuIcPH9aKFCmiLVmyxLusVatW2mOPPeb3s6xZs0bt8+TJkz7H/emnn9TrYcOGaenp6T7bjBkzRqtVq5b39SWXXKK9//77Pus8++yz6thEhY31COsRokiwDmEdEo/YEpUA2rZtq+6+4LF69Wrp0KGDdOzYUfbs2WO5Pu42tGrVSjU369q0aaPu0KCZG+/jrk67du0CHhfN4adPn5avvvpKLrzwQu/yv/3tb1K6dGnvA1C2K6+8UjWf+ysTymCE11hu1KhRI+/PaIYvW7ZsvuZs4zroHgD+mrwvuugiuemmm9TdGMjKypIVK1aou0K6devWSUZGhrqzhWZ03MWCQN0FAsE5+/7776Vnz54+5wl337CcKBZYj7AeIYoE6xDWIfGGQVQCwBcYTeZ4oFkc/Vvx5Zg4cWJY+7vgggtsrYcmbDRl44tu9K9//ctbkeqpR+3uMxj0DzZC5as3w1uto1fO5nWMUEnNmjVLNZWjq0DDhg3VA3Ae8R8BKkhUbmvWrFHN/ZCTk2O5v6SkJJ8mecC+dfgPAvD7MZ4ndB1YuXKl7XNBFE2sR1iPEEWCdQjrkHjDICoB4cuKL8+vv/5q+T4GEKKyMX65li1bpu5s1KxZUw2SREWDQZGBPPDAA6qv8p///Gc1OFRXuXJlb0WKh35HBl9Oc59hY5lQBiO8rl+/vhS0W265RX777Tf54osvVMVlvPOzfft2OXr0qPqc6JeMQZeBBnLqd5QOHjzoc36N81igPzf6Of/vf//zOU941K5du4A+JVFoWI+EhvUIkS/WIaFhHeJAse5PSAXfD/nmm2/WDhw4oB5bt27VHnzwQc3j8aj+sVb9kPft26eVLFlS69evn7Zt2zZtzpw5WqVKlVT/Wd3TTz+tlS9fXps2bZq2a9cubcWKFdqkSZMs94c+tujDjH7J/pw5c0a79NJLtWuuuUb75ptvtO+//16bNWuWtnz5cvX+7NmztaJFi2pvvPGGtnPnTu2ll15S/av1zwA4JtYzuvDCC7W33nrLsj8woIxYhjIHcvfdd6u+wzhve/bs8emnXKxYMW3QoEGqzB9//LH6HMbPbz4ufgfYz/PPP6/O3euvv67OpbEfMvp4X3DBBdorr7yi7dixQ9u0aZM2ZcoU9bmJChvrEdYjRJFgHcI6JB4xiEqAigtfGv2BAZPNmjVTlYLOXNHAokWL1Hr4UlatWlUNXjx79qz3fQzqHD58uPqyoUJJTU3VRowY4Xd/+MLh2MuWLfNb1t27d2u33367VrZsWVVxNm3aVFu1apX3fVRaF198sToeKoe3337bZ/uCrLg+++wztd61116b7z0MukxLS1MDXDHY8pNPPglYccGbb76ppaSkqAG29957r/bcc8/5VFzw3nvvaY0bN1a/A1RsOPZHH30UsJxEBYH1COsRokiwDmEdEo88+CfWrWFERERERERuwTFRREREREREIWAQRUREREREFAIGUURERERERCFgEEVERERERBQCBlFEREREREQhYBBFREREREQUAgZRREREREREIWAQRUREREREFAIGUURERERERCFgEEVERERERBQCBlFERERERERi3/8D0dOCYRy6U0wAAAAASUVORK5CYII=",
180:       "text/plain": [
181:        "<Figure size 1000x300 with 3 Axes>"
182:       ]
183:      },
184:      "metadata": {},
185:      "output_type": "display_data"
186:     }
187:    ],
188:    "source": [
189:     "import matplotlib.pyplot as plt\n",
190:     "\n",
191:     "fig, ax = plt.subplots(ncols=3, sharex=True, figsize=(10,3), sharey=True)\n",
192:     "ax[0].plot(value, counts, marker='.', linewidth=0, color='teal')\n",
193:     "ax[1].plot(naive_value, naive_counts, marker='.', linewidth=0, color='salmon')\n",
194:     "ax[2].plot(lasso_value, lasso_counts, marker='.', linewidth=0, color='black')\n",
195:     "\n",
196:     "ax[0].set_title('Original block-conn values')\n",
197:     "ax[1].set_title('Naive')\n",
198:     "ax[2].set_title('Lasso')\n",
199:     "\n",
200:     "for axis in ax:\n",
201:     "    axis.set_xlabel('Block-conn value')\n",
202:     "    axis.set_ylabel('Count')\n",
203:     "    axis.set_yscale('log')\n",
204:     "    # remove the right and top spines\n",
205:     "    axis.spines[['right', 'top']].set_visible(False)\n",
206:     "\n",
207:     "plt.show(fig)"
208:    ]
209:   },
210:   {
211:    "cell_type": "code",
212:    "execution_count": 17,
213:    "id": "091a93af",
214:    "metadata": {},
215:    "outputs": [
216:     {
217:      "data": {
218:       "image/png": "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0Aee9erVq9xjNbTozddl5cqVcuedd0rPnj3Naw0S2uSgN2Od+lxrB/QGr5/+hw4d6j5uwoQJ5smzuo8GEL2p6+vnn3/erNMAoFO967NkWp16dlhpTzzxhCnl2bp1q6SkpJy2vrCw0EzL7vmE3YiICNNEotfGF92mtSWetFbDFSz0abTZ2dnmfVz0KfLapKPHDh48WOzi+PDhiWYXAAheeXl55imwWq677jr3Y96XLVtmmj9atGhR7vHah0GL0ifJjhw50gSAa6+91qzTJgwNETfffLN5rY+F1wCgocIzfKSlpbn3cT0c7oEHHnDfnJ988klZsWKFqUXQfhllufvuu+XWW28t93ybNGnis/anuLhYEhMTvdbr6++//97n+2mwKOsYXe/a7lrnax+7hFX4cCF8AAhnRz0+UZfmap52OThuXLnN2p52jx59Tuf1008/mX+fe/To4V4XFRUlXbt2lW+//bZSIeaGG26Q/v37myYIdezYMRNItD+E1na4nDx50nz699S5c2f38uHDh02zhKv2xEVff/PNNz7PoV69eqYgTMOHtjlqVaDace+95ivhA0A4qxkTE/B9y3syrX7q96SvIyMjK/Qeuq82v8THx8sLL7zgXn/06FHzdd68eac9Gbf0e2szzLk6l2aXBg0amHPKycnxWq+vk5KSfL6fbivvGNdXXaejXTz30X4sQdvhVIf8lNWZR6u2lPaW1eX69etLrVq1ZNCgQaddiEDQNkgtNLsAQPC64IILTB+LL7/80qv/w/r1600HyooYM2aMbN682fRz0PfybFrQZg6tXWnZsqVX0eYXXzTE6HGe56T0tXYE9UWbXTZt2lRuaeKj2SUmJkY6deokmZmZ7nXa6VVfp6am+vyeus3zGPXpp5+6j9GfUwOI5z5as6OjXsp7X7+wKuHgwYPWgQMH3OXTTz/Vu7i1YsUKs/3uu++2kpOTrczMTGv9+vVW9+7drR49elTmW1h5eXnmPfVrVThaUGDJpEmm5B0/bv3444/WkSNHquS9ASBYnThxwtq6dav5GkrGjRtnNWnSxFq2bJm1ZcsWa+jQoVa9evWs33777YzHvvTSS1ZkZKT13nvved2rXP/mz5s3z4qLi7Nmzpxpbd++3fr222/NMU899ZTZvmvXLnP/+frrr73ed/r06VZ8fLy1ePFi6/vvv7ceeOABKzo62vrhhx/8dBUs871iY2OthQsXmt/jiBEjrDp16ljZ2dnufe68805rwoQJ7tdffvmlFRUVZU2bNs3atm2bNXHiRHOemzdvdu8zZcoU8z7vvvuu+fkHDBhgNW/evMJ/J1X1d1Wp8FHa6NGjrQsuuMAqKSmxcnNzzQ+5dOlS93b94fUXmZWVFRTh4/CJE4QPAGEhVMNHQUGBlZaWZjVs2NDcfHv27GmtW7euQsdqUNH7R+miN2GX1157zerYsaMVExNj1a1b1+rVq5f11ltvlRs+iouLrUmTJllNmzY197kOHTqYcORvs2bNslJSUsy5du3a1Vq9erXX9t69e5uf2dOSJUus1q1bm2Pat29vffjhh17b9X790EMPWYmJieb6XnPNNSaI2f13VU3/czY1JloVplVGOqznb3/7m/zrX/+Sa665Rn777TepU6eOe79mzZqZnsNaFVYWHf6qxbMKSIdXaYchre6qij4frmFlRyZMkIO//CINGzaU2rVrn/N7A0Cw0mZwHVqpVe2ezQ9AMPxdnfUkY9qelpubK8NOjfHWYTraTuUZPCoyhCcjI8P0NHYVDR7+Qp8PAAAC76zDx/z586Vfv34+O8xUlE6iorUcrrJ3717xJw0ghA8ACD06SZgOZiirtG/fPtCnB38Ptf3555/ls88+k7feesu9TnvQalOM1oZ41n6caWiQTlWrxV90HHrnUwFJlwkfABCadFbR0sNkSw/ThYPDx4IFC6RRo0ZmAhcXHRakv3wdwqNDbNX27dtlz5499g/hKTW9+jqPCWUIHwAQmrSvHv31wjR86FhjDR86Fa3OPOei/TV05jjtgKqzumln0VGjRpng0b17dwkWhA8A4YR/7xCMf0+VDh/a3KK1GX/84x9P2zZ9+nTz8But+dARLPpAG88nBgYDwgeAcOBqhjh+/Lj7eSfAudLuFaqiM876ctZDbf1Fh9pqLUpVDbXVpzG2O/Xgn60jR8p/c3LM8CCdvhYAnOzAgQOmH542k+vj2F0j/oCzoS0f+pwbDbY6Lfy5/D05/tkumq1+zstzL1PzASBcuDr7Hzx4MNCnAoeIiIg45+ARFuGjLIQPAOFAbxD6ADGt+dBH0gPnSufz0gByrsIufFDzASDcaPv8ubbRA1Xp3ONLiCF8AAAQWIQPAABgK8IHAACwVVQ4hI12DRu6lwkfAAAEluPDR43oaNly773u18cY5w4AQEDR7AIAAGxF+AAAALZyfLOLTq/eZd48s6xPtyV8AAAQWI4PHxo0th465F4mfAAAEFg0uwAAAFsRPgAAgK0IHwAAwFZhGT4UAQQAgMAgfAAAAFtFhUPYaJaQ4F52RQ7CBwAAgREW06vvTktzvz5WWGi+Ej4AAAgMml0AAICtCB8AAMBWjm92OVFUJL0WLjTLnw8b5g4fAAAgMBwfPkosS9bv3+9ejqLmAwCAgKLZBQAA2IrwAQAAbEX4AAAAtiJ8AAAAWxE+AACArRw/2kU1qFHDvUz4AAAgsBwfPmrGxMih8ePdr12hg/ABAEBghGWzi3nAHOEDAICACLvw4UL4AAAgMMJievV+r71mlpcNGSJx0dHUfAAAEEo1H7/88ov87//+r9SvX1/i4uLk4osvlvXr17u360394YcflsaNG5vtffr0kR07dkig6JTqq37+2RRdVoQPAABCJHz89ttv0rNnT4mOjpZly5bJ1q1b5amnnpK6deu695k6dao888wz8txzz8maNWukZs2a0rdvX8nPz5dgQfgAACBEml2efPJJSU5OlgULFrjXNW/e3L2sN/QZM2bIgw8+KAMGDDDrXnnlFUlMTJR33nlHBg8eLMGA8AEAQIjUfLz33nvSuXNnueWWW6RRo0Zy6aWXyrx589zbd+3aJdnZ2aapxSUhIUG6desmWVlZZb5nQUGBHD582Kv4m2uuDwAAEOTh46effpK5c+dKq1at5OOPP5Z77rlH/vKXv8jLL79stmvwUFrT4Ulfu7aVlpGRYQKKq2jNir9R8wEAQIiEj5KSErnsssvkiSeeMLUeI0aMkLvuusv07zhb6enpkpeX5y579+4VfyN8AAAQIuFDR7C0a9fOa13btm1lz549ZjkpKcl8zcnJ8dpHX7u2lRYbGyvx8fFeparViI42xYXwAQBAiIQPHemyfft2r3U//PCDNGvWzN35VENGZmame7v24dBRL6mpqRKo6dWP/e1vpuiyInwAABAio13GjBkjPXr0MM0ut956q6xdu1ZeeOEFU1w39bS0NHnsscdMvxANIw899JA0adJEBg4cKMFCz1ObkAAAQJCHjy5dusjbb79t+mk88sgjJlzo0NohQ4a497n//vvl2LFjpj9Ibm6uXH755bJ8+XKpXr26BAtqPgAACJxqVpDdhbWZRke9aOfTquj/kX/ypAxassQs/3+33irVo6Lk0KFDUlhYKE2bNq2CMwYAAJXh+Ge7FJeUyEenpnfXZUXNBwAAgcNTbQEAgK3CMnxQ8wEAQOAQPgAAgK0IHwAAwFaEDwAAYKuwDR8AACAwHD/UVqdUtyZOLLPmQwtBBAAAe1HzAQAAbBXW4YN+HwAA2M/x4UOnV79l6VJTdFkRPgAACBzHhw+dUv3NrVtN8ZxeXRE+AACwn+PDR1kIHwAABA7hAwAA2IrwAQAAbEX4AAAAtgrL8OFC+AAAwH5hGT6o+QAAIHAcP716jehoOZqe7l5WhA8AAALH8eFDg4Y+36X0OkX4AADAfmHd7AIAAOzn+JqPgpMn5c8ffGCWn7/hBomNiqLmAwCAAHJ8zcfJkhJ5+ZtvTNFlRfgAACBwHB8+fNEAQvgAAMB+hA8AAGArwgcAALAV4QMAANiK8AEAAGxF+AAAALZy/DwfOqX6wXHj3MsuhA8AAALD8eFDQ0bDmjXL3Eb4AADAfjS7AACA4A0fkyZNMjdtz9KmTRv39vz8fBk5cqTUr19fatWqJYMGDZKcnBwJ9PTqIz/80BRddiF8AAAQIjUf7du3lwMHDrjLF1984d42ZswYef/992Xp0qWyatUq2b9/v9x8880SSDql+pz1601xTa+uCB8AAIRIn4+oqChJSko6bX1eXp7Mnz9fFi1aJFdffbVZt2DBAmnbtq2sXr1aunfvLsGE8AEAQIjUfOzYsUOaNGkiLVq0kCFDhsiePXvM+g0bNkhRUZH06dPHva82yaSkpEhWVpYEG8IHAAAhUPPRrVs3WbhwoVx44YWmyWXy5MlyxRVXyHfffSfZ2dkSExMjderU8TomMTHRbPOloKDAFJfDhw+LHQgfAACEQPjo16+fe/mSSy4xYaRZs2ayZMkSiYuLO6sTyMjIMCHGboQPAABCcKit1nK0bt1adu7cafqBFBYWSm5urtc+OtqlrD4iLunp6aa/iKvs3btX7ED4AAAgBMPH0aNH5ccff5TGjRtLp06dJDo6WjIzM93bt2/fbvqEpKam+nyP2NhYiY+P9yp2IHwAABACzS7jxo2TG2+80TS16DDaiRMnSmRkpNx+++2SkJAgw4cPl7Fjx0q9evVMiBg1apQJHoEc6RIXHS27Ro92L7sQPgAACIHwsW/fPhM0/vOf/0jDhg3l8ssvN8NodVlNnz5dIiIizORi2om0b9++MmfOHAmkiGrV5PxSnWAV4QMAgMCoZgXZHVhHu2gtivb/8GcTjL7/f//7X2nevLnfvgcAAAjDZ7sUFhfL+E8+MUWXXaj5AAAgMBwfPoqKi2VaVpYpulwaAQQAAHs5Pnz4ojUfivABAIC9CB+EDwAAbEX4IHwAAGArwgfhAwAAWxE+CB8AANgq7MMHAAAI4hlOQ5FOqf7dPfe4l12o+QAAIDAcHz50evX2jRqdtp7wAQBAYIR9swvhAwAAezm+5kOnVH/i3/82y3+74gqJiYw0y4QPAAACw/HhQ6dUn7xqlVke36MH4QMAgACj2YXwAQCArQgfhA8AAGwVtuHDhfABAIC9wrrmQwvhAwAAe4Vt+HAhfAAAYK+wDh/UfAAAYD/HD7WtHhUla//0J/eyJ8IHAAD2c3z4iIyIkC5Nm5a5jfABAID9aHYhfAAAYKuwmF595urVZnl09+7uGU495/oAAAD2CYvp1e//7DOzfG+XLqeFD2o+AACwF80uhA8AAGxF+CB8AABgK8IH4QMAAFsRPggfAADYivBB+AAAwFaED8IHAAC2cvxQW51SfcXQoe5lT4QPAADsFxbTq195/vk+txM+AACwF80uhA8AAEInfEyZMsXcwNPS0tzr8vPzZeTIkVK/fn2pVauWDBo0SHJyciSQM5zOXrvWFF32RPgAACCEwse6devk+eefl0suucRr/ZgxY+T999+XpUuXyqpVq2T//v1y8803SyCf7XLfsmWm6LInwgcAACESPo4ePSpDhgyRefPmSd26dd3r8/LyZP78+fL000/L1VdfLZ06dZIFCxbIV199JatPPdwtmBA+AAAIkfChzSr9+/eXPn36eK3fsGGDFBUVea1v06aNpKSkSFZWVpnvVVBQIIcPH/YqduGptgAAhMBol8WLF8vGjRtNs0tp2dnZEhMTI3Xq1PFan5iYaLaVJSMjQyZPniyBrPnQQhABACAIaz727t0ro0ePltdee02qV69eJSeQnp5ummtcRb+HXQgcAAAEefjQZpWDBw/KZZddJlFRUaZop9JnnnnGLGsNR2FhoeTm5nodp6NdkpKSynzP2NhYiY+P9yp2hw/6fQAAEKTNLtdcc41s3rzZa90f/vAH06/jgQcekOTkZImOjpbMzEwzxFZt375d9uzZI6mpqRJsCB8AAAR5+Khdu7ZcdNFFXutq1qxp5vRwrR8+fLiMHTtW6tWrZ2oxRo0aZYJH9+7dJRBio6Lkg9tvdy97InwAAOCA6dWnT58uERERpuZDR7L07dtX5syZI4ESFREh/Vu3LnMb4QMAAPtVs4LszqtDbRMSEkznU3/3/9DZWHUStPPOO8+M0gEAAP7n+AfL6ZTqr53qpzLk4oslOjLSvY2aDwAA7Of48KFTqv/h3XfN8i3t2hE+AAAIsLB+qq0L4QMAAPuEdfig5gMAAPsRPggfAADYivBB+AAAwFaEDwAAYCvCBzUfAADYyvFDbXVK9SW//7172RPhAwAA+zk+fOj06re0b+9zuwYQwgcAAPYJ62YXRfgAAMBejq/5OFlSIm9v22aW/6dtW1MT4onwAQCAvRxf81Fw8qTc+uabpuhyaYQPAADs5fjwcSaEDwAA7EX4IHwAAGArwgfhAwAAW4V9+FCEDwAA7BP24YOaDwAA7EX4IHwAAGArx8/zERMZKQsGDHAvl0b4AADAXo4PH9GRkTKsY0ef2wkfAADYi2YXwgcAALYKi+nVP9650yz3bdmS6dUBAAgwx9d86JTqN7z+uilMrw4AQOA5PnycCeEDAAB7ET4IHwAA2IrwQfgAAMBWhA/CBwAAtiJ8ED4AALAV4YPwAQCArRw/z4dOqf5sv37uZV80gGgQAQAA/hUW06uP7NrV53ZX4CB8AABgD5pdPMIHAAAIsvAxd+5cueSSSyQ+Pt6U1NRUWbZsmXt7fn6+jBw5UurXry+1atWSQYMGSU5OjgRScUmJrNy92xRdLo3wAQBAEIeP8847T6ZMmSIbNmyQ9evXy9VXXy0DBgyQLVu2mO1jxoyR999/X5YuXSqrVq2S/fv3y8033yyBlH/ypFz18sum6HJpNLUAABDEfT5uvPFGr9ePP/64qQ1ZvXq1CSbz58+XRYsWmVCiFixYIG3btjXbu3fvLsGImg8AAEKkz0dxcbEsXrxYjh07ZppftDakqKhI+vTp496nTZs2kpKSIllZWT7fp6CgQA4fPuxV7ET4AAAgyMPH5s2bTX+O2NhYufvuu+Xtt9+Wdu3aSXZ2tsTExEidOnW89k9MTDTbfMnIyJCEhAR3SU5OFjsRPgAACPLwceGFF8qmTZtkzZo1cs8998jQoUNl69atZ30C6enpkpeX5y579+4VOxE+AAAI8nk+tHajZcuWZrlTp06ybt06mTlzptx2221SWFgoubm5XrUfOtolKSnJ5/tpDYqWQCF8AAAQYvN8lJSUmH4bGkSio6MlMzPTvW379u2yZ88e0yckWBE+AAAI4poPbSLp16+f6UR65MgRM7Jl5cqV8vHHH5v+GsOHD5exY8dKvXr1zDwgo0aNMsEjkCNddIbTqac6wepyaYQPAACCOHwcPHhQ/u///k8OHDhgwoZOOKbB49prrzXbp0+fLhEREWZyMa0N6du3r8yZM0cCSZ/nMr5nT5/bCR8AANirmhVkd10daqvBRjufau2Jv+mPv2vXLmnYsKHUrl3b798PAIBw5/gHy+mU6hsPHDDLlzVuLJERZXdzCbIMBgCAYzn+wXI6pXrXF180xdf06loIHwAA2MPx4aOiCB8AANiD8HGq9oPwAQCAPQgfhA8AAGxF+CB8AABgK8IH4QMAAFsRPjwmGgMAAP7n+Hk+dEr1ib17u5fLQs0HAAD2cXz40OnVJ115Zbn7ED4AALAPzS6EDwAAbOX4mo8Sy5Jthw6Z5bYNG0pEGf07CB8AANjH8TUfJ4qK5KK5c03R5bIQPgAAsI/jw0dFED4AALAP4YPwAQCArQgfhA8AAGxF+DiF8AEAgD0IH9R8AABgK8IH4QMAAFs5fp4PnVJ9XGqqe7kshA8AAOwTFtOr/+O668rdh/ABAIB9aHbhqbYAANgqLKZX35OXZ5ZTEhLKnV5dC0EEAAD/cnzNh06p3nzmTFPKm14dAADYw/HhoyJc4YN+HwAA+B/hg/ABAICtCB+EDwAAbEX4IHwAAGArwgfhAwAAWxE+CB8AANjK8fN8REVEyL2dO7uXy0L4AADAPo4PH7FRUTK7f/8K7Uv4AADA/2h2oeYDAIDgDR8ZGRnSpUsXqV27tjRq1EgGDhwo27dv99onPz9fRo4cKfXr15datWrJoEGDJCcnRwJFA8WhY8dM8RUuCB8AAARp+Fi1apUJFqtXr5ZPP/1UioqK5LrrrpNjx4659xkzZoy8//77snTpUrP//v375eabb5ZAOV5UJI2mTTNFl8tC+AAAIEj7fCxfvtzr9cKFC00NyIYNG6RXr16Sl5cn8+fPl0WLFsnVV19t9lmwYIG0bdvWBJbu3btLMOLZLgAAhEifDw0bql69euarhhCtDenTp497nzZt2khKSopkZWWV+R4FBQVy+PBhr2I3aj4AAAiB8FFSUiJpaWnSs2dPueiii8y67OxsiYmJkTp16njtm5iYaLb56keSkJDgLsnJyWI3wgcAACEQPrTvx3fffSeLFy8+pxNIT083NSiusnfvXgkEDSCEDwAAgnSej/vuu08++OAD+fzzz+W8885zr09KSpLCwkLJzc31qv3Q0S66rSyxsbGmBBrhAwCAIKz50JuzBo+3335b/vWvf0nz5s29tnfq1Emio6MlMzPTvU6H4u7Zs0dSU1MlmBE+AAAIwpoPbWrRkSzvvvuumevD1Y9D+2rExcWZr8OHD5exY8eaTqjx8fEyatQoEzwCNdJFp1Qf2qGDe9kXwgcAAPaoZlXijutrSKoOpx02bJh7krG//vWv8vrrr5uRLH379pU5c+b4bHYpTUe7aIjR/h8aXuyifU1q1KhhJkcDAABBEj7sEKjwsW/fPqlevbo0aNDAtu8JAEA4cvyD5TRbuWY2rREd7bP2hmYXAADs4fgHy2nwqJWRYYqv6dVdCB8AAPif48NHRVHzAQCAPQgfpxA+AACwB+HjFMIHAAD2IHycwpNtAQCwB+HjFGo+AACwB+HjFMIHAAD2cPw8H5EREfL7du3cy74QPgAAsIfjw0f1qChZesstZ9yP8AEAgD1odjmF8AEAgD0IH6cQPgAAsIfjm12OFRaaqdXV0fR0qRkTU+Z+hA8AAOxBzccphA8AAOxB+DiF8AEAgD0IH6UQQAAA8C/CR6np1QkfAAD4F+HjFMIHAAD2IHycQvgAAMAejh9qq1OqX9+qlXvZF55qCwCAPcJievUP77jjjPtR8wEAgD1odjmF8AEAgD0IH6cQPgAAsEdYTK/eaNo0s3xw3Lhyp1dXhA8AAPzL8eFDHS8qOuM+hA8AAOxBs8sphA8AAOxB+DiF8AEAgD0IH6cQPgAAsAfh4xTCBwAA9iB8lEL4AADAvxw/2iWiWjXp3ayZe9kXaj4AALCH48NHXHS0rBw2rEL7agAhfAAAEGTNLp9//rnceOON0qRJE3Ozfuedd7y268374YcflsaNG0tcXJz06dNHduzYIaGA8AEAQBCGj2PHjkmHDh1k9uzZZW6fOnWqPPPMM/Lcc8/JmjVrpGbNmtK3b1/Jz8+XYEf4AAAgCJtd+vXrZ0pZ9MY9Y8YMefDBB2XAgAFm3SuvvCKJiYmmhmTw4MESiOnVz5850yzvHj3a5/Tqnv0+AABAiIx22bVrl2RnZ5umFpeEhATp1q2bZGVlSaD8evy4KWdCzQcAACHW4VSDh9KaDk/62rWttIKCAlNcDh8+LIFC+AAAIAzm+cjIyDC1I66SnJwcsHMhfAAAEGLhIykpyXzNycnxWq+vXdtKS09Pl7y8PHfZu3evBArhAwCAEAsfzZs3NyEjMzPTqxlFR72kpqaWeUxsbKzEx8d7lUAhfAAAEIR9Po4ePSo7d+706mS6adMmqVevnqSkpEhaWpo89thj0qpVKxNGHnroITMnyMCBAyXYET4AAAjC8LF+/Xq56qqr3K/Hjh1rvg4dOlQWLlwo999/v5kLZMSIEZKbmyuXX365LF++XKpXry6BoFOqd27SxL18pvBRUlJi05kBABCeqllB9lFfm2m046n2/7C7CebgwYNy8uRJU1MDAAAcOtolmNDsAgCA/xE+PBA+AADwP8eHj+NFRXL+jBmm6PKZED4AAAihGU6DkYaJn/Py3MvloeYDAAD/c3zNR2UQPgAA8D/ChwfCBwAA/kf48ED4AADA/wgfpcIHAADwL8JHGTUf1H4AAOA/UeEQKNo1bOhePtO+AADAvxwfPmpER8uWe++t0L6u8KE1HwQRAAD8g2YXH+EDAAD4B+HDA+EDAAD/c3z40CnV28+ZY8qZplcnfAAA4H+O7/OhQWLroUPu5fIQPgAA8D/H13xUBuEDAAD/I3x4IHwAAOB/hI8yED4AAPAfwocHaj4AAPA/wocHwgcAAP4XFQ6BollCgnv5TPsqwgcAAP4TFtOr705Lq9C+TKkOAID/0ezigZoPAAD8j/DhgfABAID/Ob7Z5URRkfRauNAsfz5smMRFR58xgBA+AADwH8eHjxLLkvX797uXz4TwAQCAf9HsUgrhAwAA/yJ8lEL4AADAvwgfpRA+AADwL8JHKYQPAAD8i/BRCuEDAAD/cvxoF9WgRo1K7U/4AADAfxwfPmrGxMih8eMrvD81HwAAhGizy+zZs+X888+X6tWrS7du3WTt2rUSCggfAACEYPh44403ZOzYsTJx4kTZuHGjdOjQQfr27SsHDx6UYKfB4+TJk6b4ottOnDhxzvtU5Xs5+Zw47+DbJxjPifMOvn2C8Zw4b6nwe/lTNcsPH/O1pqNLly7y7LPPmtclJSWSnJwso0aNkgkTJpR77OHDhyUhIUHy8vIkPj6+SqZX7/faa2Z52ZAh5U6vrt/7119/db9u0KDBaedQVfvY/f1C9Zw47+DbJxjPifMOvn2C8Zw4b6nwe4Vcn4/CwkLZsGGDpKenu9dFRERInz59JCsr67T9CwoKTPG8MFVJp1Rf9fPP7mVfNAF6/kKUvo6MjDRFFRcXV8k+VfleTj4nzjv49gnGc+K8g2+fYDyncD3vk6dqN3S7q8aj9D41atSQqKio0K752L9/vzRt2lS++uorSU1Nda+///77ZdWqVbJmzRqv/SdNmiSTJ08+7X2qqubjWGGh1MrIMMtH09NNB9Sy6C/kwIED5/z9AAAIpn6MkZGRphJAb/dFRUWn7dO4cWOJi4sLr9EuWkOi/UM8az60icZu0T6aY5KSktyJUFNjdnb2Oe9Tle/l5HPivINvn2A8J847+PYJxnMK1/NOTk72eq89e/ZU+P4XUh1Otf1IU1ZOTo7Xen2tF6u02NhYU8PhWQJBfzl67p70tVZHxcTEmKLLVbFPVb6Xk8+J8w6+fYLxnDjv4NsnGM8pXM87yiOg+LrP2d3k4tcOp127dpVZs2a5O5ympKTIfffdZ3uH04o2u7hoMtRqKU2Cvn4hVbWP3d8vVM+J8w6+fYLxnDjv4NsnGM+J85YKv1fIhQ8dajt06FB5/vnnTQiZMWOGLFmyRL7//ntJTEwM6vABAAD8yy+R57bbbpNDhw7Jww8/bNqgOnbsKMuXLz9j8PCXGgFozwIAADbWfJyLqq75AAAAwYWn2gIAAFsRPgAAgK0cHz7yT56U/osWmaLLAAAgsAI+yZi/FZeUyEc7driXAQBAYDm+5gMAAAQXwgcAALAV4QMAANiK8AEAAGxF+AAAAOE92sU14arOdFoV9Nkukp/vfs9inu0CAIDf1K5dW6pVqxZa06vv27dPkpOTA30aAADgLFTk8ShBFz5KSkpk//79FUpOFaU1Hhpo9u7dy/NiPHBdfOPa+Ma18Y1rUzauS3hdm9oVuH8HXbNLRESEnHfeeX55b/3FOuWXW5W4Lr5xbXzj2vjGtSkb18W3+DC7NnQ4BQAAtiJ8AAAAW4VF+IiNjZWJEyear/j/cV1849r4xrXxjWtTNq6Lb7Fhem2CrsMpAABwtrCo+QAAAMGD8AEAAGxF+AAAALYifAAAAFs5JnzMnj1bzj//fKlevbp069ZN1q5dW+7+S5culTZt2pj9L774Yvnoo4/EiSpzXbZs2SKDBg0y++vsdDNmzBAnq8y1mTdvnlxxxRVSt25dU/r06XPGv7FwuTZvvfWWdO7cWerUqSM1a9aUjh07yj//+U9xqsr+W+OyePFi8//VwIEDJdyvy8KFC8218Cx6nFNV9m8mNzdXRo4cKY0bNzajYFq3bu28e5TlAIsXL7ZiYmKsl156ydqyZYt11113WXXq1LFycnLK3P/LL7+0IiMjralTp1pbt261HnzwQSs6OtravHmz5SSVvS5r1661xo0bZ73++utWUlKSNX36dMupKntt7rjjDmv27NnW119/bW3bts0aNmyYlZCQYO3bt88K92uzYsUK66233jL/L+3cudOaMWOG+f9r+fLlVrhfG5ddu3ZZTZs2ta644gprwIABVrhflwULFljx8fHWgQMH3CU7O9tyospem4KCAqtz587W9ddfb33xxRfmb2flypXWpk2bLCdxRPjo2rWrNXLkSPfr4uJiq0mTJlZGRkaZ+996661W//79vdZ169bN+vOf/2w5SWWvi6dmzZo5Onycy7VRJ0+etGrXrm29/PLLltOc67VRl156qQn1TnM210b/Vnr06GG9+OKL1tChQx0ZPip7XTR8aHgPB5W9NnPnzrVatGhhFRYWWk4W8s0uhYWFsmHDBlMN7vl8GH2dlZVV5jG63nN/1bdvX5/7h8t1CRdVcW2OHz8uRUVFUq9ePXGSc702+oEmMzNTtm/fLr169RInOdtr88gjj0ijRo1k+PDh4kRne12OHj0qzZo1Mw9VGzBggGn2dZqzuTbvvfeepKammmaXxMREueiii+SJJ56Q4uJicZKQDx+//vqr+aXoL8mTvs7Ozi7zGF1fmf3D5bqEi6q4Ng888IA0adLktBAbrtdGH6Fdq1YtiYmJkf79+8usWbPk2muvlXC/Nl988YXMnz/f9BlyqrO5LhdeeKG89NJL8u6778qrr75qnmbeo0cP2bdvn4T7tfnpp5/kzTffNMdpP4+HHnpInnrqKXnsscfESYLuqbZAsJsyZYrpPLhy5UpHd5Kr7CO0N23aZD7Nas3H2LFjpUWLFnLllVdKuDpy5IjceeedJng0aNAg0KcTVPSTvRYXDR5t27aV559/Xh599FEJZyUlJaam7IUXXpDIyEjp1KmT/PLLL/KPf/zDTMPuFCEfPvR/av0F5eTkeK3X10lJSWUeo+srs3+4XJdwcS7XZtq0aSZ8fPbZZ3LJJZeI05zttdGq5JYtW5plHe2ybds2ycjIcFT4qOy1+fHHH2X37t1y4403et1YVFRUlGmauuCCCyTUVcW/NdHR0XLppZfKzp07xUnO5to0btzYXA89zkWDmdaUaDOO1i46Qcg3u+gvQpOhftry/B9cX3sma0+63nN/9emnn/rcP1yuS7g422szdepU86ls+fLlZmipE1XV340eU1BQIOF8bXQo/+bNm02NkKvcdNNNctVVV5ll7evgBFXxN6NNDHqt9MbrJGdzbXr27GlCmCuoqh9++MFcG6cED8NyyFCm2NhYa+HChWa434gRI8xQJtfQrTvvvNOaMGGC11DbqKgoa9q0aWbY5MSJEx071LYy10WHeOlQUi2NGzc2w251eceOHZbTVPbaTJkyxQyXe/PNN72GBx45csQK92vzxBNPWJ988on1448/mv31/yv9/2vevHlWuF+b0pw62qWy12Xy5MnWxx9/bP5mNmzYYA0ePNiqXr26GYoa7tdmz549ZiTdfffdZ23fvt364IMPrEaNGlmPPfaY5SSOCB9q1qxZVkpKirlB6NCm1atXu7f17t3b/E/vacmSJVbr1q3N/u3bt7c+/PBDy4kqc110PLnm0dJF9wv3a6NDj8u6Nhpcw/3a/P3vf7datmxpbh5169a1UlNTzT+4TlXZf2vCIXxU9rqkpaW5901MTDRzWmzcuNFyqsr+zXz11Vdm+gcNLTrs9vHHHzdDtp2kmv4n0LUvAAAgfIR8nw8AABBaCB8AAMBWhA8AAGArwgcAALAV4QMAANiK8AEAAGxF+AAAALYifAAAAFsRPgAAgK0IHwAAwFaEDwAAYCvCBwAAEDv9P/s/1OiR+x8jAAAAAElFTkSuQmCC",
219:       "text/plain": [
220:        "<Figure size 640x480 with 1 Axes>"
221:       ]
222:      },
223:      "metadata": {},
224:      "output_type": "display_data"
225:     }
226:    ],
227:    "source": [
228:     "fig, ax = plt.subplots()\n",
229:     "hist, bins = np.histogram(noise.sigma_e.data, bins=50, density=True)\n",
230:     "\n",
231:     "ax.plot(bins[:-1], hist, marker='.', linewidth=1, color='#dddddd', label=f'σ_e (avg {np.average(noise.sigma_e.data):.2f})')\n",
232:     "\n",
233:     "sigma_zero = noise.sigma_zero_fun(naive_noisy_fit.block_sizes[0] * naive_noisy_fit.block_sizes[1])\n",
234:     "\n",
235:     "ax.axvline(sigma_zero, color='teal', linestyle='--', label=f'σ_zero = {sigma_zero:.2f}')\n",
236:     "plt.legend()\n",
237:     "ax.spines[['right', 'top']].set_visible(False)\n",
238:     "\n",
239:     "plt.show(fig)"
240:    ]
241:   },
242:   {
243:    "cell_type": "code",
244:    "execution_count": null,
245:    "id": "2722073f",
246:    "metadata": {},
247:    "outputs": [],
248:    "source": []
249:   }
250:  ],
251:  "metadata": {
252:   "kernelspec": {
253:    "display_name": "Python 3",
254:    "language": "python",
255:    "name": "python3"
256:   },
257:   "language_info": {
258:    "codemirror_mode": {
259:     "name": "ipython",
260:     "version": 3
261:    },
262:    "file_extension": ".py",
263:    "mimetype": "text/x-python",
264:    "name": "python",
265:    "nbconvert_exporter": "python",
266:    "pygments_lexer": "ipython3",
267:    "version": "3.12.11"
268:   }
269:  },
270:  "nbformat": 4,
271:  "nbformat_minor": 5
272: }

================
File: notebooks/sbm_visualize.ipynb
================
  1: {
  2:  "cells": [
  3:   {
  4:    "cell_type": "code",
  5:    "execution_count": 2,
  6:    "metadata": {},
  7:    "outputs": [
  8:     {
  9:      "name": "stdout",
 10:      "output_type": "stream",
 11:      "text": [
 12:       "Collecting networkx\n",
 13:       "  Using cached networkx-3.4.2-py3-none-any.whl.metadata (6.3 kB)\n",
 14:       "Using cached networkx-3.4.2-py3-none-any.whl (1.7 MB)\n",
 15:       "Installing collected packages: networkx\n",
 16:       "Successfully installed networkx-3.4.2\n"
 17:      ]
 18:     }
 19:    ],
 20:    "source": [
 21:     "!pip install networkx\n",
 22:     "!pip install matplotlib\n",
 23:     "!pip install numpy"
 24:    ]
 25:   },
 26:   {
 27:    "cell_type": "code",
 28:    "execution_count": 5,
 29:    "metadata": {},
 30:    "outputs": [
 31:     {
 32:      "data": {
 33:       "image/png": "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f/9qwwGzsrLYs2cP8+bNq/e9koWFBTNnzjTcX6xZswZPT0/D/eCPPXhPWFxcTEZGBgMGDACoduweZfjw4TXuNeryxhtvEBAQwKJFi3j++ecZPnw4v/rVr+q9LSGE+ZCEknii9e3bl61bt5KdnU10dDR//OMfycvLY/r06YYkRV3S09MpLCykW7duNV7r3r07er3eMFb/1q1bDx1W9yAvL69q37dp0wagWlLo7t27LF68GCcnJ+zs7HB2dmb48OEA5ObmAqDRaPjnP//Jnj17cHV1ZdiwYbz99tu1PjmkPqp6ENV3P2oTGBhIaGgooaGhzJw5k9WrVzNhwgReeeUV0tPT61zuzp07dR7nqterYuzWrVu9ejK99dZbfPPNN2zevLlaH4eGmDt3rmEI4TfffMPcuXPrjB+odR/8/PwMr1f926VLlxrz/XjZGzdukJubi4uLC87OztW+8vPzSUtLa9Q+CSGEEFUqKipYv349I0eOJD4+nps3b3Lz5k369+9PamoqkZGRhnnv3LlTr+tXXVatWkVQUBBarZa2bdvi7OzMrl27DPc1UHmd79ChQ7UhZT9248YNFEWhS5cuNa6PV65cqXF99PDwqJHsadOmTbX7rvreXyxcuJDjx48bruebNm2irKyMBQsW1OsYVJk7dy5xcXFcvHiRtWvXMnv27DoTUllZWbz44ou4urpiY2ODs7Mzvr6+ANWO3aNULVMf1tbWfPnll8THx5OXl8eKFSvqnTATQpgX6aEkBJUXxr59+9K3b1+6du3KkiVL2LRpU62fgDW3usaeK4oCVN7cjR49mqysLP7whz/g5+eHra0tSUlJLF68uFrzy1//+tdMnDiRb775hn379vHnP/+Zt956i4MHD9KrV6/Hsj+PMmrUKHbu3El0dPRjfTpaWFgYe/fu5e2332bEiBGNehTv008/jUajYdGiRZSUlDBz5sxmiLR2er0eFxeXOhujPtgXQQghhGiMgwcPkpyczPr161m/fn2N19esWdPgCt/arF69msWLFzN58mR+97vf4eLigoWFBW+99dZDH6pRG71ej0qlYs+ePbXeU9nZ2VX7/lH3XQ0xe/ZsXnrpJdasWcP//M//sHr1avr06VPvpFqV/v3706lTJ379618THx9f5wdWADNnzuTEiRP87ne/o2fPntjZ2aHX6xk7dmytDdHrUp9eVw/at28fUFkVdePGjQYlpIQQ5kMSSkL8SFVDx+TkZMO02j51cXZ2plWrVly7dq3Ga1evXkWtVuPp6QlUNvGOjY01SnyXLl3i+vXrrFq1ioULFxqmR0RE1Dp/p06d+M1vfsNvfvMbbty4Qc+ePfn3v//N6tWrgfoPV6tqDBkbG0toaGgT9+IH5eXlQGXj8rp4e3vXeZyrXq+K8dSpU5SVlT2yIfWAAQP42c9+xoQJE5gxYwbbtm1r8GNxbWxsmDx5MqtXryY8PLxac/Ufxw9w7do1nnrqqWqvXbt2zfB61b83btyosY4f73+nTp04cOAAgwcPbvBNoBBCCFEfa9aswcXFhQ8++KDGa1u3bmXbtm18/PHH2NjY4O3tXa/rV202b95Mx44d2bp1a7X7kh9/sNepUyf27dtXo/H1j+dRFAVfX1+6du36yG3XR33vL5ycnBg/fjxr1qxh3rx5HD9+nHfffbdR25wzZw5//etf6d69e7Wm5A/Kzs4mMjKSN998k9dee80wvbafgzEriGJiYvjf//1flixZwoULF1i2bBmXLl2qNlxfCPFkkCFv4ol16NChWj992r17N1C9RNvW1pacnJxq81lYWDBmzBi2b99ueOwqVD6RbO3atQwZMgQHBweg8mlrFy9erPXx7w39BKzqk7QHl1MUpUYfosLCwhpPG+vUqRP29vaUlJQ8dN9q07t3b3x9fXn33XdrzN+YT/Gq7Ny5E4Dg4OA65xk3bhzR0dGcPHnSMK2goIBPP/0UHx8fw5j/adOmkZGRwX//+98a66gtxtDQUNavX8/evXtZsGBBgz7Jq/Lb3/6W119/nT//+c91ztOnTx9cXFz4+OOPqx37PXv2cOXKFUNllpubGz179mTVqlXVytQjIiJqDMGcOXMmFRUV/OUvf6mxvfLy8nr9TIUQQoi6FBUVsXXrViZMmMD06dNrfL3wwgvk5eUZ+k6OGzeOqKgooqOjDetIT0+vs5L2QbXd25w6daradR8qr/OKovDmm2/WWEfVslOnTsXCwoI333yzxrVfURQyMzPreQSqb7e+9xcLFiwgLi6O3/3ud1hYWDB79uwGbw9g2bJlvP766/z73/+uc57ajhtQaxLL1tYWoMn3B2VlZSxevJgOHTrw3nvvsXLlSlJTU3nppZeatF4hxE+TVCiJJ9Yvf/lLCgsLmTJlCn5+fpSWlnLixAk2bNiAj48PS5YsMcwbEhLCgQMHeOedd+jQoQO+vr7079+fv/71r0RERDBkyBCef/55LC0t+eSTTygpKeHtt982LP+73/2OzZs3M2PGDJYuXUpISAhZWVns2LGDjz/++KHJlB/z8/OjU6dO/Pa3vyUpKQkHBwe2bNlSo/H29evXGTVqFDNnzsTf3x9LS0u2bdtGampqtZubkJAQPvroI/7617/SuXNnXFxcalTRAKjVaj766CMmTpxIz549WbJkCW5ubly9epXLly8bSp8f5tixY4YkV9X+HzlyhNmzZ+Pn51fncq+88grr1q0jPDycX/3qVzg5ObFq1Sri4+PZsmULanVlbnzhwoV89dVXvPzyy0RHRzN06FAKCgo4cOAAzz//PJMmTaqx7smTJ7NixQoWLlyIg4MDn3zyySP340HBwcGP/PlZWVnxz3/+kyVLljB8+HDmzJlDamoq7733Hj4+PtVuwt566y3Gjx/PkCFDWLp0KVlZWbz//vsEBARUq+IaPnw4zz33HG+99RYXLlxgzJgxWFlZcePGDTZt2sR7773H9OnTG7QvQgghRJUdO3aQl5fH008/XevrAwYMwNnZmTVr1jBr1ix+//vf8/XXXzN27FhefPFFbG1t+fTTT/H29iYmJuah25owYQJbt25lypQpjB8/nvj4eD7++GP8/f2rXftGjhzJggUL+L//+z9u3LhhGNZ17NgxRo4cyQsvvECnTp3461//yh//+EcSEhKYPHky9vb2xMfHs23bNp599ll++9vfNuhYNOT+Yvz48bRt25ZNmzYRHh6Oi4tLg7ZVxdvbmzfeeOOh8zg4OBh6ZJaVleHu7s7+/fuJj4+vMW9ISAgAr776KrNnz8bKyoqJEycaEk319de//pULFy4QGRmJvb09QUFBvPbaa/zpT39i+vTpjBs3rkHrE0L8xD3ux8oJ0VLs2bNHWbp0qeLn56fY2dkp1tbWSufOnZVf/vKXSmpqarV5r169qgwbNkyxsbFRgGqPtD937pwSFham2NnZKa1atVJGjhypnDhxosb2MjMzlRdeeEFxd3dXrK2tFQ8PD2XRokVKRkaGoiiKcujQIQVQNm3aVG25qsfcr1ixwjAtLi5OCQ0NVezs7JR27dopy5cvVy5evFhtvoyMDOUXv/iF4ufnp9ja2iqOjo5K//79lY0bN1Zbf0pKijJ+/HjF3t5eAQyP8a2K59ChQ9Xm/+6775TRo0cr9vb2iq2trRIUFKS8//77Dz3WVet68Mva2lrx8/NT/va3vymlpaXV5vf29q52jBVFUW7duqVMnz5dad26taLVapV+/fopO3furLGtwsJC5dVXX1V8fX0VKysrpX379sr06dOVW7duVTue//rXv6ot9+GHHyqA8tvf/vah+wIov/jFLx46z+uvv64ASnp6erXpGzZsUHr16qVoNBrFyclJmTdvnpKYmFhj+S1btijdu3dXNBqN4u/vr2zdulVZtGiR4u3tXWPeTz/9VAkJCVFsbGwUe3t7JTAwUPn973+v3L9/3zDPjx/PLIQQQjzKxIkTFa1WqxQUFNQ5z+LFixUrKyvDvUxMTIwyfPhwRavVKu7u7spf/vIX5YsvvqjxuPofX5f0er3y97//XfH29lY0Go3Sq1cvZefOnbVe+8rLy5V//etfip+fn2Jtba04Ozsr4eHhytmzZ6vNt2XLFmXIkCGKra2tYmtrq/j5+Sm/+MUvlGvXrlWLIyAgoMZ+1bbdR91fPOj5559XAGXt2rV1Hrsf8/b2VsaPH//QeVasWKEAyunTpw3TEhMTlSlTpiitW7dWHB0dlRkzZij3799XAOX111+vtvxf/vIXxd3dXVGr1dV+Jg+7t3lwPWfPnlUsLS2VX/7yl9XmKS8vV/r27at06NBByc7Orvc+CyF++lSK0oSxKkIIIYQQQgjRAEOHDkWj0XDgwAFTh9IsXnrpJb744gtSUlJo1aqVqcMRQohmIz2UhBBCCCGEEI9NcnJynQ+y+KkrLi5m9erVTJs2TZJJQgizJz2UhBBCCCGEEM3uxIkTbN26lVu3bvGHP/zB1OEYVVpaGgcOHGDz5s1kZmby4osvmjokIYRodpJQEkIIIYQQQjS7zz77jD179vDrX/+62sNPzEFcXBzz5s3DxcWF//u//6Nnz56mDkkIIZqd9FASQgghhBBCCCGEeIyOHj3Kv/71L86ePUtycjLbtm1j8uTJD13m8OHDvPzyy1y+fBlPT0/+9Kc/sXjx4scSb22kh5IQQgghhBBCCCHEY1RQUEBwcDAffPBBveaPj49n/PjxjBw5kgsXLvDrX/+aZcuWsW/fvmaOtG5SoSSEEEIIIYQQQghhIiqV6pEVSn/4wx/YtWsXsbGxhmmzZ88mJyeHvXv3PoYoa5IeSkIIIYQQZkqv13P//n3s7e1RqVSmDkcIIYSolaIo5OXl0aFDB9Tq5h9IVVxcTGlpqdHXqyhKjeutRqNBo9E0ed0nT54kNDS02rSwsDB+/etfN3ndjSUJJSGEEEIIM3X//n08PT1NHYYQQghRL/fu3cPDw6NZt1FcXIyNjU2zrNvOzo78/Pxq015//XXeeOONJq87JSUFV1fXatNcXV3R6XQUFRU12z49jCSUhBBCCCHMlL29PVB5g+7g4GDiaJ4gX30FCxeaOgphYo6OjkZb13xgtRHWk5uba4S1GJ+xjpW5758xtbRjpdPp8PT0NFy3mlNzVCZVyc/Pr3HNNUZ1UkslCSUhhBBCCDNVVXbv4OAgCaXHqWdPkOMtjCjeSOsx9/cBc98/Y2qpx+pxD8825vaq2lM31zW3ffv2pKamVpuWmpqKg4ODSaqTQJ7yJoQQQgghhHG9/bapIxBm5vemDkAIM6RSqYz+1ZwGDhxIZGRktWkREREMHDiwWbf7MJJQEkIIIYQQQgghhHiM8vPzuXDhAhcuXAAgPj6eCxcucPfuXQD++Mc/svCB4dM/+9nPuH37Nr///e+5evUqH374IRs3buSll14yRfiAJJSEEEIIIVq0Dz74AB8fH7RaLf379yc6OtrUIYlH+cc/TB2BMDOvmDoAIcyQqSuUzpw5Q69evejVqxcAL7/8Mr169eK1114DIDk52ZBcAvD19WXXrl1EREQQHBzMv//9bz7//HPCwsKMd1AaSHooCSGEEEK0UBs2bODll1/m448/pn///rz77ruEhYVx7do1XFxcTB2eqMuuXeDvb+oohBkZD1wxdRBCCKMaMWKEoe9SbVauXFnrMufPn2/GqBpGKpSEEEIIIVqod955h+XLl7NkyRL8/f35+OOPadWqFV9++aWpQxMPc+yYqSMQZmaoqQMQwgyp1Wqjfz1ppEJJCCGEEKIFKi0t5ezZs/zxj380TFOr1YSGhnLy5MlalykpKaGkpMTwvU6na/Y4RS1a6NOTxE+X/CYLYXyPo5G2uXvyUmhCCCGEED8BGRkZVFRU4OrqWm26q6srKSkptS7z1ltv4ejoaPjy9PR8HKGKH1u92tQRCDOzwNQBCCFELSShJIQQQghhJv74xz+Sm5tr+Lp3756pQ3oyTZ1q6giEmdli6gCEMEOmbsptDmTImxBCCCFEC9SuXTssLCxITU2tNj01NZX27dvXuoxGo0Gj0TyO8MTDlJebOgJhZuSPNiFESyQVSkIIIYQQLZC1tTUhISFERkYapun1eiIjIxk4cKAJIxOPZMJHOAvztM/UAQhhhqRCqekk2S2EEEII0UK9/PLLLFq0iD59+tCvXz/effddCgoKWLJkialDEw/Tr5+pIxBmJtrUAQhhhp7UJJAxSUJJCCGEEKKFmjVrFunp6bz22mukpKTQs2dP9u7dW6NRt2hh/vIX2LHD1FEIM/JnYJKpgxBCiB+RhJIQQgghRAv2wgsv8MILL5g6DCGEEMKsSIVS00kPJSGEEEIIIYzpjTdMHYEwM2+YOgAhhKiFJJSEEEIIIYQwpuPHTR2BMDODTR2AEGZIrVYb/etJ8+TtsRBCCCGEEM0pIsLUEQgzM9rUAQhhhuQpb00nPZSEEEIIIYQwJo3G1BH8JBjzjy9FUYy2LmMxakwzZqBs2tTk1bTUY94Sf37m7klMfgjjk4SSEEIIIYQQxmSEP/yFqEbOKSGM7kmtKjImGfImhBBCCCGEMc2da+oIhLmRc0oI0QJJhZIQQgghhBDGlJ9v6giEuZFzSgijkwqlppOEkhBCCCGEEMY0fLipIxDmRs4pIYxOEkpNJ0PehBBCCCGEMKYxY0wdgTA3ck4JIVogSSgJIYQQQghhTK++auoIhLmRc0oIo6uqUDLm15NGEkpCCCGEEEIIIYQQokGkh5IQQgghhBDG9Morpo5AmBs5p4QwOpVKhVptvBobvV5vtHX9VEiFkhBCCCGEEMYUG2vqCIS5kXNKCKOTIW9NJxVKQgjxE1FUWsHuS8lcS82juKwCRxsrRnRzprdXmyfyAiaEEC3Wzp3w7LOmjkKYEzmnhBAtkCSUhBCihdMVl/F+5A3WRd8jv6QcSwsVKKAA7x+8STdXO54f2ZlJPd1NHaoQQgghhBA/CcauKnoSP+CVhJIQQrRg6XklzPksitvp+eiVymnlFUq1ea6n5vPi+gvEJet4ZazfE3kxE0KIFmXHDlNHIMyNnFNCiBZIeigJIUQLVVxWwaIvTxGfUWBIJtWm6qVPjtzms2O3H0tsQgghHmLJElNHIMyNnFNCGJ30UGo6SSgJIUQL9c35JOKS86h4WDbpR/69/zq5RWXNGJUQQohHysw0dQTC3Mg5JYTRSUKp6SShJIQQLZCiKKw4Hk9Dr0ul5Xq2nktsnqCEEELUz8CBpo5AmBs5p4QQLZAklIQQogW6lprHtdR8lPoXJwGVw9/WR99rlpiEEELU0/Tppo5AmBs5p4QwOqlQajpJKAkhRAt0P6eo0csm5zZ+WSGEEEbwm9+YOgJhbuScEkK0QPKUNyGEaIH0+iYs28CqJiGEEMIUlIaW4T7Bdnz7LZOewOqHhjJmhYgxz09jrasl7t9PuSpHrVajVkuNTVNIQkkIIVogVwdto5d1cdAYMRIhhBAN9vLLpo5AmJl3TB2AEGbI2MPUfsrJtcaSdJwQQrRAPdwd8HZqRUMvS2oVTA/xaJaYhBBC1NPdu6aOQJgZL1MHIIQQtZCEkhBCtEAqlYrFg30avJxapWJmH0/jBySEEKL+Nm82dQTCzEhLbiGMT5pyN50klIQQooWa0ccTT6dWWKjrf3FaPqwj7exkyJsQQgghhBCieUlCSQghWig7jSWrn+mPs501Kh7WOLHytSm93PndmG6PJzghhBB127jR1BEIMzPT1AEIYYakQqnpJKEkhBAtmFfbVvyhtxpfdRZqVWWPpMrkkoLF99csG1U5r47z452ZwagbUM0khBCimbz0kqkjEGbmP6YOQAgzJAmlppOnvAkhRAtWVFRE7OnjjHGwYunzM/jq6DX2nLyIXmWJj7srfg7lFN44Q69WHk/kRUwIIVqkpCRTRyDMjLupAxBCiFpIhZIQQrRgmzdvRq/XM3HiRFwcbJjUzZZh1glMaJPCQj8LfjllGGoVHDt2DEV52LA4IYQQj02vXqaOQJiZ86YOQAgzJBVKTScJJSGEaKHu3bvH7du3cXZ2JiAgAACdTodKpUKr1VJSUkKrVq3w9vZGp9Nx7949E0cshBACgGeeMXUEwsx8YeoAhBCiFpJQEkKIFkhRFDZ//9jpmTN/aMWZl5eHra2tIaEEMHz4cAAOHjz4+AMVQghR0wsvmDoCYWb+a+oAhDBDarXa6F9PGumhJIQQLVBUVBQ6nY6AgADatWtnmK7T6XBwcECr1VJcXAyAj48Ptra23Llzh5ycHFq3bm2iqIUQQgghhPhpMPYwNRnyJoQQwuSKi4uJjIzE0tKSiRMnVnstLy8PBwcHNBqNoUJJpVIxYMAAAI4fP/7Y4xVCCPEjzz9v6giEmfnQ1AEIIUQtJKEkhBAtzI4dO6ioqGDkyJFoNJpqr+l0Ouzt7asllAB69+6NSqXi/Pnz1aYLIYQwgdxcU0cgzIyjqQMQwgxJU+6mk4SSEEK0IMnJyVy5cgV7e3sGDhxY4/W8vDxDQqlqyBtAq1at6NatGxUVFZw/L8+CEUIIk1qzxtQRCDMzz9QBCCFELSShJIQQLcSDjbinTp1a41OOsrIyioqKDD2UflyJ1L9/f6By2Jter388QQshhBBCCPETJBVKTScJJSGEaCHOnj1LVlYWPj4++Pj41Hg9Ly8PwNBD6cEKJQBvb28cHR3Jz8/n+vXrjyNkIYQQtfn6a1NHIMzMAlMHIISZkmRS00hCSQghWoDi4mL279+PSqVi8uTJtc6j0+kAsLe3R6vVUlFRQXl5ueF1lUplqFI6ceJEs8cshBCiDq+/buoIhJl509QBCCFELSShJIQQLcDevXspKyujf//+ODrW3nrzxxVKQI1hb8HBwajVau7du0dKSkrzBi2EEKJ2t2+bOgJhZjqaOgAhzJBarTb615PmydtjIYRoYVJSUrh48SIajYannnqqzvl0Oh0ajQZra2u0Wi1AjWFvrVq1wt/fH7VazcmTJ5s1biGEEHXo3t3UETxxzH3YyhVTByBaBEVRjPbV0mLKladj/iRJQkkIIUxIURS2bt0KQHh4OFZWVnXOq9PpcHBwAKizQgmgT58+6PV6YmNjyc/Pb4aohRBCPNTLL5s6AmFm3jF1AEKYIWnK3XSSUBJCCBO6cOEC6enpODs7ExQU9NB58/LysLe3B6izQgnAy8sLJycnFEXh9OnTxg9aCCHEwy1fbuoIhJn5zNQBCGGGJKHUdJJQEkIIEykuLmbv3r0ATJo06ZEXoby8vHpVKKlUKvr06QPA6dOnqzXuFkIIIYQQQghjkISSEEKYyIEDBygtLcXf3x93d/dHzq/T6QwVSlUJpdoqlOCH5txFRUXExMQYL2ghhBCPtnSpqSMQZuZLUwcghBmSptxN9+TtsRBCtAApKSmcPXsWCwsLxo4d+8j59Xp9tQolCwsLrKysaq1Qgh+ac1tZWREVFWXU5otCCCGEEEIIIQklIYR4zBRFYceOHQAMHTrUUHX0MAUFBSiKUm1ejUZTZ4USQEhICGVlZaSnpxMfH9/0wIUQQtTPl1JPIoxLat6EMD7podR0klASQojHLCYmhuTkZGxtbRk8eHC9lsnLywMwVChBZWPuuiqUoLI5d7t27dBoNERFRTUtaCGEEEIIIcyIDHlruidvj4UQwoQebMQ9fvx4LC0t67WcTqcDqieUHlWhpFKp6N27N6Wlpdy4cYOMjIwmRC6EEKLePpNncgnjkucGCiFaIkkoCSHEY3Tw4EGKi4vx8PDAz8+v3svpdDrUajWtWrUyTNNoNA+tUIIfmnNbWVlx6tSpRscthBCiAd55x9QRCDPzsqkDEMIMyZC3ppOEkhBCPCYpKSmcPn0aqKxOashFJy8vD3t7+2rLPGrIG/zQnNvS0pILFy5QVFTUuOCFEELU35Urpo5AmJnupg5ACCFqIQklIYR4DBRFYefOnahUKnr16kX79u0btPyDT3irUp8KJahszl1UVIRer+fs2bMN2q4QQohG6NjR1BEIM3Pb1AEIYYakQqnpJKEkhBCPQUxMDElJSVhaWjJq1KgGL6/T6WpNKD2sh1KVqubcDg4OnD59moqKigZvXwghRAO8+aapIxBm5nVTByCEGZKm3E335O2xEEI8ZsXFxezbtw+AkSNHYmtr2+B16HQ67O3tq02rz5A3qPz0JSQkBJ1Oh06n44oMxRBCiOa1YIGpIxBm5mtTByCEELWQhJIQQjSzQ4cOUVxcTOvWrenXr1+Dl1cUpUkVSlDZnFulUtGmTRuioqJQFKXBcQghhBBCCGEuZMhb00lCSQghmlFVI25FUQgPD8fCwqLB6ygpKaGsrKzWCqXy8vJ6DWGzsbEhICCAsrIykpKSSExMbHAcQggh6mnePFNHIMzMGlMHIIQQtZCEkhBCNBNFUdi1axcqlYqOHTvSpUuXRq0nLy8PoNYKJaBew96gsjl3fn4+Dg4OREVFNSoWIYQQ9eDoaOoIhJnJNXUAQpgh6aHUdE/eHgshxGMSExNDYmIier2esWPHNroMVqfTAdRaoQTUe9ibp6cn7dq1o1WrVly5coWcnJxGxSOEEOIRPvzQ1BEIM/O8qQMQwgzJkLemszR1AEIIYY6Ki4vZv38/arWaPn364Ozs3Oh1VVUo/Tih1NAKparm3BEREVhbWxMdHc2YMWMaHZcQQgjRUkhvwPox9+NkzP17EpMDQjSUVCgJIUQzqGrEbW1tzYgRI5q0Lp1OR6tWrbC0rP4ZQEMrlOCH5tyurq6cO3eO0tLSJsUmhBCiFv/9r6kjEGbmBVMHIIQZUqlURh3u9iQmISWhJIQQRlbViFuv1zNy5EhsbGyatL7anvAGDa9Qgh+ac+fm5lJSUsKFCxeaFJsQQohafPGFqSMQZuYZUwcghBC1kISSEEIYkaIo7N69GwsLC9q1a0efPn2avM68vLxaE0qNqVCCyubcubm5eHt7c+rUKbMvfxdCiMfu/HlTRyDMTC9TByCEGZIeSk0nCSUhhDCimJgY7t27R3l5OeHh4UZ52oNOp6vRPwnAwsICS0vLBlUoQWVzbmdnZ9RqNVlZWVy/fr3JMQohhHiAu7upIxBmJsnUAQhhhiSh1HSSUBJCCCOpasRtaWlJt27d6Nixo1HWm5eXV2tCCSqHvTW0QkmlUtG7d2/u3LmDm5sbUVFRxghTCCFElf/8x9QRCDPzkqkDEEKIWkhCSQghjOTQoUOUlJRQUVHB6NGjjbLOiooKCgoKah3yBpUJpYZWKEFlc261Wk3btm1JSEggJSWlqaEKIYSoMnOmqSMQZmajqQMQwgwZsyF31deT5snbYyGEaAZVjbgVRWHAgAG0bdvWKOvNy8sDqDOhpNVqG5VQsrGxwd/fn6SkJOzt7Tl16lST4hRCCCGEEEI0zAcffICPjw9arZb+/fsTHR390PnfffddunXrho2NDZ6enrz00ksNHq1gTJJQEkKIJqpqxG1tbY1Wq2XYsGFGW7dOpwN46JC3xiSUoLI5d3Z2Np07d+bSpUvk5+c3Ok4hhBAPmD7d1BEIM7PZ1AEIYYZM3UNpw4YNvPzyy7z++uucO3eO4OBgwsLCSEtLq3X+tWvX8sorr/D6669z5coVvvjiCzZs2MD//M//GONwNIoklIQQoomqGnGXlJQwatQow9PXjKE+FUqN/VSiqjl3YWEharWaM2fONDpOIYQQD/DyMnUEwszcNXUAQpghUw95e+edd1i+fDlLlizB39+fjz/+mFatWvHll1/WOv+JEycYPHgwc+fOxcfHhzFjxjBnzpxHVjU1J0koCSFEExQXFxMREYGNjQ3t27enZ8+eRl2/TqfDysoKjUZT6+tNqVBSqVSEhIRw48YNAgICOH36NOXl5U0JVwghBMA775g6AmFmXjZ1AEKIetPpdNW+artXLy0t5ezZs4SGhhqmqdVqQkNDOXnyZK3rHTRoEGfPnjUkkG7fvs3u3bsZN25c8+xIPUhCSQghmqCqEXdRURFjx441ejO+vLw8HBwc6iyhbcxT3h4UFBSEWq3GxsaGwsJCLl261Oh1CSGEEEII8VPRXEPePD09cXR0NHy99dZbNbadkZFBRUUFrq6u1aa7urrW+bCcuXPn8r//+78MGTIEKysrOnXqxIgRI2TImxBC/BRVNeJWq9X4+/vj7e1t9G3odLo6+ydB45tyV7GxsSEgIICrV6/SpUsXoqKiUBSl0esTQggB/Pvfpo5AmJnfmDoAIUS93bt3j9zcXMPXH//4R6Os9/Dhw/z973/nww8/5Ny5c2zdupVdu3bxl7/8xSjrbwxJKAkhRCNUNeK2sbGhvLyc0aNHN8t2qiqU6tLUCiWA3r17k52djbe3N2lpacTHxzdpfUII8cTbLC2UhXFJm3chjK+5KpQcHByqfdXWuqJdu3ZYWFiQmppabXpqairt27evNd4///nPLFiwgGXLlhEYGMiUKVP4+9//zltvvYVerzf+AaoHSSgJIUQjVDXiLi4uZvDgwbRu3bpZtlOfCqWysrImXUSqmnMnJSXh6urKqVOnGr0uIYQQQB39L4RorIGmDkAIM2TKptzW1taEhIQQGRlpmKbX64mMjGTgwNp/46sepPMgCwsLAJONMJCEkhBCNFBVI24HBwdsbW0ZMmRIs2xHUZR6VSgBTRr2VtWc+9q1awQHB3P9+nUyMzMbvT4hhHjitW1r6giEmZGrshDm5+WXX+azzz5j1apVXLlyhZ///OcUFBSwZMkSABYuXFhtuNzEiRP56KOPWL9+PfHx8URERPDnP/+ZiRMnGhJLj5ulSbYqhHgsKvQK93OKyC8pp5W1Be6tbbC0kDxyU1U14i4vL2fy5MlYW1s3y3YKCwupqKh4ZIUSVCa5bGxsGr2toKAgDhw4QFlZGba2tpw6dcqkT4wQQoiftBUrTB2BMDNLTR2AEGbowWFqxlpfQ8yaNYv09HRee+01UlJS6NmzJ3v37jU06r579261iqQ//elPqFQq/vSnP5GUlISzszMTJ07kb3/7m9H2oaEkoSSEGcrIL2HjmXt8dSKBFN0PlStOttYsGODNnH5etHfUmjDCn66qRty2trY4OjoSFBTUbNvKy8sDaPYKJfihOfeFCxcICQnh5MmTjBw5sklJKiGEeGI9/TTs2GHqKIQZ2Q5MMnUQQgije+GFF3jhhRdqfe3w4cPVvre0tOT111/n9ddffwyR1Y+UKghhZg5eTWXIPw7y//Zdq5ZMAsgqKOX9gzcY8s+DbL+QZKIIf7qqGnHb2tqSn5/P2LFjjfqpxo/pdDrg4QmlByuUmiokJITs7GycnZ3R6/WcO3euyesUQgghhBCiJTJlDyVzIRVKQpiRQ9fSWLbqDIoCdbVl0yugVxReXH8BgEk93R9bfD91VY24NRoNQUFBeHh4NOv2dDodKpUKW1vbOucxVoUSgIeHBy4uLsTFxREYGEh0dDQDBgww2ZhsIYQRzZoFVlawZg38z//AnTvQowe88AL87GeV8yxfDmVlsHJl5fdffgn//CdcuwadO8Of/gSLF1e+tmABtGoFn3xS+f2HH1b+/+JF8PSEf/0LZs+ufG3mTHBzg/feq/z+P/+BdesgOhpcXCqXmzKl8rVJk6BbN3j77crv//EP2LULjh0DBwdYvRqmToXycggLg379oOpxyW+8AcePQ0QEaDSwaRPMnQv5+TB8OIwZA6++WjnvK69AbCzs3Fn5/Y4dsGQJZGbCwIEwfTr85vsHtb/8Mty9+8OT2zZuhJdegqQk6NULnnmm8jgCPP885OZWHt+nn4avv4bXX4fbt6F798p1LV9eOe/SpT8cZ4DPPoN33oErV6BjR3jzTViwgB3ffssaIBd4/vsf5wvAM0AvIAl4Cdj4/WubgbvAy99//xsqnxD21sSJlb2dVqyojA1gwoTK8+Af/6j8/m9/g/374cgRsLODtWthxgwoKYHRo2Hw4MrjDPDnP1f+DPftA0tL2LoV5s8HnQ6GDoXx4yuPM8Dvf195Hm3fXvn9tm3w3HPs+OILooF1wH++j/c9wA2Y+f33s4F/AZ7AReAT4MPvX/sEaAUs+P77xcCfgM7ANeCfwPdHl5VAGfD90edn3x/HHsAd4H+ANd+/to7KnkVVNQO/AhYCfYDk76dv+f61bcAt4Lfff/97KiuJBgPZ38e0jcpP8XcD54Hvz0JeA0YATwFF3+/resAGOAgcBv73+3mffuUVFG9v2L0b1Gr45htYtAiysyt/LpMmVR5ngN/+Fm7dqjzOAFu2VJ6jycnwv/8LCxfCr35V+doLL1Se9+vWVX4v7xGV877yCsonnxjtPWKHt3flYQAcgXnf/1wXAG8CHYErwDvAZ9+/VnXuVg13XA6k/v73Nd4jAJg3DxwdK48zwH//C198AefPg7t75TGd+f1v1fTp4OVV+X4D8O9/V8Z+8mSj3iM2qVRogAjgOPDG9/H+BegHhAHlwDTga8ABOAbsAr5fK28DvsBqxE+NSjFVO3AhhFHlFZcx4O+RFJZW1JlMepAKsLRQcfwPT+HiIMPfHqW4uJj//ve/aLVadDodL7zwwkMrh4zh0KFDnD9/npdffrnOecrLy/nb3/7G5MmTCQ4ObvI2T506xf79+5k3bx5ff/0106ZNo0ePHk1erxDCNHQ6HY6OjuTm5jb7e5Z4wIkTMGiQUVZlrErYlnjL35xVvuZGOX7caOeUePzk97j+Hsf1quraOGrUKCwtjVdjU15eTmRk5BN1zX3yarKEMFPbzifVO5kElRVMFXqF9afvNWdYZuPQoUOUlpaSlZXF4MGDH8tFQqfTPXI7FhYWqNVqo1QoAQQHB6NWq0lKSsLHx4dTp04ZZb1CCPFEqfo0XwhjkXNKCKOrasptzK8njSSUhDADiqKw8nhCg5fTK/DVyQQq9C3v046WpKoRt6OjIw4ODgx6TJ8Q5uXlPTKhpFKp0Gq1RksoabVaAgICOHfuHP379ycxMZHExESjrFsIIYQQQghhPiShJIQZKCqr4HZGQb2rkx6UkV9Kiq7pDZ3NVVUjbgcHBzIyMhg9ejRWVlaPZds6nQ57e/tHzqfRaIzSlLtKSEgIOTk5WFpa4uTkRFRUlNHWLYQQTwQTPsJZmCk5p4QwOpVKZdSG3FKhJIT4SSosrWjS8tu+3c2uXbs4ePAgUVFRXLx4kRs3bpCYmEhWVhZFRUUtcsz241DViBvAy8sLf3//x7btvLy8eiWUjFmhBD80566qUoqLiyM3N9do6xdC1N8bb7xRo5zez8/P1GGJR9m/39QRCHMj55QQogWSp7wJYQbsNE37VS7Jz+FeQRlFRUUUFRVRVlZWYx6VSoWNjQ02Nja0atWKVq1aVfu+rn9/yk8IKy4uJiIiAjc3N5KTk5k1a9Zj++ShtLSU4uLievVq0mg0Rk0oqVQqQkJC2LdvH6GhoVhbWxMdHc3o0aONtg1hOnnFZUTHZ5FbVIa1pZqurvZ0dX104lKYTkBAAAcOHDB8b8wGoqKZHDnywxOghDAGOaeEMDpj9z16EiuU5I5ECDOgtbKgRwcH4pJ1NKwdkoKdqoy81ERKNdb4+Pjg4+ODp6cn9vb2FBcXU1hYSFFRUY1/i4qKyMjIqPZ9baytrR+ZdPrxv9bW1o/1DVmvKGSUllNQocfOUk07K0tUKlW1Rty9evXCzc3tscWUl5cHUK+EklarNeqQN4CgoCAiIiK4fPkyvXv35ty5cwwfPhxra2ujbkc8PrfS81lxPJ7NZxMpLtNXe62XZ2sWD/ZhQlAHLNRP3s1QS2dpaUn79u1NHYZoCDs7U0cgzI2cU0IYXdVQNWOu70kjCSUhzMTiwb78dtPFBi2jQsWvwoMY17Ev8fHxxMfHc/DgQcrLy7GxscHX1xcfHx98fX1p27btQ5M8er2e4uLiWpNPDyad8vPzSU9Pp7CwkMLCQioqag7XU6vVtSab6kpAVf2/oW/iGaXlrEvO5MukDJJLfqjK8rWxZqaDhoxz5+nY3pW0tDSeeuqpBq27qXQ6HUC9eygVFBQYdftarZYePXpUJpJmzeXa9Xg+OHORvt396ONgi9biybtg/pTtjU3hl+vOoVeotQn/xcQcXlx/gZ0xybw/pxdaq59uZaE5unHjBh06dECr1TJw4EDeeustvLy8ap23pKSkWsVi1XuJeMzWrjV1BMLcyDklhGiBJKEkhJmYEOTG33dfIaewtJ5VSgpWapgc1B6X1rZ4eHgwdOhQysvLSUxMNCSY9u7di16vx97eHl9fX8OXo6NjtbWp1WpDcqdt27b1illRFMrKyh6ZhCosLCQtLc0wra5qHI1GU+8k1NESPb9LyKBcUdD/aD0JRaX8s7AE6/5jCLt8isXDhmH3mD8ZbEiFkrGbckNl1VZW1wBW6m1560oSBPRndwlw4RYOlmoWdGjHYvd2eGqlYqmlO3YjnefXnEVRqLNxf9V7RuSVVH657jwfzw+RSqUWon///qxcuZJu3bqRnJzMm2++ydChQ4mNja014fzWW2/x5ptvmiBSUc2MGbBpk6mjEOZEzikhjE6GvDWdJJSEMBNaKwu+WNSHGR8dRwEU6n5DU1H5hjfa5jZb1t1j1qxZODk5AZVDK6qGvo0cOZKSkhLu3r1LfHw8CQkJxMTEANCmTRtDcsnHx6dRCReVSoW1tTXW1tY1ElQPo9frqyWb6kpG6XQ6UlJSDNP0+srU0a12buzv3rcqiBrrV76fXqa2YFePgYy0tcbr3j1DMkqr1TZ7SatOp0Or1dbriXLGbspdVKHn53F32JuRj8qxZnJQV67n47tprEjMYGWgL8OcpP9OS1VeoefljRe/f094NL0CEXGp7I1NYXzQ4xviKeoWHh5u+H9QUBD9+/fH29ubjRs38swzz9SY/49//CMvv/yy4XudToenp+djiVU8wIjvyUIAck4JIVokSSgJYUaybpxjrPVVjqkCyC3Wo1ZRrVpJpQJFAUvK+fekbgzo2JcNGzbw2WefMW3aNDp37lxjnRqNhi5dutClSxcAioqKSEhIMCSYzp07B4CLi4theJyPjw9arbbZ9lOtVmNra4utrW29l1EUhdLSUu7q8njqciKqh1RrGJZRqQCFV9IKWfjtN1jpfxiep9Vqax1297D+UPVJDlXR6XT1qk4C41YoVSgKP49LYH9G5TAZpY5PWiqAYr2eeTG32darM30c6/+zEI9P5NU00vMa9keIWgUrT8RLQqmFat26NV27duXmzZu1vq7RaNBoNI85KlGDPMRAGJucU0IYnfRQajpJKAlhJi5cuMB3333HnDGh/Lv/AHZfSmbl8QQuJv7wuPdurvYsGuhNxrl93L+QTNu+y1m2bBlbt25l7dq1jBo1ikGDBj20XNPGxobu3bvTvXt3oHJoVlWC6fr160RHR6NSqXBzczMkmLy8vEzezFmlUqHRaNhZkE1FPZJJVRSVmlIrazxmziNcq66zGio7O5ukpCTD94pScwuWlpaPHJJX9f/MzExsbW1RFOWR5bNarZbS0lL0en2TL2Tb03LYm1G/nit6AEXhF3F3iBrQ/Yks823p1kTdwUIFFQ1o1q9X4HRCNrfS8+nkLE1gW5r8/Hxu3brFggULTB2KeJjBg00dgTA3ck4JYXQy5K3pJKEkhBm4c+cO3377Lb169TIkhKb08mBKLw/KKvQUlJTTytoSa8vKZMN9zwl8/vnnREVFMXjwYObMmcOhQ4c4cOAAycnJPP300/VOANnb2xMYGEhgYCAA2dnZhgRTTEwMJ06cQK1W4+HhYRgi5+7ubpLHXpfrFVYkZdTomfQoamBDbgk/6+ZXr/kVRaGkpKTO5NOD/aGysrIM08rKymqs6y9/+UudlU9V/8/IyAAgMTGRNm3a0KpVKywsGtdU+fPEdNRQ72OkB+4Ul/Jddj5DZeib0SiKgqIoVFRUoNfrDV8N/T42MbtByaQH3UqThFJL8Nvf/paJEyfi7e3N/fv3ef3117GwsGDOnDmmDk08zBtvwI4dpo5CmBM5p4QQLZAklIT4icvMzGTDhg14e3szfvz4GplxKws1rVtVTw516NCBAQMGcPjwYbp3746TkxOjRo3Czc2Nb775hi+//JJZs2bRpk2bBsfTpk0b2rRpQ69evVAUhYyMDMPwuFOnTnHkyBEsLS3x8vIyJJjc3NweS4no/ZJS0krLG7ycHrhSUExqVhY2lpaoVCrUarXhU42q/z/4r1arbfCwv/LyckOy6auvvjJUeP04CZWRkVFtWpUVK1YY/m9tbd2gJ+XZ2NgQX6bnnK6wwcfHQgUrkzIeW0JJUZQmJVl+/L2x1mGsdVVUVNRa4dYYBUXBQP2HWj6opLyhqVfRHBITE5kzZw6ZmZk4OzszZMgQoqKicHZ2NnVoQgghxE+aVCg1nUox1l2rEOKxKyoq4osvvgDgmWeewcbGpt7LlpaW8uGHH9K2bVvmz59veANMS0tj/fr1FBcXM23aNDp16mS0eBVFISUlxZBgunPnDqWlpWg0Gry9vQ0JJhcXl2Z5Q76SX8TI09cavfziE3uwKS+t9/wPSzg9KimVnp6Og4MDtra2D11OpVJRVFREUlISHTp0wNLS0pCgqKioMHyVl5cb/i0vL681YXHTxZ0Ivz6NOjauSgVvl2XUK8HS1KRLc162qo6vWq3GwsLC8P/6fF/feYy1rvqsY9wHp7iX07hGrl8/04+hXSRp8VOn0+lwdHQkNze33n3ZhBGcPg19+xplVca6HrbEW/4n8Y+vxlKio412TonHT36P6+9xXK+qro0TJ05sUI/TRykrK+Pbb799oq65UqEkxE9URUUFGzdupLCwkGXLljUomQSVFSzjx49n7dq1xMTEEBwcDFQ2116+fDlbtmxhzZo1hIaGMnDgQKNcLKp6K7m5uTFo0CAqKiq4f/8+8fHxxMfHc+DAASoqKmjVqpWhubevry9OTk5G2b6dZeOGgVVZNGsGVmBIalT9++D/6/q3IfOUlJSQnp6Oi4sLDg4OhtfqWvbBC6GlpSVqtfqR23kw6VSVqMGq8Y18C8rLuXHjRr0SI1ZWViZLsjxqnebwx41Op+PKlSvExcXROr+CRNo/9KmPtbHTWNLXx6mZIhTiCSB//Atjk3NKCKOTCqWmk4SSED9BiqKwc+dO7t69y8KFC3Fyatwffl26dKFHjx7s27ePLl260KpVK6Cy8fbcuXM5ePAgERERhr5KxszgA1hYWODp6YmnpyfDhg2jrKyMxMREQ4Jp9+7dKIqCg4ODoXrJ19e30Rn/Dhor2ltbktLAYW8qRU+HshLKiyzo7Odn9OPwY0lJSZw/f55Ro0bRvn37R86fl5fHO++8w/Dhw+natWujt7s3PZeI2PhGLevZ2pEXXnih0dsWTaPT6YiLiyMuLo579+4Z+pYNaQ+XEhu2Lgu1ijn9PNFaNS0BK8QTbd8++MUvTB2FMCdyTglhdJJQajpJKAnxE3TixAkuXLjA5MmT8fb2btK6wsLC+OCDD9i/fz+TJ082TFer1YSGhuLm5sb27dv54osvGt1Xqb6srKwMSSOAkpIS7ty5Yxgid/HiRQCcnJwM8/n4+GBrW79H1luoVCxxd+af8ckNasytqNT0uH+brVE3sba2pnv37gQGBuLr69ssvZ90usqnrNU3cVb1iPDi4uImbTfIUsFKUShr4MVQDYQ7OzZp26LhcnNzDUmkxMRELCws6NSpE6NHjyYlJYXY2FgcHR0Z4GbJqeTyelUpqVRgZaFi4UCf5t8BIcyZCR48IcycnFNCiBZI3pmE+Im5cuUKBw4cYOjQoYZhak1hZ2fHmDFj2LFjB0FBQXTs2LHa6wEBAbRr147169fz2WefMX369BrzNBeNRkPXrl0NVTeFhYWGJ8glJCRw9uxZoHKYXlWCydvb+6HNsOe6teH/xd9Hr1D51/MjqFCwLivDK/E2FhYWtG/fnjt37nDx4kXs7OwIDAwkKCgIV1dXo30qodPpsLCwqPcwRisrK1QqFSUljeuVk5ycTFRUFJcuXaJL5yCuuHqhNDBRNt+tbaO2LRomJyfHkERKSkoyJJEmT56Ml5cX0dHRHDx4EI1GQ1hYWGXvnC3buKvxI7nE6qFJJbUK1CoVnyzog6dTq8e4V0KYH9W2bfW6xtSHOfdMaYn7Bi20ymDrVlNHIJqgpZ7rxmCsfavqa/Q4SYVS00lCSYifkPv377N161YCAgIYOXKk0dbbs2dPYmJi2LlzJz//+c9rDOlydXXl2WefZfPmzaxevZrRo0czYMCAx/6m2apVK/z9/fH39wcqh3pVDY+7evUqp06dQqVS0aFDB0P/JS8vL8P+VFRUcHLfXkbdSWZfQD8AHnYJVCkKlmo1KwK8ScnoxI0bN7h37x7W1tb07dsXvV7PxYsXOXnyJC4uLgQGBhIYGNjki2FeXh729vb1Pr4qlQqtVtughJJer+fatWtERUVx9+5dLC0tURSFp0p1XFerKVeU+iXcFIWprk500Fo/cl7RONnZ2YYk0v3797GwsKBz585MmTKFbt26oVKpiIqK4pNPPkFRFIYOHcqAAQOIi4tj48aNdO3alVBfT/68PY7b+raoVFQmVL9noVZRoVfo0NqG/8zqKb2ThDCCr4EFpg5CmJf582H1alNHIYQQ1UhCSYifiNzcXNatW4erqyuTJk0yejZ9woQJfPTRRxw5coTQ0NAa89jY2DBv3jwiIyPZv38/ycnJRn8yQkPZ29sTFBREUFAQiqKQk5NjSDBduHCB48ePo1ar8fT0xN3dndu3b5OWlsavJ05krocvz11OoFhf2aT6weSJCgUFFdblZfy6PIen3INh7lyuXr3Krl27KCgo4MyZM9jZ2TF8+HAcHBy4fPkyR44cITIyEh8fH4KCgujevftDq6XqkpeX1+A+URqNpl5D3oqLizl//jzR0dHk5ORga2uLSqXC3t6eUaNG4eHhwf1vdrPN0w94dMLNOS+HkYX3Ufy9nshPZZpLdnY2ly9fJi4ujuTkZCwtLencuTMDBgyga9euaDQaKioqOHv2LEePHqW4uJg+ffowdOhQWrVqxdGjRzl8+DAhISEMHjyYTz75hF/286PfiKdYH32XvZdTyCksw9pSTXc3BxYM8GZI53ao1fIzFMIYnoxn+4jH6vvh8EII45EKpaaThJIQPwGlpaWsW7cOCwsLZs+e3SxJnLZt2zJs2DAOHz5Mjx49am0GrVarGT16tKGvUnp6OrNmzaJ169ZGj6ehVCoVbdq0oU2bNvTu3RtFUcjIyOD27dtcu3aNkydPoigKFhYWxMbG4ltQwN6O3vw35hr71Tbkan8Y4uNSVsLvenTBJymeyN0nudrRCz8/P/z8/OjYsSOHDh0iKiqK0tJS9uzZg5OTEyNHjmT8+PFcvXqVmJgYduzYwe7du+nWrRuBgYF07twZC4v6NTnW6XQNTig9qkIpKyuL6Ohozp8/T1lZGc7OzlhaWqLX6xkzZgx9+/aloKCAlStX0lWv56MRw3n1XhaZZeWoFD2K6ochcGpAryh0yUxm+LXzxFaU46CxJjQ09Im8kBpLVlYWly9f5sqVK4YkUpcuXRg0aBBdu3bF2rqyCkxRFC5dusShQ4fIzs4mODiYESNG0Lp1a/R6PTt37uTcuXOMHDmSIUOGsGbNGjQaDWPHjkWr1fLymG68PKabifdWCPN2zNQBCPMzdKipIxDC7EhCqekkoSREC6fX69myZQvZ2dk888wz2NnZNdu2Bg8eTGxsLN9++y3PPPNMnQ2ne/ToQbt27diwYYOhr1JVI+2WQqVS4ezsTG5uLvfv36ddu3Y89dRTZGZmkpCQwJEjRygrK6Md8GtXV7r27IWtU1u+3bgBR2sr5o3uD25OJN66yY4dO3B3d8fe3h5ra2vCwsIIDg5m586dJCUlUV5ezpYtW2jfvj1PPfUUCxYsIC8vj0uXLhETE8P69euxsbGhR48eBAUF4e7u/tALjk6nw83NrUH7q9FoaiSUFEXhzp07REVFce3aNbRaLZ6eniQnJ5OZmcmAAQMYMmQIWq2W3NxcVq1ahV6vZ9GiRbRp04ZQFyd+seJr4jp0pNCpHfnFJTi3smGyW1scTn9HWdI98ivKUalUnDhxwpCcehIvpo2VmZlpGM6WkpKClZUVXbp0YfDgwXTp0sWQRILKn+fNmzeJjIwkNTWVbt26MXv2bFxcXIDKxPPmzZu5desWkyZNomfPnkRHR3P79m3mz5/fqGo5IUTj7DJ1AML8jB9v6giEEKIGSSgJ0cLt37+fGzduMHfuXMMfjs3FwsKCiRMn8uWXX3L69Gn69+9f57zt27dn+fLlbN68ma+//poxY8bQv3//FpNMUBSF6Oho9u3bR+fOnZk2bZrhaWiDBw+mvLycTz/9lMLCQrQaDScPRFBRUYE1UFRUzvHjx/H392fixIl8/PHHfPPNN8yfP9+wf+3bt2fp0qWcPXuWyMhINBoNZWVlrF27Fi8vL0aNGsXgwYMZPHgwqampxMTEcOnSJU6fPo2Tk5OhmbeTk1ONuBsz5E2r1RqGvJWXlxMbG8upU6dISUmhXbt29OnTh9u3b3Pr1i2Cg4MZOXKkodfTg8mkxYsXGyrObl2/Rsf0+0xq35ZBXQP45JNPWL58OR06dCDFdhiffPIJXl5e3L17F29vb6KiotDr9YwdO7bFnActUUZGhiGJlJqaipWVFV27dmXo0KF07ty5WhKpSmJiIgcOHODOnTt4eXmxZMkSvLy8DK8XFBSwdu1aMjIymDNnDp07dyYzM5MDBw7Qp08fOnXq9Dh3UYgn3j+ASaYOQpiXV16BHTtMHYUQZkUqlJpOEkpCtGCnT5/m1KlThIeH07lz58eyTU9PT/r27UtkZCR+fn4PbTDdqlUr5s+fz4EDB9i3bx/JyclMmDDBpH2VoLL59p49ezh79iwDBgxg9OjRNaqt4uLiSE9PZ+HChfj6+lJWVsa9e/fYvHkzRUVFREZGEhkZiaOjI66urty6dYvDhw9Xa4auVqvp27cvfn5+7Nu3j8uXL+Pq6kpBQQErVqyga9euPPXUU7i6ujJ69GhGjRpFQkICly5d4uTJkxw5cgQPDw+CgoJw7tKNY4WlpBYWE+3qTVtrW3rr9VjX82lrGo2GzMxMDh8+zJkzZygoKKBLly707NmTy5cvc+bMGTp27MiMGTOqDWesSiYpilItmQRw7tw5oPJJf5bfP664vLwcqEyo9ejRg4SEBGxsbLh37x6jR48mIiICvV7PuHHjnsiLal3S09MNSaS0tDSsra3p2rUrw4cPp3PnznX+zqSnp3Pw4EGuXr2Kq6src+fOpXPnztWObVZWFqtXr6a0tJTFixfj5uaGXq9n+/bt2NnZMXr06Me1m0IIIYQQ4gkiCSUhWqibN2+yZ88e+vXrR79+/R7rtkeNGsXVq1fZvXs3s2fPfmhiQK1WM2bMGNzc3NixY4ehr9LjfuxnlaKiIjZt2sSdO3eYOHEivXv3rjFPaWkpBw4cwM/PzzBUz8rKio4dO+Lt7c3Nmzfp1asXnTp1Ij4+noSEBACOHj3KxYsX6dKlC76+vvj4+NCqVSvs7e2ZPn06PXv2ZNeuXeh0Orp3705KSgoff/wxgYGBjBw5kjZt2tCxY0c6duzIuHHjuHbtGrvirvNifDrxeRYoqLBQgd63O1G5Fbx7/DKL3Nvxc09nHK3qfrtOSUnh/v37ZGRkkJaWRnBwMN26deP8+fPs3bsXV1dX5s+fX6NK5cFk0qJFi6olkwoKCrh79y5qtRpfX18KCwuBHxJKACNHjuSDDz4gMDCQixcvcuXKFSZMmMDOnTtRFIXx48c/0UmltLQ0QxIpPT0da2trunXrxsiRI+nUqdNDE6+5ubkcPnyYixcv4ujoyJQpUwgMDKxxPJOSkli7di02NjY888wztGnTBoCTJ09y7949lixZUmvFkxCieb1t6gCE+fn9700dgRBmR61W19nio7Hre9JIQkmIFigtLY3NmzfTuXNnwsLCHvv2NRoN48aNY8OGDcTFxREQEPDIZQIDAw19lT799FNmzJiBj49P8wf7gMzMTNauXUtRURELFiyoc/vHjx+nsLCQMWPG1HjNyckJlUpFamoq48aNo1u3yubFubm5rFixgpKSEm7fvs2ZM2cAcHV1xdfXF19fX7y9vXn++ec5evQoJ06coHXr1vTv35/Lly9z+fJlevfuzbBhw7C3t8fKyopbLu68n1GOovzwNLUKMDxxLru8gvfvpLIjLYdNPTvhrv0hMaDX67lx4wZRUVEkJCRgbW2NVqtl2bJlREdHs27dOuzs7Jg0aRJBQUE1LnC5ubmsXLkSoEYyCSoruAC8vLywtramtLQUqJ5QcnJyonfv3sTGxtK2bVsSExPp2bMnkyZNYvv27ej1eiZOnPjEJJUURamWRMrIyECj0dCtWzdGjRpFp06dDJVedSksLOTYsWOcPn0ajUZDWFgYffr0qbWh+/Xr19m8eTOurq7MmTOHVq0qG8unpaVx6NAhBg4cWG1YnBDi8ekGHDd1EMK8XLsGQ4aYOgohzIoMeWs6SSgJ0cIUFBSwbt06HB0dmTZtmsky3VVPNduzZw8dO3bExsbmkcu4ubnx7LPPsnnzZr766ivCwsLo16/fY3lzvX37Nps2bcLOzo5ly5bV6E1UJScnhxMnTjBgwABDNceDnJycKCsr4/79+1RUVBj+kHd0dGTevHl8+umndOzYkUWLFhEfH098fDxxcXFERUWhUqlwd3fHx8eH8ePHc/78eU6dOkVgYCCtW7fm9OnTXLx4kf79+6MP6MnPr9xD4YdkUm0qgITCYqaevUZEf380FeVcuHCBU6dOkZ2djYeHB9OnTyc9PZ3vvvuOzz77DKisHurfv3+tVTA5OTmsWrUKqD2ZBBATE4NKpTIk1H485K3KsGHDuHDhAq6urmRmZrJnzx6effZZJk+ezPbt21EUhYkTJ5rtJzaKopCammpIImVmZqLRaPDz82P06NF07NjxkUkkqKyai4qK4sSJEyiKwtChQxkwYICh79ePnT17ll27dtGtWzemTp1q+DlXVFSwbds2nJyceOqpp4y6r0KI+psEfGnqIIR52b4dnnnG1FEIIUQ1klASogUpLy9n/fr1lJWVsXjx4jr/mHxcwsPD+eCDDzhw4AATJ06s1zJVfZUiIiLYu3evoa9Sff6obqwzZ86we/duOnbsyPTp0x/6NKsDBw6g1WoZWsfjd9u2bQtU/izS0tKqPW3N2dmZMWPGsHv3bjp37kxwcDDBwcEoikJ2drYhwXTu3DkKCwtRq9W0bduWK1euYGFhwfDhwykoKOBkVBRfl9qgaG1QeHSyTa9ScbeknMXrtxFy5xoVFRUEBAQwdepUOnToQExMDKdOnaKiooKQkBCGDx9uqFb5sQeTSYsXL651aGJOTg6JiYkAdOnSBfghoVRWVlZtXnt7ewYMGMCpU6dwcHCgpKSEzZs3s3z5ctRqNdu2bUOv1zNp0iSzSSopikJKSoohiZSVlYVWq8XPz4+wsDB8fX3rfb5XVFRw9uxZjh49SnFxMX369GHo0KHY2trWue3Dhw9z9OhR+vTpQ3h4eLXjeuzYMVJTU1m2bFmz/s4JIYQQQpiDJ7GqyJjkblOIFkJRFLZv305KSkqdf+g/bg4ODoSGhrJ7926CgoLw9vau13JqtZqwsDDc3Nz49ttvSU9PZ+bMmUbfJ71ez759+4iOjqZfv36EhYU9NGlx584dLl++zKRJk+pM1lVVNqlUKhITE6sllAD69OnDzZs32bFjBz//+c+xs7NDpVLh5OSEk5MTISEhKIpCeno6t2/fJiEhgby8PEpKSti/fz9arRbrXn3J1dae8KmLApx39iDo9hVUikJRURFxcXF8++23pKWl4e7uTlJSEk899VSd+1afZBJAbGwsKpWK1q1bGxJsVZVaP65Qgsqn5p05c4bWrVtz9+5dsrOz2bNnD08//TQqlYqtW7ei1+uZMmXKTzappCgKycnJhiRSdna2IYkUHh6Or69vrcPSHra+2NhYDh06RHZ2NsHBwYwYMaLWarEqFRUV7Ny5kwsXLhieIvjgTdD9+/c5evQow4YNo0OHDk3ZXSFEE00xdQDC/GzbZuoIhBCiBkkoCdFCHDlyhNjYWGbMmIG7u7upwzHo06cPly5dYufOnTz33HMNqnoICgrC2dnZ0Fdp5syZ9U5KPUpxcTGbN2/m9u3bjB8/nj59+jx0fkVR2LdvHx06dCA4OLjO+ezt7bG0tKRVq1YkJSXRt2/faq+rVCqefvppPvroI7755hvmzZtX45MNlUqFi4sLLi4uDBgwAL1eT3JyMmfPniU2NpbdeSWoNHqUhiRXVCqKrLX0W/YztFcvcfr0aW7duoVKpaJTp054eXmRlJREcXFxrQmlqmSSSqVi0aJFD03uXbp0CUtLS0N1UtU+WVpa1ppQ0mq1DBkyhIMHD2JtbY2npyfnz5/H19eXwMBA1Go1W7ZsQa/XM3Xq1AYlXkypKol0+fJlrly5QnZ2NjY2Nvj5+TFu3LgGJ5Gq1nnz5k0iIyNJTU2lW7duzJ49GxcXl4cuV1payqZNm7h9+zaTJ0+ucQ6Xl5ezbds22rdvX2f1nRDi8fkEWG7qIIR5ee45+PxzU0chhFmRHkpNJwklIVqAmJgYjhw5wlNPPYW/v7+pw6lGpVIxYcIEPvnkE7777jtGjBjRoOXd3NxYvnx5tb5Kffv2bdIbblZWFuvWrSM/P5/58+fTsWPHRy5z4cIFkpOTWbJkyUO3XVVtpCiKYdjXj9na2jJ58mTWrFnDqVOnGDBgwEO3rVarcXd3x93dnXHjxvHt0QsoqoZX6qiAfecv4nTmOG3btiU0NJSCggIuXbrEoUOHADh48CD9+/fHzc3NsJ85OTmsXLkStVr9yGRSeno6aWlpAHTt2rXaa3UllAD69evHqVOn0Gg0JCYm4u/vz86dO3F3d8ff3x+1Ws2mTZvYsmUL06ZNa7FJJUVRuH//viGJlJOTQ6tWrfDz82P8+PH4+Pg0OvZ79+4RGRnJnTt38PLyYunSpXh6ej5yufz8fNauXUtmZiZz586t8bQ+qPy5Z2dn8+yzz7bYYyvEk+ThKWIhGuH7a7MQwngkodR0klASwsTu3r3Ljh07CA4OZkgLfXqHi4sLgwcP5tixYwQEBODs7Nyg5W1tbQ19lfbs2UNycjLjx49vVI+XhIQENm7ciI2NDcuWLTMMyXqYkpISIiMj6dGjR72eeuXk5ERmZiaZmZkUFRXV2pC8c+fO9O/fnwMHDuDr64urq2u94re0tMTGzg4Kius1fzWKQlpmJgvGj6dXr16GxMHQoUOJi4tj8+bNXL9+nZiYGNq1a2cYprh169Z6JZPgh+oklUpVo5rsYQklKysrhg8fzs6dOwHw8PAgJSWFzZs3s3TpUvz8/Jg5cyabNm1i06ZNzJgxo8UkPhRFISkpyZBEys3NpVWrVnTv3h1/f398fHyaNFQvPT2dyMhIrl27hqurK3PnzqVz5871uunIzMxk9erVlJeXs2TJEtq3b19jnjt37nDy5ElCQ0MfWekkhHg8ok0dgDA//fqZOgIhhKhBEkpCmFB2djYbNmzAw8OjxT9efdiwYVy+fJmdO3eyePHiBsdqYWHB2LFjDX2V0tLSmDVrFg4ODvVex7lz59i1axfe3t7MmDGjXk+eg8pGxSUlJYSGhtZrficnJ5KSkgBISkqic+fOtc4XGhpKQkICW7ZsYfny5bU+Ua027TVWXC0oRl+vuX+gqFQ4oJCVlUVWVpYhsadSqQyVLpMnT8bCwoKYmBiOHj1KeXk5lpaWDB8+HGtr64ev//u+Plqtlg4dOtRI+D0soQTQs2dPTpw4QWlpKWfPnmXatGl8+eWXREREEB4eTrdu3Zg1axYbNmxg48aNzJgxw2SNo6sq0KqSSDqdDltbW0MSydvbu8n9nnJzczl8+DAXL17E0dGRKVOmEBgYWO/fncTERNauXYutrW2dT+MrLS1l+/bteHp6MnDgwCbFK4QwnnWmDkCYnzlzTB2BEGZHKpSaThJKQphIcXExa9euRavVMnPmzBZTrVEXS0tLJk6cyKpVqzh37hwhISGNWk9wcHC1vkozZsx4ZF8lvV5PREQEUVFRhISEEB4eXu/jlZWVRVRUFEOGDKl3U3AnJyfy8vKwsbEhMTGxzoSSpaUlU6dO5bPPPiMiIoJx48bVa/1PO7fmYFZeveZ9kIW+grZ3b3Ey/honT57E0tKSdu3a0bVrV3r06AFUPoWtW7dutG3bljt37lBRUUHbtm05ePAghw8fpmvXrgQFBdGlS5caxzApKYns7GxUKlW1/kkP7u/DEkoWFhY89dRTbN68mfz8fPLz8xk9ejR79+7F19cXPz8/unTpwuzZs1m/fj0bN25k5syZjy2ppCgK9+7dMySR8vLysLOzMySRvLy8jNI0vLCwkGPHjnH69Gm0Wi1jx44lJCSkQb/j165dY/Pmzbi5uTFnzpw6k6cRERGGoZ8/1YbnQpij/wCTTB2EMC8vvQQ7dpg6CiGEqEYSSkKYQEVFBZs2bSI/P59ly5bV+Yj3lsbHx4eePXsSERFB165dsbe3b9R6OnTowLPPPsumTZv46quvGDt2LH369Kk1q19SUsKWLVu4efMm4eHhDe6/FBERga2tLYMHD673MlXD6JydnQ2VSnVxcXFh9OjR7Nmzhy5dutSaiHlQQkICaXv3YdWpN2WW9atoAlApevqV5NHWRkt+fj42NjaoVCpSUlJISUnh6NGjAERGRpKcnExsbCyWlpY888wzODg4kJeXR2xsLDExMWzYsAEbGxv8/f0JCgrC09MTlUplqE4qLi6uNYn2qIQSgL+/P25ubmRkZHDy5EkWLlxIfHw827dvx83NDUdHRzp37szcuXNZt24d69evZ9asWfWu7moovV7PvXv3iIuLMySR7O3tDUkkT09PoyViSktLOXnyJCdOnAAqhyIOHDjwkZVhP3bmzBl2796Nn58fU6ZMqfPY3Lp1izNnzjBu3DjD0wmFEEIIIUT9SIVS00lCSYjHTFEUdu/eTUJCAgsWLKhXD6CWZMyYMdy4cYO9e/cyY8aMRq/H1taWBQsWsH//fnbv3k1ycjLjxo2rVq2SnZ3NunXr0Ol0hr4zDXH79m2uXr3K1KlTG5SwqPrj3MHBgVu3bqEoykMvEH379uXmzZts376dn/3sZ9jZ2dWY5/79+0RERJCQkADAEIe7HHKr2Vy5Nioq36y9Y8/i4e1Bt27duHLlCjdu3MDKygovLy8UReH27dvk5OQYEhoajYZt27bh7+9PcHAwAwcOZODAgaSlpRETE8OlS5c4e/YsrVu3JjAwkJiYGOzt7bG3t691eFV9EkoqlYpRo0axevXqyuRZWhqTJk3i448/ZsuWLSxevBi1Wk3Hjh2rJZVmz55ttKSSXq/n7t27hiRSfn4+9vb2+Pv7G5JIxrzgV1RUcPbsWY4ePUpxcTF9+/ZlyJAh2NraNmg9iqJw6NAhjh07Rr9+/QgLC6sz2VVcXMz27dvp2LHjI59wKIR4/J4+cABl1ChThyHMyYsvmjqCZmWs67KiKEZZDxg3OWDMuIylJR7zx00SSk0nCSUhHrOoqCjOnTvH008/jY+Pj6nDaTAbGxvGjh3Lli1buHbtGt26dWv0uiwsLAgPD8fNzY2dO3eSlpbGzJkzcXBw4O7du2zYsAGNRsMzzzzT4Ebger2effv24enpaRgOVl/29vZYWlpibW1NUVERWVlZD038qVQqJk2axEcffcT27duZO3eu4YKSkZHBwYMHuXLlCiqVyjAs7NV+/fifW8l8dT/zobGoFD0WwMdd3PBxHcuePXtISEggLCyMcePGceHCBc6fP09ubi4qlQq1Wo1Wq6V9+/akpKSQkJBAQkICu3fvplWrVri7u9OjRw9GjhzJqFGjuHPnDjExMURFRVFWVkZxcTE+Pj4UFBTUSIjUJ6EE0LFjR7y9vbl37x4nT55k8uTJTJ8+nRUrVnDo0CFGff9Hlq+vL3PnzmXt2rWsXbuWOXPmNLiap4per+fOnTuGJFJBQQEODg706NEDf39/PDw8jH6RVxTF8IS93NxcgoODGT58eK3JuEepqKjg22+/5eLFi4SGhjJo0KCHxrt3715KS0t5+umnn8ibFyFavORkU0cgzI2cU0KIFkgSSkI8RlevXmX//v0MHjyYXr16mTqcRgsICODixYvs3r0bHx8fNBpNk9bXs2fPan2VevXqxYkTJ/D09GTmzJmNGhJ49uxZ0tLSWLZsWYP/4FapVDg5OaHXV7bNTkpKemQlma2tLZMmTWLt2rVER0fTvXt3Dh8+zPnz5w29c7p27Up4eDiOjo6UlpYSfv8WtxOSOe3eiRIra9RgaNStUvQoKjWdLNX0v3yamFMZtB05kp/97GdERESwfft2OnfuzIQJExg2bBgXL15k+/btVFRUGJ5MN23aNDw8PIiNjeXy5cvcv3+fGzducOPGDbZt24adnR1eXl4EBwdTXl7OzZs3KSoqIiEhgX//+9907tyZoKAgunXrhpWVFVZWVvVKKKlUKkJDQ/niiy+IiYlhZGgoGY5taT08lA3nz2Hn6U3/rpXVZj4+PsyfP581a9awdu1a5s6dW++kkl6vJyEhwZBEKiwsxNHRkaCgIPz9/XF3d2+WZIuiKNy8eZPIyEhSU1Pp1q0bc+bMafQT1kpKSti0aRPx8fFMnTqVwMDAh85/9epVLl68yKRJk+rdF0wI8Zht3Ajz55s6CmFO5JwSwuikQqnpVMpPuUZNiJ+Q5ORkVqxYQefOnZkxY8ZP/g0nJyeHDz/8kF69ehEeHm6Udep0Oj7//HPy8vLw9PRk0aJFjWpWXlRUxPvvv0/Xrl2ZPHlyo2LZsGEDpaWl5Obm0rFjx3o33P722285f/48UFmBpdfrsbe3Z9y4cXTt2hW9Xs+5c+c4fPgwxcXFuLi4kJqVTdf5S9iXXUBaaRkatRrL9BTaXTrLixPD8fLy4uDBg5w+fZr27dszceJE8vPz2blzJyUlJQwaNIizZ89SVFSEr68v3t7enD9/nszMTJycnOjVqxc9e/bEzs6OkpISLly4wJUrV0hJSaGkpMQQu4WFBYqiMH36dPLz84mJiSExMRFra2v8/f3JysrC2tqaefPm1etYfLx+A7uK9Fz36UYuDwzdUhRGtrblWe/2jHCyR6VSce/ePVavXo2rqyvz5s2rM0mp1+uJj48nLi6Oq1evUlhYSOvWrQ3D2Tp06NCsv1v37t0jMjKSO3fu4OXlRWhoqOEJe42Rn5/P2rVrycrKYtasWfj6+j50/oKCAj766CM8PDyYNWvWT/59RDQ/nU6Ho6Mjubm5DXqqpmiip5826wbK5j5UpiW+tyoTJ8o5VQ8y5K3+Wtoxf5zXq6ptzZ8/v9HV8bUpLS1l9erVT9Q1VxJKQjwGVYkSe3t7Fi9e3GwNiB+3kydPsn//fpYtW4a7u3uT1lVaWsrWrVu5fv06Hh4e3Lt3j969exMeHt7gp4Dt3buX8+fP88ILLzS6cXhERARxcXF4eXmRkZHB8uXLHzp/SUkJUVFRHD9+nLKyMsNFevDgwQwbNgxLS0uuX7/OgQMHyMjIICgoiP79+7NixQoGDRrEyJEjq60vPT2dDz/8EG9vbxYvXgxUVkp9++23pKWl0bdvXwYNGkRERASXL1/G0tISNzc3bGxsmDNnDoqicOfOHc6fP8/ly5dRFIVu3brRq1cvOnXqZOjNk5+fz759+4iNja22fbVaTevWrenQoQMajYbbt2+TnZ2NhYUF/fv3JygoCFdX1zqPx6mcfOZdvEVBhR6llhsWtaKgV6mY6dqGf/t5YaVWkZiYyOrVq3F2dmbevHlotVqgcjjYg0mkoqIi2rRpY0giubm5NfvNf1paGgcPHuTatWu4uroyatQoOnfu3KTtZmRksGbNGioqKpg3b95DjydU3rBt2rSJhIQEnn/++Vp7dQnxY5JQMpHCQviJPHCjMVraH6LG1iITSgUFck7VgySU6q+lHXNTJJQWLFhg9ITS119//URdc2XImxDNrLS0lHXr1qFSqYzaeLgl6N+/P5cuXWLHjh08++yzjaomAsjNzWXdunVkZ2cze/Zsunbtyvnz59m1a5ehr1J9E0MZGRmcPn2aESNGNDqZBJWNuXNzc+nQoQOxsbGUlZXV+rMrLy/nzJkzHDt2jOLiYtq0aUNmZiaKohAUFMSoUaNISkoiIiKCO3fu4Ovry9SpU3Fzc+PAgQOo1WoGDBhQY73Ozs7Y2tpy9+5dSkpK0Gg0uLu78+yzz3Lq1CkOHTrE5cuXDRVQarWaxMREHB0d0ev1qNVqfHx88PHxYezYscTExHDu3DnWrl2Lo6MjPXv2pFevXob5XVxcSEtLIzQ0lOLiYm7cuEFGRgZZWVlAZYLJ2toaRVE4d+4cJ06cwNXVlcDAQAIDA6tdNC/oCpl58RZleqXWZBKA/vvpm1KzKQc+6O6Fh4cHCxYsYPXq1Xz99dcMGjSImzdvcu3aNUMSqXfv3gQEBNC+ffvHcsOfk5PDkSNHuHjxIo6OjkyZMoXAwMAmb/vevXusW7cOOzs7Fi9eXK+ha7GxsVy5coUZM2ZIMkmIlu53v4MPPjB1FMKcyDklhNHJkLemk4SSEM1Ir9ezdetWsrKyWLJkSZMSHC2RWq1m4sSJfPbZZ5w8eZIhQ4Y0eB337t1jw4YNWFlZ8cwzzxj60PTq1QtnZ2c2btzIp59+ysyZM+s1tGjfvn04ODgwcODABsfyoLZt26IoCvb29uj1elJSUqptX6/XExMTw+HDh8nNzcXd3Z309HSKioqYPHkyRUVF7Nu3j5ycHO7evYuLi4vhSXUqlYrCwkJOnz5N3759sbGxqTWGwMBAoqKiuHTpkuFJXmq1moEDB9KhQwdWr15NeXk5vr6+jB07lq1bt5KamsoXX3zBpEmTDMfSxsaG/v37069fP5KSkgwJoaNHj9KxY0fi4+Px8/MjLS2NoKAg7O3tDY2zU1NTOXv2LLdv3yYzs7KBeFlZGWq1mtzcXCIjIzlw4AC+vr4EBQXh5+fH83F3KNcrhn5QD6MAW1OzGe/syFgnewoKCvDy8uL69ets3ryZ1q1bExISQkBAAK6uro/tQl1YWMixY8c4ffo0Wq2WsWPHEhIS0uik6YOuXr3Kli1b6NChA7Nnz67z5/+gvLw8du/ebWgyLoRo4e7dM3UEwtzIOSWEaIEkoSREMzpw4ADXr19n9uzZtG/f3tThNAs3NzcGDBjAkSNH8Pf3x8nJqd7LxsTEsGPHDtzd3Zk5c2aNp4p5eHjw7LPPsnHjRlauXMm4ceMICQmpc303btzg5s2bzJw5s8HD5H6saj/UajWWlpYkJibi6emJoihcvXqVQ4cOkZ6ejo+PD9bW1iQlJRESEsKoUaNQFIUjR44AlQmzsLAw+vXrV+0R8FFRUSiK8tDEV69evYiKiiI6Orrao+EzMzPZsmULjo6ODB48mMOHD/PZZ5/h4eGBra0tpaWlfPLJJwwbNowhQ4YYkiAqlQoPDw88PDwICwsjNjaW7777Dr1ez7Vr17C1taWsrKxaDK6urob+Ufv27ePKlSv4+vqSkJBAbm6uocw5ISGB+Ph4Pjp6gtuBgxp0rNXAPy5c4dLZI5SUlNC2bVt69erFlStX0Gq1DBw4sFGN2RujtLSUkydPcuLECQCGDh3KwIEDjVYOffr0afbs2UP37t2ZMmVKvc5TRVHYsWMHlpaW9e7lJYQwseBgU0cgzI2cU0IYnVQoNZ0klIRoJufOnePkyZOEhYXRtWtXU4fTrEaMGMGVK1fYuXMnCxYseOSbqaIoHDx4kO+++47g4GAmTJhQ5x/WdnZ2LFq0iL1797Jz506Sk5MJDw+vUSlSUVHBvn378PHxwc/Pr8n7ZG9vj6WlJdnZ2bi5uZGUlER8fDyRkZEkJSXh5eVF9+7duXLlCu3bt+eZZ57B1dWV6Ohojh07hqIoDB48mPPnzxMfH0///v0N6y4uLiY6OpqQkJAaSbQHOTs7Y2dnR3p6Ojk5ObRu3ZrMzExWrVqFRqNh4cKF2Nvb4+/vz+HDh4mKikKlUjF9+nRu377NkSNHiIuLY9KkSXTo0KHaujUaDSEhIVy9ehWNRkNGRgbFxcW8//77+Pr60rt3b/z8/Kr9XKysrFCpVEyaNAmorNK6desWFy9e5O7du+Tl5XHJ1RuVXo/yQPLsUfTADUsbPPsPZHRAd5ydnVGpVPTv35+vvvqKr776ioULFzZrUqmiooKzZ89y9OhRiouL6du3L0OHDjXaNhVFITIykuPHj9O/f3/CwsLqfdNx7tw5bt68ydy5c+tVzSSEaAGee87UEQhzI+eUEKIFkoSSEM3g9u3b7Nq1iz59+lRLJJgra2trxo8fz5o1a4iJiSH4IZ+ilZaW8s0333DlyhVCQ0MZNGjQI/+wtrCwYPz48bi5ubF7927S0tKYMWNGtSGEp0+fJisri+nTpxvl0wGVSoWTkxNZWVm0bt2aK1eucPnyZdzc3Bg8eDAXLlwgJSWFsLAw+vbtS2xsLJs2bSI/P5+QkBCGDx+Ora0tXl5erFu3jjNnztC3b18ATp06RXl5OYMGPbySR6VSERwczPHjxzl//jxBQUGGZNKiRYsMfXQ0Gg1hYWFYWlry3XffsWrVKnr37m1IxH3++ecMHDiQESNGVOsDVVBQwK1btxgwYACpqaksWrSI3Nxczp07x5YtW7CxsSE4OJjevXvj7OyMpaUl5eXlhuXVajVdunShS5cuQGWCaduxGJT6jHWrhUNAMC4urQ3fu7q6smjRIr766itWrVrFwoULH5qAawxFUbh06RKHDh0iNzeX4OBgRowYUa+eRvVVUVHBjh07iImJYcyYMQ0ajpmdnc3+/fvp1auX4TgLIX4Cnn/erJ/IJUxAzikhjE4qlJpOEkpCGFlGRgYbN27E19eX8PDwJ+aNpXPnzgQGBrJv3z46d+5c6x/+Op2OdevWkZmZyaxZsxpcSdS7d29cXFzYsGEDn332GTNnzsTDw4PCwkKOHDlC7969jTq00NbWlitXrlBQUADAyJEjiY+P5/jx4/j7+xMWFkZGRgaff/45KSkpdO/enVGjRtG2bVvDOrp27Urfvn3Zv38/3t7eODo6curUKUJCQurVUyswMJDjx49z5swZzp8/XyOZ9KCqnkljxozh8OHDXLt2jdDQUHQ6HUePHuXatWs8/fTTeHl5ARAXF4dKpUJRFGxsbPDy8kKtVhMcHExGRgbnzp3j4sWLREVF4enpiYODQ7WE0o+p1Wr0lpZQWvc8D5OSlQUPJJSq9unHSSVjNKRWFIWbN28SGRlJamoq3bp1Y86cOYZjaCwlJSVs3LiRO3fuMG3aNHr06NGgGLdv346NjQ1hYWFGjUsIIYQQ4kknCaWmq/+YBCHEIxUWFrJ27VocHByYPn16tZ45T4KqP3r3799f47WkpCQ+++wzCgsLWbp0aaOHpVX1VWrdujUrV67k3LlzHDp0CEVRGDlyZJPir5Kbm8v27duJj4+nsLDQsN4jR46Qm5vLvHnzGDZsGDt27ODrr7/G0tKSpUuXMnPmzGrJpCqjR4+mTZs2bN26lVOnTlFaWsrgwYPrFYuLiwu2trYUFhZiYWFRZzIJKiuVAAICAnjhhRfw9vZm+/bt3Llzh1mzZmFjY8OKFSvYvXs3paWlXLp0iU6dOpGQkEDnzp2rna/t2rVjzJgxvPTSS0yfPh0rKysuX75McXExu3btIjk5GcDQsPzs2bNs374dfZ6uQcf6QTFRJykpKakx3dnZmUWLFlFcXMyqVavIy8tr9Dagsq/VypUrWbt2LVqtlqVLlzJ79myjJ5Py8vJYuXIlSUlJzJ8/v0HJJKisZLtz5w6TJk0y/GyFED8RMjxJGJucU0KIFkgqlIQwkvLycjZs2EBpaSkLFy5Eq9WaOqTHztbWljFjxrB9+3aCgoLo1KkTUPm48+3bt9O+fXtmzZrV5AoTe3t7Fi1axJ49e/j2228BCA0NbfJwqIKCAr777jtOnz6NRqPB39+fuLg4zp8/D4C7uzuTJk3iu+++48KFCzg5OTFz5kz8/Pwe+omElZUVU6dO5fPPP+fYsWP07NkTBweHesWUmZlJaWkpAJ6eng89dlXnXElJCc7OzsyYMYMbN26we/duNmzYwJAhQ+jevTuHDx/m6tWr5OXlMXbsWPbu3Vvn8DtLS0sCAgIICAjg2LFjHDx4kEuXLnHmzBmsra0pLy9Hr9ejUqlwcHCgY3vIdPFEUTUsmWqtgrZp99m1axdTpkypcTzbtWvH4sWLWbVqlaFSqb7HsEpaWhoHDx7k2rVruLq6VnvqnrGlp6ezZs0a9Ho9S5YswdXVtUHLZ2RkEBkZSf/+/fH19TV6fEKIZlZYaOoIhLmRc0oIo5MKpaZ7ssonhGgmiqLw7bffkpSUxKxZs2jdurWpQzKZ4OBgfHx82LlzJ6WlpRw+fJgtW7bQvXv3h1bXNFRVX6WqiqBr166Rn5/fqHWVlJRw+PBh/u///o9z584xdOhQlixZYhjqZmdnh7e3Nzqdjo8//pjr168THh7O888/T/fu3et18Wjfvj2dO3emvLwcT0/PesWVkZHBqlWrDImyq1evPnTIWVUVy4NVPl26dOH5559nwIABHDt2jHPnzjFx4kRDs+3Y2FgAQ/LvQcXFxdy6dYujR4+ybt06jh8/bli/ra0t1tbWhmQSVFZ2jagobHAySaXXM4RSpoSN4dKlS1y4cKHW+ZycnFi8eDHl5eWsXLmS3Nzceq0/JyeHb775ho8++oi0tDSmTp3Kc889R5cuXZrlwn/37l2+/PJLNBoNy5Yta3AySa/X88033+Do6MioUaOMHp8Q4jH4+mtTRyDMjZxTQogWSCqUhDCCY8eOERMTw7Rp0+qdLDBXKpWKCRMm8OGHH/Lpp5+SmZnJU089xZAhQ4z+x/u1a9fIzMxk9OjRnDx5kk8//ZRZs2bh7u5er+XLy8s5c+YMx44do6SkhL59+zJ48GAuXbrEZ599Zki6uLi4cOnSJcrKyhgyZAhDhgxp8BCksrIyEhMTsbe358CBA3X2mapSlUyysbFhwYIFfP755+h0Oq5du0ZAQECty1RVKBUXF1ebbmVlRWhoKEFBQezcuZOtW7ei1WpxdXXl/v37qNVqEhISaN26NUlJSYavjIwMoDJR5e7ujq+vL1evXmXOnDncuXOHS5cuAWBjY4Ner6e4uBhtbjYDPCqI1ltQ397cKpUK5zPHOaqxpFOnTuzevRt3d/dah6C1adPGUKm0cuVKFi1aVGcCt6CggGPHjnHmzBm0Wi3h4eGEhITUeEKgMV25coUtW7bg4eHB7NmzG1Wp+N1333H//n2WLl1arYm6EEIIIYQwHqlQajpJKAnRRLGxsRw6dIgRI0Y0uEeKubK2tsbW1taQ7HnU08wao7y8nP3799OpUycGDhxIYGAgGzduZMWKFYwfP55evXrVuaxer+fixYscPnyYvLw8evbsyfDhw8nLy2P16tWkpqbSp08f3N3d2b59O+fOnaNz587cvHmTwMDARvWzOX/+PIWFhSxZsoT169fz7bffMmvWrFovPA8mk6qaUPfo0YOoqCguXrxYZ0KptgqlB7m4uLBkyRIOHz7M0aNHKSsrQ1EU1Go1mzZtAiovhG5ubvj6+jJkyBDc3d1p27YtBQUFHDp0CIB169ZhY2NDYGAgwcHBuLm5AZVPNzx37hw9ju/nWtBgclrZPbxaSVEA+F/31kwKnM+ePXu4desW1tbWbNiwgZ/97Ge1JlRat27NokWLqiWV2rRpY3i9pKSEqKgoTpw4AcCwYcMYMGAA1tbWdcdiBNHR0ezZs4eAgAAmT55sSEg2REpKCkeOHGHw4MF4eHg0Q5RCiMdi5UpTRyDMjZxTQhidJJSaToa8CdEEiYmJfPPNNwQFBTFs2DBTh9MiJCcn89lnnwGV1SSXL19Gr2/kc+QfIioqipycHMLCwlCpVIa+SkFBQezYsYPdu3dTUVFRbRlFUYiLi+Ojjz5ix44deHh48PzzzzN69GiOHj3KF198gVqtZsKECaSkpLB9+3asra3x9/dnxowZqFQqEhMTGxxreXk5x48fJzAwEE9PT55++mmuXbvG2bNna8z7YDLpwSGCAQEB6PV6bty4UefQvqqE0o8rlAoLC7l58yaHDx9m7dq1hkRLRUUFiqJgZWVF165d0Wg02NjYMGDAAMLDwwkICCA1NZV169bxzjvvGHpJTZgwgd/85jeEh4fToUMHw8W4U6dOjB8/Hld7O2ZfPY1vXjYAaqX6z19FZSLJzkLN7OSb6HZtw9ramgULFjBjxgysrKzIysriyy+/pKysrNZ9bd26NYsXL0atVrNq1SqysrKoqKjg1KlT/N///R/Hjh2jd+/evPjiiwwbNqxZk0mKohAREcGePXsYOHAg06ZNa1Qyqby8nG+++QZnZ2eGDx/eDJEKIR6bv/7V1BEIcyPnlBCiBZIKJSEaKScnh/Xr1+Pu7s7EiROfyIz0j8XFxbFt2zZcXFyYPXs2ubm5fPHFF0RHRzNgwACjbSc/P59jx47Rt29fnJ2dDdMtLS2ZOHEiHTp0YM+ePaSmpjJjxgzs7Oy4ffs2kZGR3L9/n06dOjFlyhTc3NyIiYlh//79VFRUMHToUNLS0ti5cydubm4sWLCA06dPU1xcjLW1NS4uLiQmJtK7d+8GxXvx4kV0Oh1Dhw4FoFu3boSEhLBv3z68vb0N+5Cenm7ombRw4cJqQ+Lc3NxwcHAgLy+P2NjYWo+nSqXC2tqa1NRUTp06ZRi6lpWVBVQOTXN3d8fS0hIvLy/atm1LbGwsWq2Wmzdv0q9fP3Jycti6dSuRkZEUFRVRWlqKh4cH4eHhtG7dmrVr1+Lt7V3rsLGSkhLWrFlDSUkJLyxZwmtOTkTeuM0ntxI5o9ZQYmmFFeBjbYFH3AWWdO/EgEnhfP7556xdu5alS5fi7+9Ply5d2LRpEzdu3OA///kPEyZMqLVXlaOjo2H42+eff46lpSX5+fkEBwczYsQIHB0dG/RzaoyKigq2b9/OpUuXCAsLa9J5fuTIEdLT01m+fHmjElJCiBbk5k1TRyDMjZxTQhidVCg1ndyxCtEIxcXFrF27Fmtra2bNmvXE//GnKArHjh3j0KFDBAQEMGnSJKysrLC3t6dv374cPHgQPz8/ozUrj4yMxMLCghEjRtR4TaVS0adPH1xcXNi4cSMff/wxjo6O3L9/H3d3dxYuXIivr68heXPnzh38/PzQaDR89913ODg4MGXKFAIDA1GpVNy6dYu4uDig8ilvDa1Qqqio4LvvviMgIIB27doZpoeFhXHnzh22bt3KM888Q3Z2dp3JpKr9CggIIDo6mgsXLjBgwAAURSEzM7Na36PS0lJOnz6NhYUFbm5udOnSBXd3d9zd3WnTpg1JSUl88cUXDBkyhD179tCtWzfGjx/P/v37OXXqlOFCqNPpUKvVjBw5kqFDh6JSqbh//z5ArVVD5eXlrF+/nszMTBYtWmRolh7atROjunTkrbfewtfXl5ycHNLS0rCysuLMiRRCAnswd+5cvvzySzZt2sScOXOwsrJizpw5rFu3jlu3brFp0yZ8fX0JDw+vlkBUFIWUlBTUajVFRUVYWloye/Zsunbt2qCfUWMVFxezceNG7t69y/Tp0+scilgfiYmJHD9+nBEjRtC+fXsjRimEMIlu3UwdgTA3ck4JIVqgJ/uvYCEaQa/Xs3nzZnQ6HcuWLaNVq1amDsmkysvL2bFjB5cuXWL48OEMHz68WnZ+1KhRXL16ld27dzNnzpwmZ+7v37/PhQsXCA8Px8bGps75bGxscHNz4+bNmxQUFNCvXz/Gjh1LeXk5kZGRnDhxAkdHR4KCgrh69SpqtZrQ0FD69etXLUHo5OREbm4uFRUVuLu7c+7cOUpKSurdRykmJoacnBxmz55dbbqVlRVTp07l888/Z9euXdy4caPOZFKVjh07cvLkSVJTU/niiy/IyMgwDG9r27YtHh4e6HQ6vLy8mDp1aq1VRJcuXcLOzg5HR0fS09Px8vLiq6++4t69e1hZWaHRaMjPz8fPzw+1Ws2hQ4e4c+cOEyZMMByXHz9pTq/Xs2XLFhITE5k/f76hp1KV4uJiysrKCAoKwt/fn6SkJL777juuXbvG+++/T+fOnRk4cCBHjhxh165dhoq/adOm8cknn6BSqcjJyeHjjz+mX79+DB8+nPT0dA4cOMDdu3fx9vYmNDSUyMhIvv32WxYtWlQtedccdDoda9euJTc3l/nz5+Pj49PodZWVlfHNN9/QoUMHhgwZYrwghRCm84c/GG1VLfETb+X7HnhN1RL3rcUy4jnVEhnrnDKmlhiTMZn7/tWHVCg1nSSUhGgARVHYs2cP8fHxzJs3r9n/aG3p8vPzWb9+PampqUybNq3WpuQajYZx48axYcMG4uLimlTFoSgKe/fuxdnZmT59+tQ6T05ODkeOHOHixYs4ODjw/9m7z7A20zP/+18J0bswzWDTTTHNBtx77723cZmW3WT3v8mmPenZTTZlN5mUSWaSscdlxn1s7MHd4F4pBlMNmGq6AdGbpPt54aCYoRgwGIyvz3FwjAdJt06EENw/ndd5LV26lLy8PO7fv09lZSWlpaXU1NTg6elJYWEhycnJhIWFMW3atA4DKhsbGyRJorKyUjckubCwEDc3txfWq9VquXnzJj4+Ph1uHe/o6MiECRO4ffs2VlZWbcKklpYWioqK2nQfqVQq3W3r6uqYOHGirvuodTexPXv2oK+v32GYpNVqSUpKYsSIEboh3LGxsXh6erJ69Wq8vb1RKBRtlgGGhYXx6NEj/vrXvzJx4kSgbaAkSRJffvkl6enprF+/HhcXl3b3W1VVBTxboiaTyXQ7oP3tb39DrVZTV1fH1atXMTQ05MGDBxgaGjJ//nwMDQ1Zs2YNu3fvJjQ0FHNzc65du0Z0dDQajQY7Ozs2bdqEp6en7rj79+9n7969bNu2rcNd4vpCWVkZn332GQA7dux46fu5fPkyVVVVbNiwAblcjDYUhCFh5044fXqgqxCGEvGcEoQ+JwKllycCJUHogfv37xMTE8OSJUtwd3cf6HIGVHFxMYcOHUKr1bJ9+3acnJw6va6Pjw++vr6cO3cOd3f3LjuLupKcnEx+fj5bt25td+L9/BbxrYFESEgICoUCd3d3iouLycjIQF9fHwsLC9LT0/H392fWrFltdgj7KqVSCUBFRQWenp4YGBjw5MmTbgVKSUlJVFRUsGbNmg4vLy0tJT4+Hn19fZqamkhKSqKsrIyCggJKSkqQJAmFQsHw4cPx8fHB2dmZzMxMkpOTaW5uZsqUKe0eByMjo3ZDuVuXhl2/fp36+noePXqEgYEB1tbW7NixA3Nz8zbXDwoKwsvLi0uXLhEdHc3w4cMZMWIE169fB6C8vBw3NzckSeLixYvEx8ezcuXKTpeatQZhX13yOH78eMLDw/n6179OS0sLcXFxxMXFcffuXR4/fsy0adPw8fFh7ty5XLhwAVdXV9RqNfr6+mg0GgwMDDAzM9P98jY1NeWtt95i//797Nu3j23btnUY5L2M3NxcDh8+jIWFBZs3b8bCwuKljpednc39+/eZP3/+Gx9QC4IgCIIgCK8XESgJQjelp6dz4cIFJk6cSEhIyECXM6DS0tI4ceIENjY2bNy4sVsn1QsXLuTDDz/k0qVLLFu2rMf32dLSwqVLl/D29m4T5jU1NXH79m3u3r2LTCZrs0W8RqPh9u3bXL16FYVCgZWVFSqVipqaGlasWEFQUNAL79fc3ByFQkFFRQVyuRwnJycKCgpeeLvWuVJeXl7tloDV1NSQkpJCZGQkMpkMSZJoaGjg/PnzDBs2DGdnZ0JCQnB2dsbW1rZNt5G5uTnx8fG0tLSQlZWFp6dnm2O3LlmDZ8uyEhMTSUhIoKysDIVCgZGREZs2bWL//v2EhIS0C5NamZiYsHz5coKDg4mIiCAlJQUfHx/S0tI4d+4cjY2NaDQa7t69y8KFCwkMDOz0saiqqkJPT6/dUr7Ro0dz4cIFYmJimD9/PosWLWLOnDl89tln5Ofn88UXX2BsbKx7fuXk5DBjxgymTJlCfn4+586d429/+xtjx45l9uzZmJiYYGJiwrZt2zhw4IAuVOqrmUTJycmcPHmSkSNHsm7dOl1XWG81NTVx6tQpXFxcGD9+fJ/UKAjCILF9+0BXIAw14jklCP3iTewq6ksiUBKEbigpKeGLL75g1KhRzJkzZ6DLGTCSJHHr1i0iIyPx9fVlxYoV3d6O3dzcnDlz5nDmzBkCAwN7PHPm9u3b1NbWMnfuXODZsqvo6Ghu3LhBS0sLYWFhTJkyRTfTKi8vjzNnzlBaWopSqaSiogIzMzOWL1/O/fv3+fLLLwFeGCrJZDKUSiXl5eXAs8Hc8fHxSJLU5S+glJQUnj59yqJFi8jJyWmzdK26uhoAuVyOu7s7Li4uaDQarl69yoQJE7oMLEeMGIG5uTlqtZqEhIR2gZJCoaCyspIDBw6QlZWFQqHAx8eHWbNmcfLkScaNG0dTUxNqtbpbw6tdXFx4//33uX37tq5Dyd7ensjISABCQ0MZN25cl8dQqVS65W5frXXMmDHExcUxa9Ys9PX1MTAw0HUZFRQU0NTURElJCQB6eno8fPiQCRMm4OrqynvvvUd0dDRXrlwhJSWFWbNmERISoguVPvvsM/bv38/WrVvbhXo9dffuXS5cuEBAQADLly/vcElhT124cIGGhgbeeust8ceMIAw1+voDXYEw1IjnlCAIg5AIlAThBWpqajh48CBKpZJVq1a9sTNO1Go1ERERJCQkMHXqVGbOnNnjk+CQkBAePnxIREQE77//frd3x6uurubWrVtMmDABa2tr4uLiuHbtGjU1NYwZM4bp06fruljq6+u5fPkyDx48wNTUFLlcTnNzM0uXLiU4OBi5XI6/vz9nzpwhPDycoqIi5s6d22VAoFQqqaysBMDZ2ZmbN29SVVXVbgmXVqulrKyM/Px8IiMj0dfX58CBA0iShL6+Pk5OTri5uZGWloaFhQXbt29vM9S9urqaCxcu4OLi0unyJ5lMhq+vLwkJCaSmptLY2IihoSE5OTkkJCSQmJiIVqvFysqKpUuX4ufnh5GREampqTQ3NxMQEEB0dDSWlpbdXmKlp6fH1KlT8fX15cMPP6SoqAh4trwuLi4OY2Njpk2b1un3s6PHqlVoaCi3b98mMTGRsWPHolariY2NpaysDI1Gg6GhIdu3b6e8vJzbt29TWFjIb3/7W8aMGcPYsWMZP348/v7+REZGcvbsWeLi4li4cCEjR45k69atbUKl4cOHt7t/SZJoliQMO/m5liSJS5cucefOHSZNmsScOXP6JPxJT0/nwYMHLFmypMsll4IgvKb+/ndYunSgqxCGEvGcEoQ+J2YovTwRKAlCF1paWjh8+DCSJLFx48Zud+MMNXV1dRw5coTCwkJWrVpFQEBAr44jk8lYsmQJH3/8MTdu3GDmzJndut3ly5fR19fHzs6Ov/zlL5SXlzN69Ghmzpyp255ekiTi4+O5ePEiLS0tKBQKWlpamDZtGhMnTmzzvVMoFCxbtgxHR0fOnz9PSUkJa9as6XR3NaVSSUpKCoBuVtSTJ0+QyWQUFBTw5MkTCgsLKSwspKWlRXe7UaNG4e3tjZOTE7a2tjx9+pR9+/bpBnB/dYfA+fPnk5uby4kTJ9i1a1enIZefnx/3798H4IsvvqC0tJTq6mqUSiUuLi4UFhay/Sut8UlJSTg4OGBjY0NGRgZeXl49/qU3bNgw3RI9hUKBVqvFzc2NmzdvkpaWxrJly3SDy59XVVXV6Swja2trvLy8iI6ORk9Pj6tXr1JVVUVQUBBjxozh6NGjRERE8NZbbzF69GguXrzInTt3SEpKIiYmBkdHR8aOHaubmXX27Fk+/fRTAgMDmTNnDlu2bOHzzz9n//79bNmyBWdnZ+o1WsJLKtlT8JSU2ga0gIFMxnSlOTudhjFdaY5cJkOtVnPq1CmSkpJYsGBBny1Lq6+v58svv8TT05OxY8f2yTEFQRAEQRCEnhGB0ssTgZIgdEKSJE6ePElZWRk7dux46eG7r6vS0lIOHTpES0sL27dv7zAw6Ak7OzumTJnCzZs3GT169At3yMrLyyMxMRFLS0vCw8N1O5I9v4SptLSUiIgI8vPz0dfXR6vVEhISwvTp0zEzM+vwuDKZjHHjxmFnZ8exY8f4+9//zvr16ztcGqVUKlGpVGRmZlJUVIS+vj6nT5/WhUeWlpY4OTkxY8YMhg8fzoULFzAyMmLjxo1taty3bx8WFhZs3bq1XZgEYGBgwOrVq/nkk0+IiorSLe97Xn19PcXFxcjlcrRaLY8fPyYkJISgoCCcnJyIiYkhNze3zZK8pqYm0tPTmTFjBhUVFVRWVuLl5dXl496RvLw8JEnC1taWt956i6tXrxITE8OwYcOQJIk9e/Ywfvx43fK1ViqVqtPldZIkMXz4cK5du0Z4eDg+Pj5s2rQJW1tbADZt2sTevXs5efIka9euZc6cORQXF1NWVsaKFStISUnh7NmzXLx4kdGjR7NgwQJKS0uJiooiLS2N6dOns3HjRo4cOcKBAwdwW7mOH5XWUaPRIge0/6ijWZKIKq/mUnk1niaG7PF24s6pk+Tn57N27Vr8/Px6/Hh15ty5c6jVapYtW/ZG/uEhCG+Ejz4a6AqEoUY8pwRBGIREoCQInYiKiiI1NbXTkOFNkJ6ezhdffIG1tTXbt2/H0tKyT447depUkpOTiYiIYMeOHZ2eVOfn5/P5558Dz2YwrVixos3spebmZq5du8adO3d0SxE9PDyYPXt2t5dzubq68u6773LkyBH27NnD0qVLGT16NKWlpTx58oSCggJycnIA+PzzzzE0NMTAwAC5XM7q1asZPnx4m8HWGRkZFBcXs23bNt3nSkpK2L9/f5dhUitHR0dmzZrF5cuX8fT0xM3NDbVaTUZGBgkJCWRkZABgYWFBfX09zc3NTJo0SbdsytDQEK1Wq9sNDZ4NUVer1fj7+5OSkoKenl6PZ1iVlJRw6NAh5HI5fn5+mJqasnjxYoKCgoiIiKC0tBRnZ2eio6N59OgRy5Ytw9XVlZaWFurr6ztc8paXl0dkZCR5eXkoFApcXFxYv359m+sMHz6c1atXc+TIES5dusS8efNYtWoVH330EYmJiWzevJmamhoePHjAgwcPiI+Px87OjgkTJqBSqbh8+TJxcXHMmTOH3Qmp/LGwGv7xfNN+pR7NP/6bXd/E/OhHbKis4mvbtjFy5MgePVZdSU5OJikpiVWrVnU6EF0QhCHgz3+GX/5yoKsQhhLxnBKEPic6lF6eCJQEoQMPHjzg5s2bzJ07Fx8fn4Eu55WTJIm7d+9y8eJFvL29WbVqVZ8u91MoFCxZsoR9+/YRExOLbJQvBwqf8qiukSathCVaRhTnY/EwBgONmlmzZjFlypQ2L9JpaWmcOXOGuro6JEnC3t6eefPm4eLi0uOvVavVMm7cOG7dusXJkycJDw9HkiTkcjn29va4uLjw8OFDFi1aRGhoKPfu3SMyMhJPT882y9IkSeLatWuMGDFCF9j0JExqNWnSJDIzMzl+/DijRo0iLS2NxsZGhg8fzrx58/D396e0tJT9+/ejUChISEhgxowZwLNACZ51JbUGSklJSbi4uGBpaUlmZiaurq49+n5WVFRw4MABrKysqK+vR5Ik3WXOzs68++673L17l6tXr2JkZISenh779u0jJCREt6Tr+TCytLSUyMhI0tPTsbe3Z/PmzZSUlHDlyhXq6uraLT309vZmwYIFnDt3DisrK8aNG8fKlSv57LPPuHXrFlOmTGH69OlMnTqVrKws4uLiuHr1KjKZDA8PD2pqavgk/DSHx81B4sU0QKOeHtfHzeKXI0Z0+3F6kdraWs6cOYOvry/+/v59dlxBEAahpKSBrkAYasRzShCEQUgESoLwFTk5OURERDB27FgmTpw40OW8chqNhjNnzvDgwQMmT57M7Nmz+yVtd3V1xTJkPNtLGyivzUBPBprWs31J4q6ZHYoJC5jVqOKHz4VJKpWK06dPk52dDTwLKubOnYufn1+36mxoaGiz41pBQQH19fXAs3k+Dg4OFBcX4+joyPr167G0tESSJFJSUtBoNMhkMpydnVGr1ZSUlLQZ9JyVlUVBQQGbN29GJpNRUlLCvn37sLS0ZNu2bRgbG7+wPpVKxcOHD1GpVNTX15OUlMS4ceMIDg7WLQODZ7uvmZiYYGZmxsOHD5k+fToymUy3lX1jYyNmZmbU1dXx+PFjFi1aRHNzMzk5OcybN69b3yN4NpT+wIEDGBkZsWXLFj799FPUanWb68jlciZNmoSfnx/nzp0jPT0dW1tb3eBwACsrK1QqFVevXiUhIQFra2tWrVqFv78/MpmM4cOHc/XqVR48eMCUKVPa1TFu3DgqKys5f/48VlZWjBo1ismTJxMVFYWLiwsjRoxALpfj6emJp6cndXV1xMfHExcXR0VFBRlegWiQ6bqTXkSSyXncpOaWqpYp1i/fSSRJEhEREcjlchYvXvxGvoMlCG+UHr65IQgvJJ5TgtDnRIfSyxOBkiA8p7y8nCNHjuDi4sKiRYveuBeF+vp6jh49Sn5+PsuXLyc4OLjf7ut6RQ2/M3OkRfts4ZHm+daRfzzuaj09Lpra8F5yDn/xGcHtmze5fv06kiRhYGDArFmzCA0N7XR4dWvo0zo0+8mTJ1RUVADPdihzcnIiNDQUJycnnJycdJ0xOTk5HDt2jE8//ZQNGzbg4OCAUqmkvLwcAEtbOx45uPCTx0VY1WiwUOgxU2lO+vXrDB8+HA8PD12YZGVlxdatW7sMk5qamkhJSSEhIYHc3Fz09fXx8/MjMDCQ69evY2Nj0yZMgmchjq+vL48ePaK2tpb8/HxGjhzZpkMJni2xkslk+Pn5kZWVhVar7fb8pIaGBj777DO0Wi3bt2/H1NRUN+y8I1ZWVmzYsIG0tDTOnTv3j2/ls+/lZ599RmVlJcbGxixatIixY8e2+b6ZmJjg7+9PTEwMkyZN6nA3xblz56JSqTh+/Djbt29n5syZ5Obm8sUXX/Dee++1eYxNTU2ZPHkykyZNIiMnh31ZFUg9/HnWk8HuJ0/7JFBKSEjg0aNHrF+/vtPh74IgDCFiaZLQ18RzShD6nAiUXp4IlAThHxoaGjh48CBmZmasW7euy23kh6KysjIOHTpEU1MTb731Vp/Ojfmq7Pom3krMokWSunWSH1FWRWliAiHpCchkMiZOnMi0adN03TjwrAOkoqKiza5rxcXFaDQa9PT0cHBwwNPTUxceKZXKTl/0XV1deeeddzhy5Ai7d+9m2bJlKJVKClVV/CSjgM+KyqnzCkKvBWRFz0KmD/NKsbTz4r3h1hQXF+uWiHUWJmm1WrKyskhISNDNOHJ3d2fFihX4+vrqlqTV1NRw/vx5XFxcdDvatfLz8yM2NhYzMzMSEhIYOXJkmw4leLbczcPDAxMTEzIyMrCxsUGpVL7wMW9ububgwYPU1NSwY8cO3ZI1hULRrkPpeTKZDF9fX9zd3bl8+TIxMTHAs7DWwMCAefPmERgY2OFtw8LCiI+PJyMjA29v73aXy+VyVq1axb59+zh06BC7du1i9erVfPzxx5w+fZp169a1+57KZDIah9lTn1P1wq/5qzQSXK+s6fHtvqqqqorz588TFBT0Ri6hFYQ30ubNcPr0QFchDCXiOSUIwiAkAiVB4NkyryNHjtDQ0MDbb7/dJqh4E7TO62md89M64Lm/fJxXQpNWi0T3U/wYuxGskDWxeuECLC0tqaurIz09vc3StdYQRalU4uzsTGBgIE5OTtjb26NQ9OzlzsrKip07dxIREcGJEyewGDGSTxxHoXpS9mx4s0z27L/PdVZVGZvyG1ULFx5Fs6qTMKmkpISEhAQSExOpra3F1taW6dOnExgY2OFOggsWLCA3N5cTJ06wc+fONkGnq6srxsbGWFlZkZyczIIFC9p0KKlUKvLz81m5ciWSJJGZmYmvr+8Lv3a1Ws3Ro0cpLS3lrbfeatMdpaenR0tLC01NTWg0GrRaLRqNps2/m5ubSUlJITExkWcPlQxJklAoFJw8eZJ79+7h7++v25Hv+dubmZlx/vx5cnNz2x1frVbT0tKCnp4eDQ0NfPjhh1hZWaFQKEhLS+PXv/41enp6aLVa3YckSeRbKCFgUre/98+r12jb7JjXU5Ikcfr0aQwNDVmwYEGvjiEIgiAIgiD0Pblc3mFX/Msc700jAiXhjdc62+TJkyds27atW90bQ4UkSdy/f58LFy7g6enJ6tWrdYFEf9BqtdyOe8BnKtD2sANMkuuR6eTG5cuXefLkCSqVCni2VMrJyYkJEybouo+6M6uoO/T19VmxYgU2Do78y9NGKgyMux7q/I/QIcF+JLNCxujqqK2tJTExkfj4eEpLSzE2NsbX1xdfX19sbW3RarU0NzdTWlraLpzRarWEhoZy6dIljh07hp+fX5vLlUolT58+pampiZMnT+qevzExMTQ3NyOTycjMzCQxMZHq6moKCws5ePBgp2GQRqOhpqaGlpYWjIyMOHDgQJvLWyX1YDho6xDv1llVhYWFFBYW6i6Xy+W6wKZ1SPr9+/d1/9/60ZGnT5/q/t3U1ISenh4KhQJ9fX3dvxvMer9kzVD+cq3QMTExZGVlsWXLljcuqBaEN9rGjQNdgTDUiOeUIAiDkAiUhDferVu3iI+PZ+XKlf26zGuw0Wg0nDt3jtjYWCZMmMDcuXP7LVVvHWodFRVFrMwA9ejxvTrGmYpa3Csr8fT0xN7eHnt7e8zMzNqELxUVFe0CmY5Ck55cflPPmKdmdj2q9w95ZdSFH0HRUN8uDGloaCAuLo64uLgeHfPRo0c8evRI9/96enrIZDLUajUymYz09HTdVvSlpaU0NTVhZGSESqWipqYGmUyGgYEBenp6usDlq2FOfn4+LS0tuLi4YG5ujiRJusdBq9VSWFiIJEnY2NjouoY0Gg0NDQ00NjZ2Gvx0RqFQYGlpibGxMQYGBigUCh4/fsywYcPw8PDAwMAAAwMDDA0Ndf9u/SgrK+PUqVP4+/uzePFi9u7dS3NzM++++26bYLRareHAzSSae1ibHAg0f/GufJ2pqKjg0qVLhIaG4uHh0evjCILwGvrKEmVBeGniOSUIfU7MUHp5IlAS3mgpKSlERkYybdq0Tue6DEUNDQ0cO3aM3Nxcli5dqtvava9JksTjx4+JjIykuLgYLy8vwsZM4Hxxdc8PJpPRoG+oW972suRyOXp6erpQ5fn/fvXfkcN9kHVz3lMrrUzGQ6UjM2uf6jqnjIyMunV/HV0OcPToUVQqFW+99RZ6eno0NzfT2NjI559/jlKppKSkhJCQEG7evImFhQVFRUWMHDkSExMTnj59ipGREQ0NDVRVVdHc3ExTUxPNzc0dhkC5ubltHqvWUKe1S0lfXx9TU1NaWlooLS2loaEBS0tLvL29sbW1xdDQEIVCwdGjR5kyZQqBgYG6Y+Tm5nL+/Hmqq6uRy+VUV1czYcIEQkJCkMlkXLp0ibi4OGbMmIG+vn6nj/Hw4cORyWScPHkSGxsb1qxZw9/+9jfOnj3LihUrdL/ULRR6rHGw5mhxBeoeZEpaYKfTsO7f4PnbarWEh4djZmbG3Llze3UMQRBeY3/+M/RgR01BeCHxnBKEPicCpZcnAiXhjVVQUMDJkyfx9/dnxowZA13OK1NeXs7BgwdpaGhg69atuLq69sv95OfnExkZSW5uLiNGjGD79u24uLhwuKgcehMoAXJJi1wuR/uPneG6oqen166jxdDQsM3HV7tfOvpcvkaiMCGn58XKoMgniPdCPHXBTUcfXV321es1NTUhSRJ//vOf291dcXExAJGRkchkMkpKSpDJZDQ0NNDS0kJDQwPDhw/HwcGhw8fl8ePHPHz4kHHjxhESEtLmsufnNoWHh1NRUcH8+fOJiooiKysLBwcHli9fjoeHR5tfpK3LEl1cXNrMYfL29sbd3Z1r165x584d9PX1OXPmDElJSSxbtozQ0FBu375NUlISY8aM6fJhDgwMRKVSceXKFaytrVm8eDEnT57Ezc2tzS6FO52GcbCootvfPjlgra9gka1lt2/zvDt37pCfn8+OHTt0A9YFQRAEQRAEYSgRgZLwRqqqquLw4cO6E+E3JU3Oysri2LFjmJmZ8fbbb/fLvKjS0lKioqJ49OgR9vb2bNy4ES8vL91j7G7cuxlNcknCXtPS5ntlamqKjY0N1tbWmJubY25ujpGRkW4wdGtY83xo09TURHV1dbvPdxZS5VvZQmBvBjrLKGho5Ne//nWX1/pqsNP6bxMTE6ysrDpc5hUTE8PEiRN1u8EVFhZy+vRpXF1daWhoQF9fn9LSUkaPHs2yZctITk4mPz+fdevW6XZre15cXBwPHz5k6tSpzJo1q8t6NRoNT58+5aOPPsLa2ppVq1bh7+/f4c9Qa6BkZWXV7jJ9fX3mzJlDQECAboZZUVERf/nLX5g1axaenp5ER0cTHBz8wp/PqVOnUllZyalTp9i6dSvBwcGcPXsWJycnXZClKMhjQm4ad11evMuaHJDL4BN/Vwx6sQy0tLSUK1euMHHixDdqGa3wZuir35c9XR77unH98ktyh/BjNRifB4Pxb7k+/d7l5PTdsQRBAAZHh9KHH37Ib3/7W4qLiwkKCuJPf/oT48aN6/T6KpWKH/zgB5w4cYKKigpcXFz44IMPWLRo0cuU3msiUBLeOE1NTRw8eBCFQsH69et7vPvX6yomJoazZ8/i7u7OmjVr+nxAcGVlJVevXuXhw4cdBg3Nzc0kJibyIDYWC2c/qo1MdUOsu0Mrk/GjyaHMWjKD8vJySktLKSkpobS0lLy8PCorK4FnL+RKpRJ7e3vs7Ox0u7xZW1t3+iLfOieoowDqVnUDEVWaDm/3IjK5nPnz52NjY9PhDCB9ff1e/eJRq9XExMQQGhqKUqlk2LBhXLhwATMzM3JycrCzs6O5uZmAgAAAMjIysLOz6zBMSk1NJSIigpCQEGbOnNnpfdbV1XHjxg2Sk5MBWLRoEWPHjm3TvfRVVVVVAB3ebyt7e3t27txJXFwcly9fRqvVcunSJZRKJRUVFRQUFODs7Nzl4yGTyViyZAnV1dUcOXKErVu38uTJE44fP87bb79NXFwc58+fZ5OfHzNc7flVTgl6MtC0+ztfQo4MI7mcfQFuTLQy6/J+O6LRaHTD0V8UzgmCMHRtA/5roIsQhpb9++HHPx7oKgRB6ENHjhzhm9/8Jh999BHjx4/ngw8+YP78+Tx69Ag7u/bzW5ubm5k7dy52dnYcP34cJycncnNzO3zz9lV5M86kBeEftFotX3zxBVVVVezcuRMzs56fML5utFotFy5c4P79+4wbN4758+f36fDt2tparl+/TmxsLCYmJu2ChpKSEmJiYnj48CEtLS14eXmx3cGaP1W1dL1j2nNkgKOhPjOV5shlMmxtbbG1tWX06NG66zQ1NVFWVqYLmUpLS7l37x4NDQ3As44YW1tb7OzsdGGTvb09pqamyGQyFAoFCoUCU1NT4FnIVFZWhkFRKdCLwcyShHFjAxduXEZfXx97e3scHBx0H3Z2dr1+R2TBggXk5uZy4sQJduzYgZ6eHj4+PhQUFGBiYkJ1dTV6enq4uLggSRKZmZltln+1ysrK4osvvmD06NEsWrSow3qampq4c+cOd+7cQSaTMWLECKqrqwkLC3thnSqVChMTky7nIMGzQCgkJARvb28uXryo25EOICIignfeeafL4AqeLXFcu3Ytn376KUePHmXFihV8/vnn7N69m5KSEiZOnMjcuXORyWTMt7ViX2E5h4vKadT+81looVbzr14j2TRcia1B1zV35saNG5SUlPD222+/MWG1IAjthQ50AcLQExMz0BUIwpAz0B1Kv/vd73jnnXfYsWMHAB999BFnzpxhz549fO9732t3/T179lBRUcHt27d1f1/31/iS7hJ/7QpvlIsXL5KZmcmmTZs6TH2HmsbGRo4fP05WVhaLFy8mNLTv/sRtbGzk9u3b3L17Fz09PWbOnMm4ceMwMDCgpaWFxMREYmNjefLkCWZmZkyYMIGxY8diaWlJg0bL9QcZJNY08KLeH9k/Pv7PewR6XbxIGxoa4uzs3KabRZIkamtr23QzlZSUkJSUhFqtBp4tm2sNmJRKJc3NzTx9+pSsrKxnwYxCgUPYbEr0DZHo/i8JGeBTkqe7D41GQ1ZWFrGxsUiShEwmY9iwYTg4OLQJm1oDra4YGhqyevVqdu/ezbVr15g1axa+vr4kJCQQEBBAYmIiJiYmyOVyCgoKqKurw8vLq80xnjx5wuHDh3Fzc2PFihXtQka1Wk1sbCzXr1+nqamJcePGMWXKFO7fv9/t3emqqqq67E76KjMzM1atWkVwcDARERFUVlZSUlLCRx99xMqVKxk+fHiXtzcyMmLTpk188sknXLx4kWHDhlFcXExwcDDznhtk6mtmzK9GOfMjd0dyG5up12g5uvdTbNVN/Pvcb3W73q8qLCzk+vXrTJs27YW1CoIwtBUNdAHC0OPoONAVCMKQ01+BUusbo61a57c+r7m5mdjYWL7//e/rPieXy5kzZw537tzp8PinT59m4sSJ/Ou//iunTp3C1taWTZs28d3vfveFb772FxEoCW+M6Oho7t27x6JFi/D09BzocvpdRUUFhw4dora2li1btuDu7t4nx21paeH+/fvcvHkTtVrN+PHjmTx5MsbGxjx9+pSYmBgSEhJobGzEw8ODdevWMWrUqDYvcsZ6cj4P9GBdXDrJ9U3PPtnBi7lM+2wI919GuzDTxqLHtcpkMt1spee3bddqtVRUVFBSUkJ2djZ5eXnk5eXpQiZ4Fk6MGDECV1dXDCxM+V1Nz5a9yWUy/rRyMZU5vqSmpvL48WM0Gg0ODg44OztjZmZGbW0tJSUlpKWl0dLSAoC5uXmbTiYHB4cOl+s5OTkxY8YMrly5goeHBx4eHhgYGNDU9OzxbJ3bkJGRoQvbWpWWlnLw4EEcHBxYt25dm++NVqslMTGRK1euUF1dTVBQEDNmzNAFQwqFos3j1JWqqqpeteC6u7vzL//yL0RFRXHnzh3Ky8v5+9//zuTJk5kxY0aXnT+WlpasWrWKAwcOIEkSzs7OpKamMm3aNKytrdtc11Shh5+ZMQAPTAwpKqrQhX09pVarCQ8Px8HBgalTp/b49oIgDC1fH+gChKGngw05BEEYnEaMGNHm/3/yk5/w05/+tM3nnj59ikajwd7evs3n7e3tSUtL6/C4WVlZREVFsXnzZs6ePUtmZib/8i//QktLCz/5yU9eWNfPf/5z/vM//xMTk7arLxoaGvjtb3/Lj3uxrFYESsIbITMzk3PnzjF+/PhuLdV53eXk5HD06FGMjY15++23sbGxeeljajQaHjx4wPXr16mrq2Ps2LFMmzYNY2Nj0tLSiImJITc3FxMTE0JCQhg7dmyXQ7+V+npsyYrngtaAdDcfCpvVum4kLaCQQXBzLX7ZqSyY5PvS9bdqamoiOzubjIwMMjMzqa6uRqFQ4ObmhqurK0qlkoaGBl1HU2xsLNWNTViNnU6VsSmSrHvLBd8faYeLlQUuwcEEBwfT1NRERkYGaWlpJCQk0NLSwrBhw/D19WX+/PkYGhpSUlJCcXExxcXFPHjwgNraWuDZ4O6OlsxNmTKFx48fc/LkSd5//328vb1JzXxMsYWSFgNDblbW8CA7Bw8PD11opFKp+OyzzzA3N2fjxo26dllJksjIyCAyMpLS0lJ8fHzYvHlzm93ZoGeBkkqlYtSoUd391rS7n3nz5lFRUUFmZiYajYbbt2+TkpLCihUrOh12XVlZyZkzZzAwMKC5uRl7e3vq6uo4fvw4O3fu7PTdmxEjRlBYWEhpaWm7X+zdERUVRUVFBe++++6AvUMkCMLg8QWwfKCLEIaW1avh9OmBrkIQhpT+6lDKz8/HwuKfb4Z/tTupt7RaLXZ2dvztb39DT0+PkJAQCgoK+O1vf9utQOlnP/sZ77//frtAqb6+np/97GciUBKEjpSWlnLs2DE8PT3bLHsZquLi4jhz5gwuLi6sXbsWY2PjlzqeJEkkJydz5coVKioqCAgIYMaMGQDcvXuX+Ph46uvrcXV1ZfXq1fj4+HRrdkxqaip5GRn8dP16Rnl7c7OylscNTTRrtVjrK5iltEBRX8uHcTe4ceMGc+bM6XX9ZWVlugApLy8PrVaLjY0Nvr6+eHp64urq2mXNtbW1LC4s5r3Casq02s5DJUkCmQy/8iL+NdilzUWGhob4+/vj7++PWq3m8ePHpKWlER0dzY0bN7CyssLHxwdfX19mzZqFTCbTdTAVFRXpuqmio6OBZ7+wbG1tUSqVFBYW8tGxL8h09+W0mTPN+s+2qY+If4zMJYhJBjIcK2sIUsCBAwdQKBRs2bJF99zIy8vj8uXL5Ofn4+rqyq5duzodhN0aKL2ok0eSpB4veevI1KlTefToEePHjychIQGVSsWnn35KWFgYc+bMwcDAQHfdwsJCDh48iKGhIe+++y6PHz/m7NmzTJgwgfv37xMZGdnpa4C3tzf37t0jNTW1x4FSXl4ed+7cYc6cOW/EUlpBEARBEAShcxYWFm0CpY4MGzYMPT09SkpK2ny+pKQEBweHDm/j6OiIvr5+mzcvfX19KS4uprm5uc3fxR3p7O/3hISEXu/+LQIlYUirra3l4MGDWFtbs3r16j4dRj3YtO6OdffuXUJCQli4cOFLdUq0DnOOioqiuLgYLy8vVq1aRXV1NWfPnuXx48cYGRkRFBREaGgow4YN6/axm5qaOH/+PN7e3vj4PNvGfZrSnGmYt72igRWTJ0/m5s2bjBkzptudVl11Ic2fPx8vL692y5+6YmZmxsRRnlxxVbPlTCSJlnZoZDLkgATIkNAgw0zdTFBeBgEFj/lT8n2srKywt7dvMwRcqVSiUCjw9vbG29ubJUuWkJubS2pqKklJSdy9exczMzO8vb3x9fXF1dW1zXK95uZmSktLdZ1MxcXFZFkO47yjD9omkPTb/iKRZDLutsCa+MeEVRYzrbmZt3fuxNzcnJKSEqKiokhPT8fBwYHNmzfj4eHRZVCkUCiQJAmtVtvl86uurg6NRvPSu044OTkxfPhwysvL+cY3vsGlS5eIj48nOjqatLQ0VqxYgbu7O+np6Rw/fhx7e3s2btyIiYkJSqWSyspK7ty5Q3BwMHfu3MHV1bXDrqnWjqecHm7L3NzcTHh4OCNGjGDixIkv9bUKgjB0nBzoAoShZ+XKga5AEIacgRzKbWBgQEhICJGRkaxYsQJ4dj4XGRnJ17/e8cLpyZMnc/DgQbT/GAsCkJ6ejqOjY5dhUuv4DJlMxqhRo9rUqdFoqK2t5f333+927c8TgZIwZLW0tHDkyBE0Gg0bN27ss1bDwaipqYkvvviCzMxMFi5cSFhY2Eu9OObl5REZGUleXh4jR45k7dq1lJSUcPjwYWpra3F2dmbFihX4+fm9cAevjly5coXGxkYWLFjwwutOnjyZ+Ph4Ll68yMaNGzu8Tl90IXWHjYGC7c0qqorKkU2bS0pdA40aLRYKPWbZWDDHxgKteixJSUl8+eWXKBQKWlpaiIuL0y1f09PTw9bWVhcytQZNbm5uLFq0iCdPnpCamkpqaiqxsbEYGRnpwiV3d3cMDAzaDB+/WVnDTxIeo9FKHc6hAnSDz6Ot7FGOVVJaWkpUVBRJSUm6sHX06NHdes60PoZqtbrLQKmqqgrgpTuUAEJDQzl9+jSNjY0sX76c4OBgTp06RWVlJQcOHMDJyYmCggJ8fHxYtWpVm+fk3LlzqaqqIjExkREjRhAeHs7777/f7l0jPT09jIyMePr0aY9qu3Tpkm5O2VAOrAVB6JnHA12AMPQ89+aSIAh9Y6B3efvmN7/JW2+9RWhoKOPGjeODDz6grq5Ot+vbtm3bcHJy4n/+538A+NrXvsaf//xn/v3f/51vfOMbZGRk8Mtf/pJ/+7d/6/J+PvjgAyRJYufOnfzsZz9r8/e5gYEBrq6uvX5jVARKwpAkSRKnTp2iuLiY7du398lJ7WBVWVnJoUOHqK6uZtOmTS81cPz5jhU7OzumT59OYWEhx48fR19fn8DAQEJDQ3s1Y6ZVUVER9+/fZ/bs2d3qXtHX12fevHkcO3aMjIwM3W5lL+pC8vT07HXrZleUSiXFKSn8+wjbDi/X09dnzJgxGBgYcPz4cfz8/Ni6dSt1dXWUlpa22XEuJSVFN4zb2Ni4TcC08h/vRGZmZurmLunr6+Pl5YWvry9eXl7I9Q14PzkXSaLTMKkNmYwLGGB47jJOVU8xNzfH2dmZmpoacnJycHBweOESydawRq1WdxnSqlQqgJfuUALw9/fn0qVLxMTEMG/ePFxcXPjXf/1Xbt68ybVr1ygoKEBPT4/AwMB2AadMJmPFihXs37+f8vJy5HI5J06cYNu2be0CIBsbGwoKCtq869OVx48fExMTw6JFi/rluSYIwuvrP4EbA12EMLT87//CtGkDXYUgCH1o/fr1lJWV8eMf/1i3M/H58+d151p5eXlt/iYdMWIEFy5c4D/+4z8IDAzEycmJf//3f+e73/1ul/fz1ltvAeDm5sakSZN61RDQGREoCUPS1atXSU5OZt26dTg5OQ10Of0mLy+PI0eOYGhoyK5du9oNUO6uyspKrly5QmJiIpaWlvj5+VFQUMC1a9dwdHRk8eLFBAQEvHBd7ototVrOnDnDsGHDmDBhQrdv17r0KyIigrCwMLKyssjNzUWr1aJUKnVdSC4uLn36AtkRpVJJVVUVGo2myw6d0aNHU1FRQVRUFEqlkqCgINzc3HBzc9NdR5IkKisr24RM2dnZxMTE6HZps7Kyws7OjpEjR9LY2KgLovT09KjxC+apdcezjjoj02p5MnoMO83llJWVUVJSQmpqqm7QtqWlZbtd5iwtLXXvuDzfodSVqqoqDAwMMDIy6lF9HdHX1yc4OJgHDx4wc+ZM9PX1kSSJp0+fIkkS1tbWVFZWcvToUby9vVm6dCmmpqZtbr9hwwZ2796NVqslLy+Pa9euMXPmzDb3M3LkSAoKCigsLOx0hlSrxsZGTp8+jbu7O6GhoS/9NQqCIAiCIAiv1kB3KAF8/etf73SJ29WrV9t9buLEidy9e7fH9wMwffp0tFot6enplJaWotVq21w+rRehtQiUhCEnISGB69evM3v2bHx9+253sMEmPj6eL7/8khEjRrBu3bp20/q7o6amhuvXrxMbG4uhoSEODg6UlpaSkZGBv78/oaGhDB8+vM9qjouLo6CggB07dnRrvtPzXUhPnz6ltraWK1eu4OHh0a9dSF1RKpW6IOhFc6OmTJlCRUUFp0+fxsrKCheXtoO6ZTIZSqUSpVKpmyUFz8KasrKyNkFTeno6NTU1wLPlWSYmJpzSM0EmdTEkvAOSXE683AS3MaOZYPgsfNNqtZSXl7eZyxQdHU19fT2A7rnh4OCgC+yampq6vB+VStUmiHpZoaGh3Llzh6SkJHx8fDhy5AhPnjxh7dq1+Pr6kpSUxJkzZ3j06BFZWVksXboUf39/3f2bmpqyefNmdu/ejaWlJdevX8fV1bVNwOfj48OdO3d49OjRCwOl8+fP09TUxLJly/r0DxFBEIaG7wx0AcLQ85vfDHQFgiC85u7evcumTZvIzc3VvXndSiaTodFoOrll50SgJAwpeXl5fPnllwQHBzN58uSBLqdftA5ru337NmPGjGHx4sU9Hr7d0NDArVu3uHv3LjKZDCMjIxoaGtBqtcyfP5/AwMA+6Sx5Xm1tLZcvXyY4OLjTLd9bZyFlZmaSmZnZpgvJz88PlUpFdnY2S5cuxdzcvMNj9LfWweAVFRUvDJRkMhlLlixBpVJx5MgRdu3a1a3B4gqFAkdHRxwdHdt8vr6+vs2yuTJjix6FSa20QEZ9I/b/CJTkcjm2trbY2toSEBAAPPte1NbWtgmZMjIyqKioAODjjz/Gzs4OBwcH7O3tdYFT6/OmqqqqT5a7tVIqlXh6enL37l1u3bpFfX0927Zt0z2XAgIC8PLy4vz58yQkJHDixAliY2NZvXq17rliY2PDhg0b2LdvH2ZmZpw4cYL3339f183U2s2Ym5vbZS2tSxCXL18+pJfTCoLQe8sBcfov9KlTp+C5N58EQXh5g6FD6VV6//33CQ0N5cyZMzg6OvZJvSJQEoaMiooKDh8+zIgRI1iyZMmg/4HujebmZk6cOEF6ejrz5s1jwoQJPfo6W1pauHv3Ljdv3tTN7pHL5Xh5eREaGoqzs3O/PW6XLl1CLpczd+7cNp9/vgvp8ePHVFVVdToLqaGhgT//+c9tdkN41czNzVEoFLpg5UX09PRYt24de/bs4eDBg+zatatX3WQAJiYmuLq64urqCsA3riWAVur6Rp1IfJSOo60VVlZWWFpathtYLpPJMDc3x9zcXDe3CiA/P589e/YwYcIEGhoaKCkpITExUfeOhpWVFQ4ODhQUFODo6EhVVRUWFhZ98rzy8PDgwoULmJubdxjOGRkZsWLFCkJDQzl+/Di5ubn84Q9/YP78+YSGhiKTyRg5ciQrV67kiy++QF9fn/DwcDZt2oRMJkNPTw9jY+MuB3PX1dURERGBt7c3QUFBL/01CYIwNA3Nt7SEAXXr1kBXIAhDjkwm69NNVQb7+WdGRgbHjx9/qZm7XyUCJWFIaGho4ODBgxgbG7Nu3boed+y8Dqqqqjh06BCVlZVs2LChw63PO6PRaLh37x7Xrl2jubkZeLZ9ZFhYGEFBQb0OOLorOzubhw8fsmzZMoyNjSktLe2wC8nb2xsvL69OZyEZGxsza9YsIiIiCAkJYcSIEf1ad0dal6l1N1CCZ3Vv2rSJTz75hCNHjrB169aX3nEOwFxPj0Zt17OMOpNw5zal1f/8GszNzbGy+mfA1PrvrwZOrc+VUaNG6ZbwaTSadkvm6urqyMzM5IMPPsDIyKjdXKZhw4b16Oc0IyODyMhI9PT0GDFiRJedXs7OznzjG9/g5s2bXL9+nbNnzxIbG8v69euxtrbG398flUpFZGQkmZmZ3L59W9fROGzYMPLz81Gr1e2+R5IkcebMGbRa7ZANrQVB6BuVA12AMPRYWw90BYIgvObGjx9PZmamCJQE4XkajYZjx45RX1/Prl27XrhL1esoPz+fI0eOoK+vz65du7Czs+vW7bRaLTdu3OD27ds0Nzcjk8nw8vJi4sSJuLq6vpITYrVaTUREBMOGDdMN+m7tQnJ1dWXevHl4eXl1exbSmDFjiI2N5dy5c7z99tsDslV7TwMleBbgtS63+vLLL1mxYsVLP/7zhllwuKiCnq52tlTo8X9ff5/m2lpUKlWbj6qqKvLy8qiurm6zttrMzAwrKyvd8rDWQd6tgVPrDnWBgYE0Njby61//moULF2JlZUVRURElJSU8evRIN0RQT09Pt6Pd80FTRzvHxcXFERERgZeXF8OHD+fGjRvU19d3GYTq6ekxffp0goKCOHbsGIWFhfzpT39i2rRpTJ8+ncmTJ1NZWUlcXByRkZG4uLjg7OzMyJEjSS0t48uMHGwd7LHRV+BjaoRMJiMpKYnU1FTWrFmDmZlZDx91QRDeJNsHugBh6Nm3b6ArEIQh501Y8vbw4UPdv7/xjW/wrW99i+LiYgICAtq9gR8YGNjj44tASXittXYM5ObmsnXr1m7Np3ndPHz4kNOnT+Pk5MS6deva7F7VmcbGRiIjI4mPj9d1WowfP54pU6a8khPh1h24MjIyiI6O1m0hr9VqX9iF9CJyuZwFCxbw6aefEh8fz9ixY/u4+hdTKpWkpKT0+HYjRoxgxYoVfPHFFyiVSqZPn/5SdWx3GsbnRT0LtvSArcNtMNXXx9TaGutO3vHUaDRUV1e3C5vKy8sBuH//Pvfu3dNdvzVwsrKy0n1fNRoNSqUSNzc33ecaGxspKSnRdTJ9dcmctbW1Llyyt7cnKyuL+/fvExoaysKFC2lsbOTGjRs8ePCgW3PSrKysePvtt0lMTCQiIoJr166RkJDAhg0bWLRokW4u15GjRxm1YSt/N3Pk/vj5HCiuheJaANyNDdk8zJzy8xfw9/dn9OjRPXrMBUF485wEVg50EcLQsmIFhIcPdBWCILxmgoODkclkbd4o3rlzp+7frZeJodzCG+nOnTs8ePCA5cuX6+bKDBWSJBEVFcXNmzcJCgpiyZIlL1wmVVRUxNWrV8nIyECSJN0SsZ7OWuqN5uZmsrKydEvZqqqq0NPTQ6PR4ObmxpIlS/psR7aRI0cSGBhIZGQkfn5+fT5A/EWUSiVVVVVoNJoeL6/09/enoqKCK1euYG1t3at3AuBZOFcRF81wVTNFljbdGs4tAxRyGW85dT1MHJ51+Fh3EDg1NTXxq1/9ipUrVzJixIh2HU4qlYqysjIALl68yMWLF4G2gVPrkrrRo0czefJkzMzMqKqqarNk7s6dOzQ2NgKgr69PeXk5ly9fxsHBAQ8PD6Kjo5k4cWK3OtRkMhmBgYF4e3tz6tQpUlNT+eijjwgNDWXNmjV89OleDtm5kfeogI6+m9kNTfxXXiPmgVM4GSYGogqC8GKvvndWGPK+sr23IAgv703oUMrOzu7X44tASXhtpaWlcenSJaZMmUJwcPBAl9OnmpubCQ8PJzU1lTlz5jBp0qROX6Cam5tJTk7mzp07uhN5MzMz5s6dS0BAQL+9sD3fhdTRLCRPT0/u3LlDRUUFGzZswMDAoE/vf86cOaSmpnL16lUWLFjQp8d+EaVSiSRJVFZWvnCnt45MnTqViooKTp8+jaWlpW4WUXdVVFRw8uRJCgoKmKfQ58KUhZRq6HLpm0ySkMngk9FujDDq/feiNdTUaDS6gOir7t+/z4ULF/j6179OVVVVmw4nlUrFkydPqKqqavNOiampqe549vb2VFdX09TURGBgIBYWFpSVlZGamsqdO3d0t/nwww9xcXFp09HU0ZK5VoaGhqxbt468vDyOHj1KTEwMiampXJ84l/ymZ3+od/QYSgAyGfUGRqxLyedCqMlLPYaCIAx9Zwe6AGHoWbRooCsQhCHnTQiUenqe0VMiUBJeS0VFRZw4cQI/Pz9mzZo10OX0qerqag4dOkR5eTnr16/Hp5MtYktLS4mNjSU+Pl43aLu/g6SOupA6m4WUnJxMdnZ2v4RJ8GyI9LRp04iKimLs2LHdnivVF1qXVlZUVPQqUJLJZCxdupSqqiqOHDnC22+/3a3uLUmSePDgAefPn8fMzIyAgADS09O5EObL+2l53FbVIZO0bbqV5JKEVibDVNKwMv8Rc2YE97je58nlcmQyGWp158PAVSoVlpaWHXY4tdJqtW2W1LWGTU+fPiU1NRXtP96JTUhIAP4ZODk4OKCnp8fjx49paGggPz+f+Ph4XTilVCrbDQA3MzNr8/MwcuRIvvnNb3L58mX+lldCXJMWuvHzogGq1Bq+nZbP4WCP7j5kgjCkPB8EDxZ99fuuL7+2B312pKGtL/9WGYzPzT41ZsxAV9CO+P4Jwuvl9OnTHX5eJpNhZGSEp6cnbm5uPTqmCJSE105r4GJra9sng40Hk4KCAg4fPoxcLmfnzp04ODi0uVytVpOSkkJsbCx5eXkoFArUajWmpqbMnDmT4ODgPt3h7qtdSHl5ebq5OK1dSK6uru1mITU1NXH+/Hl8fHzw9vbus3q+asKECbqAZevWra/suWBubo5CoejxYO7n6enpsW7dOnbv3s3BgwdfOFC+dbv6tLQ0xowZw7x58/j444/x8/PDztiQQ34j+d5Hn1AcGEqivim1Gg0Gcjme+nKGxd5mi68Hd3IyKSkpafe86gmZTKZ73nWmqqqqw86l58nl8nYdTsXFxRw8eBBzc3M2btyIkZFRh0PDVSoVTU1NSJJEQ0MDAEZGRrqlj0+ePCE9PV1Xo7GxMY6Ojm1CJhsbG+bOncv/dzsJmrq/U55GgmuVNeQ0NOFq3Hk3lCAIb7YfAMsHughhaPnFL6CTk0FBEHrnTehQel7rufNXA9zn5yhNmTKF8PDwTt8U/ioRKAmvlebmZg4dOoRMJmPjxo29Guo8WCUlJXHq1CkcHBxYv359m+HZ5eXlum6khoYGLC0tkcvlKBQKZs6cSVhYWJ89Fs3NzWRnZ+tCpOe7kObOndutHdmioqJoamrq96VoCoWC+fPnc+jQIdLS0vD19e3X+2slk8l6tdPbVxkbG7Np0yY++eQTjhw5wtatWzsMBDMyMjh16hRarVbXtfbkyRNUKhX+/v7As+Ht1lXl/CzEFwsLiza3/yTpDqWFhZiamhIfH//S35fuBEq2trY9Oubjx485evQoNjY2bNq0Sff872xJYFNTE7///e/x9PTEy8urXeCkfW7WRENDA7m5ueTm5uqGDcrlcqqcXHniFtCt7qTnyYH9BeX82HN4j24nCIIgCIIgCAPl0qVL/OAHP+AXv/gF48aNA56NqvjRj37ED3/4QywtLXnvvff4z//8T3bv3t2tY4pASXhtaLVaTpw4QUVFBTt37hwy23ZLksS1a9e4du0aAQEBLFu2DIVCgUajIS0tjdjYWLKzszE2NsbW1paioiLq6+uZPHkykyZNeumB1L3tQupMYWEh0dHRzJkzB0tLy5eqrTtGjRqFl5cXFy5cwNPT85WFjH0RKLUeZ8OGDezfv58vv/yS5cuX697daGlp4eLFi8TExODp6cmyZcswNzcHIDExEXNzc1xcXJAkiZiYGLy9vduFSQAhISGcPn2a4OBgkpKSmDt37kt1sr0oUFKpVHh6enb7eA8ePCAiIgIPDw/WrFnTrSWShoaGjBkzhoSEBJYvX97u+67VaqmtrW3X4VRRUUFFRQW1tbVkaWXIJAmph4GSBkisre/RbQRBeLP8eKALEIaen/98oCsQhCHnTetQ+vd//3f+9re/MWnSJN3nZs+ejZGREe+++y7Jycl88MEHbXaBexERKAmvjcuXL5Oens7GjRuxt7cf6HL6REtLC6dOnSI5OZlZs2YxZcoUVCoVcXFxPHjwgLq6OkaMGEFgYCCZmZk8efKE0NBQpk6d+lKBWl90IXVEq9Vy5swZbG1tGT9+fK/r66n58+fzl7/8hdu3bzN9+vRXcp9KpZLU1NQ+OdbIkSNZvnw5J06cQKlUMm3aNAoLCzlx4gRVVVUsWrSI0NBQ3S8prVZLcnIyAQEByOVy8vPzKS0tZd68eR0ef/To0Vy4cAF4tnTu8ePHjBo1qtf1dhUoqdVq6urqXrjkDdqGqWPHjmXx4sXd2rWtVVhYGHfv3iU5ObndYH65XI6FhQUWFhaMHDmy3W21Wi2/ycjnXmFll8PMO1OnEbvtCILQuRlAwkAXIQwtV6/CENuERhAG2psWKD1+/LjDN58tLCzIysoCwMvLi6dPn3b7mCJQEl4LsbGx3LlzhwULFuDl5TXQ5fSJmpoaDh8+TFlZGWvWrEGhUHDw4EEyMzMxNDTU7W4VGxtLfn4+QUFBzJgxo1sn6l/V111InYmJiaGwsJCdO3f26SynF7GxsWHChAncvHmToKCgXj1GPaVUKlGpVGg0mj75WgMCAqioqODKlSuUlJSQlpaGvb097733XrvB39nZ2dTV1REQEAA8e9ytra1xd3fv8NgGBgYEBgaSkpKCnZ0dCQkJ/RYoVVVVAbywO02j0RAREUF8fLwuTO3pL2GlUomnpyfR0dE93ulRLpdjZ2qClsoe3Q5ABlgrXt3zWxi6rl+/zm9/+1tiY2MpKiri5MmTrFixQne5JEn85Cc/4e9//zsqlYrJkyfz17/+dcj8HhzKZgF/GOgihKElKgr+3/8b6CoEQXiNhYSE8O1vf5v9+/frxlOUlZXxne98h7CwMODZqI0RI0Z0+5giUBIGvaysLM6cOUNYWNgr7XrpT0VFRRw6dAitVktgYCAXLlygpqYGJycnli1bhoGBAdevX6e0tBQfHx82btzY413MXtSF5OnpqdutrC/U1tbqdlzryYtQX5k2bRoPHz7k0qVLrF27tt/vT6lUIkkSlZWVvdrprSMBAQHcv3+flJQUAgMDWbZsWYdhVVJSEkqlEkdHR+rr60lOTmbmzJldBjKhoaFER0fj4eFBcnIyDQ0NXQ4B70pXgZJKpQLoMtRramri6NGj5OTksHLlSgIDA3tVBzz7ug4fPkxBQQFOTk49uu00pTm93VNmpk37d3cEoafq6uoICgpi586drFq1qt3lv/nNb/jjH//Ivn37cHNz40c/+hHz588nJSXlpZc7C/2rYaALEIaeXv7OFgShc29ah9Lu3btZvnw5zs7OuvO1/Px83N3dOXXqFPDsnO6HP/xht48pAiVhUCsrK+Po0aN4eHj0+4DnVyU5OZkTJ05gYGBAU1MTDx8+JDAwkJCQEJqbm4mMjCQ/Px9XV1d27dqFs7Nzt47b2oWUmZlJRkaGrgvJ2tq6T7uQOnPhwgX09PSYM2dOvxz/RQwNDZk7dy4nT54kOzu7x1te9lTrksCKioqXDpQkSSIhIYFz585hbGyMvb29LgT86tJDtVpNamoq48ePRyaTER8fD/DCDh07OztGjBihG1idnJxMaGhor+rtTodSR+208GyXxoMHD6JSqdiyZctLf5+8vLywtLQkOjq6x4GSp4kRk63MuKuq7dGyNwO5jHUOPV8SKghftXDhQhYuXNjhZZIk8cEHH/DDH/6Q5cuf7Re2f/9+7O3tCQ8PZ8OGDa+yVKGHxHdH6HNHjgx0BYIgvOa8vb1JSUnh4sWLpKen6z43d+5c3diJ5zulu0MESsKgVVdXx8GDB7G0tGTNmjU9mq0yGNXU1BAeHq5bn2phYUFYWJhuqVNUVBSZmZk4OjqyZcsW3N3dX5hyv+oupM48fvyYpKQkli9f3uuul74QEBBAdHQ058+f57333uvX54yFhQUKheKlB3PX19cTERFBamoqwcHBLFiwAI1Gw+7duzl48CC7du1q85hmZGTQ1NREQEAAkiQRGxuLn58fpqamL7yvkJAQwsPDGTlyJA8fPuyXQEmlUmFubt5hZ1VJSQkHDx4EYOfOnT3uuuuIXC4nNDSUq1evMm/ePExMTHp0+38dacctVW337w/YNtwGC7HkTehn2dnZFBcXtwnpLS0tGT9+PHfu3Ok0UGpqaqKpqUn3/9XV1f1eq9DeYUSoJPSx9etFqCQIfexN61CCZ387L1iwoM+aNUSgJAxKarWaI0eO0NLSwltvvYWhoeFAl9QrkiSRk5NDdHQ0aWlpSJKEvb09ixcvxtnZmYqKCr788kuSk5OxsbFh7dq1+Pr6dvpi9HwXUmZmpm4bdGtra91uZ/3ZhdQRtVrN2bNncXFxISgo6JXdb0dkMhkLFy7k73//OzExMbrtMPvrvl52p7fMzExOnTqFRqNh7dq1+Pn56S7btGkTu3fv5ujRo2zZskUX0CQlJeHo6MiwYcPIysqioqJC173wIn5+fpw/fx4jIyPS09MpLy/vVeCor6/fZYdSR8vdsrOzOXLkCNbW1mzatEm3W11fGDNmDFevXuXBgwdMnjy5R7c1epTEuJxc7rv6vvC6cmC8lSk/9Bjey0oFofuKi4sB2m1CYW9vr7usI//zP//Dz372s36tTXgxsThJ6HMNYiGlIPS1NyFQ+uMf/8i7776LkZERf/zjH7u87r/927/1+PgiUBIGHUmSOH36NEVFRbz11luvZMByb6mbm2luqEdhaIi+oZHuRaS+vp6EhARiY2MpLy9HoVAgk8lYsmQJY8eOpbq6moiICB48eIC5uTlLly4lODi4w46ajrqQ9PT0cHNze6VdSJ25efMmKpWKDRs2DIoX0eHDhzN27FiuXLmCv79/jztWeqK3gVJLSwuXL1/m/v37eHh4sHz58nYBi42NDevXr+fAgQNERESwbNkympubefToEbNmzQKeDeO2tbXt9swqfX19goKCePjwIQYGBjx8+JCZM2f2uH6FQtGmA+J5VVVV7QZyJyQkcPr0adzc3Fi7dm2fB8SmpqaMHj2amJgYJk2a1K3noSRJREZGcuvWLf7f1KlkeQ7n54+LaJGeTVV6fraSHqABlttZ8TufkRi+5t2SwsuLi4tDX19fNxj/1KlTfPrpp/j5+fHTn/4UAwODAavt+9//Pt/85jd1/19dXT0gc+3edFEDXYAw9Pzjd78gCEJP/P73v2fz5s0YGRnx+9//vtPryWQyESgJQ8P169dJTExkzZo13Z4f9CqpW1rIuH+bB+e+pCgjTfd5Szt7XCdMRaUwIi0jEwA3NzcaGhqQyWRs3LgRa2trLl26xP3799HX12fu3LmEhYWhUPzzR3EwdiF1pry8nJs3bzJp0iTdTgGDwaxZs0hOTiYqKoolS5b02/0olUpSU1N7dJuioiJOnDiBSqViwYIFjBs3rtMAxMXFhWXLlnHy5EmUSiXm5uZoNBr8/f2pqakhLS2NBQsW9CjICw0N5d69e7i6uvLw4UNmzJjR4yBQoVBQV1fX4WUqlUr3cytJEjdu3ODKlSsEBwezZMmSftv9LywsjIcPH5KZmfnCHbC0Wq0u0J03bx4TJ05kFrDGQcnR4gr2F5aT39hMi0aLYUsTy2ws+Dc/dzxMxBBk4Zn33nuP733vewQEBJCVlcWGDRtYuXIlx44do76+ng8++OCl78PBwQF4tlTU0dFR9/mSkpIuZ6YZGhq+tl29Q8nVgS5AGHpmzBjoCgRhyJHL5X06ImMwjmjJzs7u8N99RQRKwqCSmJjI1atXmTlzJqNHjx7octopzcnixK9+Sl1lBTJZ2xeMqtIS4k8fRyaXE7hgOSODQjh79iw2NjasXr2alJQUbt++jSRJTJo0iUmTJun+6G/tQmoNkVQqFXp6eri6ujJnzhy8vLwGtAupI5IkcfbsWczNzZk2bdpAl9OGqakpM2fO5Pz584SEhLQ5GetLSqUSlUqFRqN5YVCi1Wq5ffs2V65cwc7OjnfffbdbIVxgYKBuxpa9vT0uLi5YWFhw7do1FApFj3dIGzZsGC4uLjQ2NqJSqcjNzcXV1bVHx9DT0+twyZtWq6W6uhorK6s2oc2MGTOYNm1av3awOTk54ejoSHR0dJeBklqt5sSJE6SlpbF8+fI2J+ZW+greHWHHuyOezXbKyclh3759TJw4EQ8Tv06OKLyJ0tPTdc+dY8eOMW3aNA4ePMitW7fYsGFDnwRKbm5uODg4EBkZqbuv6upq7t27x9e+9rWXPr7Qv34OdG8xsiB0049/DKdPD3QVgiAMAa3nnh4eHm0aG3pDBErCoJGfn8+pU6cIDAxk6tSpA11OO2V5ORz+yXdQNzcDIEnadteRPbuAjLMnSUx4iOf4STg7O7N3714aGxsJDQ1l6tSpmJiYdNqF5OXlNai6kDqTnJxMVlYWmzZtGpR1hoaGEhsby7lz59ixY0e/hBlKpRJJklCpVF0GfiqVipMnT5KXl8fkyZOZOXNmjzp1pk+fTmlpKampqUyaNAmtVktcXBz+/v692jo8JCSEEydOYGFhQUJCQo8Dpc6GctfU1CBJEqamphw6dIisrKx2oU1/kclkhIaG8uWXX1JZWYm1tXW76zQ3N3PkyBFyc3NZv3493t7eXR5z+PBns5Ly8/P7pWbh9SVJElrts98Bly9f1nVCjhgxgqdPn3b7OLW1tWRmZur+Pzs7m/j4eJRKJSNHjuT//b//x3//93/j5eWFm5sbP/rRjxg+fHiPd2ARBEEQBKG9N2GG0vPq6+v5xje+wb59+4Bnb5C5u7vzjW98AycnJ773ve/1+JgiUBIGhcrKSg4fPoyTkxNLly4ddD+MWq2G8F//HHVzM5K2fZDUhiQhAUaF2RTmOPDo0SOCgoKYNGkSFRUVXL16tdMuJKVSOei+9o40NjZy4cIFfH19X7i8aKDo6emxYMECDhw4QFJSkm7WSV9SKp9tHd/ZcGtJknj48CHnzp3DyMiI7du34+Li0uP7kclkjBgxgtTUVN3JZnV1da93afP19cXExARzc3NSUlJYtGhRj0LBzgIllUoFQFRUFNXV1WzatAkPD49e1dgbAQEBXLp0iZiYGObOndvmsvr6eg4ePEhZWRlbtmzpVohmYGCAkZFRjwIC4c0QGhrKf//3fzNnzhyuXbvGX//6V+BZIPTVIdpdiYmJaTPHrHX20VtvvcXevXv5zne+Q11dHe+++y4qlYopU6boBusLg9svBroAYej5wQ8GugJBGHLetEDp+9//PgkJCVy9erXNLm9z5szhpz/9qQiUhNdTY2Mjhw4dwtDQkPXr1790211/iIu6TPXT0m5fX8azDiaj6gr8Z8yjuLiYjz/++LXrQupMVFQUzc3NfbbdZH9xd3fH19eXS5cu4e3t3eeDci0sLFAoFB0O5m5oaCAiIoKUlBQCAwNZuHDhS50Epqam4u7uTmVlJRcuXMDBwUHXQdNTCoWC4OBgYmNjaW5uJi0trUeBW2e7vLV28jQ2NrJz584enVj3BX19fYKDg3XL7Fp/tqqrqzlw4AD19fVs3769R0sgbWxsKCgooKWl5bX8WRX6xwcffMDmzZsJDw/nBz/4AZ6engAcP36cSZMmdfs4M2bMQJKkTi+XyWT8/Oc/5+c///lL1yy8WmOA+wNdhDC0PHgA48cPdBWCILzGwsPDOXLkCBMmTGgTfo0ePZrHjx/36piD78xdeKNotVqOHz9OTU0Nu3bt6tcduXqqpaWF5ORkYmNjeXorssc/LDKgLiude4bmuLq7v3ZdSJ0pKCggOjqaefPmYWFhMdDlvNC8efP48MMPuX79OnPmzOnTY8tkMqytrdsFSllZWYSHh9PS0sKaNWteeh6YSqUiPz+fVatWYWpqyoEDB1Cr1d2a3dSZkJAQbt++jY2NDQkJCT0KlDrqUMrJyeHatWvIZDLeeeedAXtuhIaGcvfuXZKTkwkODqa8vJwDBw4AsHPnzh7PIhsxYgQFBQUUFRUxcuTI/ihZeA0FBgaSmJjY7vO//e1v+23wvPB6WQR8PNBFCEPL2bPw/vsDXYUgDClvWodSWVkZdnZ27T5fV1fX69oH3xhy4Y3ROtQ5OzubdevWMWzYsIEuCYCnT59y/vx5fve733Hq1CkMDQ3Rb+x4R6sXkWk17Nq8kS1btjBhwgRsbGwG/QtNV7RaLWfOnMHe3p7xr8m7ZFZWVkyePJm7d+9SXl7e58e3sbHRBUpqtZrz589z4MABbG1t+drXvtYnw+WTkpLQ19fH29ubrKws9PX1qaioICIiosvuhq4olUrc3NzQarVkZWVRU1PT7dt+NVBKTEzks88+w9jYGDs7uwENGm1sbPDw8CAmJoaioiL27NmDgYFBr8IkQNd5kpGR0delCq85lUrFJ598wve//33da0BKSgqlpd3vZhWGrhcsjheEnhuEu0cJgvB6CQ0N5cyZM7r/bz0v/eSTT5g4cWKvjik6lIQBc+/ePWJjY1m6dClubm4DWotarSYtLY2YmBhyc3MxMTEhJCSEsWPHYmVpye+/PNzrY2tamvuw0oEVHR1NUVERu3btGpTbYnZm8uTJxMfHc/HiRTZu3Ninx1YqlaSmplJcXMyJEyeoqKhg/vz5jB8/vs/Cw8TERLy9vdHT0+PBgweMGTOG4cOHEx4ejo2NDVOmTOnVcUNDQzl27Bh6eno8fPiQyZMnd+t2CoWClpYWJEni1q1bREZGEhQURE1NTZ8vK+yNsLAwDh8+zKeffoqdnR2bNm3qdfejs7MzAHl5eX1ZovCae/jwIbNnz8bKyoqcnBzeeecdlEolJ06cIC8vj/379w90icIAWznQBQhDT3j4QFcgCEPOm9ah9Mtf/pKFCxeSkpKCWq3mD3/4g24n8mvXrvXqmK/PGaEwpKSnp3PhwgUmTZrE2LFjB6yOiooKLl26xO9//3u++OILZDIZq1ev5j/+4z+YM2fOs+Vpcjnyl1jCYGBk3IcVD5yamhqioqIICQnRnWS/LvT19Zk3bx7p6el93mlibW1NZWUln3zyCXK5nHfffbfduuSXUVpaSmlpKf7+/qSmplJfX09oaChBQUFMmzaNyMhIkpOTe3Vsb29vTE1NsbS0JCEhodvdTgqFQtetFhkZybRp01i+fDlVVVVYWlr2qpa+1Lr7lqGhIdu2bXuppbSGhoYYGhqKwdxCG9/85jfZsWMHGRkZbWajLVq0iOvXrw9gZW8mSZL65KMv7e3DY7We8AymD6F7+vQxf+utgf5y2umrn72+/vkThO56014fp0yZQnx8PGq1moCAAC5evIidnR137twhJCSkV8cUHUrCK1dcXMzx48fx8fHp85k23aHRaEhPTyc2NpbHjx9jZGREUFAQoaGh7ZbdPX36lJSUFDC1QKqupKcvEfpGxlgPd+q74gfQhQsXUCgUzJ49e6BL6RVfX19cXV05f/487u7ufTLnpKqqipiYGODZTJVFixb1+VD5xMREjIyM8PT05MCBA7i4uGBraws8G+hbUVFBeHg4lpaWPQ769PT0GDNmDPfu3aOlpYXi4uIeDaxu7TAcO3YskiQNikApPj6e06dPY2trS0VFBWq1+qW7ppRKJUVFRajV6kG5aYDw6kVHR/Pxx+0n5Dg5OVFcXDwAFQmDjfVAFyAMPZWVA12BIAivqZ/85CfMnj2bCRMm4OHhwd///vc+O7boUBJeqZqaGg4dOsSwYcNYuXLlK01xq6qquHLlCh988AFHjx6lqamJFStW8M1vfpMFCxbowqTy8nKuX7/ORx99xIcffsitW7ewGR3U4zBJJpcTOHse+gaGff/FvGKZmZkkJyczf/58jI1fz44rmUzGggULqKys5O7duy99vMTERP76179SX18PgI+PT5+HDZIkkZSUhJ+fHxUVFeTm5hIaGqq7XCaTsXz5chwdHTl8+DAqlarH9zF27FhaWlowNDQkISHhhdevra3lxo0bAKxZs0bXYVhfX49arcbKyqrHNfSVO3fucOrUKcaMGcPWrVuBZwHTy2oN6kpKSl76WMLQYGhoSHV1dbvPp6en6wJf4c12a6ALEIaebi5LFwShZ96E7qT9+/czY8YMrKysmD17Nr/4xS+4fft2h7s295R4q1V4ZZqbmzl06BCSJLFx48ZXMmtFq9WSmZlJbGwsGRkZ6OvrExgYSGhoaJstzcvLy0lJSSE5OZmSkhLdAOTp06fj6emJXAZ/S4mnoaYaSdvNUZuSRNDcRf30lb06LS0tnD17FldX1x7tBDYY2dvbExYWxvXr1wkMDMTc3LzHx2hoaODs2bMkJSUREBDAwoUL+d3vftdup7e+UFBQgEqlIiAggJiYGExMTPD19W1zHYVCwfr169m9ezcHDx5k586dbZbgvIi1tTWenp4UFxeTmJjI3LlzO+3eevr0KZ9//jmNjY0AbXY9aw2zBqJDSZIkoqKiuHnzJlOmTGHWrFnIZDL8/PyIiYlh4sSJL/VL3svLi+joaDIzM3FyGhodh8LLWbZsGT//+c85evQo8OyP0by8PL773e+yevXqAa5OGAxODXQBwtCzfPlAVyAIwmsqOzubnJwcrly5wtWrV/n73//Oj370I0xNTZk8eTIzZ85k5syZjBs3rsfHFh1KwishSRLh4eE8ffqUjRs39upEvidqamq4fv06f/zjHzl06BA1NTUsXryYb33rWyxevBh7e3sqKiq4ceMGH3/8MX/+85+5ceMGtra2rFu3jm9/+9usXr0aX19f9PX10VPos/w/fwgyGd1d5T17179g7fj6n3zevHmTqqoqFi9ePKiT9+6aMWMGenp6REZG9vi22dnZfPTRR2RkZLBq1SpWrVqFsbEx1tbW/RIoJSYmYm5ujqOjIwkJCYwZM6bDsMfU1JRNmzZRU1PDsWPH0Gg0PbqfkJAQamtrqa+vJzMzs8Pr5OXlsWfPHvT19Vm06FlQ+vy7GlVVVQCvvEOpdZbTzZs3mTt3LrNnz9Y9T8PCwqisrOz0a+quESNGAJCbm/vS9QpDw//93/9RW1uLnZ0dDQ0NujcfzM3N+cUvfjHQ5QmDwG8GugBh6PnOdwa6AkEYct6kGUqurq7s2LGDffv2kZOTw+PHj/nDH/6AnZ0dv/zlL5k0aVKvjis6lIRXIjIyktTUVDZs2NCjGS09IUkSWVlZxMbG8ujRI/T09PD39yc0NJThw4cDz4ZwJycnk5KSQnFxMfr6+owaNYpp06bh6emJvr5+53dgZkGjqw/GeRloW5qRoN0yONk/dj6b+87XCZg1r1++zlfp6dOn3Lx5k8mTJ7ebL/W6MjY2Zvbs2URERBASEqILC7qiVquJiorizp07uLq6smLFijadODY2Nn0eKGm1WpKTkwkICCAlJYWmpqYuh+UNGzaMdevW8dlnn3HmzBmWLl3a7V9qo0aNwtzcHLVaTUJCAt7e3m0uT05O5uTJk4wYMYJ169bpBlR/NVDS19d/pUsi1Wo1J0+eJDU1lWXLljFmzJg2lzs7O+Pg4EBMTAxeXl69vh8jIyMMDAzEdvCCjqWlJZcuXeLmzZs8fPiQ2tpaxo4dOyBzAQVBEARB6J2+DoEGc6D0vNzcXK5fv861a9e4fv06LS0tTJs2rVfHEoGS0O8ePHjArVu3mDdvXrsT1b5QV1dHfHw8sbGxVFZWYmdnx/z58wkMDMTIyIiKigpu3rxJSkoKRUVFuhBp6tSpeHl5dR0i/UNNTQ2HDx/Gzt2Ljd/7/4jY+wn5MXegqVF3HSMzc4LnLSJg9gIshr3+MzQkSeLs2bNYWloyderUgS6nT40ZM4bY2FjOnTvHO++80+WLf0lJCSdOnKC8vJy5c+d2uHzK2tqatLS0Pq0xOzuburo6AgICOHPmDJ6enlhbdz3m1c3NjaVLl3Lq1ClsbGyY3M15C3K5nDFjxnDr1i0ePXpEQ0MDxsbGSJLEnTt3uHTpEgEBASxbtgyFQqGbFdXS0qI7hkqlwtLS8pX9Im1ububIkSPk5uaybt06fHx82l1HJpMRFhbGl19+SWVl5Qsfv64olUpKSkrQarXI5aK5V3hmypQpTJkyZaDLEAah/x3oAoSh5z//c6ArEAThNZWXl8fVq1d1S96ePn3KpEmTmD59Ou+88w7jxo3r9TgaESgJ/So7O1vXCTJhwoQ+O64kSeTl5RETE0NqaioAo0ePZuXKlTg7O6NSqYiJiWkTInl5eTFlyhQ8PT179AOjVqt1czLWr1+PiZkZpTIDPFdtYfa0KTTX16NvaISptRK9IbQDVGJiItnZ2WzevLlbodvrRC6Xs2DBAj799FMePHigGyz9PEmSuHv3LpGRkdjY2PDOO++0mbv1PBsbG1QqFRqNpk92jwNISkpCqVQiSRKFhYVs2LChW7cLDg6moqKCy5cvY21tjZ+fX7duN3bsWG7cuIEkSSQnJzN27FguXLjA/fv3mTx5cpulZK2B0lc7lF7Vcrf6+noOHjxIWVkZmzdvxs3NrdPrtm6JGhsb+1LdI8OHD6e4uJiysrJOnwfC0PbHP/6x29f9t3/7t36sRHgdeAA3BroIYWh5/Bh62UEgCELH3pQOJVdXV0aOHMnXvvY1vva1rxESEtJn5yxD5+xXGHSePn3K0aNHcXV1ZeHChX3yA9bQ0EBCQgKxsbE8ffoUGxsbZs+eTVBQEE1NTaSkpHDu3DmKiopQKBSMGjWKyZMn4+Xl1avUVZIkzpw5Q1FRETt27MDc3JzCwkIqKipYtGgR5sphoHzpL2vQaWho4OLFi/j5+eHp6TnQ5fSLkSNHEhgYSGRkJH5+fm0GWVdXVxMeHk52djYTJkxg9uzZXe7g1hr8qFQqbGxsXro2tVpNamoqEyZMIDY2FgsLix4t2Zo5cyYVFRWcPHkSS0vLbg2StrS0xMvLi9zcXB48eMDjx4959OgRixcvbrOzHHQeKL2KgdXV1dV89tln1NXV8dZbb+mWs3ZGX1+f4OBg4uLimDFjRq934vPy8iIuLo6MjAwRKL2hfv/737f5/7KyMurr63VBqkqlwsTEBDs7OxEoCawE9g50EcLQcvIk7Ngx0FUIgvAaWrduHdeuXePXv/41t27dYvr06cycOZMxY8a89Dm6CJSEftHaQWBmZsbatWtfKgGVJImCggJiY2NJSkpCq9Xi6+vLokWLsLKyIiUlhc8//5zCwkIUCgVeXl4vFSI97969e8THx7Ny5UrdyXJycjImJiZddkW87iIjI2lpaWH+/PkDXUq/mjNnDqmpqVy9epUFCxYAzzqDzpw5g76+Plu3bsXd3f2Fx1Eqn6WK5eXlfRIoZWRk0NTUhJeXF/v27WPy5Mk9WmYlk8lYsWIF+/bt49ChQ7z99tvd6h4KCQkhPT2dwsJCSktL2bBhA6NGjWp3vdaOtecDJZVK1e1uqN4qLy/nwIEDSJLEjh07uj3XKywsjHv37pGcnExQUFCv7tvFxQWAnJwcscTpDZWdna3798GDB/nLX/7C7t27dUu5Hz16xDvvvMN77703UCUKgiAIgtADcrm8T0cZDNaxCIcPHwYgLS1Nt+ztt7/9LY2NjUyZMoXp06czY8YMwsLCenxsESgJfa51iVhTUxNvv/12j7Ywf15TUxOJiYnExMRQUlKClZUV06dPx83NjdzcXC5fvtwmRJo4cSKjRo166RCp1ePHj7l48SKTJk0iMDAQQLccyM/Pb9C+YLysJ0+eEBsby4IFC7CwsBjocvqVubk506ZNIyoqCn9/f6Kjo3n48CGjR49m8eLF3R4wbWFhgUKh6LPB3ImJiTg6OlJQUIBare5wSd6LKBQKNmzYwCeffMLBgwfZuXPnC38Wra2tkclkSJKEv79/h2FS67Hhn4FSU1MTjY2N/brkraioiM8//xxjY2O2bNnSZij6i9jY2ODu7k50dHSvAyVjY2P09fXFYG4BgB/96EccP368zVxAb29vfv/737NmzRo2b948gNUJg8HqgS5AGHq++GKgKxCEIedNWfLWysfHBx8fH772ta8BkJKSwsGDB/nv//5vvv/977d5s7i7RKAk9ClJkoiIiODJkyds27atV0Nwi4qKiImJITExEbVajbe3NxMnTqS2tpbU1FQiIyP7LURqVV5ezvHjx/Hw8GD27Nm6zz958oSqqir8/f379P4Gi9Yt2B0dHXuVUL+OJkyYwP3799m7dy8KhYKVK1cSEBDQo18IMpkMa2vrPgmUmpqaSE9PZ+bMmcTExODj44O5uXmvjmVqasqmTZvYvXs3x48fZ+PGjZ12C+bn53Po0CGMjIxobGwkKysLSZI6fBy+GihVVVUB9Cjk6Ync3FwOHTqEjY0NmzdvxsTEpMfHCAsL48iRIxQWFr5wmVxnrK2tKSsr6/RxEd4cRUVFHf7RpdFoKCkpGYCKhMHmz8D7A12EMLR8/evw8ccDXYUgCK+5kpISrl69qhvSnZ6ejqGhYa83YRKBktCnbt68SUJCAqtWrWLkyJHdvl1zczPJycnExMRQWFiIhYUFISEhGBgY8PjxY8LDw9HT08PLy4tVq1YxatQoDA0N++VraGxs5PDhw5iamrJ69eo2nUhJSUmYm5v36Gt7ndy/f5/i4mLefvvtIduB9Ty1Ws2VK1eoqakBYMGCBbputJ6ysbHpk0ApNTUVjUaDUqmkrKxMtxSvt2xtbVm/fj2fffYZ586dY/Hixe3CkNTUVE6cOMHw4cNZvHgxH330EdXV1eTk5HS4tLM1lGo9oVapVAD90qH06NEjjh8/zogRI1i/fn2vf+5HjRqFhYUF0dHRLF++vFfHGD58OKWlpZSXl3d7uZ0wNM2ePZv33nuPTz75RNdBGBsby9e+9rWXGv4uDB2OA12AMPQUFQ10BYIw5LwpHUpHjx7VhUiPHj1CX1+fsLAw1q1bx8yZM5k0aVKv/8YWgZLQZ5KTk4mKimL69OkEBAR06zalpaXExsaSkJBAU1MTrq6uBAcHU1ZWxt27d19ZiNRKq9Vy4sQJampqeOedd9osEdJqtaSkpODv7z9oXyxeRnV1NVeuXCE0NPSVDFceaKWlpZw8eZLS0lLmzJlDTk4Ot27dIigoqFe72llbW5OWlvbSdSUlJeHi4kJqaipKpbJPZnW5ubmxZMkSTp8+jVKpZNKkSbrL7t27x/nz5xk9ejQrVqxAoVDg7e1NRkYGCQkJHd6/TCZDT0+vTYeSXC7HzMzspWt9XkJCAqdOncLHx4dVq1b1eqA2PFvTHhoayvXr15k3b163lzM+z9PTk/j4eDIyMkSg9Ibbs2cPb731FqGhoW1mis2fP59PPvlkgKsTBoOYgS5AGHq+skGGIAhCd23ZsoXQ0FBWrlzJzJkzmTx5cq/+Fu6ICJSEblM3N9NQU41MJsPYwgI9xT9PugsKCggPD8ff35/p06d3fRy1mpSUFGJjY8nLy8PExIThw4fT0NBATk4Oenp6eHp6vrIQ6XlRUVFkZmayadOmdsOVc3Nzqa2tZfTo0a+snlfpwoUL6Ovrt1niNxRJksS9e/e4fPkySqWSt99+G0dHR3x8fPjLX/7C7du3X/gc7oiNjQ0qlQqNRtPrIfS1tbVkZWUxZ84coqKimDVrVp+Fl2PGjKGiooJLly5hbW2Nj48PFy9e5O7du0ycOJG5c+fq7iskJIS0tDSSk5NZtGhRh0tKFQpFmw4lCwuLPu1qu3v3LhcuXGDMmDEsWbKkT449duxYrl69Snx8PBMnTuzx7VvDtZycnF7dXhg6bG1tOXv2LOnp6aSmpiKTyfDx8el07pjw5tk/0AUIQ8+2bQNdgSAMOW9Kh1JlZSWmpqb9cmwRKAldkiSJJ6lJxF88Q8a920haLQB6Cn18p84geN5iDJXDOHToEI6OjixfvrzTH6Ty8nJiY2OJj4+noaEBpVKJjY0N5eXl5OXl4enpycSJE/H29n6lIVKrxMREbt26xdy5c/H09Gx3eVJSElZWVkOyeycjI4OUlBRWrVrV6yHqr4Pq6mpOnTpFVlYW48ePZ/bs2bruAhsbGyZMmMDNmzcJCgrq8fItpVKJJEmoVKpe7/SWkpKCTCajqakJgODg4F4dpzOzZs2ioqKCEydO4OzsTE5ODgsXLmTcuHFtrufh4YGFhQXV1dWkpaV1uAxQX1+/TYdSXy13kySJK1eucOPGDSZNmsScOXP67Jezqakpo0ePJjo6mgkTJvT4uCYmJigUCjEjR9AZNWoUXl5ewOD9I1IYGH8Eere4VhA68W//BqdPD3QVgiC8hvorTAIRKAldaKqv58vf/w+5Dx8gk8t1YRKARt1C8rUokq5cQs/eCYWbD+vXr2+3JEWj0ZCWlkZsbCzZ2dno6+vrAouqqio8PDyYNm0ao0aNGtAgo7CwkNOnTxMUFNRh54FGoyE1NZWxY8cOuZOGlpYWzp49i5ub25AdNg7Pwpovv/wSfX19tmzZgoeHR7vrTJs2jYcPH3Lp0iXWrl3bo+MrlUrgWXDa20ApMTERDw8PEhMTGT16dK+GT3dFJpMxb948MjMzycnJYcmSJYSEhHR4vbCwMKKiooiLi+swUHq+Q6mqqqrXX/PztFot586dIyYmhjlz5jB58uSXPuZXhYWFkZiYyOPHjzsMjl/EysqKiooKMZhbYP/+/fz2t78lIyMDeBYuffvb32br1q0DXJkgCIIgCN0hl8v7tMP+TZhB+1UiUBI61NLcxPH//iEl2ZkAbcKkVpJWA4C6pIARdrYYG/8zEKqsrCQuLo64uDjq6+t1HUdqtRpHR0dmz56Nt7f3oOiGqamp4fDhw9jb27NkyZIOTxKzs7NpaGgYkoHLjRs3qKmpYcuWLUPyBLmpqYlz586RkJCAn58fixcv7jSoMTQ0ZM6cOYSHh5Odnd2j+UUWFhYoFIpeD+aurKzkyZMnTJ48mYyMDFauXNmr43SloqKCzz//HD09PczMzLh//z7+/v4ddgQGBwcTFRVFbm4u1dXVWFhYtLn8q0ve3N3dX6o2jUbDyZMnSUlJYenSpbpBx33N2dkZe3t7oqOjexUoOTo68vTpU1QqVa92sRSGht/97nf86Ec/4utf/7ou+Lx58ybvv/8+T58+5T/+4z8GuEJhoP15oAsQhp6vf32gKxCEIedNWfLWn0SgJHTo5qH9lGRlIkntg6SvkgFPEuOJO3sacy8/7t69S05ODjKZTPcu/siRIxk9evSgCZFaqdVqjh49CtBhh1WrpKQkbGxssLe3f5Xl9buysjJu3brF1KlT+6TDZLDJzc0lPDyc+vp6VqxYQWBg4Atf6AMDA4mJieH8+fO899573X6nQSaTYW1t3etAKSkpCX19fcrKyrC3t8fZ2blXx+lMQUEBBw8exMjIiLfffhuNRsPu3bs5fvw4GzdubPd1mpmZ4e3tTVpaGgkJCe22ElUoFLS0tKBWq6mtrX2pJW/Nzc0cPXqUnJwc1q5di6+vb6+P9SKt3VcRERGoVKoe1+3p6UliYiKZmZmEhYX1T5HCoPenP/2Jv/71r2x7bqbJsmXLGD16ND/96U8HZaBkaWnZJ8eRJKlPjjPUDb3fqP1jsD6f+uqksE+/vkOH+u5Ywis3KJ9TgtAH3ryeLOGFmhsbeBh5vlth0vOuHj7A4UOHdGGSu7s7y5cv5zvf+Q6bNm0iKChoUIVJkiRx5swZioqKWL9+Pebm5h1eT61Wk5aWNuR2d2v9+q2srJgyZcpAl9OnNBoNkZGR7N27F3Nzc95//32CgoK69f2TyWQsXLiQ0tJSYmJ6tk+PjY3NSwVK7u7uZGRkEBIS0qfPtUePHrF3716USiW7du1CqVRia2vLunXryMrK4ty5cx3+gdI6Wyk2Nrbd5a0dStXV1UDvT1YbGho4cOAA+fn5bN68uV/DpFYBAQEYGhr2+PsL6DqxsrKy+ros4TVSVFTUZrfEVpMmTaJIbO0tABsHugBh6BGBkiD0udYOpb78eB1kZmZy4cIFGhoagJcLKkWgJLSTeuMq6n8MBe4JWUszDsYGLF++nG9/+9ts2bKF4ODgQRUiPe/evXvEx8ezbNmyLgdtZ2Zm0tTUNOR2d3v48CG5ubksWrTopbZjH2zKysrYvXs3t2/fZtasWWzfvr3HS5OGDx/OmDFjuHLlCvX19d2+XW87lEpKSigtLUWhUKCvr9/hzKLeun//PkeOHMHLy4tt27a1We7n7u7O4sWLiYmJ4e7du+1u6+rqirm5OVVVVe1OkhUKBRqNBpVKBdCrDqWamhr27t1LeXk527Zt69ESw5dhYGBAcHAwDx480C3b6y4zMzP09PTEYO43nKenp6679XmtP2uCIAiCIAiDTXl5OXPmzGHUqFEsWrRI9/f9rl27+Na3vtWrY4pASWin8FEKsl4MFJPp6THaZQTBwcEYGxv3Q2V95/Hjx1y8eJFJkya98OQ9OTkZe3t7bG1tX1F1/a+hoYGLFy/i7+/f4XDq15EkSdy/f5+//e1vtLS0sGvXLqZOndrr4XizZ89GkiSioqK6fRsbGxtUKhUajaZH95WUlIShoSF5eXm67pmXJUkSly5d4ty5c4wbN441a9bodrR73tixY5k0aRIXL14kLS2tzWUymYzx48cDtOvmae1QqqqqAmg3Y+lFKioq2LNnD42NjezcufOV754YGhpKfX09KSkpPb6tlZUV1dXVou38Dfazn/2MH//4xyxYsID/+q//4r/+679YsGABP/vZz/j5z38+0OUJg8DmgS5AGHo+/3ygKxCEIedN61D6j//4DxQKBXl5eW3eZF6/fj3nz5/v1TFFoCS009zY0OEQ7heRAc0N3e/mGCjl5eUcP34cDw8PZs+e3eV1m5ubefTo0ZDrTrp8+TIajYZ58+YNdCl9oqamhoMHD3Lu3DnGjBnDu+++y/Dhw1/qmKampsyYMYPY2NhuL2FRKpVIkqTr2ukOSZJISkrCycmJmpoaQkNDe1nxP6nVar744gtu377N/PnzWbBgQZfB2pw5c/D19eXEiRMUFha2uWzMmDHIZDISExPbBGWtgZJKpcLMzKxHXW7FxcXs2bMHPT09du7cybBhw3r+Rb6kYcOG4e7uTnR0dI9v6+DggEajoaamph8qE14Hq1ev5t69e9jY2BAeHk54eDjDhg3j/v37/TJQX3j9/HKgCxCGnv/v/xvoCgRhyHnTAqWLFy/y61//ut2sVi8vL3Jzc3t1TBEoCe0YGBn3qkMJwGCQdyY1NjZy+PBhTE1NWb169Qu7V9LT02lpaRlSu7vl5+cTFxfHrFmzOp0b9TpJTU3lr3/9K8XFxWzevJlFixZ12InTG2FhYdja2nY6Y+irlEol8Cy07K4nT56gUqlobGzE2dkZBweHXtcLz7rPPvvsMx49esTatWuZMGHCC28jk8lYuXIldnZ2HDp0SNd1BGBiYoKnpydqtZr09HTd55/vUOrJcrfc3Fz27t2LhYUFO3bs6LNBwb0RFhbGkydPejzzprWrLzMzsz/KEl4TISEhfP7558TGxhIbG8tnn33GmDFjBrosYZBwGegChKGnlyd7giAIrerq6jrc7bqioqLXKyREoCS0M9zbt1cdSlqNhuHe/T9Qt7e0Wi0nTpygpqaGjRs3dmu2U3JyMk5OTkNme3CtVsuZM2dwdHTsk06YgdTU1MSpU6c4evQoLi4ufO1rX+vVNvBd0dPTY8GCBeTn55OUlPTC61tYWKBQKHo0RykpKQlTU1MKCwsJCQl5mXJRqVTs2bOH0tJStm3bhp+fX7dvq6+vz4YNG9DT0+PQoUM0PTdHrXVb9OfnLLXu8lZVVdXtUCg9PZ3PPvsMR0dH3nrrLUxNTbtdX38YNWoUFhYWPe5Sag2UxGDuN49cLkdPT6/Lj6E0k07ovRf/xhCEHhpCb24KwmAhl8v7/GMwmzp1Kvv379f9v0wmQ6vV8pvf/IaZM2f26pjirx6hHd8pM7i6fzfq5p4N5ja3GYZr0Nh+qurlRUVFkZmZyaZNm7CxefGGvo2NjWRkZLxwWdzr5N69e5SWlvL2228P+he8ruTn53Py5Enq6upYtmwZwcHB/dZi6u7ujq+vL5cuXcLb2xsDA4NOryuTyXo0mFur1ZKcnIyFhQUajealllYWFhZy8OBBDAwM2LVrV7ee419lZmbGpk2b2LNnD8ePH2fjxo3I5XJGjhyJqakpeXl51NfXY2JioutQqq2t7dbywocPHxIeHo63tzerV68eFCfdcrmckJAQbty4wdy5c7s9+83CwgI9PT2xm9cb6OTJk51edufOHf74xz+i7cUbMsLQ8+eBLkAYer7+9YGuQBCE19xvfvMbZs+eTUxMDM3NzXznO98hOTmZiooKbt261atjvr5nlEK/MTA2IXD2fGSynj09xixchlyu109VvZzExERu3brFnDlzut3F8ujRo5c+yR9MqqqquHLlCmFhYS89X2igaDQaoqKi+PTTTzEzM+P999/XzfjpT/PmzaOhoYEbN2688Lo2NjbdDpSys7Opq6ujoqKC4ODgXi/VS09PZ+/evVhZWfU6TGplZ2fH2rVrefz4MefPn0eSJGQyGePGjQMgLi4O+OeSt+rq6hcuebt37x4nT54kKCiItWvXDoowqdXYsWPRarXEx8f36HYWFhZUV1f3T1HCoLV8+fJ2Hz4+Puzdu5f//d//Ze3atTx69GigyxQGgY8GugBh6Hn//YGuQBCGnDdthpK/vz/p6elMmTKF5cuXU1dXx6pVq3jw4EGvN2oaPH/VC4PKlI3byE9NojQnixf/WMhQm1lQLCnQarWDrvOlsLCQ06dPExgYyMSJE7t9u6SkJEaOHNnj3asGq/Pnz2NoaNjrdsaB9vTpU06ePElxcTEzZsxgypQpr+y5ZmVlxeTJk7l58yZjxozRzUrqiLW1dbvd0jqTlJSEmZkZtbW1vV7uFhsby5kzZxg1ahSrV6/uk/lRHh4eLF68mIiICJRKJRMmTCAsLIyrV68SHR3NlClTUCgUNDc3o9VqO13yJkkSV69e5fr160ycOJG5c+cOul+0ZmZm+Pn5ERMTw4QJE7pdn729PZWVldTW1mJmZtbPVQqDUWFhIT/5yU/Yt28f8+fPJz4+fkjN2xMEQRCEN8Fg+9u0v1laWvKDH/ygz44nAiWhQzI9BY2uPsgqKqG6Eplc3m6ukkyuh6TV4DNlOg4TpnPm3Dnq6uv77KS2L9TU1HD48GHs7e1ZunRpt18w6uvrycrKYsGCBf1c4auRnp5OWloaq1ev7tbsqMFEkiRiYmK4ePEilpaWA7LFPDybIxQfH8+FCxfYuHFjp9ezsbFBpVKh0WjQ0+u8Y6+lpYWUlBSMjIxwc3Pr8U5nkiQRFRXFzZs3CQsLe+FObj0VEhJCeXk5Fy5cwNraGm9vb0aOHElubi5lZWW6GUpAhx1KkiRx7tw5oqOjmT17NlOmTOmz2vpaWFgYn376KVlZWd1+d8bDw4O0tDSysrIIDAzs5wqFwaSqqopf/vKX/OlPfyI4OJjIyEimTp060GUJg8zfB7oAYeh5552BrkAQhNfcw4cPO/y8TCbDyMiIkSNH9ng4twiUhHYkSeLLL7+krKKS7T/9FVpVOef2fUJN7nMDaOVy/KbNJHjeYhw8vACwsLLi2LFj7N+/n40bN3Y4Qf5VUqvVHD16FEmSWL9+fY+W2aSmpiJJEr6+g3fIeHe1tLRw9uxZPDw8Xrvle7W1tZw+fZqMjAxCQkKYN29elzOM+pO+vj7z5s3j2LFjZGRk4OXl1eH1RxRSJwAAnMNJREFUlEolkiShUqm6XHqWkZFBc3Mzzc3NzJs3r0e1aDQaTp06RWJiInPnzmXixIn98u7K3Llzqays5IsvvmDHjh3MmDGDD45+wdejk8kzMafCfzL66hbUlY3sNGvCzcRQV194eDjJycksWbLkpYeN97cRI0Zgb29PdHR0twOl1u//48ePRaD0BvnNb37Dr3/9axwcHDh06BDLly8f6JKEQWpwvK0mDCn/eBNHEIS+09fL1AZ7t9Pzc2dbd7B+vmZ9fX3Wr1/Pxx9/3O0mBBEoCe3cvXuXhw8fsnLlymedIE5OtLh44zlxBjOnTuHMmbM0abQs2Lmzze28vLzYvn07Bw8eZPfu3WzZsmXAdkeTJIkzZ85QVFTEjh07MDc379Htk5OTcXNzGxJLWa5du0ZtbS3btm0b9C9yz3v06BGnT59GJpOxceNGRo0aNdAl4evri6urKxcuXMDd3b3DDqTW5XDl5eVdBkpJSUmYmJggl8vx8fHpdg2NjY0cOXKE/Px8Vq9e3a9LbGQyGatWrWLv3r387fgJ4ibM5l7YbGSSFkmSg/GzXdr2FFbw98IKZivN+T+v4USePEF2djZr1qzp0U5zA0UmkxEWFsaZM2dQqVQvnAkFz2YoyeVyCgsL+79AYdD43ve+h7GxMZ6enuzbt499+/Z1eL0TJ0684sqEwWY70PkId0Hohb17YdWqga5CEITX2MmTJ/nud7/Lt7/9bd181Pv37/N///d//OQnP0GtVvO9732PH/7wh/zv//5vt44pAiWhjaysLC5dusSkSZN077rX1NTw9OlTpk+fjsUwO2ydnDvdQn348OHs3LmTzz//nN27d7Np06YBGQB979494uPj/xmK9UBtbS05OTksWbKkn6p7dUpLS7lz5w7Tpk3rcu7PYNLc3MyFCxeIi4vD29ubpUuXDvj28q1kMhkLFizg448/5t69e0yaNKnddSwsLFAoFF0O5m5sbOTRo0fIZDImTZrU5dK451VVVfH5559TU1PD1q1bcXFx6fXX0l36+vpMWbWGJbEZNNQ0gEyG9JWB/Zp//PdqRQ0zbj5kdWExuzZtwt3dvd/r6ysBAQFcunSJ2NjYbu3sKJPJMDc3p6qq6hVUJwwWr1swLwiCIAhC5+RyeZ+OjBhss4S/6he/+AV/+MMfmD9/vu5zAQEBODs786Mf/Yj79+9jamrKt771LREoCT1XUVHBsWPHcHd3b3NClZOTA4CrqyvwbOhwVVUVarW6w2VkSqWSnTt3cujQIfbu3cu6deu6vbNaX3j8+DEXL15sE4r1REpKCjKZ7LVf7tbapWVtbc3kyZMHupxuefLkCSdPnqSmpoYlS5YwduzYQXfyZm9vT1hYGNeuXSMgIKBd95tMJsPa2rrLQCktLU23tfjYsWO7db/FxcV8/vnnKBQKdu7cia2tbe+/iB5o1mrZlVFMo74BL9oMXQNUKfS5OXke/+Xm9irK6zMGBgYEBQURFxfH9OnTu7VE1t7envT0dBoaGjA2Nn4FVQoDbe/evQNdgvCa2PniqwhCz+zZM9AVCMKQ86YteUtMTOzwDWkXFxcSExOBZ8viioqKun3MwR2hCa9MU1MThw8fxsTEhNWrV7dJV7Ozs7G1tdUt/2rtdFGpVJ0ez9TUlG3btuHq6sqhQ4d6vCV3b5WXl3P8+HE8PDy61WXQkaSkJDw8PF77E8SEhATy8vJYtGjRoNqmvSMajYarV6+yZ88ejI2Nef/99wkJCRm0L8ozZsxAT0+PyMjIDi9XKpVdBkqJiYkYGBgwatSobi2vyszM5NNPP8Xc3Jxdu3a9sjAJ4GxZFVkNTboupBeRZHIeNWm4VlHTr3X1h7CwMOrr60lJSenW9d3+EZplZ2f3Z1mCILyGvjvQBQhDz69/PdAVCILwmvPx8eFXv/oVzc3Nus+1tLTwq1/9SjeCo6CgAHt7+24fUwRKApIkER4eTlVVFRs2bGgXpOTk5Oi6k+CfgVJlZWWXxzUwMGDDhg0EBwdz6tQpbty4oRv+1R8aGxs5fPgwpqam7UKx7qqqqiI/P/+13/q5vr6eixcvEhAQMOiXHZWXl/Ppp59y/fp1pk2bxs6dOwf98jxjY2Nmz55NQkICT548aXd5V4FSbW0tWVlZNDc3d2tYdVxcHAcPHsTFxYXt27e/8rleu5+U9fgXhR6wp+Bpf5TTr4YNG4abmxvR0dHdur63tzfwLPATBEF4nvdAFyAMPY8eDXQFgjDktHYo9eXHYPbhhx8SERGBs7Mzc+bMYc6cOTg7OxMREcFf//pX4NkInH/5l3/p9jEHd9uC8Epcu3aNtLQ0NmzY0K7zQaVSUVlZqXsnHsDc3Bw9Pb0uOzBayeVylixZgoWFBVFRUVRVVbFo0aI+X1+q1Wo5ceIENTU1vP32292eSv9VycnJKBQK3Yni6+ry5ctotdoe7x72KkmSRFxcHBcuXMDc3JydO3fi7Ow80GV125gxY4iJieHcuXO8/fbbbX6B2NjYoFKp0Gg07eYjtXa/WFhYdLkUVJIkrl69yvXr1wkJCemXn5sXqWhRE11d3+PbaYDL5dU0a7UYDPK15F8VFhbG0aNHKSoqwtHRscvrWllZIZPJKCgoeEXVCYLwuhAxs9DnXuH4CEEQhqZJkyaRnZ3N559/Tnp6OgBr165l06ZNujEeW7du7dExRaD0hktNTeXatWvMnDmzwxCldSnH8x1KcrkcKyurF3YotZLJZEyfPh1zc3MiIiKora1l9erV6Ov33aa6UVFRZGZmsmnTJoYNG9br4yQnJ+Pl5YWhoWGf1faq5eXl8eDBAxYtWjRod6mrq6vj9OnTpKenM3bsWObPn4+BgcFAl9UjcrmchQsX8umnn/LgwYM2s5CUSiWSJKFSqdrt9JaQkIBMJiM0NLTTgEij0fDll1+SkJDArFmzmDJlyoC841HRou71bSWgSq3B1uD1CpS8vb2xsLAgOjqaZcuWdXnd1sHcXS3/FQThzfTfA12AMPT88IcDXYEgDDlv2gwleNYc8v777/fZ8USg9AYrLS0lPDwcX19fpk6d2uF1cnJycHR0bLcMTqlUdjtQajV27FjMzc05duwY+/fvZ+PGjZiYmPS6/laJiYncunWLuXPnvtTw74qKCgoLCzvcuet1odFoOHPmDE5OTt1aTjUQ0tPTOX36NJIksWHDhte6G2zkyJEEBAQQGRmJn5+frjOudcleRUVFm0CpsrKSwsJCZDIZY8aM6fCYjY2NHDt2jJycHFauXNmrwfJ9xeAlfym+7O0HglwuJyQkhBs3bjB37twXzlKzs7MjMzOT5ubm1y4UFd4shwATYDPwS8AFSAL+DHz0j+v8HdDn/2fvvuOjuO/E/7921btWAvUCSBTRRBO9m45Fb8aYaps4cZqTfC+53MXJ3eWc5H6Xdolt3HBs0zG9FwnRe5VAAoQqQgLUe9md3x+yFGQEqIw0q9X7+XjIWLuzM+8ZzZZ57/vz/lRPeQ/VjaX/herhW3f5JklSk2h97TVwdIQ1a6p/f//96v+/dg0CA+F//gcWLaq+b8EC8PWFv/yl+vc//Yl/Cw1lMPAQWA1s/2abO4EE4P998/vPgenAKKAAeA34muoPsAeB88C/f7Psr4ERwESgHFgArAOcgRjgEPDbb5b9HdAbqJnPdSbwGeAJnAG2Av/7zX1/BIKAed/8vgD4E+APXAE+/eY4ArwPuAE53t4weDB8+SW8+y7cuwdhYfDOO/DGG98c4G9ad9c0W/74Y/jjH+HWLejSBX7zm+rjDPDqq+DmVn2cAf72N/j0U7hyBfz94U9/qj7OAPPmQVBQ9boA/vd/YetWOHMGPD1h7dp//h1ffhl694bf/a7699/+Fg4dgpgYcHaG9eth/nwoL4eJE2HECPj1r6uX/fd/h/Pn4eBBsLaGbdtgyRIoKIBRo2D6dPj5z6uX/X//r3rI1s6d1b9v3w6rV1fHMXgwvPIK/PjH1ff98Ifw4AFs3lz9+8aN8LOfQVoahIdXP65mOMbq1VBSUn2cAT7/HP7rv+DuXejeHf7lX/55nJcvBxub6uMM8OGH1ccxNhaCg+G//7v6OAPK+vXVx+pv3/xl//pX+OILuHix+lz+299g7tzq+2bPhpAQqJkR6Q9/qN7PU6dg2TL4xz9g1iwwmWDaNOjfv/o4A/zHf8CxYxAVBQ4OsGkTLFwIpaUwfjyMHQu/+lX1srm51fHt2wd6PezYUb3+3Nzqv8vMmdXHGeCnP4XExOrjDPD11/D22/DgAb/avZsvgL9+c87+jerz/pVvfm/ua8Tn39z3JVBC9fMb4Lvf/H84kAb8DNj4zX2bgQfAD7/5/cffxGNJrxHfnPm1rxGvfvP7a8BvgC7ArW/W9c0ZSk0b9pom/28Av9fpCAPuAe9SfZz5Zj/yqT7OAG8Dq4D+wP1vjuk3zyi2AqnAO9/8/pNvYh8GZH+zvZp491B9HnzzTOaXwCRgDFD0zX5sBuyAw8Apqo8zwH9S/TecDFQBc7+J1xU4Aeyl+jgD/AHQYjqX9pBQ2rVrV4OXfdGXqfXRKS3Z1EaYrdLSUj7++GNsbGxYtWpVvRdCiqLwpz/9id69ez81dGr//v3cu3eP733ve43e9v3791m/fj0ODg68+uqrGAyGJu9HRkYGa9eupWfPnsyaNatZT+Ljx49z8uRJfvazn6laPdWaTp06xdGjR3njjTdeOFyntVVUVHDo0CEuXbpE165dmTFjhtlWUDVGQUEBf/vb3xgwYABTpkwBqp87//3f/81LL73E0KFDa5c9fvw40dHRhIWFsaDmg/+31rV+/Xry8vJYuHBhnaGmWigzmgg7eYNSU+PfJgzWVsSN7I3eDN9YX6SoqIg//elPTJw4sc7frz6nTp3iyJEjvPLKK3Tr1q2VIhSi4QoKCnBzc1NtfWp9bDTHD91qUiIjoREf4oV4oRkzVDmnLP25J9q+/Px8XF1dW3QbNe+N//jHP1QpcKhRUlLCsmXLWmUfGurbIyJ0Ot1T7+U1rwtGY0On4Xli/U0PTbRVJpOJrVu3UlZWxqJFi575rXp2djaFhYX1XtQaDAZyc3Ob9MHS39+fVatWYTKZ+PTTTxs1LeGTioqK2LhxI97e3kRGRjb7DTIuLo4ePXq02WRSXl4eMTExDB482OySSffv32fNmjVcu3aN6dOn88orr1hEMgmqeyGNHj2a8+fP8+jRI6D6RdlgMDzVZ+zKlStAdZ+eb8vKyuKTTz6htLSUlStXap5MArC30rPQ1xOrRj61rIBl/h3aZDIJwNnZmZ49e3LhwoUXvsbVVNjduXOnNUITQrQVjexBIcQLyTklhOr0er3qP+bGZDLV/hw6dIh+/fqxf/9+8vLyyMvLY//+/QwYMIADBw40af3mt8eixR0+fJikpCTmz5//3Oqg5ORkdDodQUFBT93n4eGB0WikoKCgSTF4eHiwatUq3Nzc+Pzzz0lMTGzU46uqqti0aROKorBw4UKsrZs3evPhw4c8fPiQXr16NWs9Wjpw4AD29vaMGzdO61BqmUwmYmJi+PTTT7G3t2f16tUMGjTI4r4dGzp0KO7u7uzfv782AfHtmd6ysrLIy8vDxcWlTk8yqJ5NYe3atTg5OfH666/j5eXVmuE/1zI/T4yNzBubgCV+ni9czpwNGjSInJwc7t2799zlPD090el09c72J4Rox1T8xlsIQM4pIUSz/ehHP+Ivf/kLkydPxtXVFVdXVyZPnswf//hHfvCDHzRpnZJQameuXbvG2bNnmTx58gsrIJKSkvD396+3QXVNIqqxfZSe5OTkxLJlywgODmb9+vVcu3atQY9TFIW9e/fy4MEDFi1aVNuRvjni4uKws7MjJCSk2evSQnx8PAkJCUyZMsVsGorn5OSwdu1aYmJiGDVqFCtXrmxWw3RzZm1tzZQpU0hKSiI+Ph54OqF0+fJloDr59GRC7erVq6xbt46AgACWL1+uyvmspjBnB74b2LgE1887+xJg37b7CQUFBeHl5cWFCxeeu5xOp8PZ2blZr4VCCAtU01tKCLXIOSWE6mp6KKn5Y84SExNxd3d/6nY3NzeSk5ObtE5JKLUj9+/fZ/fu3fTr14/Bgwc/d1lFUUhOTn5m0qkmofTtIT2NZWtry6JFiwgPD2fHjh2cOHHihUNMzp07x9WrV4mMjMTf379Z24fqfY2NjSUsLKzZlU5aqKioYP/+/YSGhhIWFqZ1OCiKwuXLl/nwww8pLi5mxYoVjBs3DisrK61Da1Fdu3YlNDSUgwcPEXXzAR/d0rHmQSD9/+MQY/4nmg/OPqRAsa9txq0oCjExMezcuZPw8HBeeeUVs0kGftu/hfiy4puKI90znp81w+J+FOzND4LNp8KqqXQ6HREREdy+fZv8/PznLtuxY0fKy8upqmr6rHhCCCGEEKJ1tbeEUkREBO+88w5ZWVm1t2VlZfGzn/3shfmBZ5GEUjtRWFjIpk2b8PHxYfr06S882R8+fEhJSckzE0rW1ta4urqq8q28Xq8nMjKSMWPGEBUVxb59+zCZTPUum5iYyKFDhxg2bBjh4eHN3jZAZmYmOTk59O7dW5X1tbaYmBhKSkqYOnWq5i9ixcXFbN68md27d9O7d29Wr15NYGCgpjG1Fp1Oh1+f4XySFcjKLy5zJbOCYsWW3JJKUrJLuFHuyddlvfn+5lhyi8rYvXs3x44dY+zYsURGRpp1wk2v0xGZnc7UuHMMdPxn5ZHuiX/HGFzYGN6Fn3fx1fw8VEvfvn2xtbXl4sWLz10uODgYgJSUlNYISwjRFtTMxiaEWuScEkI002effcaDBw8ICgoiNDSU0NBQgoKCuH//Pp9++mmT1tn2yjFEo1VVVbF58+ZG9RtKSkrCysqKgICAZy5T05hbDTqdjrFjx+Lq6sqePXsoKipizpw5dRpkZ2dns3XrVkJCQpgwYYIq2wWIjY3F0dHRLJogN1ZWVhZnz55lzJgxtVPVa+XOnTvs3LkTk8nEwoUL6dGjh6bxtLYzidm8uekWVUp1ldG3+w4p36RfouIfMul/DjHZKpZ5M2fSr1+/Vo608QoKCoiJOcb88HCmDe1FYkkZlwpKKDaacLHSE+HmRLCDeVZXNYetrS3h4eFcvnyZMWPGPPO1s0ePHkRHR3Pnzp02O2xWCKGyNWvgP/9T6yiEJZFzSgjVqV1VZO5fqoaGhnL9+nUOHz5c26YjLCyMCRMmNDl2SShZOEVR2LdvHw8ePGhUf5akpCQCAwOfO+OZh4cHmZmZaoUKwIABA3B2dmbr1q188cUXvPLKKzg6OlJeXs7GjRtxcnJi7ty5qnXQVxSFuLg4wsLCzLIr//PU9JLy8PBg+PDhmsVRWVnJoUOHuHjxIqGhocyYMcPs+gC1tKyCMl7/xwWMJoUX9a82KfC4XE9C4PA2kUwCOHjwIDY2NowfPx6AEEd7QhztNY6qdQwaNIjz589z69Yt+vTpU+8yHTt2RKfTkZaW1srRCSHMVgP7QgrRYHJOCSFUoNPpmDRpEpMmTVJlfW3rClo02oULF7hy5Qovv/zyc6uNnmQymUhJSXlhxY6aFUpP6tatG8uWLSMnJ4fPPvuM7Oxsvv76awoLC1m0aBH29updyKanp5Ofn98mh7tduXKFtLQ0pk2bplnvp4yMDNasWcPVq1eZNm0aixcvbnfJJIB151IprTRiauBsaAo6LqQVk5BZ2LKBqeDu3bvcvHmTyZMnq/rcays6duxI586dn9ucW6fT4ejo2OyeckIIC9JOhnuLViTnlBCq0+v1qv+Yo2nTptXpCfq73/2OvLy82t+zs7Pp2bNnk9ZtnnssVJGcnMyBAwcYMmRIoyohHjx4QHl5+QsTSh4eHpSVlVFaWtrMSJ/m7+/PqlWrMJlMrFmzhrt37zJv3jzVZwmLi4vDxcWFoKAgVdfb0kpKSjhy5Ah9+/bVZKieyWTixIkTfPrpp9ja2rJ69WoiIiLMvsyzJVQaTXx1JqXByaQaVnodX5017547VVVV7Nu3j06dOrXJpKtaBg0aRFpa2nMrMjt27EhZWRlGo7EVIxNCmK3/+R+tIxCWRs4pIVTXXppyHzx4kPLy8trf//u//7vOF6FVVVUkJCQ0ad2SULJQeXl5bNmyhU6dOjW6nC0pKQkbGxv8/Pyeu5xaM709S81QrsrKSvR6vepPUJPJRFxcHD179jTbbPKzHD58GEVRVCtVbIzc3Fw+//xzoqOjGT58OKtWrVI90deW3LifT05JRaMfZzQp7I990AIRqefkyZPk5+c3qJG/JevRowcuLi7PrVKqSUqnp6e3VlhCCHO2aJHWEQhLI+eUEBbp73//O506dcLe3p4hQ4Zw/vz5Bj1u48aN6HQ6Zs2a9cJlvz2L+otmVW+MtnUVLRqkoqKCjRs3Ymtry7x58xqdLElOTiY4OPiFs07VNIFuiWFvUD2c6uDBg/Tu3ZvOnTuzfv16rqk4fjw1NZWioqI2V3mRkpLC1atXmTBhAk5OTq22XUVRuHr1Kh9++CGFhYUsX76cl156yaxnJ2sN+SWVTX5sYZn5TjOfk5PDyZMnGT58eLtOGEJ1OfTAgQO5ceMGZWVl9S5T04S+qd/uCCGEEEKI1qV1hdKmTZt45513ePfdd7l8+TLh4eFMnjyZhw8fPvdxycnJ/PSnP2XUqFHN2X1VSELJwiiKws6dO8nJyWHRokU4Ojo26vFGo5GUlBQ6der0wmXt7e1xcHBokQqloqIiNm7ciLe3NzNnzuSVV14hPDycHTt2cOLECVWyqrGxsbi5ueHv769CxK3DaDSyd+9eAgICGDBgQKttt6SkhC1btrBz50569uzJd77znTY3TLCl2Fk3/WXUthmPbUk1zfydnZ0ZPXq01uGYhQEDBmA0Grl69Wq99/v4+ABIY24hRLUFC7SOQFgaOaeEsDh//OMfeeONN1ixYgU9e/bkww8/xNHRkc8+++yZjzEajbz66qv85je/oUuXLg3aTn3JLrVGH8gsbxbm5MmT3Lx5k/nz5+Pt7d3ox6enp1NVVdXgvjwt0Zi7qqqKTZs2oSgKCxcurG04HRkZiaurK1FRURQUFDB16tQmD1UzGo3cunWL/v37t6mhPGfOnOHx48e8+eabrRb33bt32blzJ0ajkfnz5ze5YZul6tLRGZ0OGpvj1Ougq5dzywTVTLdu3SIxMZFFixY9d6bH9sTFxYWwsDAuXrzIkCFD6n1TdnR0JDs7W6MIhRBmxddX6wiEpZFzSgjVqd33qGZdBQUFdW63s7PDzs6uzm0VFRVcunSJX/ziF7W36fV6JkyYwJkzZ565jf/4j//Ay8uLVatWceLEiQbFpSgKy5cvr42hrKyM73znO7WjXZ7sr9RY5vn1uGiS27dvExUVxejRo5t80Z+UlIS9vX3tt+0v4uHhoWpCSVEU9u7dy4MHD1i0aFGdGcN0Oh1jx44lMjKSS5cusWXLFiormzbcKCkpiZKSEnr16qVW6C0uLy+PmJgYhgwZ0uC/T3NUVlayf/9+1q1bh7e3N2+99ZYkk+rh42bP+O5eWOkb92ZkUmDpsE4tE1QzlJeXc+DAAbp370737t21DsesREREkJ2dTVJSUr33d+jQgdLSUlXHpQsh2qi//EXrCISlkXNKCNW11JC3wMBA3Nzcan/ee++9p7b9+PFjjEbjU0Ug3t7ez5wI5uTJk3z66ad8/PHHjdrPZcuW4eXlVRvPkiVL8PPzq/3dy8uLpUuXNmqdNaRCyUI8fvyYr7/+mu7duzN27Ngmryc5OZlOnTo1uPLHYDCQkqLeTFXnzp3j6tWrzJo165lD0QYMGICzszNbt27lyy+/bNLQvri4ODw9PVslMaOGmiFIDg4Ozfr7NtSDBw/Ytm0beXl5TJkyhcGDB7epSq7WtnR4J47GP3+s85N0gKuDNVP7mN/5d+zYMUpLS5kyZYrWoZidoKAgvLy8uHDhQr0lxoGBgaSmpnL//n0CAgI0iFAIIYQQQmgtLS0NV1fX2t+/XZ3UFIWFhbz22mt8/PHHje5vunbt2mZv/1mkQskClJWVsXHjRlxdXZk9e3aTL/wrKytJS0trUP+kGgaDgcLCwiZXCj0pMTGRQ4cOMWzYMMLDw5+7bLdu3Vi2bBnZ2dl89tln5OXlNXg7VVVV3Lp1i169erWZJEl8fDx37txh6tSpqrwgPYvJZOLkyZN88sknWFtb8+abb9Y7vEfUNbprB+b290fHiytTdN/853/n98PO2rwammdlZXHu3DnGjBmDu7u71uGYHZ1Ox6BBg0hISCA/P/+p+2squqQxtxCCP/1J6wiEpZFzSgjV6XQ69Hq9aj8110yurq51fuq7fuvQoQNWVlZkZWXVuT0rK6veoofExESSk5OJjIzE2toaa2trvvjiC3bt2oW1tTWJiYktc5BeQBJKbZzJZOLrr7+muLiYRYsWNSvZkJqaislkanD/JFBvprfs7Gy2bt1KSEgIEyZMaNBj/P39WblyJSaTiU8//fSZpYHflpiYSHl5eZuZ3a2iooIDBw7QtWvX2pmkWkJeXh7/+Mc/OHr0KMOGDeP111+nY8eOLbY9SzPG8T5drKob1Fs9I/9mpddhpdfxl0X9mdCz8T3OWlLNcFNPT0+GDRumdThmq2/fvtjY2HDp0qWn7qupqpTG3MIc5efnoyhKs3+0mAWntahxfGp+2LBB690RFubfQkNVee6peZ6r+pwRrU7rv/m3f+r7ss6S2draMnDgQI4ePVp7m8lkqr0W+7YePXpw48YNrl69WvszY8YMxo0bx9WrVwkMDGzN8GvJkLc2LioqisTERBYvXoynp2ez1pWUlISTk1OjkggGgwGoTih5eXk1abvl5eVs3LgRJycn5s6d26hG256enqxcuZINGzawdu1aFixYQEhIyHMfExsbi5eXV5tJlhw7doySkhKmTp3aIh/CFUXh+vXr7N+/H3t7e5YvX05wcLDq27FkZ8+e5crli/x+9nRyHAL4/HQypxPrNme2t9Ezb2AAy4Z1oqu3yzPWpJ2rV6+SlpbGsmXLsLIyr8opc2JnZ0d4eDiXL19mzJgxdY6VXq/HwcGBx48faxihEMIsnD+vdQTCwgzWOgAhLFBLNeVuqHfeeYdly5YxaNAgBg8ezJ///GeKi4tZsWIFAEuXLsXf35/33nsPe3v7pwoiakYUaFkoIQmlNuzGjRucOnWKiRMnEhoa2uz11fRPaswTwcXFBWtra3Jycpq0TZPJxLZt2ygsLOT111/H3t6+0etwdnZm2bJlbNmyhfXr1zNjxoxnDpmrqKggISGBUaNGNSne1paZmcnZs2cZN25cbfJOTaWlpezdu5e4uDj69u3L1KlTm/Q3aM9u3brFoUOHGDFiBIMGDQJgUi8fkh8Xk5BVSFmlEVcHGwYFG3CxN88Z00pKSjh8+DB9+/Zt1JDX9ioiIoILFy5w8+ZN+vTpU+c+T09P7t+/X1vJIYRop5r4JZsQz9LwTo1CiIbSOqG0cOFCHj16xK9+9SsyMzPp168fBw4cqG3UnZqa2uRZzVuLJJTaqAcPHrBr1y769OmjyvCUsrIyMjIy6N+/f6Mep9PpMBgMTR7yFh0dzZ07d3jllVca3VzsSba2tixatIg9e/awY8cOCgsLGTFixFNP6jt37lBZWdkmZnd7cgjS8OHDVV//vXv32LFjB5WVlcydO7fNDAE0J+np6Wzbto1evXrx0ksv1bmvUwcnOnVw0iiyxjly5Agmk4mJEydqHUqb0LFjRzp16sSFCxeeSigFBgaSnp7+zPHvQoh2Ys0arSMQFma11gEIIVrE22+/zdtvv13vfceOHXvuYz///HP1A2ok8053iXoVFxezadMmOnbsSGRkpCpZ1dTUVBRFaVT/pBoeHh5NSijduHGDkydPMmHCBLp27drox3+blZUVM2bMYPTo0Rw9epT9+/djMpnqLBMXF4efn19t7ydzdvnyZdLT03n55ZdVHYJUVVXFgQMH+PLLL+nQoQNvvfWWJJOaIDc3lw0bNuDr68usWbPabDVKWloaV65c4aWXXsLZ2VnrcNqMiIgI0tLSnurd1q1bN0AacwvR7s2erXUEwsJs1zoAISyQWn0Bzb1HYEuSCqU2xmg0snnzZqqqqli4cCE2NuoMoUlKSsLV1bVJw6oMBgO3b99u1GMyMjLYtWsXffv2VbUBsE6nY9y4cbi6urJ3714KCwuZM2cONjY2lJeXc/v2bcaPH6/a9lpKcXExR44coV+/fqr2M8rMzGTbtm3k5OQwefJkmcGtiUpLS1m/fj329vYsWrQIa+u2+VJqMpnYu3cvfn5+DBw4UOtw2pTu3bvj4uLChQsXiIyMrL09KCgIgJSUFK1CE0IIIYQQolVIhVIbc+DAAdLT01mwYAFubm6qrTcpKYnOnTs3KblgMBjIy8t7qhroWYqKiti4cSPe3t6qVVh928CBA1m0aBF3797lyy+/pKSkhPj4eIxGY5sY7nb48GGABs949yKKonD69Gk++eQT9Ho9b775JkOHDpVkUhNUVVWxefNmiouLWbx4MY6OjlqH1GTnz58nKyuL6dOnm/34bHNjZWXFgAEDuHHjBmVlZbW36/V67O3tefTokYbRCSE0N3Om1hEIC7NT6wCEsEB6vV71n/am/e1xG3bp0iUuXrzItGnTar8FV0NJSQlZWVlNGu4G1UPeTCYTBQUFL1y2qqqKTZs2oSgKCxcubNHKjm7durFs2TKys7NZu3YtV69eJSgoSNVEXEtITk7m2rVrTJw4ESen5vfgyc/P54svvuDw4cMMHjyY119/vckz8rV3iqKwe/du0tLSWLRoUbNnVtRSQUEB0dHRDBo0CD8/P63DaZMGDhyI0Wjk2rVrdW738PCguLhYpkEWoj3r3l3rCISFkYHUQqhPhrw1nySU2ojU1FT27dvHoEGDVB+akpycDNDk2Z1qhsm9aKa3mibTDx48YNGiRbi4tPzU6QEBAaxcuZLKykqSk5MJDAxs8W02h9FoZO/evQQGBja6QXp9bty4wQcffEBOTg5Lly5l0qRJbXZ4ljmIiYnh+vXrzJo1S9WkrhYOHTqEjY3NU83ERcO5uLjQo0cPLly4UCd55O/vj6IoZGdnaxidEEJTf/iD1hEIC/P/tA5ACCHqIQmlNiA/P5/NmzcTGBjIlClTVF9/UlISHh4eTa7ccXd3R6fTvbAx97lz57h69SqRkZH4+/s3aVtN4enpyeDBg4HqIT737t1rtW031unTp8nOzmb69OnNynCXlpby9ddfs23bNrp168Zbb73V5Ao0Ue3q1avExMQwfvz4Nt/EPDExkbi4OCZNmoS9vb3W4bRpERERZGdnk5SUVHtb928qE+Lj47UKSwghhBBCiBYnCSUzV1lZyaZNm7C2tmb+/PmqzvZVIzk5ucnVSVDdS8TNze25FUqJiYkcOnSIYcOGER4e3uRtNdXdu3fp1KkTwcHBrFu3juvXr7d6DC+Sm5vL8ePHGTp0KN7e3k1eT1JSEh9++CF37txhzpw5zJkzR5IGzZSUlMTu3bvp378/I0eO1DqcZqmqqmLfvn106tTpqSnvReMFBwfTsWNHLly4UHtbzetpTfWnEKId+t3vtI5AWJifax2AEELUQxJKZqymX8ujR49YuHChKv10vq2wsJDHjx83u3rFYDA8s0IpJyeHrVu3EhISolqT6cYoKioiOTmZPn36sGjRIvr27cv27ds5efKk2fQ4URSFffv24ejoyNixY5u0jqqqKg4dOsQXX3yBh4cHb731liQMVPDo0SM2bdpEp06dml05Zg5OnTpFXl4e06ZNa/P7Yg50Oh0REREkJCTU9pGzsrLCzs5OGnML0Z7t3at1BMLCTNc6ACEskPRQaj5JKJmxM2fOcOPGDWbOnImvr2+LbKNmmEZzKpSgOqFUX4VSeXk5GzZswMnJiblz52rS+f7mzZvodDrCwsKwsrJixowZjB49mqNHj7J///4Gz07Xkm7dusXdu3eZOnUqtra2jX58VlYWn3zyCefPn2fixIksXbrU7JuPtwVFRUWsX78eNze3FqsQbE05OTmcOHGCYcOG0bFjR63DsRh9+/bFxsaGixcv1t5mMBgoKirSMCohhKZOnNA6AmFhRmkdgBAWSBJKzScJJTN19+5djhw5wogRI1q0X0tSUhJeXl44Ozs3az0eHh7k5ubWqfgxmUxs27aNwsJCFi1apNmwq7i4OEJCQnBwcACqXzjGjRvHyy+/zMWLF9myZQuVlZWaxAbVSbcDBw7QvXt3evTo0ajHKorCmTNn+Pjjj1EUhTfeeIPhw4e3yxcztVVWVrJhwwaqqqpYvHhxmx82qCgK+/fvx9nZmdGjR2sdjkWxs7Ojb9++XL58GaPRCFQ35jaZTC/sLSeEsFCurlpHICzMi+dSFkKI1icJJTOUk5PD119/TUhICOPHj2/RbTW3f1INDw8PKioqKCkpqb0tOjqaO3fuMHfuXDp06NDsbTRFfn4+qamp9OrV66n7Bg4cyMKFC7l79y5ffvklpaWlGkRYfZzKysoa3XC9oKCAL7/8kkOHDhEREcEbb7zRrN5L4p9qkqGPHj1i8eLFFlHtFR8f36wqOPF8ERERFBcXc+vWLQC6du0KSGNuIdqtr77SOgJhYV7TOgAhLJBUKDWfJJTMTGsOEcvNzSUvL0+V2b8MBgNA7bC3GzducPLkSSZMmFB7YaWFmzdvYmVl9czKn+7du7Ns2TIeP37MZ599Rl5eXqvG9+DBA86fP8+YMWNwd3dv8ONiY2P54IMPePz4Ma+99hqTJ0/G2tq65QJtZw4fPkxCQgLz5s1rseGmramiooIDBw7QrVu32hnIhLq8vLwIDg6ubc4dEhICUGf2NyFEOzJnjtYRCAvztdYBCCFEPSShZEYURWH79u2tNkQsKSkJnU6nSoVSTUIpNzeXjIwMdu3aRd++fRk2bFiz190csbGxdO3aFTs7u2cuExAQwKpVq6iqquLTTz8lMzOzVWIzmUzs3buXDh06MHTo0AY9pqysjO3bt9dWsL311lt06dKlhSNtX86fP8/Zs2eZMmUK3bp10zocVRw7doySkhKmTp2qdSgWLSIigtTUVLKysrC2tsbW1paHDx9qHZYQQgtVVVpHICyMfG0ohPqkQqn5JKFkRo4dO0ZCQgJz5sxplSFiycnJ+Pr6qpK4srOzw8nJiczMTDZt2oS3tzeRkZGaPqlycnLIyMhoUA8qT09PVq1ahYuLC2vXruXevXstHt/ly5e5f/8+L7/8coOaPScnJ/Phhx+SkJDA7NmzmTt3bm1fKKGO27dvc+DAAYYOHcrgwYO1DkcVDx8+5OzZs4wePbpRVXCi8Xr06IGzs3NtlZK7uzuFhYUaRyWE0MTkyVpHICzMQa0DEMICSUKp+SShZCZu3rzJ8ePHGT9+fKtURSiKQlJSkirVSTXc3d25du0aJpOJhQsXaj4EKy4uDhsbmwYPuXN2dmb58uUEBQWxbt06rl+/3mKxFRUVceTIEfr160dQUNBzl62qquLw4cP84x//wN3dne985zv07du3Xb5gtaSMjAy2bt1K9+7dmThxotbhqEJRFPbu3YunpyfDhw/XOhyLZ2VlxcCBA7l+/TplZWX4+flhMpkoKJBWqkK0OxbypYQwH+e1DkAIIeohCSUzkJWVxY4dO+jVqxcjR45slW1mZ2dTVFSkSv8kqL5wLSkpoaSkhIULF+Li4qLKepsjLi6O7t27N6oBsa2tLYsWLaJv375s376dU6dO1Zm5Ti2HDx9Gr9e/MHHx8OFDPv30U86ePcuECRNYunSpVJm0gPz8fDZs2ICXlxdz5sxp0d5lrenatWukpqYybdq0BlXBieYbOHAgVVVVXLt2jdDQUEAacwvLoiiKxf6o6j//U931iRey9AqDf9c6ANEsZvk6pRK1nndaTIIjFUrNZxlXTW1YSUkJGzduxMPDgxkzZrTaSZiUlIRer39hdUxDnTt3jtzcXOzs7AgICFBlnc3x6NEjsrKy6p3d7UWsrKyYMWMGo0eP5siRIxw4cACTyaRabElJSVy/fp2JEyfi6OhY7zKKonDu3Dk++ugjjEYjr7/+OiNGjLCYRIc5KSsrY/369VhbW7No0SJsbGy0DkkVpaWlHD58mD59+qiWOBYv5uLiQlhYGBcvXqxNKEljbiGEEEIIYYmkv5uGTCYTW7dupaKigmXLlrXqVN5JSUn4+/urss3ExEQOHTpEaGgod+/epaKiQvNpyWNjY7Gzs6u9oGssnU7HuHHjcHFxYd++fRQWFjJ79uxmJxuqqqrYu3cvQUFB9OvXr95lCgsL2bFjB/fu3WPw4MFMmDDBYpIc5sZoNLJlyxYKCgpYuXIlzs7OWoekmiNHjmA0Gpk0aZLWobQ7ERER/OMf/yAjIwMbGxuysrK0DkkI0dp+/WutIxAW5tdaByCEBVK7qkgqlESrOnToEMnJycyfP79VhzEpikJycrIqVQs5OTls3bqVkJCQ2uF6ubm5zV5vcyiKQlxcHGFhYc3u4zRo0CAWLlzInTt3+OqrrygtLW3W+k6dOkVubi7Tp0+v9wXn5s2bfPDBBzx8+JAlS5YwdepUSSa1kJr+QsnJySxYsICOHTtqHZJq0tPTuXz5MuPHj7eoJFlbERwcTMeOHblw4QJubm7SQ0mI9ujUKa0jEBZmhNYBCCFEPSShpJErV65w7tw5pkyZompj7IbIysqitLS02Qml8vJyNmzYgJOTE3PnzsXT0xOoTjJpKSsri+zs7CYNd6tP9+7dWbp0KY8ePeKzzz4jPz+/SevJycnhxIkTDBs2DC8vrzr3lZeXs2PHDrZs2ULnzp156623CAkJUSN88QwnT57kypUrzJgxw6KGhJlMJvbu3Yuvry+DBg3SOpx2SafTMWjQIOLj4+nQoQNGo5GSkhKtwxJCtKbDh7WOQFgYy5guRAhhaSShpIH09HT27t1L//79iYiIaPXtJyUlYW1t3axeRyaTiW3btlFYWMiiRYuwt7fHyckJGxsbzRNKsbGxODg4qJokCAwMZNWqVVRVVfHpp5+SmZnZqMcrisK+fftwdnZm9OjRde5LSUnhww8/5NatW8yaNYt58+Y9s7eSUMeNGzeIiopizJgxhIeHax2Oqi5cuEBmZibTp0+XnlsaCg8Px8bGBkVRMCo6Tl+OJTO/jLJKo9ahCTNy/PhxIiMj8fPzQ6fTsWPHjjr3L1++/Klmn1OmTNEmWNE4dnZaRyAsTLnWAQhhgaQpd/NJD6VWVlhYyKZNm/D19WXatGmanHRJSUkEBgY2azhYdHQ0t2/fZvHixXTo0AGofkJ6eHhoOuStZrhbz549VZ/VytPTk1WrVrF+/XrWrl3LwoUL6dKlS51linKyuXflImVFhVhZ2+Dh509weH9u3YonMTGRRYsW1faXMhqNHDt2jJMnTxIYGMjSpUsxGAyqxiyelpqays6dO+nbty9jxozROhxVFRYWEhUVxcCBA/H399c6nHbNzs4Ojy59+fJmDvHl/flizyPYcxQrnY6JvbxZOiyYYV082+UHD/FPxcXFhIeHs3LlSubMmVPvMlOmTGHt2rW1v9tJoqJt2LJF6wiEhVmgdQBCCFEPSSi1oqqqKjZt2oROp2PBggXN7u/TFCaTiZSUlNp+R01x48YNTp48ycSJE+natWud+7ROKN2/f5+8vDx69+7dIut3dnZm2bJlbNmyhXXr1jFr1iz69OnDg7sJXNj5NXcvnEFRFHR6PXwzvaeTu4FiZwPdBgyme/fuQPUsdNu3bycrK4vx48fLDG6tJDs7m40bNxIYGNiqsyq2lkOHDmFtbc1LL72kdSjtWqXRxL9tj2XTFdBhQOGf55lRUTh8M4sDsZkM7eLBmtcG4eYgfdLaq6lTpzJ16tTnLmNnZ4ePj08rRSRUs3gxrF+vdRTCgqwDXtU6CCEsjDTlbj5JKLWSmgbAmZmZrFixAhcXF03iyMjIoKKiosl9mzIyMti1axd9+/Zl2LBhT91vMBi4efNmM6NsutjYWJydnQkKCmqxbdjZ2fHKK6+we/dutm3bRuK5U9w7ug+o/jsDKCZT7fLFebkoebmU64wUv/wycQm3OXz4MO7u7qxatQo/P78Wi1X8U3FxMevWrcPJyYkFCxaoXsGmtXv37hEbG8usWbNwcHDQOpx2y2RS+NHGq+y78QCgTjKphtFU/TpxISmXxR+fZct3huFoK2/Hon7Hjh3Dy8sLg8HA+PHj+a//+q/anoX1KS8vp7z8n4NjpCm8RoqKtI5AWBiZYkMI9UlCqfmkJKKVnD9/nqtXrxIZGanpUJSkpCRsbW2blMQoKipi06ZNeHt7ExkZWe8TxmAwkJ+fj9HY+n1CTCZT7XC3lq72sbKyYubMmfQN9OPu4T0oJlOdJNK36YCc+2l88rPvs3/vHvr378+bb74pyaRWUlMdWFFRweLFiy0u4VJVVcW+ffsIDg6mb9++WofTrq07n8reGw9QGrCsUVG49aCA9/bFt3hcom2aMmUKX3zxBUePHuX3v/89MTExTJ069bnvse+99x5ubm61P4GBga0YsahlYUOqhfZitA5ACCHqIQmlVpCUlMTBgwcZOnSo5g2Ak5OTCQ4ObnR1Rs0FuclkYuHChc8crufh4YGiKE2eCa05UlNTKSoqarHhbt+mmExknTteT/3Bs5evys9laEgw06ZNw8ZGhrm0BkVR2LFjBw8ePOCVV16xyD5Vp0+fJjc3V7O+bKKaoih8cuJeg18TAEwKbL6YRkFZZYvFJdquRYsWMWPGDPr06cOsWbPYs2cPFy5c4NixY898zC9+8Qvy8/Nrf9LS0lovYPFPkyZpHYGwMIe0DkAICyUNuZtHEkotLDc3t3Yq+IkTtZ3ws6qqitTU1EYPd6sZrvfgwQMWLlz43OF6NRfrWsz0FhcXh5ubW7Nmr2uMe5cvUJzX+H5R6ZfO1Q6NEy3v6NGjxMXFMWfOHItsVJ2bm8uJEycYOnQoXl5eWofTrp25l01KdkmDqpOeVFFlYtul9BaJSViWLl260KFDB+7evfvMZezs7HB1da3zIzTwy19qHYGwML/VOgAhhKiHJJRaUEVFBRs3bsTe3p558+Zp3nQ5PT2dqqoqOnfu3KjHPTlc70XJGjc3N/R6fas35jaZTNy8eZNevXq1Wnb4+tGD1c23GykvM4OMhFstEJH4tkuXLnHq1CkmTZpEWFiY1uGoTlEU9u/fj6Ojo8XNWNcWXUzOxUrfhNcfHVxI0W4yA9F2pKenk52dja+vr9ahCCGEEG2emtVJ7bVKSRJKLaRmmE1eXh6LFi0yi54tSUlJ2NvbN2q2mHv37nHw4EGGDRvWoOF6er0ed3f3Vq9QSkpKoqSkpNWGuwHkPrj/3L5Jz5P/MFPlaMS33b17l7179xIREcHQoUO1DqdFJCQkcOfOHaZOnYqtra3W4bR7xeVVNCWfpChQWFalfkDC7BUVFXH16lWuXr0KVL+XXb16tXYI989+9jPOnj1LcnIyR48eZebMmYSGhjJ58mRtAxcv9vOfax2BsDC/0zoAISyQJJSaTxJKLeTEiRPcunWL2bNnm80wlOTkZDp37tzgEz0nJ4ctW7YQEhLChAkTGrwdg8HQ6hVKsbGxeHh4tOrUyiZj0y8AjVVy8diSsrKy2LJlC6GhoUyZMsUiX9wrKirYv38/Xbt2pXv37lqHIwAnO2tMTRjNqteBi53M8tYeXbx4kf79+9O/f38A3nnnHfr378+vfvUrrKysuH79OjNmzKBbt26sWrWKgQMHcuLECezs7DSOXLxQbKzWEQgL03pfmQohRMPJJ9gWkJCQQHR0NGPGjKFHjx5ahwNUX3ymp6c3+FvN8vJyNmzYgJOTE3Pnzm3UcD2DwUBqampTQ220qqoq4uPjGTx4cIsmDhRFIT09nevXr5OcnExxUQl6aFQD3hqObm5qhye+UVBQwPr16/Hw8DCLoaYtJSYmhpKSEqZOnWqRCbO2aGCwAWMTMkqKUv1Y0f6MHTv2uT31Dh482IrRCFXt2QNvvql1FMKCvAx8rHUQQlgYtauK2uNnckkoqezRo0ds27aNHj16mFVPk7S0NEwmU4P6J5lMJrZt20ZhYSGvv/469vb2jdqWh4cH165dQ1GUVnlSJSYmUlZWRq9evVRdb1VVFXfv3iUuLo709HTy8/NrP/hbWVnh4htA1b3GT/dt6+BAUG9tZ/uzVDWJUIDFixdb7DCwhw8fcvbsWcaMGWORs9a1RYqi4Fr6AHerSvKM1jQm1WxjpWfuwNaZTEAIIYQQQgi1SEJJRaWlpWzcuBE3NzdmzZplVhnKpKQknJyc6NChwwuXjY6O5vbt2yxevLhBy3+bwWCgsrKSoqKi584Ip5a4uDi8vLyaPbSwvLycmzdvcuvWLTIyMiguLq69z8bGBh8fH7p06UJ4eDgdO3akrKiID1e/hrGq4dN963R6+oyfjI1d45J04sVMJhNff/01OTk5rFy5slXOPS0oisK+ffswGAwMHz5c63DaPUVRuH37NtHR0WRlZTHKuye7M2wa/Hi9DuYN9MfNoeGPEUK0Abt2aR2BsDAztQ5ACCHqIQklldRczJaUlPDGG2+YXX+DpKSkBvVPio2N5eTJk0yYMIGuXbs2aVseHh5AdQ+mlr6or6ysJD4+npEjRzb6sQUFBdy4cYPbt2+TlZVFeXl57X329vYEBwfTtWtX+vbtW+9+2Ds7M/DlWZzfsaWBW9Rh0kGevTNVVVVYW8vTTy01s53dvXuXV199FW9vb61DajHXr18nJSWF1157Tc4hjd27d4/o6GjS09MJDg5mxYoVBAQEUrn+MgdjM3nR4DcrnY5u3s78cnrPVolXCNGKVqyAtWu1jkJYkM+AlVoHIYSFkSFvzSdXIyo5evQo9+7dY8mSJbUJFXNRVlbGgwcPGDhw4HOXy8jIYOfOnfTt27dZlQ81Q3Byc3MJDg5u8noa4s6dO1RWVr5wdjdFUXj48CHXr18nKSmJx48fU1n5z8oiJycngoKC6NGjB7169WpwQnDEwiXkZT7g9tmTz11Op9ejt7Km15xXOHczgUdr1zJ//nzc3d0btB3xfGfOnOHixYtERkYSEhKidTgtprS0lEOHDtG7d2+6dOmidTjtVlpaGlFRUSQnJ+Pv78+SJUvo0qVL7YeIvy7qz79uv8HWS+lY6XVP9VWquW1AsDufLI3ASRpyi1bgplLvvuf1fBJPyM7WOoKnqHmhY47ngTnGpCZPldZjrhe8av39zHX/zDEuc4xJtD3yKVYF169f5/Tp00yaNMksL/JSUlJQFOW5/ZOKiorYtGkTXl5evPzyy816gbGxscHFxYWcnJwmr6OhYmNj8fX1fSqJZzQaSUtLIzY2luTkZHJzczGZTED1i6erqyuBgYH06tWL0NDQJld66PVWvPzD/8eZgCAu7tlGZVkZ6HTVXXapTiQpJhMdgzsz6c3v490llF5DM9i8eTNr1qxhzpw5Ta4EE9Vu3rzJ4cOHGTlyJAMGDNA6nBZ19OhRqqqqmDRpktahtEuZmZlERUVx584dvLy8WLRoEd26dXvq9dLWWs//Nz+cZcM68eXZZHZcyaDCWPP6A+N7eLFsWCeGh3ii18uHOSEs0rBhWkcgLMwZrQMQwgJJhVLzSUKpmTIyMti9ezfh4eEMHTpU63DqlZSUhJub2zOrYaqqqti8eTMmk4mFCxdiY9P8Xh4Gg4Hc3Nxmr+d5ysvLuXPnDuPGjaO8vJzExMTaBtoFBQW1y+n1egwGA506daJPnz4EBgaqOvOXTq9n+PzFRETOIf70ce6cP0NJQR4PMjPx7RzKxFeX4d0ltHZ5Pz8/Vq9ezY4dO1i/fj0jR45k3LhxFjsbWUtKT09n+/bt9OrVi/Hjx2sdTou6f/8+ly5dYsqUKRbbH8pcPX78mOjoaG7evImHhwdz586lV69eL/zQ0CfAjT/MC+c/ZvYmt6QCo0nBw8kWR1t56xXC4s2bp3UEwsJs1ToAIYSoh3yqbQY1q3pa0vP6JymKwt69e8nIyGD58uW4urqqsk0PDw8ePXqkyrrqU1hYSFRUFFVVVZw4cYLDhw/X3mdtbY2Pjw8hISH06dMHLy+vVvnb2Njb02f8JPqMr64e+eCDDzAEBdVJJtVwcHBg0aJFnDp1iqioKNLT05k7dy7Ozs4tHqelyM3NZcOGDfj6+ppdE3y1mUwm9u7di4+PDxEREVqH027k5uYSExPD9evXcXV1ZcaMGYSHhzc6+WtvY4Wvm0MLRSmEMEs/+Yk05haq+l+kMbcQapMKpeaThFITGY3GOlU95toct7i4mIcPHzJixIh67z9//jxXr15l1qxZBASoN221wWAgISFBlXUpisLjx4+Jj4/nzp07ZGVlUVFRUef+oKAgunXrRs+ePXF3dzeLJ/OLqrR0Oh0jR44kICCArVu3smbNGubNm9fifacsQWlpKevWrcPe3p5FixaZ7fNPLRcvXuTBgwesWrVKKtlaQUFBAcePH+fKlSs4OjoyZcoUBgwYYPHnmRBCCCFEeyIJpeaTT8dNtH//fjIyMli2bJlqVT0tITk5GYBOnTo9dd+9e/c4ePAgw4YNIzw8XNXtGgwGSktLKSsrw97evlGPNRqNZGRkcPPmTe7du0d2djZGo7H2fkdHR/z9/UlOTmbs2LGMHj1a1djVYjAYuH379guX69SpE6tXr+brr7/mH//4By+99BLDhw9vly9IDVFVVcWmTZsoKSlh1apVODo6ah1SiyoqKiIqKooBAwaomvQVTysuLubkyZNcvHgRGxsbxo8fz+DBg1UZBiyEaGfeeUfrCISF+aPWAQghRD0kodQEFy9e5NKlS8yYMYPAwECtw3mupKQkPD09n0p65eTksGXLFrp06cKECRNU325Nk+zc3Fx8fX2fu2x5eTkpKSncunWLlJQU8vLy6sz0UNNAOywsjJCQEOzt7bl8+TLJyclm3YTZYDCQl5eHyWR6YVWJi4sLS5cuJTo6miNHjpCamsqsWbNwcJBhMk9SFIXdu3eTnp7O0qVL8fRUa84T83Xo0CGsrKxa5HkqqpWVlXH69GnOnTsHwIgRIxg6dGijk+FCCFErNVXrCISFCdI6ACEskFQoNZ8klBopJSWF/fv3ExERQf/+/bUO54WSk5Ofqk4qLy9n48aNODk5MW/evBYZQmMwGIDqxNW3E0oFBQUkJSVx69Yt7t+/T1FRUe19Op2utoF2z549CQoKqrc6IC4ujk6dOpl1zyGDwYDJZKKgoOCZDdGfpNfreemllwgMDGT79u189NFHzJ8/Hz8/v5YPto04duwY169fZ+7cuQQFWf5Hq6SkJG7cuMHMmTMludgCKioqOHfuHKdPn6aqqorBgwczYsQIi696E0K0gq1bYelSraMQFmQe8KXWQQghxLdIQqkR8vPz2bx5M0FBQUyePFnrcF6ooKCA7Oxsxo0bV3uboihs27aNgoICXn/99Rb7Bt7BwQE7OztycnJ49OgRiYmJJCQk8ODBA8rLy2uX0+v1eHt7ExISQo8ePfDz88PKyuq56y4uLiYpKYnp06e3SOxqebJKqyEJpRrdunVj9erVbNmyhc8++4wpU6YwcODAdpnxftLVq1c5fvw4L730Er1799Y6nBZnNBrZu3cvQUFBqg9Jbe+qqqq4ePEiJ0+epLS0lIEDBzJq1CiZPU8IIYQQoh2RCqXmk4RSA1VWVrJx40ZsbGyYP3/+C5Me5iApKQmo2z8pKiqK27dvs3jxYjp06KD6Nmv6H929exeTyUR0dDRRUVG199vY2BAQEEC3bt3o2rUrXl5eja6QunnzJjqdjrCwMLXDV5WbmxtQnVDq3Llzox7r7u7OihUrOHjwIHv37iU1NZWXX34ZW1vblgjV7CUlJbF792769+//zAbzlub06dPk5OSwYMGCdvnm1BKMRmNtYrKwsJDw8HDGjBnTqISvEEI0yObNWkcgLMwCrQMQwgJJQqn5JKHUAIqisGvXLrKzs1m5cqVZD4coLymmOC8XxaSQmBCPt7c3Tk5OAMTGxnLy5EkmTJhA165dVdleWVkZaWlp3L59m6SkJHJycur0P9Lr9XTu3JkePXrQpUsXPDw8mv1Ei42NpUuXLmb9dwCwtrbG1dX1uTO9vejx06dPJygoiN27d/PgwQMWLFhAx44dVY7UvD169IhNmzbRuXNnpk+f3i5eqHNzczl+/DhDhw7Fy8tL63DaPJPJRGxsLMeOHSM3N5fevXszduzYdtGDSwihkR//GD74QOsohAX5E/BdrYMQQohvkYRSA5w+fZrY2FjmzZuHj4+P1uE8RVEU0m/e4MrBvdy9cAbFZKq9z8k/iHuXL2Dr5cvOnTvp27cvw4cPb/K2CgoKSElJ4fbt26SkpFBYWFjnficnJ4KCgujevTv379/n9u3bvPbaa03eXn3br2lY3RYYDIYmJ5Rq9OnTBx8fH7Zs2cLHH39MZGQkffr0USlC81ZUVMS6detwc3NrM5WBajhw4ACOjo6MHTtW61DaNEVRiI+PJzo6mkePHtG9e3cWLlyIt7e31qEJISzd/ftaRyAsjL/WAQhhgaRCqfkkofQCd+7c4ciRI4waNYpevXppHc5TKsvL2PvX/yHx4jl0en2dZBJAyYN0tv/+N+DsRseBw3n55ZcbfKIrisKjR49ISUnhzp07pKWlUVZWVmcZNzc3OnXqRPfu3QkODq5TNWQ0Grlw4QJVVVVYW6tzqsXFxWFlZUX37t1VWV9LMxgMPHz4sNnr6dixI6+//jp79uxh27ZtpKamMnnyZNWOqzmqrKxkw4YNGI1GFi9ejJ2dndYhtYqEhARu377NggUL2u0Qx+ZSFIXExESioqJ48OABXbp0YcaMGQQEBGgdmhCivWgDE7eItuWK1gEIIUQ9LPdqVAXZ2dl8/fXXdOvWrU5ja3NhrKpi+x/+k/SbNwCeSibVua0oH5vEOBRjFdQzaxpUN6rNyMggOTmZu3fv8uDBA6qqqmrv1+l0dOjQgZCQEEJDQwkMDHzuRX5NU+q8vDzV+jXFxcXRtWvXNjOdt8FgICEhQZV12draMnv2bIKCgjhw4AD3799n/vz5tTPqWRKTycS2bdt49OgRK1asqO1HZekqKirYv38/oaGh9OjRQ+tw2qSUlBSioqJITU0lMDCQZcuWPTXTpRBCtLhVq7SOQFiYT7UOQAgh6iEJpWcoKytj48aNuLi4MHv2bLMsX7u4extpcdfhiZ5Fz5Obkc6J9Z/z0sq3gH/2P0pKSiIxMZFHjx491f/I19eXrl270qVLF/z9/RtVEVOT6MjJyVEloZSbm8v9+/eZO3dus9fVWgwGA6WlpZSVlamSBNPpdAwaNAh/f382b97MRx99xKxZs9pMxVZDHTp0iISEBBYtWoSvr6/W4bSa48ePU1xczLJly8zyNcec3b9/n+joaBITE/Hx8WHx4sWEhobKcRRCaOPtt2HXLq2jEBbkb8BMrYMQwsLIkLfmk4RSPRRFYfv27RQWFvLGG2+YZTWMyWjk8oHdDU4mQXW10vWjhyhw7UBK+n3y8/Pr3G9jY4Ofnx/dunWjU6dO+Pj4NHoGtie5urpiZWXV7B5CNeLi4rCxsaFbt26qrK811CTVcnNzVU2M+Pr68uabb7Jz5042btzIiBEjGD9+fLP+Xubi3LlznDt3jmnTprWpv3VzPXr0iDNnzjB69GiLrDprKQ8fPiQ6Opr4+Hg6dOjA/PnzCQsLa5dv6EIIIYQQQrQmSSjVIzo6mtu3b/Pqq6+a7SxA9y5foCSv8YkaY1UlN08co8rDC3t7e4KCgggNDSU4OJiOHTuqnqE1GAzk5OSosr7Y2Fi6devWpvrK1Az7UzuhBODg4MDChQs5ffo0R48eJT09nblz5+Li4qLqdlpTQkICBw8eZOjQoURERGgdTqtRFIW9e/fi7u7OiBEjtA6nTcjJyeHYsWPcuHEDg8HArFmz6NOnj0UkVYUQFuC7Mh+XUNf7WgcghAWSCqXmk4TSt8TFxXHixAkmTJhAaGio1uE804M78eitrDAZjY16nE6no1MHA9Pe/gHu7u4tftKrMcsZVFdvZGVltblZrxwcHLC1tVWtSuvbdDodI0aMICAggK1bt7JmzRrmzp1L586dW2R7LSkjI4Ovv/6aHj16MGnSJK3DaVU3btwgJSWFJUuWWHSjdTXk5+cTExPD1atXcXZ2Zvr06fTv37/dzAAohGgjvlUFLkRztY9ukkKItkauXJ6QmZnJzp076d27N8OHD9c6nOcqLSpqzGi3f1LA2cGh1YbUGAwG7t271+z1xMXFYWdnZ9ZJvvrUVGm1VEKpRnBwMKtXr2bbtm18+eWXjBs3jpEjR7aZLHleXh4bNmzAy8vLbHuWtZTS0lIOHTpEr169CAkJ0Tocs1VUVMSJEye4dOkSdnZ2TJw4kUGDBmHzjEkGhBB15efn4+rqqnUYtczxdV5p0gerZ1i3DhYuVG99KlB1/0SrexXYrHUQLUit1wQ1z3M1X6fUisscXzvbMqlQaj5JKH2jpKSEjRs34unpyYwZM8zuZMjLyyM1NZW7d++SkpJC2d2b2JiMNDZKnV6HnaNji8RYHw8PDy5duoSiKE0+poqiEBcXR48ePdpk9UZrJJQAnJ2dWbJkCceOHSMqKoq0tDRmz56Ng4NDi2+7OcrKyli/fj3W1tYsWrSo3SUIoqKiqKysZPLkyVqHYpZKS0s5deoU58+fR6/XM3r0aIYOHdqmhr4KIYQQQgjzIwml5mt7V+ctwGg0smXLFiorK1mxYoXmF7Qmk4lHjx6RnJzMnTt3SE9Pp7y8vM4yjoYO6B4/aPS6FZOJgLDeaoX6QgaDAaPRSEFBQZOnfs/KyuLx48dtdhiUwWAgPj6+Vbal1+sZP348gYGBbN++nTVr1jB//nz8/f1bZfuNVfPcKywsZOXKlTg7O2sdUqvKyMjg4sWLTJ48uU33vmoJ5eXlnD17ljNnzmAymRgyZAjDhw83+wSpEEIA8OWXWkcgLMxrWgcghBD1kIQScPDgQVJTU1m6dGmTkx7NUVVVxf3797l79y6JiYk8fPgQ4xO9kXQ6HZ6ennTu3JkuXboQEBCAs5MTn/zgdQoePWzUtmzsHeg+YrTau/BMTzalbuqxjY2NxcHBgS5duqgZWqsxGAzk5+djMplarWFw165dWb16NVu2bOGzzz5j8uTJREREmFXWXFEU9uzZQ3JyMq+99hodO3bUOqRWZTKZ2LNnD97e3gwePFjrcMxGZWUlFy5c4OTJk1RUVDBo0CBGjRqFk5OT1qEJIUTDvfsu/PnPWkchLMhvgB9rHYQQFkYqlJqv3SeULl++zIULF5g+fTrBwcGtss3S0lKSk5NJSEggNTWVvLy8OuNqbW1tCQgIqJ19zdfXt96hXoNenk3U2jUN3q4ClLt5cis+gT59+rTKCe/u7g5Uz8jUqVOnRj++ZrhbWFhYm226azAYMJlM5Ofnt+p08G5ubqxYsYJDhw6xf/9+0tLSePnll7Gzs2u1GJ7n5MmTXL16lVmzZjXp3GjrLl26xIMHD1i5cqXMTEZ1tdrly5c5fvw4JSUl9OvXjzFjxphVzxchhGgwFfpHCvGktvm1qhDC0rXrhFJaWhp79+5l4MCBDBo0qEW2oSgK+fn5JCYmkpCQwP379ykpKamzjKurK4GBgXTr1o2goCDc3NwalOzpN2k69+NvknD2JC/s0K3TYXRwxi0snO3bt3Pr1i1efvnlFv/W39raGjc3tyb3EMrIyCAvL4/evVtvmJ7aapJIubm5rZpQArCysmLq1KkEBQWxa9cuPv74YxYsWICXl1erxvFtN27cICoqijFjxhAeHq5pLFooKiri6NGjDBgwgMDAQK3D0ZTJZOL69evExMSQl5dH3759GTNmTG11oxBCtElhYVpHICzMLa0DEMICSYVS81l0Qulh8j3uXjhLaWEBVjY2ePgF0GP4KGwdHCkoKGDz5s0EBAQwdepU1bZpMpnIysoiPj6+dvhaZWVl7f1WVlZ4e3vTpUsXunbtir+/f5Oby+r0eqZ9/6fYOTlx/cgBdHo9islUZxm9lRUmo5HQQUNw7DOI02fPERYWRkpKCu+//z7Tp0+nZ8+ezdrnF2lOU+rY2FicnZ1brXqsJbi7u6PT6VqlMfez9OrVC29vb7Zs2cInn3zC9OnTNUvkpKSksHPnTsLDwxkzZowmMWjt8OHD6PV6XnrpJa1D0YyiKNy8eZPo6Giys7MJCwtj8eLF7W7ooxDCQr3zjtYRCAvzR60DEEKIelhkQinx0nnOfr2BzMQ76PT6bzKFOkzGKqI//4ieo8dzr0JBr9czf/78Zg2lqqysJCUlhZs3b5Kamkpubi6mJ5I6Dg4OtdVHISEheHp6qpq51FtZMfGNtxkwdSbXDu8jNvowleVlAFhZ29Bj5Fj6T56Od5dQABydXThy5Aj9+/entLSULVu20Lt3b6ZOnYpjC83+ZjAYyMzMbPTjaoa79ezZs00PCbKyssLV1VXThBJAhw4deP3119m7dy87duwgNTWVqVOnturMednZ2WzatInAwEAiIyPbZRY/OTmZ69evM2PGjBZ7zpkzRVG4c+cOUVFRZGVlERoaypw5c/Dz89M6NCGEUM8bb8CuXVpHISzIx8BMrYMQQohvsbiE0oVdX3N83Vr45kJVMZl4cjBYVUU5148ewGRtw8z/926jZ5UqKSkhPj6ehIQEMjIyKCoqqr1Pp9Ph7u5OUFAQPXr0IDg4uNVmJPIMCGT8itWMW/YGFWVlKIoJOwdHdN9KxIwYMQJ7e3v27NlD3759mTVrFgcOHOCDDz7g5Zdfpnv37qrH5uHhwc2bN1EUpVEJhNTUVAoLC9v0cLcazanSUpONjQ0zZ84kKCiIffv2kZGRwYIFC1plKF5xcTHr1q3DycmJBQsWtNmeWM1hNBrZu3cvgYGB9OvXT+twWl1SUhJRUVGkp6cTHBzMihUrCAoK0josIYQQQgjRTrXHL7jVZFEJpdhjR6qTSfD8nkKKglVVFcc//j+Cfvdn7J3qTyopikJ2djY3btzg3r17PHz4kIqKitr7bW1t8fPzo0uXLoSFheHj46N5JY1Or8fuBVUPAwcOxM7Oju3bt1NRUcGbb77J/v372bhxI+Hh4UyZMgV7e3vVYjIYDJSXl1NaWtqoiozY2FhcXV0JCAhQLRatNLVKqyXodDoGDBiAr68vW7ZsYc2aNcyaNYsePXq02DYrKyvZuHEjFRUVrFq1qt1O/X7mzBmys7NZvXp1u3rzSktLIzo6mqSkJPz8/FiyZAldunRpV8dACNHOrFypdQTCwnymdQBCCFEPi0koVVVWEvPFJw1eXlFMFDzK4tqhfQyZvQCo7n+UlJREXFxc7exrRqOx9jE1vXy6d+9Ot27dcHFxUX0/Wkvv3r2xtbVly5YtVFRUsGDBAm7evMnBgwe5d+8eM2bMIDQ0VJVt1TTXzc3NbXBCyWQycfPmTcLDwy3iotNgMHDrlnm1U/T19eXNN99k586dbNq0ieHDhzN+/HjVK4cURWHHjh1kZmayfPnyVm9Mbi7y8vKIiYlhyJAheHt7ax1Oq8jMzCQqKoo7d+7g5eXFwoUL6d69u0U8p4UQQgghRNsmTbmbz2ISSnfOnaKsuOjFCz5BURTO79lOYmklDx5k1hm+ZmVlVTt8rXfv3gQHB1vcEJ1u3brx6quvsmHDBr766isWL15Mly5d2LVrF+vWrWPAgAFMmjSp2dPM1yQQcnJy8Pf3b9BjkpKSKCkpsYjhblB9DMrKyigtLTWr6hx7e3sWLFjA2bNnOXz4MOnp6cybN0/VZOnRo0e5efMmCxYsaPDf3xIdOHAABwcHxo4dq3UoLe7x48dER0dz8+ZNPDw8mDNnDr17926Xb7JCiHbqs89g1iytoxAWZCWwU+sghBDiWywmoRR77DA6nR5FMb144SdUFBVy78plrD07EhAQQEhICH379m03U1Z36tSJpUuXsm7dOv7xj3+wZMkSlixZwqVLlzh06BCJiYnMnDmTzp07N3kb9vb2ODg4NKqHUFxcHB4eHvj6+jZ5u+akJqmWm5trVgklqM6kDxs2DH9/f7Zu3cqaNWuYM2cOXbp0afa6L126xKlTp5g0aRJh7XgK5YSEBBISEpg/f36zE7TmLDc3l5iYGK5fv46rqyuRkZH069dP86HAQgghhBBCCPVZTEKp4OHDRieTakROmUT4S5NVjqjt8Pf3Z/ny5Xz55ZesXbuW1157jUGDBhESEsLOnTv54osviIiIYMKECdja2jZpGx4eHg1OKBmNRm7dukVERITFVDQ8OezPXGezCgoKYvXq1Wzbto2vvvqKsWPHMmrUqCb/De7evcvevXuJiIhg6NChKkfbdlRWVrJ//35CQkIsNqlWWFjI8ePHuXz5Mg4ODkyZMoUBAwa06gyCQghhVj7+WOsIhIV5Q+sAhLBAMuSt+Szma+OmJpMArOTbc7y8vFi5ciWKorB27VoeP36MwWBg2bJlTJ48mStXrrBmzRpSU1ObtH6DwUBOTk6Dlk1MTKSsrMxihrtBdZWWnZ2dWcz09jxOTk68+uqrjBo1iujoaNavX09JSUmj15OZmcmWLVvo2rUrU6ZMaZcvrjWOHz9OUVER06ZNs7jjUFJSwqFDh/jrX/9KXFwc48eP54c//CGDBw+WZJIQon374x+1jkBYmHe0DkAIIephMZkUZ48O0MSLtWOnz7B//37i4uLq9FFqbwwGAytWrMDOzo61a9fy4MEDdDodQ4cO5Tvf+Q6Ojo6sXbuWQ4cOUVlZ2eh1NzSZEhsbS8eOHfHy8mrKbpglnU7XqGOgJb1ez7hx43j11Ve5f/8+a9asIT09vcGPLygoYP369Xh4eDB37tx2Pdzp0aNHnD59mpEjR1rUMNqysjKio6P5y1/+wqVLlxgxYgQ/+MEPGDFiBDY2NlqHJ4QQ2jOziThE22eZNc5CaKumQknNn/bGYr5C7jl6PPfj4xr9OBsHRwLCenPnzh3Onz8PgKenJ0FBQQQHBxMUFIS7u3u7OTlcXFxYvnx5bU+lxYsXExQUhKenJytWrODMmTNER0dz584dZs2a1eAmyx4eHhQWFlJZWfncC87KykoSEhIYMWKEWrtkNtpKQqlGaGgoq1evZuvWraxdu5ZJkyYxePDg5z4XysvLWb9+PTqdjsWLFzd5iKQlUBSFffv24e7uzsiRI7UORxUVFRWcP3+eU6dOUVVVxeDBgxkxYkSDZ28UQoh2Q4U+hEI86Z7WAQhhgWTIW/NZTEIpbMQYjn3xMZVlZQ1+jE6vZ+DUSEbMmQNU9wFJSUkhJSWF1NRUrly5AoCrq2udBFPHjh0t+mRxdHRk6dKlbNiwgS+//JKFCxcSGhqKXq9nxIgRdOvWjR07dvDpp58yYsQIxowZ88LhLU/2EHpe5dGdO3eoqKigV69equ6TOTAYDNy8eVPrMBrFzc2N5cuXc/jwYQ4cOEBqaiozZsyot7G0yWRi69at5ObmsnLlSlVnimuLYmNjSU5OZsmSJW1++FdVVRUXL17k5MmTlJaWMnDgQEaNGtXu/8ZCCPFMv/mN1hEIC/Ou1gEIIUQ92vZVzhNs7O0ZPm8xMV991qDldXo9Di4u9Jv8cu1tLi4u9O7du7Z3T2lpKampqbUJpri4OBRFwcHBoTa5FBwcjI+Pj8UN67Gzs+PVV19l69atbNiwgblz59KzZ08AOnbsyMqVKzl16hQxMTHcvn2bWbNmPXdGtidnOXteQikuLg5fX188PT3V3SEzYDAYyM/Px2g0YmVlpXU4DWZlZcWUKVMICgpi586dfPzxx8yfPx9vb+/aZWqqce7du8fixYvr3NcelZWVcfDgQXr27ElISIjW4TSZ0Wjk6tWrHD9+nMLCQsLDwxkzZgzu7u5ahyaEEObttddg1y6toxAW5EtgptZBCCHEt1hMQglg4MuzKcrN4dLeHc9dTqfXY+foxLxf/hdO7oZnLufg4ED37t3p3r07UD3cIz09vTbBFBUVRVVVFba2tgQGBtYmmPz9/dt8RQKAjY0NCxYsYMeOHWzdupXIyEj69+8PVCcZRo8eXVut9MknnzBq1ChGjRpVb7LE2dkZGxub5zbmLi8v5/bt24wdO7aldklTBoMBRVHIz89vk/10evbsibe3N1u2bOGTTz5h+vTp9OvXD4AzZ85w6dIlIiMj23QCRS1RUVFUVlYyeXLbnD3SZDIRGxtLTEwMOTk59OrVi7Fjx9KhQwetQxNCWAhFUbQO4SlqVp8rkZGqrUstqu6fGf79hADzPc8teXSLaN/aftbjCTqdjjGvrcIzIIizX2+k4PFD9FZWmEym6iexAqAQMnAwY5e+jpuXT6PWb2trS5cuXejyzbj4qqoqHjx4UJtgOn36NNHR0VhZWeHv71+bYAoMDKx3iFBbYGVlxezZs7Gzs2PXrl2Ul5fXmQLex8eHN954g5iYGI4fP15brfTtKqSaptTPSyjdvn2bqqoqixzuBnWrtNpiQgmq+4utWrWKffv2sXPnTlJTU+ncuTOHDx9m5MiRDBgwQOsQNZeRkcHFixeZOHEirq6uWofTKIqiEB8fT3R0NI8ePaJbt27Mnz8fH5/GvVYKIUS79+qrWkcgLMw6rQMQwgJJD6Xms6iEElT/EfuMn0TvsRNIuX6FOxfOUFZUhJWNDQZfP3qPm4iLhzrfsltbWxMYGEhgYCBQ/a1+VlZW7TC5K1eucPLkSXQ6HT4+PnX6MDk5OakSQ2vQ6/VMnz4de3t7Dh48SFlZGWPGjKl9wlhZWTF+/Hi6d+/Ojh07+Oijjxg7dizDhw+vMxTwRU2pY2NjCQgIsNjhNG5ubuh0ujbVmLs+NjY2zJw5k6CgIPbu3cuVK1fo2rUr48eP1zo0zZlMJvbu3YuXlxdDhgzROpwGUxSFxMREoqOjycjIoEuXLsyYMYOAgACtQxNCiLbJzU3rCISFydc6ACEskCSUms/iEko1dHo9nfoNpFO/ga22Tb1ej6+vL76+vgwZMgRFUcjOzq5NMCUkJHDu3DkAOnToUJtgCg4Oxs3MP3jodDomTJiAvb09R48epaysjMmTJ9d50vj7+7N69Wqio6M5evQo8fHxzJo1q3aYjMFg4Pbt2/Wuv7S0lLt37zJp0qRW2R8tWFlZ4ebm1uYTSjWCg4OxsbFBp9ORmppKfHw8YWHte1Lby5cvk5GRwYoVK9pMX7WUlBSioqJITU0lMDCQZcuW0alTJ63DEkKItu3992HKFK2jEBbku8BBrYMQQqju73//O//zP/9DZmYm4eHh/N///R+DBw+ud9mPP/6YL774gtjYWAAGDhzIf//3fz9z+dZgsQklc6DT6ejQoQMdOnSoHQqUn59fm2BKSUnh8uXLQHX1ypONvj09Pc0ywzly5Ejs7OzYt28f5eXlREZG1rlwtra2ZuLEifTo0YMdO3awZs0axo8fz9ChQ/Hw8CAvLw+TyfTUxXZ8fDwmk6m28belelGVVltRWlrK+vXrcXR0ZMmSJRw+fJjNmzczdOhQJkyY0KaajquluLiYo0eP0r9/f4KCgrQO54UyMjKIiooiMTERHx8fFi9eTGhoqFm+7gghhBBCCGFpNm3axDvvvMOHH37IkCFD+POf/8zkyZNJSEiodyKrY8eO8corrzB8+HDs7e35/e9/z6RJk4iLi8Pf31+DPQCdIl31NFVcXExqamptkikzMxNFUXBycqozRM7b29usKh6uX7/Ojh07CAsLY/bs2fU2Ia+srOTIkSOcP3+eoKAg+vXrx65du/jBD35Q20+oxldffYXRaGTZsmWttQua2L17NxkZGaxevVrrUJqsqqqKr776iocPH/L666/j4eGBoiicO3eOw4cP4+/vz7x589pc/6Dm2rFjB7dv3+btt9/G0dFR63Ce6eHDh0RHRxMfH0+HDh0YN24cYWFhkkgSwkIVFBTg5uZGfn5+u3tdbixVm/mmpICZfblgrs2KRcME6XSkaR1EOyNNubXRGu9XNe+NsbGxuLi4qLbewsJCevfu3eB9GDJkCBEREfztb38DqttnBAYG8v3vf5+f//znL3y80WjEYDDwt7/9jaVLlzY7/qaQCiWNOTk5ERYWVjtUqLy8nLS0tNoE0+HDhzEajdjZ2REYGFibYPLz89N0Jrm+fftiZ2fHli1b2LhxIwsWLMDW1rbOMjY2NkydOpWwsDB27tzJ/v37AcjJyamTUCouLubevXtMmzatVfdBCwaDgbi4OBRFaZNvLIqisGvXLtLT01m6dGltc3GdTsfQoUPx9/dn69atrFmzhjlz5rSbGd+Sk5O5du0akZGRZptMysnJ4dixY9y4cQN3d3dmzZpFnz59zCpRLYQQFuPTT+E3v9E6CmFBVgG/1joIISxMS/VQKigoqHO7nZ3dU5N0VVRUcOnSJX7xi1/U3qbX65kwYQJnzpxp0PZKSkqorKzUdMInSSiZGTs7O0JDQwkNDQWqq0Hu379fO5PciRMnqKiowNramoCAgNoqpoCAgKcSOi2te/fuvPrqq2zYsIGvvvqKxYsXY29v/9RynTp14q233uLgwYNcvnyZ/fv389prr9X2jbp58yaAxQ93g+qEUnl5OaWlpWabeHiemoTEvHnz6h3WFRgYyOrVq9m2bRtfffUVY8aMYfTo0RadtDAajezbt4+AgAD69++vdThPyc/PJyYmhqtXr+Ls7Mz06dPp379/uxyWKIQQrebKFa0jEBbG/D5hCNH2tVRCqWbSrhrvvvsuv/71r+vc9vjxY4xGI97e3nVu9/b2Jj4+vkHb+5d/+Rf8/PyYMGFC04NuJkkomTlra+vaxt1QXQaXmZlZm2C6cOECx48fR6fT4efnV2eYnIODQ4vH17lzZ5YuXcq6dev4xz/+wZIlS+qdwc7W1pbIyEgSEhIoLCzk/fffZ/LkyfTv35+4uDhCQkLaZIKlsWoqs3Jzc9vc/l69epXjx4/z0ksv0atXr2cu5+joyOLFizlx4gTHjh0jPT2d2bNnt6mZDRvj7NmzPH78mDfffNOsqs6Kioo4ceIEly5dws7OjokTJzJo0CBsbGy0Dk0IISyfRr0shOW6r3UAQogGS0tLqzPk7dvVSWr43e9+x8aNGzl27Fi9RR2tRRJKbYxer8fPzw8/Pz+GDRuGoig8fvy4NsEUFxdXWyLn5eVVJ8HUUmNRAwICWLFiBV9++SVr166tU330bd7e3lhbW+Po6Mju3buJjY0lJSWFmTNntkhs5qamHDE3N1ezxmlNce/ePXbv3s2AAQMYMWLEC5fX6/WMGTOGgIAAtm3bxpo1a5g/f/5T2fq2rqb6Z/Dgwfj4+GgdDlDdMP3UqVOcP38evV7P6NGjGTJkSIu8kQkhhHiGP/1J6wiEhfmx1gEIYYFaqkLJ1dX1hdfeHTp0wMrKiqysrDq3Z2VlvfC64v/7//4/fve733HkyBH69u3bvKCbSRJKbZxOp6Njx4507NiRQYMGoSgK+fn5tbPIJSUlcfHiRaC6OubJmeQMBoNqTyAvL6+nkkqenp5PLWcwGEhPT+eVV14hLCyMr7/+GqgeNtRW+wo1hr29Pfb29m1qpreHDx+yefNmOnfuzLRp0xr1NwoJCWH16tVs3bqVzz//nIkTJzJkyBCL+TsfOHAAe3t7xo0bp3UolJeXc/bsWc6cOYPJZGLIkCEMHz68VSoVhRBCfMuCBbBrl9ZRCAuyGWgfX78K0T7Y2toycOBAjh49yqxZs4Dq0UhHjx7l7bfffubj/vCHP/Db3/6WgwcPMmjQoFaK9tkkoWRhdDod7u7uuLu7Ex4eDlQPfalp8p2amsrVq1cBcHZ2rpNg8vLyataFvoeHx1NJpW+PCbWrqiA/MYFrh/dj7+yCh6sLxeUV7Nmzh7t37zJ9+nScnZ2bHENbYDAY2kxCqaioiPXr1+Pm5sb8+fOb1HfH1dWVZcuWcfToUQ4ePEhqaiozZszQtDRTDbdv3yY+Pp558+ZpWv1TWVnJhQsXOHXqFOXl5QwaNIhRo0ZZ7BBDIYQQQgghLME777zDsmXLGDRoEIMHD+bPf/4zxcXFrFixAoClS5fi7+/Pe++9B8Dvf/97fvWrX7F+/Xo6depEZmYmUH1dr9U1tCSU2gFnZ2d69uxZ2/S6rKyMtLS02gTTwYMHMZlM2NvbExQUVJtg8vX1bXQCwdXVleXLl7Nu3To+//xzFi9ejL+/H7dOHOPy/l08TErEGjjyyR0AFHT49enH8FFjOHHpCu+//z7Tp09/bo+etq6tJJQqKirYsGEDJpOJxYsXNytpYmVlxaRJkwgMDGTnzp18/PHHzJ8/32yGiTVWZWUl+/fvJyQkRLNm8kajkcuXL3PixAmKi4vp168fY8aMkWnBhRDCHMybp3UEwsJs1ToAIYTqFi5cyKNHj/jVr35FZmYm/fr148CBA7VFGampqXUmN/rggw+oqKhg3rfeY+pr+t1adIqiKJpsWZiNysrKOjPJpaWlUVlZiY2NzVMzyTW0oW9ZWRkbNmzgwf10giuLyIyPQ6fTUd/ppvvmSTJu5VvcyS3k1q1b9OrVi2nTprW5xtUNceTIEWJjY/nRj36kdSjPZDKZ2Lx5M/fu3WPFihX4+vqqtu6cnBy2bNnC48ePmTZtmlnOjPYiUVFRnD59mrfeeqveoZ0tyWQycf36dWJiYsjLy6Nv376MGTNG0+lChRDmq6CgADc3N/Lz8yXh/AJqDsdWoqNh7FjV1qcGVfdPLh9a3Vidjhitg2hn1DzPLaXdQ2tojfermvfG+Ph4XFxcVFtvYWEhPXr0aFfvuZJQEk8xGo11ZpJLSUmhrKystiF4zTC5oKCg5w5bKi8v4+Of/ZCyrPs09CU08p1/pdzRhX379mFlZcXLL79Mjx491NkxM3Hp0iX27t3LL3/5S7Oduv3AgQOcP3+eV155ha5du6q+/poKnytXrtCvXz+mTZvWZmYfe/z4MR988AEjR45s1d5JiqJw8+ZNjh07xuPHjwkLC2PcuHF07Nix1WIQQrQ9klBqOFUTLpGRZtdDSRJKbdsunU56KLUySShpozUTSgkJCaonlLp3796u3nNlyJt4ipWVFf7+/vj7+zN8+HAUReHRo0e1jb6vXbvGqVOngOpZ24KDg2uTTE+O3Uy5eonyRiSTAA6v+Sur13xJp06d2LNnD5s2baJv375MmTLFYpoLGwwGFEUhLy+v1atbGuLcuXOcO3eOadOmtUgyCcDGxoYZM2YQFBTE3r17efDgAfPnzzfL4/EkRVHYt28fbm5ujBw5stW2eefOHaKjo8nMzCQ0NJTZs2fj5+fXKtsXQgghhBBCiPpIQkm8kE6nw8vLCy8vLyIiIlAUhdzc3Nrqpbt373L+/HkAPD09a4fIxe7ejk6vRzGZGrytsuIi7pw7RdjIsSxatIhr165x4MABkpKSmDFjBqGhoS21m63GYDAAkJuba3YJlISEBA4cOMCwYcOIiIho8e3169cPX19ftmzZwkcffcTMmTM160nUEHFxcSQlJbF48eJWqahKSkoiKiqK9PR0goODWbFiBUFBQS2+XSGEEM30v/+rdQTCwvxE6wCEsEA6nU7V6rH2WIkmCSXRaDqdDg8PDzw8POjXrx9QXd735BC5q+fO4HQ3vgnr1nPt8H7CRo5Fp9PRr18/OnfuzO7du1m3bh39+/dn8uTJms6q1Vxubm7o9Xqza8ydkZHB119/TVhYGBMnTmy17Xp7e/PGG2+we/dutmzZwpAhQ5g4caLZDQcsKyvj4MGDhIWFtVjlVo309HSioqJISkrCz8+PJUuW0KVLl3b5JiWEEG3S1q3wi19oHYWwIPOA32kdhBBCfIsklIQqXFxc6N27N7179wYg/txp9v7xRqPXoygmcu6n1bnNzc2NV199lUuXLnHo0CHu3bvHzJkz6dy5syqxtza9Xo+bm5tZJZTy8vJYv349Xl5ezJ49u9UTF3Z2dsydO5egoCAOHjzI/fv3mTdvHm5ubq0ax/NER0dTXl7OlClTWmwbmZmZREdHc/v2bby8vFi4cCHdu3eXRJIQQrQ1Z85oHYGwMMO0DkAIIeohCSXRIqz0Tb8ALisr5dixY7i5ueHu7o6bmxuurq4MGjSIkJAQdu3axRdffEFERAQTJkzA1tZWxchbh8FgMJuEUllZGevXr8fGxoZXXnlFs+bYOp2OwYMH4+fnx9atW1mzZg1z5swxi2GODx484MKFC0yYMKFFGuw9fvyYY8eOERcXh4eHB3PmzKF3796SSBJCqMacEvRg+U2d1+7ezUqVXsPVOlaWfszNkZrv45+ptib1mGPTanOMCdSLy9Jjam0y5K35JKEkWoSDczO65VvZcOnSJYqKiurc7OzsjJubG25ubnTq1IlLly5x69Ytxo8fT1hY2HNnnDM3BoOB9PR0rcPAaDSyefNmCgsLWbVqFU5OTlqHREBAAG+++Sbbt29n3bp1jB49mjFjxqDX6zWJR1EU9u7dS8eOHRkyZIiq687LyyMmJoZr167h6upKZGQk/fr102xfhRBCqGOl1gEIiyPnlBDCHElCSbQI367dsXd2oayosFGP0+n0DJw4lTFLVlBVVUVBQQF5eXnk5+c/9QNQVFTErl272LVrF7a2trUVTTU/T/7u7OxsNhfqBoOBGzduoCiKZplsRVHYs2cPKSkpvPbaa3To0EGTOOrj6OjI4sWLOXHiBMeOHSM9PZ05c+ZokvC6fPky9+/fZ8WKFar1dSosLOT48eNcvnwZBwcHpkyZwoABA7C2lpdkIYSwBDtBpngXqpJzSgj1SYVS88nVi2gRVtY29Js0jXM7tjRqljeTYiI+O5+AxES6dOlS2/y7PoqiUFBQwOnTp7l48SLW1tZ4enpiNBpJS0vjxo0blJeX1y6v1+txdXV9KulUk3hydXVtteFeBoOBiooKSkpKNKsKOnHiBFevXmX27Nl06tRJkxieR6fTMXr0aAIDA/n6669Zs2YN8+bNa9VZzoqLizly5Aj9+vVTZbslJSWcPHmSCxcuYGNjw/jx4xk8eLBmwwyFEEIIIYQQoqkkoSRaTPjEaVzev5vKsjIU5cVJJZ1OT0CffhQ5u/DVV18RHBzMSy+9RGBg4DOW1+Hm5sbUqVMZNGgQO3bsID4+nuHDhzN//nysra0pKyurU9WUl5dHQUEB2dnZ3Lt3j8LCuhVUTk5O9Sabav7fwcFBlcyzwWAAIDc3V5OE0o0bN4iOjmbs2LH07du31bffGJ07d2b16tVs3bqVzz//nAkTJjBs2LBW+QbgyJEjAEyYMKFZ6ykrK+PMmTOcPXsWgBEjRjB06NA2NUxTCCFEw+3ROgBhceScEkKYI0koiRbj7OHJ7H/5FV//9lcYjVXPrVTS6XT4hHZlzk//FWtbO+7cuUNUVBSfffYZXbt2Zfz48fj4+Dzz8R07dmTVqlWcPHmSmJgY7ty5w6xZs/D19cXe3h5vb+96H2c0GikoKKhNNj2ZfLpz5w75+flUVVXVLm9jY/NUkunJ311cXBo0rO7JhFJAQMALl1dTSkoKO3fuJDw8nNGjR7fqtpvKxcWFZcuWcfToUQ4fPkxaWhozZ85s0YRMSkoKV69e5eWXX25y0q+iooLz589z6tQpqqqqGDx4MCNGjMDR0VHlaIUQQpiTWK0DEBZHzikh1CdD3ppPp8iUD6KFZd27y76//S8599PQ6a1QTMba+3Q6Peig5+jxvLTqLWxs7WrvUxSFuLg4oqOjycnJoVevXowbNw5PT8/nbi8zM5MdO3bw6NEjRo0axahRo5rc+0ZRFIqLi5+qcnry99LS0if2R4erq2udYXTfTj7VzEr3hz/8gaFDh7ZqUufx48d8+umn+Pj4sGTJEtV6ArWmhIQEtm/fjqOjIwsWLHhuorGpjEYjH330ETY2NqxatarRbw5VVVVcunSJEydOUFpaysCBAxk1ahQuLs1oVi+EEE1QUFBgdjO8gXnOOKbmhYCa/W7M8ViJhjHXc0ot5jijmjnGBOY5o5o5xgSQn5/fIrMqP6nmvTExMVHVz+eFhYWEhIS0yj6YC0koiVahKAr3E25y7dA+HqUkUVlejoOLCyGDhtBn/GScDfX3SQIwmUxcvXqVmJgYCgsL6devH2PGjHnuB2Sj0cjx48c5ceIE3t7ezJo165lVSs1VUVFRb6Kp5rbCwsI6L9gODg64u7uTm5uLs7MzAwYMqFPl5Ojo2CLZ7eLiYj799FOsrKxYtWpVmx5ulZuby5YtW3j48CHTpk2jf//+qh6z06dPc+TIEd544w18fX0b/Dij0ci1a9dqz9Xw8HDGjBmDu7u7arEJIURjSEKp4cz14t8cj5VoGHM9p9Rijskbc4wJzDN5Y44xQesmlO7du6d6QqlLly6SUBLCHFVVVXHx4kVOnDhBeXk5gwYNYtSoUc8djpSRkcGOHTvIzs5m7NixjBgxotVnejMajRQWFj5V4XT79m3KysoA6gyrs7a2fmYPJ3d3d1xcXBpdWVRZWckXX3xBbm4ur7/+ukUkOKqqqjhw4ACXLl0iPDycadOm1VZ/NUd+fj5///vfGTBgAFOmTGnQYxRFITY2lmPHjtVW040dO9asZs4TQrRPklBqODUvinqj3hAlczxWomHM9ZxSizkmb8wxJjDP5I05xgSSUGprJKEk2pzy8nLOnTvH6dOnMZlMDB06lOHDhz+z4qaqqopjx45x+vRp/Pz8mDVrlllc6B89epTr16/zox/9iNLS0mdWOOXn51NSUlL7OJ1Oh4uLy3Obh9vZ1R06uHXrVm7fvs3y5cvx9/fXYndbzPXr19mzZw/u7u4sWLCg2X/bzZs3k5aWxttvv13nONZHURQSEhKIjo7m4cOHdOvWjXHjxrXIMDwhhGgKSSg1nJoXRe8Af1RpXeZ4rETDmOs5pRZzTN6YY0xgnskbc4wJWjehlJSUpHpCqXPnzu0qoSRNuUWbY2dnx+jRo4mIiODUqVOcOXOGCxcuMGLECAYPHvxUlYq1tTUTJkyge/fu7Ny5kzVr1jB+/HiGDBnS6tVKTzIYDBQUFGA0GnF0dMTR0RE/P796l62srHxmD6f09HQKCgowPdH03N7evjbJlJ+fT2ZmJsOHD0dRFIqKinBycrKYpnF9+/bFx8eHLVu28PHHHxMZGUnv3r2btK47d+5w69Yt5s6d+9xkkqIoJCYmEh0dTUZGBl26dCEyMrLVG6wLIYQwT2Mwv4t/0bbJOSWEMEdSoSTavMLCQk6cOMGlS5dwcHBg9OjRDBgwAGvrp/OllZWVHD16lHPnzhEUFMTMmTPx8Hh2/6aWlJSUxBdffMH3vve9ZlfVmEymOsPqahJPqampPHr0CCsrK4zGfzZDt7Kyem6Fk6ura73Hz5xVVFSwe/duYmNjiYiIYNKkSc/cB0VRqCyvHm5oY2ePTqejsrKSDz74AIPBwJIlS56ZcEtJSSEqKorU1FQCAwMZP348nTp1aqndEkKIZpEKpYZT84uWdcCrKq3LHI+VaBhzPafUYo7VQOYYE5hnNZA5xgRSodTWSEJJWIy8vDxiYmK4du0arq6ujB07lr59+9ZbhZSSksKOHTsoLi5mwoQJREREtHrFTl5eHn/5y19YvHgxXbt2VX39d+7cYcOGDQwaNIgpU6ZQXl7+3ObhxcXFdR7v7Oz81Ax1TyaezLGpt6IoXLx4kQMHDuDr68u8efPq9It6nJbCtcP7iDt2tE5CqdfYlyh368jlW/G89dZb9c4kmJGRQVRUFImJifj4+DB+/HhCQ0MtptJLCGGZJKHUcOb6em6Ox0o0jLmeU2oxx+SNOcYE5pm8MceYoPUTSmpuq6CgQBJKQrR1jx494tixY9y8eZMOHTowbtw4wsLCnnqxq6io4PDhw1y8eJHOnTszY8aMVm1WbTKZ+O1vf8vkyZMZPHiwquvOzMxk7dq1dOrUiYULFzZoaF9VVdVTSaaCgoI6Cagnh9XZ2dk9t8rJxcVFsw9S9+/fZ8uWLVRUVDB79my6dO7EoY/+j5sxUej0epQn9gOovc2jW0+WvvtbrKxtau97+PAh0dHRxMfHP/d8EkIIcyQJpYZT83V9M7BApXWZ47ESDWOu55RazDF5Y44xgXkmb8wxJpCEUlsjCSVhsTIyMoiOjubu3bv4+voyfvx4QkJCnnrRu3fvHjt37qSsrIzJkyerPgX98/zf//0f3bp1Y/Lkyaqts6CggE8++QRnZ2eWL1+uysxnQG3/pfqqnGp+Ly8vr11er9fj6ur6VJXTk7+35LC60tJStm/fzp3bt/ErzqYgLRle9HKn09FlQAQzf/pL8vLyOXbsGDdu3MDd3Z2xY8fSp08fTftuCSFEY0lCqeHMdYp3czxWomHM9ZxSizkmb8wxJjDP5I05xgStm1BKTk5WPaHUqVMnSSgJYUlSUlI4evQoaWlpBAUFMX78eIKDg+ssU1ZWxsGDB7l69SqhoaFERka2yovAV199hbW1NYsWLVJlfeXl5axdu5bS0lJef/11VccEN0RZWdkzm4fn5+dTWFhYZ3knJ6faJNO3k0/u7u7Y29s3601KURQ2/+X/I+1MDI1ZS4f+Q0ipUHB2dmb06NH0798fKyurJschhBBakYRSw6l5UfQ28DeV1mWOx0o0jLmeU2oxx+SNOcYE5pm8MceYQBJKbU3b6rorRBMEBwezYsUK7t69S1RUFJ9//jmhoaGMHz8eX19foHpWtJkzZxIWFsbu3bv54IMPmDJlCn379m3RaiWDwUBqaqoq6zKZTGzdupW8vDxWrFjR6skkqD6O9vb2eHt713u/0Wh8ahhdzdC6zMxM8vPz6zQPt7W1fWpY3ZNVTi4uLs+tGDIZjeTEXW1UMkkBHt24zITv/pSIwYOxsbF54WOEEEKIJ53SOgBhceScEkKYI0koiXZBp9PRtWtXQkNDuXnzJtHR0Xz00Uf07NmTcePG1c6y1q1bN7773e9y4MABduzYwa1bt3j55ZdxdnZukbgMBgPXrl1DUZRmV+Ls27ePe/fusXjx4mcmdLRmZWWFwWDAYDDUe7+iKBQXF9db5XT//n3i4uIoKyurXV6n0+Hq6vrUULqan8e3b1FSkN+oGHUAVZV0tNFJMkkIIUST/BrzG54k2rZfI+eUEGrT6XSqFg+0xx6rklAS7YpOp6NXr16EhYVx7do1YmJieP/99wkPD2fMmDG4u7vj4ODA7Nmz6dGjB3v37uX9999n2rRp9O7dW/V4DAYDlZWVFBcXNytpdfr0aS5dukRkZCQhISEqRti6dDodzs7OODs74+/vX+8yNbPVfbvCKTc3l+TkZAoLC2tLeG0zU7BBh47GlfTqraxIu3mDroOHN3ufhBBCPM0ch22oaUZkJMquXVqHITSm5rm5ywwvVM3x4tkcYwLLH9In2i9JKIl2Sa/X079/f/r06cOlS5c4ceIE169fZ+DAgYwePRpnZ2fCwsIICgpi3759fP3119y6dYvp06fj6OioWhw1lTq5ublNTijFxcVx5MgRRo4cyYABA1SLzVzZ2dnh5eWFl5dXvfcbjUYKCwvJz8/n1Jef8CD3EY3MJ6EoUFFSokK0Qggh2qV//3etIxAW5j+1DkAICyQVSs0n0xWJds3a2pohQ4bwgx/8gLFjx3Ljxg3++te/cuTIEUpLS3FycmL+/PnMnTuXpKQk3n//feLj41Xb/pMJpaZIS0tj+/bt9O7dm/Hjx6sWV1tVWVlJZmYm9+7dIy4ujpz8/BdO7FYfnQ5s7O3VD1AIIUT7cP681hEICzNY6wCEEKIeUqEkBNXNn0eNGsWgQYM4ffo0586d4+LFi4wYMYIhQ4bQu3dvOnXqxO7du9m0aRN9+/ZlypQpODg4NGu7dnZ2ODo6NimhlJOTw8aNG/H392fmzJntKiOuKApFRUVkZmaSlZVFVlYWmZmZZGdn1/aj8vT0xMXHj/LUe41ev8loxCekWwtELoQQol04eBC+9z2toxAWZDLwvtZBCCHEt0hCSYgnODg48NJLLzFkyBBOnDhBTEwM586dY9SoUQwcOJBFixZx7do1Dhw4QFJSEpGRkXTt2rVZ2zQYDI1OKJWWlrJ+/Xrs7e1ZuHAh1taW+1Q2Go08fvy4NmlU82/JN0PS7Ozs8Pb2pnPnzgwbNgxvb2+8vLywsbGhsqKcD9+8REVpaaO2aevgSPdho1pid4QQQrQHFvy+LLRRpXUAQlggGfLWfPJuJ0Q9nJ2dmTp1KsOGDSMmJoaDBw9y+vRpxo4dS3h4OF26dGHXrl2sX7+e/v37M3nyZOzs7Jq0rcYmlKqqqti4cSMlJSW8/vrrqvZ00lppaelTiaNHjx5hNBoBcHd3x8fHh4iICHx8fPD29sbd3f2ZL942tnaET5zGxd3bGtzEUKfTET5pGta2tqrtlxBC1Oe9995j27ZtxMfH4+DgwPDhw/n9739P9+7da5cpKyvjJz/5CRs3bqS8vJzJkyfz/vvvm+1snuIb27ZpHYGwMHO1DkAIIeohCSUhnsPd3Z2ZM2cyYsQIjh07xq5duzh16hTjxo1j8eLFXLlyhUOHDnHv3j1mzJhBly5dGr0Ng8FASkpKg5ZVFIVdu3Zx//59li1bhoeHR6O3Zw4URSE3N5fMzMw6w9by8/OB6t5WXl5e+Pr60r9/f7y9vfH29sa+CX2Nhs1fTGrcdR4mJaKYTM9dVqfX4905lGHzXmnSfgkhRGPExMTwve99j4iICKqqqvjXf/1XJk2axM2bN3FycgLgxz/+MXv37mXLli24ubnx9ttvM2fOHE6dOqVx9OK5liyBr77SOgphQb4EXtM6CCGE+BadYo5zrQphph48eEB0dDR37tzB29ub8ePH07FjR3bt2kVycjKDBg1i4sSJ2DaiuuXKlSvs2rWLX/7yly8cuhYVFcWJEyeYN28evXr1au7utIqKigoePnxYp+ro4cOHVFRUANXVYN7e3rUVRz4+Pnh6eqLXqzdnQHlJMTv/579Iu3kDnV7/VGKp5rbAXn2Z+dNfYufopNq2hRCioR49eoSXlxcxMTGMHj2a/Px8OnbsyPr165k3bx4A8fHxhIWFcebMGYYOHfrCdRYUFODm5tbSoWtKrY+yag5VUCIjYdcu1dYnxC6djplaByE0p+alu7kOz8rPz8fV1bVFt1Hz3pienq7qtgoKCggICGiVfTAXUqEkRCP4+vqyePFiUlNTOXr0KBs2bCAwMJBx48YRFhbGkSNHSExMZObMmQQHBzdonU/O9NaxY8dnLnflyhVOnDjBSy+9ZJbJJEVRKCwsrJM4ysrKIjs7G6h+0+rYsSPe3t706NGjNoHk7Ozc4rHZOTox/99/S/K1y1w5uIekKxfr3N8pfCD9p7xMp7790amYyBJCiMaoqdKsqT69dOkSlZWVTJgwoXaZHj16EBQU9MyEUnl5OeXl5bW/FxQUtHDUol6jpA+fUNcJrQMQQoh6SEJJiCYICgpi+fLlJCYmEhUVxRdffEFISAizZ8/mzJkzfP755wwZMoSXXnoJGxub566rIQmle/fusWfPHgYMGMCIESNU35/GMhqNPHr06KlZ1kq/aX5tb2+Pt7c3ISEhjBgxAh8fHzp27Khp83CdXk/n/oPo3H8QpYUFFOdV961ycjfg4NI+vkEQQpgvk8nEj370I0aMGEHv3r0ByMzMxNbWFnd39zrLent7k5mZWe963nvvPX7zm9+0dLjiRaZP1zoCYWH2ah2AEELUQxJKQjSRTqcjNDSUkJAQbt26RXR0NJs3b6ZHjx4MHz6cc+fOcffuXWbNmkVAQMAz1+Pq6oqVlRXZjx+jhIY+VSHz8OFDNm/eTOfOnZk+fXqrl6eWlJQ8lTh69OgRpm+GjRkMBnx8fBgyZEht1ZGbm5vZltECOLi4ShJJCGFWvve97xEbG8vJkyebtZ5f/OIXvPPOO7W/FxQUEBgY2NzwRGP9/Ocy5E2o6ncgQ96EEGZHEkpCNJNOp6Nnz5706NGD69evc+zYMRISEujWrRt5eXl89tlnDB8+nLFjxz5VoZN59zZXD+/DIe4Cp2+c5fRfwLWjF+ETp9F73ERMeivWr1+Pm5sb8+fPV7Wv0LeZTCZycnKemmWtsLAQqG6U7e3tjb+/PwMHDsTHxwcvL68mz24nhBCi2ttvv82ePXs4fvx4nS8gfHx8qKioIC8vr06VUlZWFj4+PvWuy87OTl6XhRBCiAbQ6XSqfgluzl+otxRpyi2Eyqqqqrh8+TLHjx+npKQEPz8/Hjx4gKenJ7NmzcLPz4+y4iL2/Pl3pFy/ik5vhWIy1lmHTqdDp9djExJGhcGLVatWqdpUtby8vLZRdk3y6OHDh1RWVgLg4uJSp0m2t7c3Hh4eLZrQEkKI9kZRFL7//e+zfft2jh07RteuXevcX9OUe8OGDcydWz1peEJCAj169JCm3E8wy6bcJ07AyJGqrU+IkTodMrejkKbc6qh5b7x//77qTbn9/f2lKbcQoumsra0ZPHgw/fr14/z585w6dQqdTkdJSQmffPIJw4cM4f7hXWTfTwN4KpkE1W8WitFI+e1YwqfPbvLFgKIoFBQU1EkcZWZmkptb3T9Ir9fXNsru1atXbQLJ0dGx6QdACCFEg3zve99j/fr17Ny5ExcXl9q+SG5ubjg4OODm5saqVat455138PDwwNXVle9///sMGzasQckkoaGEBEkoCVV1B0koCSHMjlQoCdHCysrKOHPmDKdPn0ZRFGxS72Cdn92odcz7t/8iuE+/5y5TVVVVp1F2zb9lZWUAODg41FYb1SSOOnTooGmjbCGEaM+e9e3w2rVrWb58OVD9HvKTn/yEDRs2UF5ezuTJk3n//fefOeTt26RCqeFUrVCKjJQeSkJVu3Q66aEkpEJJJTXvjRkZGapXKPn5+UmFkhBCPfb29owbN47BgwcTfegA8TfONurxOr2eS3t31EkoFRcXP5U4evz4cW2jbE9PT7y9vRk2bBg+Pj74+Pjg4uJitm8cQgjRHjXkwsDe3p6///3v/P3vf2+FiIQQQgghGk4SSkK0EicnJzyqytHrdI36dkExmUi6cpF9278mt6SMzMxMioqKALCxscHb25vAwEAiIiJqG2Xb2tq21G4IIYQQ4kW2b9c6AmFhZmsdgBBC1EMSSkK0opTrV5pcqhp//iy+fQfQv3//Oo2ypepICCGEMDOrV8Mnn2gdhbAga4A3tA5CCAsjs7w1nySUhGhFZcVFTXqcTqdj7KiRDJgmo+eFEEIIs/fwodYRCAvjpXUAQghRD0koCdGKbOztm/Q4RVGwtmvaY4UQQgi1GoSq9e2rxc8JM3iw1hE8RdWm45b+9zND51Vaj7n+7Sy9ssMsJw8ww5hE26PXOgAh2hPf0O7o9E172nl3CVU5GiGEEEK0iFde0ToCYWE2aB2AEELUQxJKQrSi8IlTUb6Zia2hdDod3l1C8e4c0kJRCSGEEEJVP/6x1hEIC/MnrQMQwgLV9FBS86e9kYSSEK2oQ2AwAWG9GlWlpCgKA6bOaMGohBBCCCGEEEKIxpGEkhCtbMp3f4ydk1PDkko6Hd2HjyZs5NgWj0sIIYQQKvnhD7WOQFiYv2gdgBBC1EMSSkK0MjcvHxb95g84uXtU31BPaaRObwVAz1HjmPq9Hze575IQQgghNPDggdYRCAvjq3UAQlggGfLWfHKVKoQGPP0DWfGnD5jw+vfw9A+sc59Or6frkGEsePc9pnz3x1hZ22gUpRBCCCGaZPNmrSMQFmaB1gEIIUQ9rLUOQIj2ytbegfCJU+k7YQr5WZmUFORjZW2Na0cvHFyaP7WzEEIIIYQQQgjRUiShJITGdDod7j6+uPtIMbMQQghhETZu1DoCYWEWaR2AEELUQ4a8CSGEEEIIoaaf/UzrCISF+R+tAxBCiHpIhZIQQgghhBBqSkvTOgJhYQJfvIgQopHUbqQtTbmFEEIIIYQQzRMernUEwsJc0zoAIYSohySUhBBCCCGEUNPq1VpHICzMGq0DEEKIekhCSQghhBBCCDV997taRyAszPtaByCEBaoZ8qbmT3sjCSUhhBBCCCGEEEII0SiSUBJCCCGEEEJNMuRNqEyGvAkhzJEklIQQQgghhFBTSYnWEQgL46h1AEIIUQ9JKAkhhBBCCKGmL7/UOgJhYV7TOgAhLJD0UGo+a60DEEIIIYQQ7YuaH7oVRVFtXWrZtXs3M1XaR7X2zxyPk2jb2uPFc1OZ47FSKya1XlsKCgpwc3NTZV2i9UiFkhBCCCGEECparnUAwuIs1zoAIYSohySUhBBCCCGEUNG/aR2AsDhyTgmhPhny1nySUBJCCCGEEEJFoVoHICyOnFNCCHMkCSUhhBBCCCFUlKB1AMLiyDklhDBH0pRbCCGEEEIIFf1e6wCExZFzSgj1qT1MTYa8CSGEEEIIIZrlM60DEBZHzikhhDmShJIQQgghhBBCCCGEaBRJKAkhhBBCCKGiz7UOQFicz7UOQAgh6iE9lIQQQgghhFBRpdYBCIsj55QQ6pMeSs0nFUpCCCGEEEKo6A2tAxAWR84pIYQ5koSSEEIIIYQQQgghhGgUGfImhBBCCCGEir6jdQDC4sg5JYT6ZMhb80mFkhBCCCGEECp6W+sAhMWRc0oIYY4koSSEEEIIIYSKemsdgLA4ck4JIcyRJJSEEEIIIYRQUYrWAQiLI+eUEOqrGfKm5k9j/f3vf6dTp07Y29szZMgQzp8//9zlt2zZQo8ePbC3t6dPnz7s27evqbuvCkkoCSGEEEIIoaJ/1ToAYXHknBLC8mzatIl33nmHd999l8uXLxMeHs7kyZN5+PBhvcufPn2aV155hVWrVnHlyhVmzZrFrFmziI2NbeXI/0mnKIqi2daFEEIIIUSLKSgowM3Njfz8fFxdXZu9PnNsOKrWR1k1920nMFOldclHdQGwS6dT5ZxS83wyx9cD0frUOqfUfr/SYluNXe+QIUOIiIjgb3/7GwAmk4nAwEC+//3v8/Of//yp5RcuXEhxcTF79uypvW3o0KH069ePDz/8ULX9aAyZ5U0IIYQQwkLVfNAvKCjQOJKWY477VqLiusxx/0TrU+uckvNJqE2tc6pmPa2ZRFf7+VCzvm+v187ODjs7uzq3VVRUcOnSJX7xi1/U3qbX65kwYQJnzpypd/1nzpzhnXfeqXPb5MmT2bFjhwrRN40klIQQQgghLFRhYSEAgYGBGkfSctzc3LQO4SmvqLguc9w/0XbJ+STUpvY5VVhY2OLnqa2tLT4+Pi3y3ujs7PzUet99911+/etf17nt8ePHGI1GvL2969zu7e1NfHx8vevOzMysd/nMzMzmB95EklASQgghhLBQfn5+pKWl4eLi8szhKQUFBQQGBpKWltbiwwxENTnmrU+OeeuTY9762vIxVxSFwsJC/Pz8Wnxb9vb2JCUlUVFRofq6FUV56v3229VJlkQSSkIIIYQQFkqv1xMQENCgZV1dXdvcBUhbJ8e89ckxb31yzFtfWz3mrVlBZ29vj729fatt79s6dOiAlZUVWVlZdW7PysrCx8en3sf4+Pg0avnWILO8CSGEEEIIIYQQQrQSW1tbBg4cyNGjR2tvM5lMHD16lGHDhtX7mGHDhtVZHuDw4cPPXL41SIWSEEIIIYQQQgghRCt65513WLZsGYMGDWLw4MH8+c9/pri4mBUrVgCwdOlS/P39ee+99wD44Q9/yJgxY/jf//1fpk+fzsaNG7l48SIfffSRZvsgCSUhhBBCiHbMzs6Od99916J7PJgbOeatT45565Nj3vrkmLctCxcu5NGjR/zqV78iMzOTfv36ceDAgdrG26mpqej1/xxUNnz4cNavX8+//du/8a//+q907dqVHTt20Lt3b612AZ3SmvPyCSGEEEIIIYQQQog2T3ooCSGEEEIIIYQQQohGkYSSEEIIIYQQQgghhGgUSSgJIYQQQgghhBBCiEaRhJIQQgghhBBCCCGEaBRJKAkhhBBCtGN///vf6dSpE/b29gwZMoTz589rHZLF+vWvf41Op6vz06NHD63DsijHjx8nMjISPz8/dDodO3bsqHO/oij86le/wtfXFwcHByZMmMCdO3e0CdZCvOiYL1++/KnzfsqUKdoEayHee+89IiIicHFxwcvLi1mzZpGQkFBnmbKyMr73ve/h6emJs7Mzc+fOJSsrS6OIhaWShJIQQgghRDu1adMm3nnnHd59910uX75MeHg4kydP5uHDh1qHZrF69erFgwcPan9OnjypdUgWpbi4mPDwcP7+97/Xe/8f/vAH/vrXv/Lhhx9y7tw5nJycmDx5MmVlZa0cqeV40TEHmDJlSp3zfsOGDa0YoeWJiYnhe9/7HmfPnuXw4cNUVlYyadIkiouLa5f58Y9/zO7du9myZQsxMTFkZGQwZ84cDaMWlkinKIqidRBCCCGEEKL1DRkyhIiICP72t78BYDKZCAwM5Pvf/z4///nPNY7O8vz6179mx44dXL16VetQ2gWdTsf27duZNWsWUF2d5Ofnx09+8hN++tOfApCfn4+3tzeff/7/t3fnIVH1exzHP9PYIpSKpU4SpS2jtiFamVhGOWQSQTuGUBNJERmULRRhtqe0EBUGQWhBC1FUEBWBZZFFy1DSYlZiWYRZ1lRGq87zx8Mz3Lnd5+HOvZOHZt4vEPR3DsfPGb5/ffidM2XKzs42MK1/+PfPXPpzh5LT6fxp5xJ85/Xr14qMjNSlS5eUnp6u9+/fKyIiQocOHdLUqVMlSQ8fPlRCQoKuXbum4cOHG5wY/oIdSgAAAAHo27dvcjgcstls7rV27drJZrPp2rVrBibzb48fP1Z0dLR69+6tnJwc1dfXGx0pYNTV1amhocFj5kNDQ5WSksLM/2IVFRWKjIxUXFyc5s+fr6amJqMj+ZX3799LksLDwyVJDodD379/95j1+Ph49ezZk1mHT1EoAQAABKA3b96opaVFUVFRHutRUVFqaGgwKJV/S0lJUVlZmc6dO6c9e/aorq5OI0eO1MePH42OFhD+mmtmvm2NGzdOBw4cUHl5uYqLi3Xp0iVlZWWppaXF6Gh+obW1VYsWLVJaWpoGDhwo6c9Z79Chg8LCwjzOZdbha0FGBwAAAAACQVZWlvv3wYMHKyUlRb169dLRo0c1Z84cA5MBv86/Pko4aNAgDR48WH369FFFRYUyMjIMTOYfFixYoHv37vE+NhiCHUoAAAABqFu3bjKbzT9968+rV69ksVgMShVYwsLCZLVa9eTJE6OjBIS/5pqZN1bv3r3VrVs35t4H8vLydPr0aV28eFE9evRwr1ssFn379k1Op9PjfGYdvkahBAAAEIA6dOig5ORklZeXu9daW1tVXl6u1NRUA5MFjubmZtXW1qp79+5GRwkIsbGxslgsHjP/4cMHXb9+nZlvQy9evFBTUxNz/39wuVzKy8vTiRMndOHCBcXGxnocT05OVvv27T1mvaamRvX19cw6fIpH3gAAAAJUfn6+Zs2apSFDhmjYsGHasWOHPn36pNmzZxsdzS8tXbpUEyZMUK9evfTy5UsVFhbKbDZrxowZRkfzG83NzR47X+rq6nTnzh2Fh4erZ8+eWrRokTZs2KB+/fopNjZWBQUFio6O9vhWMnjnnz7z8PBwrV27VlOmTJHFYlFtba2WL1+uvn37KjMz08DUv7cFCxbo0KFDOnXqlLp06eJ+L1JoaKiCg4MVGhqqOXPmKD8/X+Hh4QoJCdHChQuVmprKN7zBp0wul8tldAgAAAAYY/fu3dqyZYsaGhqUmJionTt3KiUlxehYfik7O1uXL19WU1OTIiIiNGLECG3cuFF9+vQxOprfqKio0OjRo39anzVrlsrKyuRyuVRYWKi9e/fK6XRqxIgRKikpkdVqNSCtf/inz3zPnj2aOHGibt++LafTqejoaI0dO1br16//6eXo+O+ZTKb/uF5aWiq73S5J+vLli5YsWaLDhw/r69evyszMVElJCY+8wacolAAAAAAAAOAV3qEEAAAAAAAAr1AoAQAAAAAAwCsUSgAAAAAAAPAKhRIAAAAAAAC8QqEEAAAAAAAAr1AoAQAAAAAAwCsUSgAAAAAAAPAKhRIAAAAA/I9iYmK0Y8cOo2MAQJujUAIAAADg1+x2u0wmk4qKijzWT548KZPJZFAqAPi9USgBAAAA8HudOnVScXGx3r17Z3QUAPALFEoAAAAA/J7NZpPFYtHmzZv/9pzjx49rwIAB6tixo2JiYrRt2zaP442NjZowYYKCg4MVGxurgwcP/nQNp9Op3NxcRUREKCQkRGPGjFFVVZX7eFVVlUaPHq0uXbooJCREycnJunXrlu9uFADaCIUSAAAAAL9nNpu1adMm7dq1Sy9evPjpuMPh0PTp05Wdna27d+9qzZo1KigoUFlZmfscu92u58+f6+LFizp27JhKSkrU2NjocZ1p06apsbFRZ8+elcPhUFJSkjIyMvT27VtJUk5Ojnr06KGbN2/K4XBoxYoVat++/S+9dwD4FYKMDgAAAAAAbWHSpElKTExUYWGh9u3b53Fs+/btysjIUEFBgSTJarXqwYMH2rJli+x2ux49eqSzZ8/qxo0bGjp0qCRp3759SkhIcF/jypUrunHjhhobG9WxY0dJ0tatW3Xy5EkdO3ZMc+fOVX19vZYtW6b4+HhJUr9+/dri1gHA59ihBAAAACBgFBcXa//+/aqurvZYr66uVlpamsdaWlqaHj9+rJaWFlVXVysoKEjJycnu4/Hx8QoLC3P/XVVVpebmZnXt2lWdO3d2/9TV1am2tlaSlJ+fr9zcXNlsNhUVFbnXAeB3Q6EEAAAAIGCkp6crMzNTK1eu9Pm1m5ub1b17d925c8fjp6amRsuWLZMkrVmzRvfv39f48eN14cIF9e/fXydOnPB5FgD41XjkDQAAAEBAKSoqUmJiouLi4txrCQkJqqys9DivsrJSVqtVZrNZ8fHx+vHjhxwOh/uRt5qaGjmdTvf5SUlJamhoUFBQkGJiYv72/1utVlmtVi1evFgzZsxQaWmpJk2a5NN7BIBfjR1KAAAAAALKoEGDlJOTo507d7rXlixZovLycq1fv16PHj3S/v37tXv3bi1dulSSFBcXp3HjxmnevHm6fv26HA6HcnNzFRwc7L6GzWZTamqqJk6cqPPnz+vp06e6evWqVq1apVu3bunz58/Ky8tTRUWFnj17psrKSt28edPjPUwA8LugUAIAAAAQcNatW6fW1lb330lJSTp69KiOHDmigQMHavXq1Vq3bp3sdrv7nNLSUkVHR2vUqFGaPHmy5s6dq8jISPdxk8mkM2fOKD09XbNnz5bValV2draePXumqKgomc1mNTU1aebMmbJarZo+fbqysrK0du3atrx1APAJk8vlchkdAgAAAAAAAL8PdigBAAAAAADAKxRKAAAAAAAA8AqFEgAAAAAAALxCoQQAAAAAAACvUCgBAAAAAADAKxRKAAAAAAAA8AqFEgAAAAAAALxCoQQAAAAAAACvUCgBAAAAAADAKxRKAAAAAAAA8AqFEgAAAAAAALxCoQQAAAAAAACv/AEHVFK5QMppQAAAAABJRU5ErkJggg==",
 34:       "text/plain": [
 35:        "<Figure size 1200x500 with 3 Axes>"
 36:       ]
 37:      },
 38:      "metadata": {},
 39:      "output_type": "display_data"
 40:     }
 41:    ],
 42:    "source": [
 43:     "import networkx as nx\n",
 44:     "import matplotlib.pyplot as plt\n",
 45:     "import numpy as np\n",
 46:     "\n",
 47:     "def plot_sbm_graph(block_sizes, p_matrix):\n",
 48:     "    # Validate the connectivity matrix\n",
 49:     "    n_blocks = len(block_sizes)\n",
 50:     "    if p_matrix.shape != (n_blocks, n_blocks):\n",
 51:     "        raise ValueError(\"The connectivity matrix dimensions must match the number of blocks.\")\n",
 52:     "    if np.any(p_matrix < 0) or np.any(p_matrix > 1):\n",
 53:     "        raise ValueError(\"All probabilities in the connectivity matrix must be between 0 and 1.\")\n",
 54:     "\n",
 55:     "    # Generate Stochastic Block Model graph\n",
 56:     "    G = nx.stochastic_block_model(block_sizes, p_matrix)\n",
 57:     "\n",
 58:     "    # Get adjacency matrix\n",
 59:     "    adj_matrix = nx.to_numpy_array(G)\n",
 60:     "\n",
 61:     "    # Assign colors based on block membership\n",
 62:     "    colors = [G.nodes[node]['block'] for node in G.nodes]\n",
 63:     "\n",
 64:     "    # Plotting the graph\n",
 65:     "    pos = nx.spring_layout(G, seed=42)  # For consistent layout\n",
 66:     "    plt.figure(figsize=(12, 5))\n",
 67:     "\n",
 68:     "    # Subplot 1: SBM graph\n",
 69:     "    plt.subplot(1, 2, 1)\n",
 70:     "    nx.draw(G, pos, node_color=colors, cmap=plt.cm.tab10, with_labels=False,\n",
 71:     "            node_size=100, edge_color='gray')\n",
 72:     "    plt.title('Stochastic Block Model')\n",
 73:     "\n",
 74:     "    # Subplot 2: Adjacency matrix with visible block structure\n",
 75:     "    plt.subplot(1, 2, 2)\n",
 76:     "    plt.imshow(adj_matrix, cmap='Greys', interpolation='none')\n",
 77:     "    plt.colorbar(label='Edge Weight')\n",
 78:     "    plt.title('Adjacency Matrix')\n",
 79:     "    plt.xlabel('Nodes')\n",
 80:     "    plt.ylabel('Nodes')\n",
 81:     "\n",
 82:     "    # Overlay block boundaries for visual separation\n",
 83:     "    block_boundaries = np.cumsum([0] + block_sizes)\n",
 84:     "    for boundary in block_boundaries:\n",
 85:     "        plt.axhline(boundary - 0.5, color='red', linestyle='--', linewidth=0.5)\n",
 86:     "        plt.axvline(boundary - 0.5, color='red', linestyle='--', linewidth=0.5)\n",
 87:     "\n",
 88:     "    plt.tight_layout()\n",
 89:     "    plt.show()\n",
 90:     "\n",
 91:     "# Example usage\n",
 92:     "block_sizes = [5, 8, 10]  # Sizes of each block\n",
 93:     "p_matrix = np.array([[0, 0.1, 0.5],\n",
 94:     "                     [0.1, 0.6, 0.1],\n",
 95:     "                     [0.5, 0.1, 0.8]])  # Full inter-block connectivity matrix\n",
 96:     "\n",
 97:     "plot_sbm_graph(block_sizes, p_matrix)\n"
 98:    ]
 99:   },
100:   {
101:    "cell_type": "code",
102:    "execution_count": null,
103:    "metadata": {},
104:    "outputs": [],
105:    "source": []
106:   }
107:  ],
108:  "metadata": {
109:   "kernelspec": {
110:    "display_name": "anon_sbm",
111:    "language": "python",
112:    "name": "python3"
113:   },
114:   "language_info": {
115:    "codemirror_mode": {
116:     "name": "ipython",
117:     "version": 3
118:    },
119:    "file_extension": ".py",
120:    "mimetype": "text/x-python",
121:    "name": "python",
122:    "nbconvert_exporter": "python",
123:    "pygments_lexer": "ipython3",
124:    "version": "3.13.0"
125:   }
126:  },
127:  "nbformat": 4,
128:  "nbformat_minor": 2
129: }

================
File: notebooks/visualize_generated_networks_08-07-2025.ipynb
================
  1: {
  2:  "cells": [
  3:   {
  4:    "cell_type": "markdown",
  5:    "id": "a39b7981",
  6:    "metadata": {},
  7:    "source": [
  8:     "# Visualizing a series of observed and surrogate networks"
  9:    ]
 10:   },
 11:   {
 12:    "cell_type": "code",
 13:    "execution_count": 18,
 14:    "id": "9ec1e6ca",
 15:    "metadata": {},
 16:    "outputs": [],
 17:    "source": [
 18:     "from pathlib import Path\n",
 19:     "import numpy as np\n",
 20:     "import scipy.sparse as sp\n",
 21:     "import matplotlib.pyplot as plt\n",
 22:     "import networkx as nx\n",
 23:     "\n",
 24:     "from sbm.sampling import sample_sbm_graph_from_fit\n",
 25:     "from sbm.io import SBMFit, SBMWriter, GraphLoader\n",
 26:     "from sbm.noisy_fit import create_sbm_noise\n",
 27:     "\n",
 28:     "RNG = np.random.default_rng(0)"
 29:    ]
 30:   },
 31:   {
 32:    "cell_type": "code",
 33:    "execution_count": 19,
 34:    "id": "ab4db642",
 35:    "metadata": {},
 36:    "outputs": [
 37:     {
 38:      "name": "stdout",
 39:      "output_type": "stream",
 40:      "text": [
 41:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_lastfm_asia_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_3\n"
 42:      ]
 43:     }
 44:    ],
 45:    "source": [
 46:     "name = \"lastfm_asia\"\n",
 47:     "sbm = SBMWriter.load(\n",
 48:     "    Path(f\"/Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_{name}_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_3\")\n",
 49:     ")\n",
 50:     "g = GraphLoader.load(\n",
 51:     "    Path(f'/Users/lmmi/anon_sbm/data/processed/{name}.edgelist'),\n",
 52:     "    force_undirected=True, # type: ignore\n",
 53:     "    )"
 54:    ]
 55:   },
 56:   {
 57:    "cell_type": "code",
 58:    "execution_count": 20,
 59:    "id": "ce7dc0d4",
 60:    "metadata": {},
 61:    "outputs": [],
 62:    "source": [
 63:     "import numpy as np\n",
 64:     "import igraph as ig\n",
 65:     "import matplotlib.pyplot as plt\n",
 66:     "from matplotlib import cm\n",
 67:     "from scipy.sparse import isspmatrix_csr\n",
 68:     "\n",
 69:     "\n",
 70:     "def plot_csr_network_igraph(\n",
 71:     "    ax,\n",
 72:     "    csr_adj,\n",
 73:     "    title=\"\",\n",
 74:     "    *,\n",
 75:     "    layout=\"kamada_kawai\",      # \"fr\" (Fruchterman-Reingold) or any igraph layout name\n",
 76:     "    base_node_size=5,          # pixel diameter of the least-connected node\n",
 77:     "    max_node_size=10,\n",
 78:     "    node_cmap=cm.magma,\n",
 79:     "    with_labels=False,\n",
 80:     "    restrict_to_lcc=True,\n",
 81:     "):\n",
 82:     "    \"\"\"\n",
 83:     "    Draw an undirected graph stored as a CSR array on the supplied Matplotlib Axes.\n",
 84:     "\n",
 85:     "    Parameters\n",
 86:     "    ----------\n",
 87:     "    ax : matplotlib.axes.Axes\n",
 88:     "        Host axes created by plt.subplots.\n",
 89:     "    csr_adj : scipy.sparse.csr_array / csr_matrix\n",
 90:     "        Symmetric adjacency matrix.  Non-zeros are treated as edge weights.\n",
 91:     "    title : str\n",
 92:     "        Subplot title.\n",
 93:     "    layout : str | (n,2) array\n",
 94:     "        igraph layout name or explicit coordinates.\n",
 95:     "    *size / *width : float\n",
 96:     "        Ranges for vertex bubble diameters and edge strokes (pixels).\n",
 97:     "    node_cmap : matplotlib colormap\n",
 98:     "        Vertex colour map keyed on degree.\n",
 99:     "    with_labels : bool\n",
100:     "        Draw integer node labels.\n",
101:     "    \"\"\"\n",
102:     "\n",
103:     "    # 1 ────────── build igraph graph from sparse input\n",
104:     "\n",
105:     "    n = csr_adj.shape[0]\n",
106:     "    coo = csr_adj.tocoo()\n",
107:     "    mask = coo.row < coo.col                      # keep each undirected edge once\n",
108:     "    edges = list(zip(coo.row[mask], coo.col[mask]))\n",
109:     "    weights = coo.data[mask].astype(float).tolist()\n",
110:     "\n",
111:     "    g = ig.Graph(n=n, edges=edges, directed=False)\n",
112:     "    if restrict_to_lcc:\n",
113:     "        g = g.connected_components().giant()\n",
114:     "\n",
115:     "    if weights:\n",
116:     "        g.es[\"weight\"] = weights  # optional\n",
117:     "\n",
118:     "    # 2 ────────── vertex/edge aesthetics\n",
119:     "    deg = np.array(g.degree())\n",
120:     "    deg_norm = (deg - deg.min()) / (deg.ptp() + 1e-9)\n",
121:     "    g.vs[\"size\"] = (base_node_size + deg_norm * (max_node_size - base_node_size)).tolist()\n",
122:     "\n",
123:     "    rgba = node_cmap(deg_norm)\n",
124:     "    g.vs[\"color\"] = [cm.colors.to_hex(c) for c in rgba]\n",
125:     "    g.vs[\"frame_color\"] = [\"white\"] * n\n",
126:     "    g.vs[\"frame_width\"] = 0.1\n",
127:     "\n",
128:     "    if \"weight\" in g.es.attributes():\n",
129:     "        w = np.array(weights)\n",
130:     "        w_norm = (w - w.min()) / (w.ptp() + 1e-9)\n",
131:     "    else:\n",
132:     "        w_norm = np.zeros(len(g.es))\n",
133:     "    g.es[\"width\"] = 0.1 #(base_edge_width + w_norm * (max_edge_width - base_edge_width)).tolist()\n",
134:     "    g.es[\"color\"] = [\"#bbbbbb\"] * len(g.es)\n",
135:     "\n",
136:     "    # 3 ────────── layout\n",
137:     "    if isinstance(layout, str):\n",
138:     "        try:\n",
139:     "            coord = g.layout(layout)\n",
140:     "            coord = np.array(coord)\n",
141:     "        except ValueError:\n",
142:     "            # if the layout name is not recognized, use a default layout\n",
143:     "            raise ValueError(f\"Unknown layout: {layout}. Please use a valid igraph layout name.\")\n",
144:     "    else:                       # numpy array supplied\n",
145:     "        coord = np.array(layout)\n",
146:     "\n",
147:     "    # scale limits to fit the graph\n",
148:     "    x_min, x_max = min(coord[:, 0]), max(coord[:, 0])\n",
149:     "    y_min, y_max = min(coord[:, 1]), max(coord[:, 1])\n",
150:     "\n",
151:     "    # set data to range between 0 and 1 \n",
152:     "    coord[:, 0] = (coord[:, 0] - x_min) / (x_max - x_min)\n",
153:     "    coord[:, 1] = (coord[:, 1] - y_min) / (y_max - y_min)\n",
154:     "    \n",
155:     "    # 4 ────────── draw\n",
156:     "    ax.set_title(title, fontsize=12)\n",
157:     "    ax.axis(\"off\")\n",
158:     "    ig.plot(\n",
159:     "        g,\n",
160:     "        target=ax,\n",
161:     "        layout=coord,\n",
162:     "        vertex_size=g.vs[\"size\"],\n",
163:     "        vertex_color=g.vs[\"color\"],\n",
164:     "        vertex_frame_width=g.vs[\"frame_width\"],\n",
165:     "        vertex_frame_color=g.vs[\"frame_color\"],\n",
166:     "        edge_width=g.es[\"width\"],\n",
167:     "        edge_color=g.es[\"color\"],\n",
168:     "        vertex_label=g.vs.indices if with_labels else None,\n",
169:     "        vertex_label_size=8,\n",
170:     "    )\n",
171:     "\n",
172:     "    scale = 1.025\n",
173:     "    ax.set_xlim(1-scale, scale)\n",
174:     "    ax.set_ylim(1-scale, scale)\n"
175:    ]
176:   },
177:   {
178:    "cell_type": "code",
179:    "execution_count": 21,
180:    "id": "3c5b959a",
181:    "metadata": {},
182:    "outputs": [
183:     {
184:      "name": "stdout",
185:      "output_type": "stream",
186:      "text": [
187:       "max σ_n: 0.042, max σ_e: 0.163\n",
188:       "[LASSO]    Added 0 edges to previously-zero pairs\n",
189:       "[NAIVE]    Added 0 edges to zero pairs.\n"
190:      ]
191:     }
192:    ],
193:    "source": [
194:     "EPS, DELTA, ALPHA = 1, 1e-4, 1-1e-4\n",
195:     "\n",
196:     "sbm_g = sample_sbm_graph_from_fit(sbm, RNG)\n",
197:     "\n",
198:     "noise = create_sbm_noise(sbm, EPS, DELTA, ALPHA, noise_type=\"heterogeneous_gaussian\")\n",
199:     "\n",
200:     "lasso_noisy_fit = noise.sample_sbm_fit(RNG, post='lasso')\n",
201:     "lasso_g = sample_sbm_graph_from_fit(lasso_noisy_fit, RNG)\n",
202:     "\n",
203:     "naive_noisy_fit = noise.sample_sbm_fit(RNG, post='naive')\n",
204:     "naive_g = sample_sbm_graph_from_fit(naive_noisy_fit, RNG)"
205:    ]
206:   },
207:   {
208:    "cell_type": "code",
209:    "execution_count": 22,
210:    "id": "69e8d221",
211:    "metadata": {},
212:    "outputs": [],
213:    "source": [
214:     "# check that graph is undirected\n",
215:     "assert (sbm_g.adjacency != sbm_g.adjacency.T).sum() == 0,\\\n",
216:     "    \"The sampled SBM graph is not undirected.\"\n",
217:     "assert (lasso_g.adjacency != lasso_g.adjacency.T).sum() == 0,\\\n",
218:     "    \"The lasso noisy graph is not undirected.\"\n",
219:     "assert (naive_g.adjacency != naive_g.adjacency.T).sum() == 0,\\\n",
220:     "    \"The naive noisy graph is not undirected.\""
221:    ]
222:   },
223:   {
224:    "cell_type": "code",
225:    "execution_count": 23,
226:    "id": "45e318fa",
227:    "metadata": {},
228:    "outputs": [
229:     {
230:      "data": {
231:       "image/png": "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",
232:       "text/plain": [
233:        "<Figure size 1600x400 with 4 Axes>"
234:       ]
235:      },
236:      "metadata": {},
237:      "output_type": "display_data"
238:     }
239:    ],
240:    "source": [
241:     "fig, ax = plt.subplots(ncols=4, figsize=(16, 4))\n",
242:     "\n",
243:     "for idx, (name, adjacency) in enumerate(\n",
244:     "    [\n",
245:     "        (\"Empirical\", g.adjacency),\n",
246:     "        ('SBM', sbm_g.adjacency),\n",
247:     "        (\"Lasso Noisy Fit\", lasso_g.adjacency),\n",
248:     "        (\"Naive Noisy Fit\", naive_g.adjacency),\n",
249:     "    ]\n",
250:     "):\n",
251:     "    plot_csr_network_igraph(\n",
252:     "        ax[idx],\n",
253:     "        adjacency,\n",
254:     "        title=name,\n",
255:     "        layout=\"kamada_kawai\", \n",
256:     "        base_node_size=1,\n",
257:     "        max_node_size=10,\n",
258:     "        restrict_to_lcc=False,\n",
259:     "        )\n",
260:     "\n",
261:     "plt.show()"
262:    ]
263:   },
264:   {
265:    "cell_type": "code",
266:    "execution_count": null,
267:    "id": "1ff4b1df",
268:    "metadata": {},
269:    "outputs": [],
270:    "source": []
271:   },
272:   {
273:    "cell_type": "markdown",
274:    "id": "ada47c4b",
275:    "metadata": {},
276:    "source": [
277:     "# Visualize for all networks:\n"
278:    ]
279:   },
280:   {
281:    "cell_type": "code",
282:    "execution_count": 24,
283:    "id": "c24dbce9",
284:    "metadata": {},
285:    "outputs": [],
286:    "source": [
287:     "import sys\n",
288:     "from pathlib import Path\n",
289:     "from itertools import product\n",
290:     "from tqdm import tqdm\n",
291:     "\n",
292:     "### Load all surrogate statistics\n",
293:     "folder_path = Path('/Users/lmmi/anon_sbm/data/processed/')\n",
294:     "\n",
295:     "# find all log files in the logs directory\n",
296:     "edgelist_files = list(folder_path.glob(\"*.edgelist\"))\n",
297:     "size = (3,6,12,25)"
298:    ]
299:   },
300:   {
301:    "cell_type": "code",
302:    "execution_count": 25,
303:    "id": "9654c7d7",
304:    "metadata": {},
305:    "outputs": [],
306:    "source": [
307:     "def extract_network_name(file_path: Path) -> str:\n",
308:     "    \"\"\"\n",
309:     "    Extract the network name from the file path.\n",
310:     "    \"\"\"\n",
311:     "    return file_path.stem.split('.')[0]  # Assuming the name is the first part of the filename"
312:    ]
313:   },
314:   {
315:    "cell_type": "code",
316:    "execution_count": 26,
317:    "id": "c41de916",
318:    "metadata": {},
319:    "outputs": [],
320:    "source": [
321:     "EPS, DELTA, ALPHA = 3, 1e-4, 1-1e-4"
322:    ]
323:   },
324:   {
325:    "cell_type": "code",
326:    "execution_count": 27,
327:    "id": "0dc7e752",
328:    "metadata": {},
329:    "outputs": [
330:     {
331:      "name": "stderr",
332:      "output_type": "stream",
333:      "text": [
334:       "0it [00:00, ?it/s]"
335:      ]
336:     },
337:     {
338:      "name": "stdout",
339:      "output_type": "stream",
340:      "text": [
341:       "Processing /Users/lmmi/anon_sbm/data/processed/eu_email.edgelist with block size 3...\n",
342:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_eu_email_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
343:       "max σ_n: 0.133, max σ_e: 0.729\n",
344:       "[LASSO]    Added 0 edges to previously-zero pairs\n",
345:       "[NAIVE]    Added 0 edges to zero pairs.\n"
346:      ]
347:     },
348:     {
349:      "name": "stderr",
350:      "output_type": "stream",
351:      "text": [
352:       "1it [00:41, 41.13s/it]"
353:      ]
354:     },
355:     {
356:      "name": "stdout",
357:      "output_type": "stream",
358:      "text": [
359:       "Processing /Users/lmmi/anon_sbm/data/processed/eu_email.edgelist with block size 6...\n",
360:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_eu_email_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
361:       "max σ_n: 0.133, max σ_e: 0.729\n",
362:       "[LASSO]    Added 0 edges to previously-zero pairs\n",
363:       "[NAIVE]    Added 0 edges to zero pairs.\n"
364:      ]
365:     },
366:     {
367:      "name": "stderr",
368:      "output_type": "stream",
369:      "text": [
370:       "2it [01:20, 39.87s/it]"
371:      ]
372:     },
373:     {
374:      "name": "stdout",
375:      "output_type": "stream",
376:      "text": [
377:       "Processing /Users/lmmi/anon_sbm/data/processed/eu_email.edgelist with block size 12...\n",
378:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_eu_email_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
379:       "max σ_n: 0.133, max σ_e: 0.729\n",
380:       "[LASSO]    Added 0 edges to previously-zero pairs\n",
381:       "[NAIVE]    Added 0 edges to zero pairs.\n"
382:      ]
383:     },
384:     {
385:      "name": "stderr",
386:      "output_type": "stream",
387:      "text": [
388:       "3it [01:59, 39.71s/it]"
389:      ]
390:     },
391:     {
392:      "name": "stdout",
393:      "output_type": "stream",
394:      "text": [
395:       "Processing /Users/lmmi/anon_sbm/data/processed/eu_email.edgelist with block size 25...\n",
396:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_eu_email_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
397:       "max σ_n: 0.133, max σ_e: 0.729\n",
398:       "[LASSO]    Added 0 edges to previously-zero pairs\n",
399:       "[NAIVE]    Added 0 edges to zero pairs.\n"
400:      ]
401:     },
402:     {
403:      "name": "stderr",
404:      "output_type": "stream",
405:      "text": [
406:       "4it [02:38, 39.33s/it]"
407:      ]
408:     },
409:     {
410:      "name": "stdout",
411:      "output_type": "stream",
412:      "text": [
413:       "Processing /Users/lmmi/anon_sbm/data/processed/caltech_fb.edgelist with block size 3...\n",
414:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_caltech_fb_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
415:       "max σ_n: 0.247, max σ_e: 1.191\n",
416:       "[LASSO]    Added 0 edges to previously-zero pairs\n",
417:       "[NAIVE]    Added 0 edges to zero pairs.\n"
418:      ]
419:     },
420:     {
421:      "name": "stderr",
422:      "output_type": "stream",
423:      "text": [
424:       "5it [03:11, 37.24s/it]"
425:      ]
426:     },
427:     {
428:      "name": "stdout",
429:      "output_type": "stream",
430:      "text": [
431:       "Processing /Users/lmmi/anon_sbm/data/processed/caltech_fb.edgelist with block size 6...\n",
432:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_caltech_fb_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
433:       "max σ_n: 0.247, max σ_e: 1.191\n",
434:       "[LASSO]    Added 0 edges to previously-zero pairs\n",
435:       "[NAIVE]    Added 0 edges to zero pairs.\n"
436:      ]
437:     },
438:     {
439:      "name": "stderr",
440:      "output_type": "stream",
441:      "text": [
442:       "6it [03:45, 36.07s/it]"
443:      ]
444:     },
445:     {
446:      "name": "stdout",
447:      "output_type": "stream",
448:      "text": [
449:       "Processing /Users/lmmi/anon_sbm/data/processed/caltech_fb.edgelist with block size 12...\n",
450:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_caltech_fb_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
451:       "max σ_n: 0.247, max σ_e: 1.191\n",
452:       "[LASSO]    Added 0 edges to previously-zero pairs\n",
453:       "[NAIVE]    Added 0 edges to zero pairs.\n"
454:      ]
455:     },
456:     {
457:      "name": "stderr",
458:      "output_type": "stream",
459:      "text": [
460:       "7it [04:18, 35.13s/it]"
461:      ]
462:     },
463:     {
464:      "name": "stdout",
465:      "output_type": "stream",
466:      "text": [
467:       "Processing /Users/lmmi/anon_sbm/data/processed/caltech_fb.edgelist with block size 25...\n",
468:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_caltech_fb_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
469:       "max σ_n: 0.247, max σ_e: 1.191\n",
470:       "[LASSO]    Added 0 edges to previously-zero pairs\n",
471:       "[NAIVE]    Added 0 edges to zero pairs.\n"
472:      ]
473:     },
474:     {
475:      "name": "stderr",
476:      "output_type": "stream",
477:      "text": [
478:       "8it [04:53, 35.00s/it]"
479:      ]
480:     },
481:     {
482:      "name": "stdout",
483:      "output_type": "stream",
484:      "text": [
485:       "Processing /Users/lmmi/anon_sbm/data/processed/congress_twitter.edgelist with block size 3...\n",
486:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_congress_twitter_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
487:       "max σ_n: 0.002, max σ_e: 2.017\n",
488:       "[LASSO]    Added 0 edges to previously-zero pairs\n",
489:       "[NAIVE]    Added 0 edges to zero pairs.\n"
490:      ]
491:     },
492:     {
493:      "name": "stderr",
494:      "output_type": "stream",
495:      "text": [
496:       "9it [05:15, 30.94s/it]"
497:      ]
498:     },
499:     {
500:      "name": "stdout",
501:      "output_type": "stream",
502:      "text": [
503:       "Processing /Users/lmmi/anon_sbm/data/processed/congress_twitter.edgelist with block size 6...\n",
504:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_congress_twitter_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
505:       "max σ_n: 0.002, max σ_e: 2.017\n",
506:       "[LASSO]    Added 0 edges to previously-zero pairs\n",
507:       "[NAIVE]    Added 0 edges to zero pairs.\n"
508:      ]
509:     },
510:     {
511:      "name": "stderr",
512:      "output_type": "stream",
513:      "text": [
514:       "10it [05:37, 27.99s/it]"
515:      ]
516:     },
517:     {
518:      "name": "stdout",
519:      "output_type": "stream",
520:      "text": [
521:       "Processing /Users/lmmi/anon_sbm/data/processed/congress_twitter.edgelist with block size 12...\n",
522:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_congress_twitter_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
523:       "max σ_n: 0.002, max σ_e: 2.017\n",
524:       "[LASSO]    Added 0 edges to previously-zero pairs\n",
525:       "[NAIVE]    Added 0 edges to zero pairs.\n"
526:      ]
527:     },
528:     {
529:      "name": "stderr",
530:      "output_type": "stream",
531:      "text": [
532:       "11it [05:58, 25.99s/it]"
533:      ]
534:     },
535:     {
536:      "name": "stdout",
537:      "output_type": "stream",
538:      "text": [
539:       "Processing /Users/lmmi/anon_sbm/data/processed/congress_twitter.edgelist with block size 25...\n",
540:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_congress_twitter_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
541:       "max σ_n: 0.002, max σ_e: 2.017\n",
542:       "[LASSO]    Added 0 edges to previously-zero pairs\n",
543:       "[NAIVE]    Added 0 edges to zero pairs.\n"
544:      ]
545:     },
546:     {
547:      "name": "stderr",
548:      "output_type": "stream",
549:      "text": [
550:       "12it [06:19, 24.38s/it]"
551:      ]
552:     },
553:     {
554:      "name": "stdout",
555:      "output_type": "stream",
556:      "text": [
557:       "Processing /Users/lmmi/anon_sbm/data/processed/enron_email.edgelist with block size 3...\n",
558:       "Processing /Users/lmmi/anon_sbm/data/processed/enron_email.edgelist with block size 6...\n",
559:       "Processing /Users/lmmi/anon_sbm/data/processed/enron_email.edgelist with block size 12...\n",
560:       "Processing /Users/lmmi/anon_sbm/data/processed/enron_email.edgelist with block size 25...\n",
561:       "Processing /Users/lmmi/anon_sbm/data/processed/lastfm_asia.edgelist with block size 3...\n",
562:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_lastfm_asia_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
563:       "max σ_n: 0.077, max σ_e: 0.400\n",
564:       "[LASSO]    Added 0 edges to previously-zero pairs\n",
565:       "[NAIVE]    Added 0 edges to zero pairs.\n"
566:      ]
567:     },
568:     {
569:      "name": "stderr",
570:      "output_type": "stream",
571:      "text": [
572:       "17it [10:28, 41.88s/it]"
573:      ]
574:     },
575:     {
576:      "name": "stdout",
577:      "output_type": "stream",
578:      "text": [
579:       "Processing /Users/lmmi/anon_sbm/data/processed/lastfm_asia.edgelist with block size 6...\n",
580:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_lastfm_asia_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
581:       "max σ_n: 0.077, max σ_e: 0.400\n",
582:       "[LASSO]    Added 0 edges to previously-zero pairs\n",
583:       "[NAIVE]    Added 0 edges to zero pairs.\n"
584:      ]
585:     },
586:     {
587:      "name": "stderr",
588:      "output_type": "stream",
589:      "text": [
590:       "18it [14:22, 73.24s/it]"
591:      ]
592:     },
593:     {
594:      "name": "stdout",
595:      "output_type": "stream",
596:      "text": [
597:       "Processing /Users/lmmi/anon_sbm/data/processed/lastfm_asia.edgelist with block size 12...\n",
598:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_lastfm_asia_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
599:       "max σ_n: 0.077, max σ_e: 0.400\n",
600:       "[LASSO]    Added 0 edges to previously-zero pairs\n",
601:       "[NAIVE]    Added 0 edges to zero pairs.\n"
602:      ]
603:     },
604:     {
605:      "name": "stderr",
606:      "output_type": "stream",
607:      "text": [
608:       "19it [18:28, 106.06s/it]"
609:      ]
610:     },
611:     {
612:      "name": "stdout",
613:      "output_type": "stream",
614:      "text": [
615:       "Processing /Users/lmmi/anon_sbm/data/processed/lastfm_asia.edgelist with block size 25...\n",
616:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_lastfm_asia_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\n",
617:       "max σ_n: 0.077, max σ_e: 0.400\n",
618:       "[LASSO]    Added 0 edges to previously-zero pairs\n",
619:       "[NAIVE]    Added 0 edges to zero pairs.\n"
620:      ]
621:     },
622:     {
623:      "name": "stderr",
624:      "output_type": "stream",
625:      "text": [
626:       "24it [22:35, 56.50s/it] "
627:      ]
628:     },
629:     {
630:      "name": "stdout",
631:      "output_type": "stream",
632:      "text": [
633:       "Processing /Users/lmmi/anon_sbm/data/processed/wiki_vote.edgelist with block size 3...\n",
634:       "Processing /Users/lmmi/anon_sbm/data/processed/wiki_vote.edgelist with block size 6...\n",
635:       "Processing /Users/lmmi/anon_sbm/data/processed/wiki_vote.edgelist with block size 12...\n",
636:       "Processing /Users/lmmi/anon_sbm/data/processed/wiki_vote.edgelist with block size 25...\n"
637:      ]
638:     },
639:     {
640:      "name": "stderr",
641:      "output_type": "stream",
642:      "text": [
643:       "\n"
644:      ]
645:     }
646:    ],
647:    "source": [
648:     "for index, (edgelist_path, block_size) in tqdm(enumerate(product(edgelist_files[::-1], size))):\n",
649:     "    print(f\"Processing {edgelist_path} with block size {block_size}...\")\n",
650:     "\n",
651:     "    name = extract_network_name(edgelist_path)\n",
652:     "\n",
653:     "    # too big\n",
654:     "    if name in {'enron_email', 'wiki_vote'}:\n",
655:     "        continue\n",
656:     "\n",
657:     "    sbm = SBMWriter.load(\n",
658:     "        Path(f\"/Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_{name}_cooling_rate_0_9999_force_undirected_True_init_method_metis_min_block_size_6\")\n",
659:     "    )\n",
660:     "    g = GraphLoader.load(\n",
661:     "        Path(edgelist_path), force_undirected=True)\n",
662:     "\n",
663:     "    sbm_g = sample_sbm_graph_from_fit(sbm, RNG)\n",
664:     "\n",
665:     "    noise = create_sbm_noise(sbm, EPS, DELTA, ALPHA, noise_type=\"heterogeneous_gaussian\")\n",
666:     "\n",
667:     "    lasso_noisy_fit = noise.sample_sbm_fit(RNG, post='lasso')\n",
668:     "    lasso_g = sample_sbm_graph_from_fit(lasso_noisy_fit, RNG)\n",
669:     "\n",
670:     "    naive_noisy_fit = noise.sample_sbm_fit(RNG, post='naive')\n",
671:     "    naive_g = sample_sbm_graph_from_fit(naive_noisy_fit, RNG)\n",
672:     "\n",
673:     "    fig, ax = plt.subplots(ncols=4, figsize=(16, 4))\n",
674:     "\n",
675:     "    if g.adjacency.shape[0] > 1000:\n",
676:     "        layout = 'large'\n",
677:     "        restrict_to_lcc = True\n",
678:     "    else:\n",
679:     "        layout = 'kamada_kawai'\n",
680:     "        restrict_to_lcc = False\n",
681:     "\n",
682:     "    for idx, (method_name, adjacency) in enumerate(\n",
683:     "        [\n",
684:     "            (\"Empirical\", g.adjacency),\n",
685:     "            ('SBM', sbm_g.adjacency),\n",
686:     "            (\"Lasso Noisy Fit\", lasso_g.adjacency),\n",
687:     "            (\"Naive Noisy Fit\", naive_g.adjacency),\n",
688:     "        ]\n",
689:     "    ):\n",
690:     "        plot_csr_network_igraph(\n",
691:     "            ax[idx],\n",
692:     "            adjacency,\n",
693:     "            title=method_name,\n",
694:     "            layout=layout, \n",
695:     "            base_node_size=1,\n",
696:     "            max_node_size=10,\n",
697:     "            restrict_to_lcc=restrict_to_lcc,\n",
698:     "            )\n",
699:     "\n",
700:     "    save_path = Path(f\"/Users/lmmi/anon_sbm/results/figures/sbm_fit_{name}_block_size_{block_size}.png\")\n",
701:     "    save_path.parent.mkdir(parents=True, exist_ok=True)\n",
702:     "    fig.savefig(save_path, dpi=300, bbox_inches='tight')\n",
703:     "    plt.close(fig)"
704:    ]
705:   },
706:   {
707:    "cell_type": "code",
708:    "execution_count": null,
709:    "id": "d95132b0",
710:    "metadata": {},
711:    "outputs": [],
712:    "source": []
713:   }
714:  ],
715:  "metadata": {
716:   "kernelspec": {
717:    "display_name": "Python 3",
718:    "language": "python",
719:    "name": "python3"
720:   },
721:   "language_info": {
722:    "codemirror_mode": {
723:     "name": "ipython",
724:     "version": 3
725:    },
726:    "file_extension": ".py",
727:    "mimetype": "text/x-python",
728:    "name": "python",
729:    "nbconvert_exporter": "python",
730:    "pygments_lexer": "ipython3",
731:    "version": "3.12.11"
732:   }
733:  },
734:  "nbformat": 4,
735:  "nbformat_minor": 5
736: }

================
File: planted_partitions/undirected_planted_partitions.py
================
  1: #!/usr/bin/env python3
  2: """
  3: undirected_planted_partition.py
  4: --------------------------------
  5: Simple smoke-test for the swap-only MCMC implementation.
  6: For each of 100 independent repetitions we
  7: 1.  Draw an undirected 100-node SBM with
  8:         – B = 10 blocks of size 10
  9:         – p_in  = 0.30   (within-block connection probability)
 10:         – p_out = 0.05   (between-block probability)
 11: 2.  Build an initial *random* equal-size partition with
 12:         UniformSmallBlockAssigner(min_block_size=10)             (code in block_assigner.py)
 13: 3.  Run the adaptive swap-only MCMC for `n_iter` iterations.
 14: 4.  Compute the Jaccard index between
 15:         – the set of node pairs co-clustered in the *final* state, and
 16:         – the same set for the planted partition.
 17: The script prints the mean, standard deviation and a histogram
 18: of the 100 Jaccard scores so you can eyeball whether the sampler
 19: typically finds the planted structure.
 20: """
 21: from typing import Sequence, Hashable
 22: from collections.abc import Sequence
 23: import numpy as np
 24: from scipy.sparse import csr_array
 25: from scipy.optimize import linear_sum_assignment
 26: from tqdm import tqdm
 27: from sbm.graph_data import GraphData
 28: from sbm.block_assigner import (
 29:     MetisBlockAssigner,
 30: )
 31: from sbm.model import SBMModel
 32: ###############################################################################
 33: # utility helpers
 34: ###############################################################################
 35: def planted_blocks(n_nodes: int, block_size: int, rng) -> dict[int, int]:
 36:     """Random planted partition: block 0 → nodes 0–9, block 1 → 10–19, …"""
 37:     random_nodes = rng.permutation(n_nodes)
 38:     # generate a random list of blocks for the nodes ensuring the correct block size
 39:     random_blocks = np.arange(n_nodes) // block_size
 40:     random_blocks = rng.permutation(random_blocks)
 41:     return {v: block for (v, block) in zip(random_nodes, random_blocks)}
 42: def sample_sbm(rng: np.random.Generator,
 43:                blocks: dict[int, int],
 44:                p_in: float,
 45:                p_out: float) -> csr_array:
 46:     """Generate an undirected loop-free adjacency matrix for a binary SBM."""
 47:     n = len(blocks)
 48:     adj = np.zeros((n, n), dtype=np.int8)
 49:     # probability matrix look-up
 50:     for u in range(n):
 51:         for v in range(u + 1, n):          # u < v → strict upper triangle
 52:             p = p_in if blocks[u] == blocks[v] else p_out
 53:             if rng.random() < p:
 54:                 adj[u, v] = adj[v, u] = 1  # symmetrise
 55:     return csr_array(adj)                 # sparse CSR
 56: def misclassification_rate(
 57:     true_labels: Sequence[Hashable],
 58:     est_labels: Sequence[Hashable],
 59: ) -> float:
 60:     """
 61:     Percentage of vertices whose community label is wrong *after*
 62:     optimally permuting the estimated labels to match the true ones.
 63:     Parameters
 64:     ----------
 65:     true_labels : sequence
 66:         Ground-truth block labels – length N.
 67:     est_labels  : sequence
 68:         Estimated block labels  – length N.
 69:     Returns
 70:     -------
 71:     float
 72:         Mis-classification rate in the interval [0, 1].
 73:     Notes
 74:     -----
 75:     * Label sets may use arbitrary hashables (str, int, …) and need not
 76:       have the same cardinality.  Any surplus estimated or true blocks
 77:       are matched to “dummy” columns/rows filled with zeros.
 78:     * Uses the Hungarian algorithm (via `scipy.optimize.linear_sum_assignment`)
 79:       to maximise the number of correctly matched vertices.
 80:     """
 81:     true = np.asarray(true_labels)
 82:     est  = np.asarray(est_labels)
 83:     if true.shape != est.shape:
 84:         raise ValueError("true_labels and est_labels must have the same length")
 85:     # Map arbitrary labels to contiguous integers 0..T-1 and 0..E-1
 86:     true_ids,  true_inv  = np.unique(true, return_inverse=True)
 87:     est_ids,   est_inv   = np.unique(est,  return_inverse=True)
 88:     T, E = len(true_ids), len(est_ids)
 89:     N    = len(true)
 90:     # Build contingency matrix C[e, t] = |{ i : est_i=e and true_i=t }|
 91:     C = np.zeros((E, T), dtype=int)
 92:     np.add.at(C, (est_inv, true_inv), 1)
 93:     # Pad to square (Hungarian implementation needs it or we need to
 94:     # maximise on rectangles by padding zeros).
 95:     if E != T:
 96:         dim = max(E, T)
 97:         C_padded = np.zeros((dim, dim), dtype=int)
 98:         C_padded[:E, :T] = C
 99:         C = C_padded
100:     # Maximise trace(C[perm])  →  minimise −C for Hungarian
101:     row_ind, col_ind = linear_sum_assignment(-C)
102:     matched = C[row_ind, col_ind].sum()
103:     return 1.0 - matched / N
104: ###############################################################################
105: # main loop
106: ###############################################################################
107: def main(
108:     n_nodes = 100,
109:     block_size = 10,
110:     p_in = 0.30,
111:     p_out = 0.05,
112:     n_experiments = 10,
113:     n_iter = 3_000,
114:     rng_master = np.random.default_rng(42),
115:     temperature: float = 1
116: ):
117:     init_scores = []
118:     final_scores = []
119:     for rep in tqdm(range(n_experiments)):
120:         rng = np.random.default_rng(rng_master.integers(2**32))
121:         # --- 1. plant graph -----------------------------------------------------
122:         planted = planted_blocks(n_nodes, block_size, rng)
123:         adj     = sample_sbm(rng, planted, p_in, p_out)
124:         # --- 2. initial random partition ---------------------------------------
125:         gdata    = GraphData(adjacency_matrix=adj, directed=False)
126:         assigner = MetisBlockAssigner(graph_data=gdata,
127:                                             rng=rng,
128:                                             min_block_size=block_size
129:                                         )
130:         init_blocks = assigner.compute_assignment()
131:         init_scores.append(
132:             misclassification_rate(
133:                 true_labels=list(planted.values()),
134:                 est_labels=list(init_blocks.blocks.values())
135:             )
136:         )
137:         sbm = SBMModel(
138:                 initial_blocks=init_blocks,
139:                 rng=rng,
140:                 logger=None,  # no logging
141:             )
142:         print(f"Initial nll {sbm.likelihood_calculator.nll:.3f}")
143:         sbm.fit(
144:             min_block_size=block_size,
145:             initial_temperature=temperature,
146:         )
147:         final_blocks = sbm.get_block_assignments()
148:         # --- 4. score -----------------------------------------------------------
149:         final_scores.append(
150:             misclassification_rate(
151:                 true_labels=list(planted.values()),
152:                 est_labels=list(final_blocks.values())
153:             )
154:         )
155:     # --- print results ----------------------------------------------------------
156:     print(f"Initial misclassification rate: {np.mean(init_scores):.3f} ± {np.std(init_scores):.3f}")
157:     print(f"Final misclassification rate:   {np.mean(final_scores):.3f} ± {np.std(final_scores):.3f}")
158: if __name__ == "__main__":
159:     main(
160:         n_nodes=300,
161:         block_size=3,
162:         p_in=0.5,
163:         p_out=0.01,
164:         n_experiments=1,
165:         n_iter=5_000,
166:         rng_master=np.random.default_rng(42),
167:         temperature=1e-2
168:     )

================
File: src/data_processing/process_caltech.py
================
 1: """
 2: Script for converting caltech-facebook data to simple edgelist format
 3: change from format:
 4:     %MatrixMarket matrix coordinate pattern symmetric 
 5:     769 769 16656
 6:     5 1
 7:     31 1
 8: to format:
 9:     769 769 16656
10:     5 1
11:     31 1
12: """
13: from pathlib import Path
14: if __name__ == "__main__":
15:     file_path = Path("data/raw/socfb-Caltech36/socfb-Caltech36.mtx")
16:     # read file
17:     with file_path.open("r") as f:
18:         lines = f.readlines()
19:     # process lines
20:     processed_lines = []
21:     # skip first two lines (Matrix Market header)
22:     for idx, line in enumerate(lines):
23:         if idx < 2:
24:             continue
25:         parts = line.split()
26:         if len(parts) >= 2:
27:             processed_lines.append(f"{parts[0]} {parts[1]}\n")
28:     # processed data goes in the "processed" folder in the parent-folder
29:     out_folder_path = Path("data/processed")
30:     out_file_path = out_folder_path / "caltech_fb.edgelist"
31:     # write to output file
32:     out_folder_path.mkdir(parents=True, exist_ok=True)
33:     with out_file_path.open("w") as f:
34:         f.writelines(processed_lines)
35:     print(f"Processed edgelist saved to {out_file_path}")

================
File: src/data_processing/process_congress_twitter.py
================
 1: """
 2: Script for converting congress data to simple edgelist format
 3: change from format:
 4:   0 4 {'weight': 0.002105263157894737}
 5:   0 12 {'weight': 0.002105263157894737}
 6:   0 18 {'weight': 0.002105263157894737}
 7:   0 25 {'weight': 0.004210526315789474}
 8: to format:
 9:   0 4
10:   0 12
11:   0 18
12:   0 25
13: """
14: from pathlib import Path
15: if __name__ == "__main__":
16:     file_path = Path("data/raw/congress_twitter/congress.edgelist")
17:     # read file
18:     with file_path.open("r") as f:
19:         lines = f.readlines()
20:     # process lines
21:     processed_lines = []
22:     for line in lines:
23:         parts = line.split()
24:         if len(parts) >= 2:
25:             processed_lines.append(f"{parts[0]} {parts[1]}\n")
26:     # processed data goes in the "processed" folder in the parent-folder
27:     out_folder_path = Path("data/processed")
28:     out_file_path = out_folder_path / "congress_twitter.edgelist"
29:     # write to output file
30:     out_folder_path.mkdir(parents=True, exist_ok=True)
31:     with out_file_path.open("w") as f:
32:         f.writelines(processed_lines)
33:     print(f"Processed edgelist saved to {out_file_path}")

================
File: src/data_processing/process_email_eu.py
================
 1: """
 2: Script for converting email-eu data to simple edgelist format
 3: change from format:
 4:     582 364 0
 5:     168 472 2797
 6:     168 912 3304
 7:     2 790 4523
 8: to format:
 9:     582 364
10:     168 472
11:     168 912
12:     2 790
13: while removing self-loops and duplicate edges.
14: """
15: from pathlib import Path
16: if __name__ == "__main__":
17:     file_path = Path("data/raw/email_eu/email-Eu-core-temporal.txt")
18:     # read file
19:     with file_path.open("r") as f:
20:         lines = f.readlines()
21:     # process lines
22:     processed_lines = []
23:     edgeset = set()
24:     for line in lines:
25:         parts = line.split()
26:         edge = tuple(sorted(( int(parts[0]), int(parts[1]) )))
27:         if edge not in edgeset:
28:             edgeset.add(edge)
29:             # only keep the first two parts of the line
30:             # and ignore the third part (weight)
31:             # also ignore self-loops
32:             if len(parts) >= 2 and parts[0] != parts[1]:
33:                 processed_lines.append(f"{parts[0]} {parts[1]}\n")
34:     # processed data goes in the "processed" folder in the parent-folder
35:     out_folder_path = Path("data/processed")
36:     out_file_path = out_folder_path / "eu_email.edgelist"
37:     # write to output file
38:     out_folder_path.mkdir(parents=True, exist_ok=True)
39:     with out_file_path.open("w") as f:
40:         f.writelines(processed_lines)
41:     print(f"Processed edgelist saved to {out_file_path}")

================
File: src/data_processing/process_enron_email.py
================
 1: """
 2: Script for converting enron-email data to simple edgelist format
 3: change from format:
 4:     # Directed graph (each unordered pair of nodes is saved once): Email-Enron.txt 
 5:     # Enron email network (edge indicated that email was exchanged, undirected edges)
 6:     # Nodes: 36692 Edges: 367662
 7:     # FromNodeId	ToNodeId
 8:     0	1
 9:     1	0
10:     1	2
11:     1	3
12: to format:
13:     0	1
14:     1	0
15:     1	2
16:     1	3
17: while removing self-loops and duplicate edges.
18: """
19: from pathlib import Path
20: if __name__ == "__main__":
21:     file_path = Path("data/raw/enron_email/email-Enron.txt")
22:     # read file
23:     with file_path.open("r") as f:
24:         lines = f.readlines()
25:     # process lines
26:     processed_lines = []
27:     edgeset = set()
28:     for index, line in enumerate(lines):
29:         if index >= 4:
30:             parts = line.split()
31:             edge = tuple(sorted(( int(parts[0]), int(parts[1]) )))
32:             if edge not in edgeset:
33:                 edgeset.add(edge)
34:                 if parts[0] != parts[1]:
35:                     processed_lines.append(f"{parts[0]} {parts[1]}\n")
36:     # processed data goes in the "processed" folder in the parent-folder
37:     out_folder_path = Path("data/processed")
38:     out_file_path = out_folder_path / "enron_email.edgelist"
39:     # write to output file
40:     out_folder_path.mkdir(parents=True, exist_ok=True)
41:     with out_file_path.open("w") as f:
42:         f.writelines(processed_lines)
43:     print(f"Processed edgelist saved to {out_file_path}")

================
File: src/data_processing/process_lastfm_asia.py
================
 1: """
 2: Script for converting lastfm-asia data to simple edgelist format
 3: remove the header and remove self-loops and duplicate edges.
 4: """
 5: from pathlib import Path
 6: if __name__ == "__main__":
 7:     file_path = Path("data/raw/lastfm_asia/lastfm_asia_edges.csv")
 8:     # read file
 9:     with file_path.open("r") as f:
10:         lines = f.readlines()
11:     # process lines
12:     processed_lines = []
13:     edgeset = set()
14:     for index, line in enumerate(lines):
15:         if index >= 1:
16:             parts = line.split(",")
17:             edge = tuple(sorted(( int(parts[0]), int(parts[1]) )))
18:             if edge not in edgeset:
19:                 edgeset.add(edge)
20:                 if len(parts) >= 1 and parts[0] != parts[1]:
21:                     processed_lines.append(f"{parts[0]} {parts[1]}\n")
22:     # processed data goes in the "processed" folder in the parent-folder
23:     out_folder_path = Path("data/processed")
24:     out_file_path = out_folder_path / "lastfm_asia.edgelist"
25:     # write to output file
26:     out_folder_path.mkdir(parents=True, exist_ok=True)
27:     with out_file_path.open("w") as f:
28:         f.writelines(processed_lines)
29:     print(f"Processed edgelist saved to {out_file_path}")

================
File: src/data_processing/process_wiki_vote.py
================
 1: """
 2: Script for converting wiki-voce data to simple edgelist format
 3: change from format:
 4:     # Directed graph (each unordered pair of nodes is saved once): Wiki-Vote.txt 
 5:     # Wikipedia voting on promotion to administratorship (till January 2008). Directed edge A->B means user A voted on B becoming Wikipedia administrator.
 6:     # Nodes: 7115 Edges: 103689
 7:     # FromNodeId	ToNodeId
 8:     30	1412
 9:     30	3352
10:     30	5254
11: to format:
12:     30	1412
13:     30	3352
14:     30	5254
15: while removing self-loops and duplicate edges.
16: """
17: from pathlib import Path
18: if __name__ == "__main__":
19:     file_path = Path("data/raw/wiki_vote/wiki-vote.txt")
20:     # read file
21:     with file_path.open("r") as f:
22:         lines = f.readlines()
23:     # process lines
24:     processed_lines = []
25:     edgeset = set()
26:     for index, line in enumerate(lines):
27:         if index >= 4:
28:             parts = line.split()
29:             edge = tuple(sorted(( int(parts[0]), int(parts[1]) )))
30:             if edge not in edgeset:
31:                 edgeset.add(edge)
32:                 # only keep the first two parts of the line
33:                 # and ignore the third part (weight)
34:                 # also ignore self-loops
35:                 if parts[0] != parts[1]:
36:                     processed_lines.append(f"{parts[0]} {parts[1]}\n")
37:     # processed data goes in the "processed" folder in the parent-folder
38:     out_folder_path = Path("data/processed")
39:     out_file_path = out_folder_path / "wiki_vote.edgelist"
40:     # write to output file
41:     out_folder_path.mkdir(parents=True, exist_ok=True)
42:     with out_file_path.open("w") as f:
43:         f.writelines(processed_lines)
44:     print(f"Processed edgelist saved to {out_file_path}")

================
File: src/metrics/assortativity.py
================
 1: """ 
 2: Metrics for comparing assortativity of two graph.
 3: """
 4: import numpy as np
 5: from scipy.sparse import csr_array
 6: import networkx as nx
 7: ###############################################################################
 8: #Assortativity coefficient difference ------------------------------------
 9: ###############################################################################
10: def assortativity_difference(
11:     emp_adj: csr_array,
12:     sur_adj: csr_array,
13:     *,
14:     rng: np.random.Generator = np.random.default_rng(1),
15: ) -> float:
16:     """Absolute difference in degree‑assortativity (Pearson) coefficient."""
17:     def _assort(adj: csr_array) -> float:
18:         G = nx.from_scipy_sparse_matrix(adj)
19:         # NetworkX warns for disconnected graphs → ignore
20:         try:
21:             return float(nx.degree_pearson_correlation_coefficient(G))
22:         except Exception:
23:             return 0.0  # fallback (e.g., for trivial graphs)
24:     emp_assort = _assort(emp_adj)
25:     sur_assort = _assort(sur_adj)
26:     return abs(emp_assort - sur_assort)

================
File: src/metrics/community.py
================
 1: """
 2: Metric functions to compare the community structure of two graphs.
 3: """
 4: import numpy as np
 5: from scipy.sparse import csr_array, csr_matrix
 6: # external heavy‑duty packages (all listed in requirements.txt)
 7: from infomap import Infomap  # type: ignore
 8: import igraph as ig  # type: ignore
 9: import leidenalg  # type: ignore
10: ### Utility -----------------------------------------------------------------
11: def _modularity(adj: csr_array) -> float:
12:     g = ig.Graph.Adjacency(csr_matrix(adj), mode="UNDIRECTED")
13:     part = leidenalg.find_partition(g, leidenalg.ModularityVertexPartition, weights=None)
14:     return g.modularity(part)
15: ###############################################################################
16: # Infomap codelength difference -------------------------------------------
17: ###############################################################################
18: def infomap_codelength_difference(
19:     emp_adj: csr_array,
20:     sur_adj: csr_array,
21:     *,
22:     directed: bool = False,
23:     rng: np.random.Generator = np.random.default_rng(1),
24: ) -> float:
25:     """Absolute difference in Infomap codelength (compression) between graphs."""
26:     def _codelength(adj: csr_array) -> float:
27:         im = Infomap("--directed" if directed else "")
28:         rows, cols = adj.nonzero()
29:         for u, v in zip(rows, cols, strict=False):
30:             if u < v or directed:
31:                 im.add_link(int(u), int(v))
32:         im.run(silent=True)
33:         return im.codelength
34:     return abs(_codelength(emp_adj) - _codelength(sur_adj))
35: ###############################################################################
36: # Modularity distance via Leiden ------------------------------------------
37: ###############################################################################
38: def leiden_modularity_difference(
39:     emp_adj: csr_array,
40:     sur_adj: csr_array,
41:     *,
42:     rng: np.random.Generator = np.random.default_rng(1),
43: ) -> float:
44:     """Absolute difference in maximum modularity found by Leiden."""
45:     return abs(_modularity(emp_adj) - _modularity(sur_adj))

================
File: src/metrics/embedding.py
================
 1: """
 2: Metrics for comparing two adjacency matrices based on node embeddings
 3: """
 4: from typing import Literal
 5: import numpy as np
 6: import networkx as nx
 7: from scipy.sparse import csr_array
 8: from scipy.stats import wasserstein_distance  # 1‑D Earth mover distance
 9: from scipy.spatial.distance import cosine
10: from sbm.utils.util import restrict_to_lcc
11: from nodevectors import Node2Vec, ProNE  # type: ignore
12: ### Aliases --------------------------------------------------------
13: EmbeddingMethods = Literal["node2vec", "prone"]
14: ### Helper functions -----------------------------------------------
15: def _embed_and_sample(
16:         adj: csr_array,
17:         method: str,
18:         dim: int,
19:         n_pairs:int,
20:         rng:np.random.Generator
21:     ) -> np.ndarray:
22:     G = nx.from_scipy_sparse_matrix(adj)
23:     if method == "node2vec":
24:         model = Node2Vec(n_components=dim, walklen=80, return_weight=1.0, 
25:                             neighbor_weight=1.0, epochs=20, verbose=False)
26:     elif method == "prone":
27:         model = ProNE(n_components=dim)
28:     else:
29:         raise ValueError("Unknown method")
30:     emb = model.fit_transform(G)
31:     nodes = np.arange(emb.shape[0])  # node indices
32:     vecs = np.vstack([emb[n] for n in nodes])
33:     # sample pairs uniformly without replacement (if possible)
34:     m = nodes.size
35:     total_pairs = m * (m - 1) // 2
36:     n_samp = min(n_pairs, total_pairs)
37:     idx1 = rng.choice(m, size=n_samp, replace=True)
38:     idx2 = rng.choice(m - 1, size=n_samp, replace=True)
39:     idx2[idx2 >= idx1] += 1  # ensure idx2 ≠ idx1
40:     # compute inner products between sampled pairs
41:     #ip = np.array([cosine(vecs[idx1[i]], vecs[idx2[i]]) for i in range(n_samp)])
42:     ip = np.einsum("ij,ij->i", vecs[idx1], vecs[idx2])  # inner product
43:     return ip.ravel().astype(float)  # return as 1D array
44: def _embedding_ip_emd(
45:     emp_adj: csr_array,
46:     sur_adj: csr_array,
47:     *,
48:     dim: int = 128,
49:     n_pairs: int = 10_000,
50:     embedding_method: EmbeddingMethods = "node2vec",  # "node2vec" or "prone"
51:     rng: np.random.Generator = np.random.default_rng(1),
52: ) -> float:
53:     """Compare Node2Vec *and* ProNE embeddings via inner‑product distributions.
54:     The returned distance is the mean of the two 1‑D Wasserstein distances.
55:     """
56:     if embedding_method == "node2vec":
57:         ip_emp_n2v = _embed_and_sample(emp_adj, "node2vec", dim=dim,
58:                                        n_pairs=n_pairs, rng=rng
59:                                     )
60:         ip_sur_n2v = _embed_and_sample(sur_adj, "node2vec", dim=dim,
61:                                        n_pairs=n_pairs, rng=rng
62:                                     )
63:         d = wasserstein_distance(ip_emp_n2v, ip_sur_n2v)
64:     elif embedding_method == "prone":
65:         ip_emp_prn = _embed_and_sample(emp_adj, "prone", dim=dim,
66:                                        n_pairs=n_pairs, rng=rng
67:                                     )
68:         ip_sur_prn = _embed_and_sample(sur_adj, "prone", dim=dim,
69:                                        n_pairs=n_pairs, rng=rng
70:                                     )
71:         d = wasserstein_distance(ip_emp_prn, ip_sur_prn)
72:     else:
73:         raise ValueError(f"Unknown embedding method: {embedding_method}")
74:     return float(d)
75: ###############################################################################
76: # Embedding inner‑product EMD ---------------------------------------------
77: ###############################################################################
78: def embedding_node2vec_ip_emd(
79:     emp_adj: csr_array,
80:     sur_adj: csr_array,
81:     *,
82:     dim: int = 128,
83:     n_pairs: int = 10_000,
84:     rng: np.random.Generator = np.random.default_rng(1),
85: ) -> float:
86:     """Compare Node2Vec embeddings via inner‑product distributions."""
87:     return _embedding_ip_emd(emp_adj, sur_adj, dim=dim, n_pairs=n_pairs, 
88:                              embedding_method="node2vec", rng=rng)
89: def embedding_prone_ip_emd(
90:     emp_adj: csr_array,
91:     sur_adj: csr_array,
92:     *,
93:     dim: int = 128,
94:     n_pairs: int = 10_000,
95:     rng: np.random.Generator = np.random.default_rng(1),
96: ) -> float:
97:     """Compare ProNE embeddings via inner‑product distributions."""
98:     return _embedding_ip_emd(emp_adj, sur_adj, dim=dim, n_pairs=n_pairs, 
99:                              embedding_method="prone", rng=rng)

================
File: src/metrics/spectral.py
================
  1: """
  2: Spectral-subspace distance metric.
  3: This module provides :pyfunc:`eigen_subspace_distance`, which compares the
  4: leading *k* eigenpairs of two graphs.  It is robust to
  5: * integer or float adjacency matrices (we up-cast when needed);
  6: * asking for *too many* eigenpairs (ARPACK requires ``k < n``);
  7: * graphs of **different size** – we fall back to an eigenvalue-only distance;
  8: * tiny numerical noise – any value below *tolerance* is rounded to exact 0.
  9: """
 10: from typing import Tuple, Literal
 11: import numpy as np
 12: from scipy.sparse import csr_array
 13: from scipy.sparse.linalg import eigsh
 14: from scipy.spatial.distance import cosine
 15: from scipy.stats import wasserstein_distance
 16: # --------------------------------------------------------------------------- #
 17: # type aliases
 18: # --------------------------------------------------------------------------- #
 19: metric_type = Literal['eigen_val', 'eigen_vec']
 20: # --------------------------------------------------------------------------- #
 21: # helpers                                                                     #
 22: # --------------------------------------------------------------------------- #
 23: def _eig_pairs(A: csr_array, k: int, which: str = "LA") -> Tuple[np.ndarray, np.ndarray]:
 24:     """
 25:     Return the *k* largest-algebraic eigenvalues and eigenvectors of ``A``.
 26:     Parameters
 27:     ----------
 28:     A
 29:         Square symmetric matrix in CSR format.
 30:     k
 31:         Number of eigenpairs requested.  If ``k`` is ≥ *min(A.shape)`` it is
 32:         reduced to ``n − 1`` to satisfy ARPACK.
 33:     which
 34:         Part of the spectrum to compute (``"LA"`` = largest algebraic).
 35:     Returns
 36:     -------
 37:     λ, V
 38:         ``λ`` is length-``k`` (descending order); ``V`` has shape (*n*, *k*).
 39:     """
 40:     n = min(A.shape)
 41:     if k >= n:
 42:         k = n - 1  # ARPACK cannot handle k == n
 43:     A = A.astype(float, copy=False)  # ensure a float dtype for eigsh
 44:     vals, vecs = eigsh(A, k=k, which=which)
 45:     order = np.argsort(vals)[::-1]  # descending
 46:     return vals[order], vecs[:, order]
 47: def _eigen_distance(
 48:     emp_adj: csr_array,
 49:     sur_adj: csr_array,
 50:     *,
 51:     k: int = 10,
 52:     tolerance: float = 1e-12,
 53:     metric: metric_type = 'eigen_val',
 54: ) -> float:
 55:     """
 56:     Distance between the leading spectral subspaces of two graphs.
 57:     If *both* graphs have the same node count the metric is::
 58:         ||λ_emp − λ_sur||₂  +  mean_i(1 − cos(|v_emp,i|, |v_sur,i|))
 59:     where the absolute value removes the ± sign ambiguity of eigenvectors.
 60:     If node counts differ an eigenvector comparison is undefined.  In that
 61:     case a `RuntimeWarning` is emitted and the metric degrades gracefully to
 62:     **eigenvalue-only** distance ``||λ_emp − λ_sur||₂``.
 63:     Any result whose magnitude is below *tolerance* is returned as *exact*
 64:     0.0 so that identical graphs do not yield tiny floating-point residues.
 65:     Parameters
 66:     ----------
 67:     emp_adj, sur_adj
 68:         CSR adjacency matrices (weighted or unweighted, symmetric).
 69:     k
 70:         Number of leading eigenpairs to use (will be clamped so that
 71:         ``k < min(n_emp, n_sur)``).
 72:     tolerance
 73:         Numerical zero threshold for the final distance.
 74:     Returns
 75:     -------
 76:     float
 77:         Non-negative spectral distance.
 78:     """
 79:     # ------------------------------------------------------------------ k clamp
 80:     k_emp = min(k, emp_adj.shape[0] - 1)
 81:     k_sur = min(k, sur_adj.shape[0] - 1)
 82:     k_ = min(k_emp, k_sur)
 83:     # ---------------------------------------------------------------- eigpairs
 84:     λ_emp, V_emp = _eig_pairs(emp_adj, k_)
 85:     λ_sur, V_sur = _eig_pairs(sur_adj, k_)
 86:     if metric == 'eigen_val':
 87:         val_dist = float(np.linalg.norm(λ_emp - λ_sur))
 88:         return val_dist if abs(val_dist) >= tolerance else 0.0
 89:     elif metric == 'eigen_vec':
 90:         # ------------------------------------------------------------- vectors term
 91:         if emp_adj.shape == sur_adj.shape:
 92:             vec_dist = [
 93:                 cosine(np.abs(V_emp[:, i]), np.abs(V_sur[:, i]))
 94:                 for i in range(k_)
 95:             ]
 96:             vec_dist = float(np.mean(vec_dist))
 97:             return vec_dist if abs(vec_dist) >= tolerance else 0.0
 98:         else:
 99:             raise ValueError(
100:                 "Cannot compare eigenvectors of graphs with different node counts."
101:             )
102:     else:
103:         raise ValueError(
104:             f"Unknown metric type: {metric}. Use 'eigen_val' or 'eigen_vec'."
105:         )
106: # --------------------------------------------------------------------------- #
107: # main functions
108: # --------------------------------------------------------------------------- #
109: def eigen_val_distance(
110:     emp_adj: csr_array,
111:     sur_adj: csr_array,
112:     *,
113:     k: int = 10,
114:     tolerance: float = 1e-12,
115: ) -> float:
116:     return _eigen_distance(emp_adj, sur_adj, k=k, tolerance=tolerance, metric='eigen_val')
117: def eigen_vec_distance(
118:     emp_adj: csr_array,
119:     sur_adj: csr_array,
120:     *,
121:     k: int = 10,
122:     tolerance: float = 1e-12,
123: ) -> float:
124:     return _eigen_distance(emp_adj, sur_adj, k=k, tolerance=tolerance, metric='eigen_vec')
125: def centrality_distance(
126:     emp_adj: csr_array,
127:     sur_adj: csr_array,
128:     *,
129:     tolerance: float = 1e-12,
130: ) -> float:
131:     _, V_emp = _eig_pairs(emp_adj, 1)
132:     _, V_sur = _eig_pairs(sur_adj, 1)
133:     d = wasserstein_distance(
134:         np.abs(V_emp.ravel()),
135:         np.abs(V_sur.ravel()),
136:     )
137:     return d if abs(d) >= tolerance else 0.0

================
File: src/pipelines/evaluate_noisy_surrogates.py
================
  1: """
  2:     Generate surrogate differentially private SBM graphs and evaluate them against empirical data.
  3: """
  4: import argparse
  5: import yaml
  6: import csv
  7: from pathlib import Path
  8: import numpy as np
  9: from itertools import product
 10: from multiprocessing import Pool, cpu_count
 11: from tqdm import tqdm
 12: from metrics import REGISTRY
 13: from sbm.io import SBMWriter
 14: from sbm.sampling import sample_sbm_graph_from_fit
 15: from sbm.io import GraphLoader
 16: from sbm.utils.pipeline_utils import (
 17:     sbmfit_folderpath,
 18:     surrogate_statistics_filename,
 19:     FitConfig,
 20:     EvalConfig,
 21: )
 22: from sbm.noisy_fit import create_sbm_noise
 23: #######################
 24: ### Configuration Types 
 25: #######################
 26: def _generate_and_evaluate(
 27:         sbm_config, # fitting configs of the SBM
 28:         ds, # dataset specifications
 29:         eval_config, # evaluation configurations
 30:         rng: np.random.Generator,
 31:         eps:float, # privacy level epsilon
 32:         delta_sum:float, # sum of privacy level delta and alpha
 33:     ):
 34:     # split the privacy level delta (probability of failure)
 35:     delta, alpha = delta_sum/2, delta_sum/2
 36:     # load fitted model
 37:     fit_folder_path = sbmfit_folderpath(
 38:         base_dir=Path("results/sbm_fits"),
 39:         sbm_config=sbm_config,# type: ignore
 40:         data_spec=ds,
 41:     )
 42:     # load the sbm fit
 43:     sbm_fit = SBMWriter.load(fit_folder_path)
 44:     noise_factory = create_sbm_noise(
 45:         sbm=sbm_fit,
 46:         eps=eps,
 47:         delta=delta,
 48:         alpha=alpha,
 49:         noise_type="heterogeneous_gaussian"
 50:     )
 51:     # check if metrics have been cached earlier
 52:     out = surrogate_statistics_filename(
 53:         base_dir=Path("results/surrogate_statistics/dp"),
 54:         eval_configs=eval_config,
 55:         sbm_config=sbm_config,# type: ignore
 56:         data_spec=ds,
 57:     )
 58:     out.parent.mkdir(exist_ok=True)
 59:     if out.exists() and not eval_config["overwrite"]:
 60:         return
 61:     # Generate surrogates and campare metrics
 62:     results = []
 63:     for i in tqdm(range(eval_config["n_surrogates"])):
 64:         # sample an SBM graph from the sbm fit
 65:         emp = sample_sbm_graph_from_fit(sbm_fit, rng)
 66:         # sample differentially private sbm-fit
 67:         lasso_noisy_fit = noise_factory.sample_sbm_fit(rng, post='lasso') # type: ignore
 68:         # sample graph from the noisy sbm fit
 69:         private_surr = sample_sbm_graph_from_fit(lasso_noisy_fit, rng)
 70:         private_surr = private_surr.adjacency
 71:         row = {"dataset": ds["name"], "surrogate": f'surr_{i}'}
 72:         for m in eval_config["metrics"]:
 73:             row[m] = REGISTRY[m](emp, private_surr)
 74:         results.append(row)
 75:     with out.open("w", newline="") as f:
 76:         w = csv.DictWriter(f, fieldnames=results[0].keys())
 77:         w.writeheader(); w.writerows(results)
 78: ############################################
 79: ### main function
 80: ############################################
 81: def main(fit_config: str, eval_config: str, parallel:bool): # type: ignore
 82:     fit_config: FitConfig = yaml.safe_load(Path(fit_config).read_text())
 83:     rng = np.random.default_rng(fit_config["seed"])
 84:     data_config = fit_config["datasets"] # type: ignore
 85:     eval_config: EvalConfig = yaml.safe_load(Path(eval_config).read_text())
 86:     # load lists of privacy levels
 87:     eps_list = eval_config["eps"] # type: ignore
 88:     delta_sum_list = eval_config["delta"] # type: ignore
 89:     # Prepare arguments for the worker function
 90:     args = [
 91:         (sbm_config, ds, eval_config, rng, float(eps), float(delta_sum))# type: ignore
 92:         for sbm_config, ds, eps, delta_sum in
 93:             product(
 94:                 fit_config["sbm"],
 95:                 data_config,
 96:                 eps_list,
 97:                 delta_sum_list,
 98:             )
 99:     ]
100:     if parallel:
101:         # Create a pool of workers
102:         n_workers = max(1, cpu_count() - 1)  # Leave one core free
103:         with Pool(n_workers) as pool:
104:             # Execute the worker function in parallel
105:             pool.starmap(_generate_and_evaluate, args)
106:     else:
107:         for sbm_config, ds, eval_config, rng, eps, delta_sum in args:
108:             _generate_and_evaluate(
109:                 sbm_config=sbm_config,
110:                 ds=ds,
111:                 eval_config=eval_config,
112:                 rng=rng,
113:                 eps=eps,
114:                 delta_sum=delta_sum,
115:             )
116: if __name__ == "__main__":
117:     p = argparse.ArgumentParser()
118:     p.add_argument("--fit_config", type=str, help="Path to the configuration file.")
119:     p.add_argument("--eval_config", type=str, help="Path to the configuration file.")
120:     p.add_argument("--parallel", action="store_true", help="Run in parallel leaving one core free.")
121:     args = p.parse_args()
122:     main(
123:         fit_config=args.fit_config,
124:         eval_config=args.eval_config,
125:         parallel=args.parallel,
126:     )

================
File: src/sbm/utils/logger.py
================
  1: """
  2: sbm.utils.logger
  3: =================
  4: Enhanced CSV logger that also records online convergence diagnostics
  5: (R̂ and ESS) produced by :pyclass:`sbm.diagnostics.OnlineDiagnostics`.
  6: * The monitoring class keeps only *running* summaries, so you need an
  7:   external sink if you want to inspect those values later or feed them
  8:   into your existing visualisation pipeline.
  9: Row schema
 10: ----------
 11: ```
 12: iteration, elapsed_seconds, neg_log_likelihood,
 13: accept_rate_window, temperature,
 14: rhat_max, ess_min
 15: ```
 16: If you pass ``None`` for the diagnostic fields the columns are left
 17: empty, so existing parsing code keeps working when the diagnostics are
 18: switched off.
 19: """
 20: import csv
 21: import time
 22: from pathlib import Path
 23: from typing import Union, TextIO, Optional
 24: __all__ = ["CSVLogger"]
 25: class CSVLogger:
 26:     """Light‑weight CSV logger for long‐running SBM fits.
 27:     Parameters
 28:     ----------
 29:     file
 30:         Path to a CSV file *or* an already opened file handle.  If a path
 31:         is given and the file exists it will be **overwritten** so that
 32:         every fit starts with a clean log.
 33:     log_every
 34:         Only every ``log_every``‑th call to :py:meth:`log` results in a
 35:         new row.  Use this when your chain runs millions of sweeps but
 36:         you only need a coarse‑grained trace on disk.
 37:     """
 38:     header = [
 39:         "iteration",
 40:         "elapsed_seconds",
 41:         "neg_log_likelihood",
 42:         "accept_rate_window",
 43:         "temperature",
 44:         "rhat_max",   # max split‑R̂ across monitored scalars
 45:         "ess_min",    # min bulk/tail ESS across monitored scalars
 46:     ]
 47:     # ---------------------------------------------------------------------
 48:     def __init__(
 49:         self,
 50:         file: Union[str, Path, TextIO],
 51:         *,
 52:         log_every: int = 1_000,
 53:     ):
 54:         self.log_every = int(log_every)
 55:         self._start = time.time()
 56:         # Ensure we own a fresh handle ------------------------------------------------
 57:         if isinstance(file, (str, Path)):
 58:             file = Path(file)
 59:             if file.exists():
 60:                 file.unlink()  # start from scratch every run
 61:         # Open handle + CSV writer ----------------------------------------------------
 62:         if isinstance(file, (str, Path)):
 63:             self._own_handle = True
 64:             path = Path(file)
 65:             path.parent.mkdir(parents=True, exist_ok=True)
 66:             first = not path.exists()
 67:             self._fh: TextIO = path.open("a", newline="")
 68:             self._writer = csv.writer(self._fh)
 69:             if first:
 70:                 self._writer.writerow(self.header)
 71:         else:  # already a file‑like object
 72:             self._own_handle = False
 73:             self._fh = file
 74:             self._writer = csv.writer(self._fh)
 75:             # assume caller has written the header
 76:         self._iteration_since_flush = 0
 77:     # ------------------------------------------------------------------
 78:     def log(
 79:         self,
 80:         iteration: int,
 81:         neg_loglike: float,
 82:         accept_rate_window: float,
 83:         temperature: float,
 84:         *,
 85:         rhat_max: Optional[float] = None,
 86:         ess_min: Optional[float] = None,
 87:     ) -> None:
 88:         """Append one new row if ``iteration`` meets the cadence.
 89:         The diagnostics fields are *optional* so you can turn them off
 90:         without touching call‑sites.
 91:         """
 92:         if iteration % self.log_every:
 93:             return  # skip — not a checkpoint
 94:         elapsed = time.time() - self._start
 95:         self._writer.writerow([
 96:             iteration,
 97:             f"{elapsed:.3f}",
 98:             f"{neg_loglike:.6f}",
 99:             f"{accept_rate_window:.6f}",
100:             f"{temperature:.6f}",
101:             f"{rhat_max:.5f}" if rhat_max is not None else "",
102:             f"{ess_min:.1f}"   if ess_min  is not None else "",
103:         ])
104:         # Flush every ~10 rows to amortise disk writes.
105:         self._iteration_since_flush += 1
106:         if self._iteration_since_flush >= 10:
107:             self._fh.flush()
108:             self._iteration_since_flush = 0
109:     # ------------------------------------------------------------------
110:     def close(self):
111:         if self._own_handle:
112:             self._fh.close()
113:     # Context‑manager sugar ------------------------------------------------
114:     def __enter__(self):
115:         return self
116:     def __exit__(self, exc_type, exc, tb):
117:         self.close()

================
File: src/sbm/initial_partition.py
================
 1: import numpy as np
 2: import scipy.sparse as sp
 3: from scipy.sparse.linalg import eigsh
 4: from typing import Dict, Optional
 5: from sklearn.cluster import KMeans
 6: from scipy.sparse import csr_matrix
 7: class SpectralPartitioner:
 8:     def __init__(self, adjacency: csr_matrix, seed: Optional[int] = None):
 9:         """
10:         Initialize the SpectralPartitioner.
11:         :param adjacency: The adjacency matrix of the network (sparse CSR matrix).
12:         :param seed: Random seed for reproducibility.
13:         """
14:         self.adjacency: csr_matrix = adjacency.tocsr()
15:         self.num_nodes: int = self.adjacency.shape[0]
16:         self.rng = np.random.default_rng(seed)
17:         self.degree_vector = np.array(self.adjacency.sum(axis=1)).flatten()
18:         self.laplacian = self._compute_normalized_laplacian()
19:     def _compute_normalized_laplacian(self) -> csr_matrix:
20:         """
21:         Compute the normalized Laplacian matrix of the graph.
22:         :return: The normalized Laplacian matrix (sparse CSR matrix).
23:         """
24:         # Avoid division by zero
25:         with np.errstate(divide='ignore'):
26:             d_inv_sqrt = np.power(self.degree_vector, -0.5)
27:             d_inv_sqrt[np.isinf(d_inv_sqrt)] = 0.0
28:         D_inv_sqrt = sp.diags(d_inv_sqrt)
29:         L = sp.eye(self.num_nodes) - D_inv_sqrt @ self.adjacency @ D_inv_sqrt
30:         return L
31:     def partition(self, num_blocks: int) -> Dict[int, int]:
32:         """
33:         Partition the nodes into blocks using spectral clustering.
34:         :param num_blocks: The desired number of blocks.
35:         :return: A dictionary mapping node indices to block indices.
36:         """
37:         # Compute the first (num_blocks) eigenvectors of the normalized Laplacian
38:         # Use 'SM' to find eigenvalues closest to zero
39:         eigenvalues, eigenvectors = eigsh(
40:             self.laplacian, k=num_blocks, which='SM', tol=1e-6, maxiter=5000
41:         )
42:         # Normalize rows to unit length to improve clustering
43:         embedding = eigenvectors
44:         row_norms = np.linalg.norm(embedding, axis=1, keepdims=True)
45:         row_norms[row_norms == 0] = 1e-10  # Avoid division by zero
46:         embedding_normalized = embedding / row_norms
47:         # Use k-means clustering on the spectral embeddings
48:         kmeans = KMeans(n_clusters=num_blocks, random_state=self.rng.integers(1 << 32))
49:         labels = kmeans.fit_predict(embedding_normalized)
50:         # Map nodes to blocks
51:         blocks = {node: int(label) for node, label in enumerate(labels)}
52:         return blocks

================
File: src/sbm/noisy_fit.py
================
  1: ###############################################################################
  2: #  noisy_fit_refactored.py
  3: #  ───────────────────────────────────────────────────────────────────────────
  4: #  Differential-privacy noise generation for Stochastic-Block-Model (SBM) fits
  5: #
  6: #  This module implements three Gaussian–mechanism variants:
  7: #
  8: #    • **heterogeneous_gaussian**  – optimal per-coordinate σq   (Sec.-4, eq. 12)
  9: #    • **naive_degree_gaussian**   – one common  σ  calibrated to global
 10: #                                     Δmax-degree  (classic node-DP baseline)
 11: #    • **naive_edge_count_gaussian** – one common  σ  calibrated to
 12: #                                       Δnlk  (α-quantile “single–block change”)
 13: #
 14: #  All noise is added to the *SBM sufficient statistics*
 15: #           n_r   … block sizes            (1 × B   coordinates)
 16: #           m_rs  … upper-tri edge counts  (B(B+1)/2 coordinates)
 17: #
 18: #  Memory footprint is O(B + nnz(m)), never B².
 19: #
 20: #──────────────────────────────────────────────────────────────────────────────
 21: #  SYMBOL TABLE  (matches notation in the derivation)
 22: #──────────────────────────────────────────────────────────────────────────────
 23: #
 24: #  B           : number of blocks.
 25: #  k_vec       : integer array [k₀,…,k_{B-1}]  — true block sizes (≈k or k+1).
 26: #
 27: #  m_rs        : true edge count between blocks r and s (upper triangle incl. diag).
 28: #  N_rs        : number of *possible* edges, =
 29: #                  k_r·(k_r-1)/2    if r=s
 30: #                  k_r·k_s          if r≠s
 31: #
 32: #  p_rs        : edge probability  m_rs / N_rs.  For p=0 or 1 we clip to
 33: #                clip_p   (default 1e-12) to keep weights finite.
 34: #
 35: #  Δ_nlk       : “single-block change” sensitivity — α-quantile of the
 36: #                maximum number of neighbours a *single* node can have in the
 37: #                *same* block (max Binomial), eq. (2).
 38: #  delta_tail  : 1-α — contributes to δ in (ε,δ+δ_tail)-DP.
 39: #
 40: #  c_n         : sensitivity² for n_r.  Here Δ=1 ⇒  c_n = 1.
 41: #  c_e_val     : sensitivity² for *all* edge counts m_rs = Δ_nlk².
 42: #
 43: #  w_n[r]      : utility weight for n_r
 44: #  w_rs        : utility weight for m_rs
 45: #  w_e         : list of w_rs for every stored upper-tri cell.
 46: #
 47: #  S_sum       : Σ_q √(c_q w_q)   (needed in eq. (10)–(12)).
 48: #
 49: #  R           : ε² / (2 ln(1.25/(δ+δ_tail)))   — Gaussian mech. constant.
 50: #
 51: #  σ_n[r]      : standard deviation for noise on n_r  (heterogeneous case).
 52: #  σ_e[r,s]    : standard deviation for noise on m_rs (upper-tri CSR).
 53: #  σ_common    : single σ used by the two naïve variants.
 54: #
 55: #  noise_type  : one of {"heterogeneous_gaussian", "naive_degree_gaussian",
 56: #                        "naive_edge_count_gaussian"}.
 57: #
 58: #  clip_p      : lower/upper bound substituted for p_rs = 0 or 1.
 59: #  weight_clip : optional upper bound on w to avoid extreme σ→0.
 60: ###############################################################################
 61: # sbm/noisy_fit.py
 62: from dataclasses import dataclass
 63: from typing import List, Optional, Callable, Literal, Tuple
 64: import math
 65: import numpy as np
 66: import scipy.sparse as sp
 67: from scipy.sparse import csr_array
 68: from scipy.special import binom
 69: from math import exp, sqrt
 70: from scipy.stats import norm
 71: from sbm.io import SBMFit
 72: from sbm.post_process import (
 73:     naive_clamping,
 74:     constrained_lasso,
 75:     PostProcessFnName,
 76: )
 77: # --------------------------------------------------------------
 78: ### aliasses
 79: # --------------------------------------------------------------
 80: NoiseType = Literal[
 81:     "heterogeneous_gaussian",
 82:     "naive_degree_gaussian",
 83:     "naive_edge_count_gaussian"
 84: ]
 85: # --------------------------------------------------------------
 86: ### Helper functions
 87: # --------------------------------------------------------------
 88: # ---------------------------------------------------------------------
 89: #  analytic_gauss_K  (now with the 2-factor)
 90: # ---------------------------------------------------------------------
 91: def analytic_gauss_K(eps: float, delta: float, tol: float = 1e-12) -> float:
 92:     """
 93:     Return alpha* for the analytic Gaussian mechanism (Balle et al. 2018, Alg. 1).
 94:     Works for any eps > 0 and 0 < delta < 1.
 95:     """
 96:     delta0 = norm.cdf(0.0) - exp(eps) * norm.cdf(-sqrt(2*eps))
 97:     # ----------------------------------------------------------------
 98:     # Branch A  (delta >= delta0)  ->  solve for v >= 0
 99:     # ----------------------------------------------------------------
100:     if delta >= delta0:
101:         def B_plus(v: float) -> float:
102:             return float(norm.cdf(sqrt(eps)*v) - \
103:                    exp(eps) * norm.cdf(-sqrt(eps)*(v + 2.0)))
104:         lo, hi = 0.0, 1.0
105:         while B_plus(hi) < delta:      # B_plus increases in v
106:             hi *= 2.0
107:         while hi - lo > tol:
108:             mid = 0.5 * (lo + hi)
109:             if B_plus(mid) < delta:
110:                 lo = mid
111:             else:
112:                 hi = mid
113:         v_star = hi
114:         alpha  = sqrt(1.0 + v_star/2.0) - sqrt(v_star/2.0)
115:     # ----------------------------------------------------------------
116:     # Branch B  (delta < delta0)   ->  solve for u >= 0
117:     # ----------------------------------------------------------------
118:     else:
119:         def B_minus(u: float) -> float:
120:             return float(norm.cdf(-sqrt(eps)*u) - \
121:                    exp(eps) * norm.cdf(-sqrt(eps)*(u + 2.0)))
122:         lo, hi = 0.0, 1.0
123:         while B_minus(hi) > delta:     # B_minus decreases in u
124:             hi *= 2.0
125:         while hi - lo > tol:
126:             mid = 0.5 * (lo + hi)
127:             if B_minus(mid) > delta:
128:                 lo = mid
129:             else:
130:                 hi = mid
131:         u_star = hi
132:         alpha  = sqrt(1.0 + u_star/2.0) + sqrt(u_star/2.0)
133:     return alpha      # this is K
134: def _upper_tri_csr(rows, cols, data, B):
135:     """Return symmetric CSR from upper-tri lists."""
136:     coo = sp.coo_array((data, (rows, cols)), shape=(B, B))
137:     csr = csr_array(coo)
138:     return csr + csr.T - sp.diags(csr.diagonal())
139: def max_binom_quantile(k: int, ps: np.ndarray, alpha: float) -> int:
140:     """
141:     Small k (≤50) ⇒ brute-force exact cdf of max{Bin(k,p_s)}.
142:     Returns the smallest c s.t.   P(max ≤ c) ≥ α.
143:     """
144:     if not (0 < alpha < 1):
145:         raise ValueError("alpha must be in (0,1)")
146:     # pre-compute per-block Binomial pmf for 0..k
147:     pmf = np.array([binom(k, j) * ps**j * (1 - ps)**(k - j)
148:                     for j in range(k + 1)])        # shape (k+1,B)
149:     cdf = pmf.cumsum(axis=0)                       # shape (k+1,B)
150:     # P(max ≤ c) = ∏_s F_s(c)
151:     prod = np.prod(cdf, axis=1)                    # length k+1
152:     for c in range(k + 1):
153:         if prod[c] >= alpha:
154:             return c
155:     return k  # should never happen if alpha<1
156: def n_possible(k_r: int, k_s: int, same_block: bool) -> int:
157:     if same_block:
158:         return k_r * (k_r - 1) // 2
159:     return k_r * k_s
160: def add_edge_noise(
161:         block_conn: sp.csr_array,
162:         sigma_e: sp.csr_array,
163:         rng: np.random.Generator
164:     ) -> sp.csr_array:
165:     noisy_conn = sp.triu(
166:         block_conn.copy(),
167:         k=0, # include diagonal
168:         format="csr"
169:     )
170:     # add noise to edge-counts (m_rs) upper traingle
171:     rr, cc = noisy_conn.nonzero() # coordinates of the stored upper-tri values
172:     sigma = np.asarray(sigma_e[rr, cc]).ravel() # shape the sigma_e vector
173:     data = np.array(noisy_conn.data, dtype=float)
174:     data += rng.normal(0.0, sigma, size=len(sigma))
175:     return sp.csr_array(
176:         (data, (rr, cc)),
177:         shape=noisy_conn.shape,
178:         dtype=float
179:     )
180: # ---------------------------------------------------------
181: #### Main class
182: # ---------------------------------------------------------
183: @dataclass
184: class Noise:
185:     """Base class for noise added to an SBM fit."""
186:     fit: SBMFit
187:     sigma_n: np.ndarray              # shape (B,)
188:     sigma_e: sp.csr_array            # upper triangle incl. diag
189:     eps: float
190:     delta: float
191:     delta_tail: float                # = 1 - alpha
192:     delta_nlk: int                   # sensitivity used for m_rs
193:     metadata: dict
194:     def sample_sbm_fit(self,
195:                        rng: np.random.Generator,
196:                        post: Optional[Callable[[sp.csr_array], sp.csr_array]] = None,
197:                        ) -> SBMFit:
198:         """
199:         Draw *one* noisy SBM draw.
200:         Returns a **new** `SBMFit` instance ready for `sample_sbm_graph`.
201:         """
202:         raise NotImplementedError("Must be implemented in subclass")
203: @dataclass
204: class HeterogeneousGaussNoise(Noise):
205:     """An `SBMFit` with optimal Gaussian noise already added."""
206:     fit: SBMFit
207:     sigma_n: np.ndarray              # shape (B,)
208:     sigma_e: sp.csr_array            # upper triangle incl. diag
209:     sigma_zero_fun: Callable[[int], float]  # function to compute σ for zero pairs
210:     eps: float
211:     delta: float
212:     delta_tail: float                # = 1 - alpha
213:     delta_nlk: int                   # sensitivity used for m_rs
214:     S_sum: float                     # Σ_q √(c_q w_q) used in σ formula
215:     #R: float
216:     metadata: dict
217:     # ---------- sampling ---------------------------------------------
218:     def sample_sbm_fit(self, # type: ignore
219:                      rng: np.random.Generator,
220:                      post: Optional[PostProcessFnName] = 'naive',
221:                      ) -> SBMFit:
222:         """
223:         Draw *one* noisy SBM draw, then (optionally) post-process the
224:         noisy counts.
225:         Returns a **new** `SBMFit` instance ready for `sample_sbm_graph`.
226:         """
227:         k_vec = np.array(self.fit.block_sizes, int)
228:         # find the most frequent block size (this will be k)
229:         k_val = int(np.bincount(k_vec).argmax())  # most frequent block size
230:         # 1) add Gaussian noise to non-zero elements --------------------
231:         n_noisy = k_vec + rng.normal(0, self.sigma_n)
232:         noisy_conn = add_edge_noise(
233:             block_conn=self.fit.block_conn,
234:             sigma_e=self.sigma_e,
235:             rng=rng
236:         )
237:         ### post-process the noisy counts ------------------------
238:         if str(post).lower() == 'lasso':
239:             conn, n_noisy = constrained_lasso(
240:                 n_noisy=n_noisy,
241:                 noisy_conn=noisy_conn,  # type: ignore
242:                 sigma_rs=self.sigma_e,
243:                 k_val=k_val,
244:                 sigma_zero_fun=self.sigma_zero_fun,
245:                 rng=rng,
246:                 round_thresh=0.5,  # threshold for rounding
247:                 lam=None,  # λ in soft-threshold (impute from noisy fit)
248:                 n_possible_fn=n_possible,
249:             )
250:         else:
251:             ### perform simple post-processing:
252:             conn, n_noisy = naive_clamping(
253:                 n_noisy=n_noisy,
254:                 noisy_conn=noisy_conn, # type: ignore
255:                 sigma_e=self.sigma_e,
256:                 k_val=k_val,
257:                 sigma_zero_fun=self.sigma_zero_fun,
258:                 rng=rng,
259:                 round_thresh=0.5,  # threshold for rounding
260:                 n_possible_fn=n_possible,
261:                 )
262:         # 2) re-symmetrise & cast to int -----------------------------
263:         block_sizes = n_noisy.astype(int).tolist()
264:         return SBMFit(
265:             block_sizes=block_sizes,
266:             block_conn=conn,
267:             directed_graph=self.fit.directed_graph,
268:             neg_loglike=float("nan"),          # unknown after noise
269:             metadata={
270:                 **self.fit.metadata,
271:                 "dp_eps": self.eps,
272:                 "dp_delta": self.delta,
273:                 "dp_delta_tail": self.delta_tail,
274:             },
275:         )
276: @dataclass
277: class _HomogGaussNoiseBase(Noise):
278:     """
279:     Base for 'naïve' variants with *single* σ for n_r, single σ for m_rs.
280:     Stores only two scalars:  sigma_n_scalar, sigma_e_scalar
281:     """
282:     sigma_n_scalar: float      # same σ for every n_r
283:     sigma_e_scalar: float      # same σ for every m_rs (non-zero counts)
284:     # ---- helper ----------------------------------------------------
285:     def _draw_noisy_counts(self,
286:                            rng: np.random.Generator,
287:     ) -> tuple[np.ndarray, sp.csr_array]:
288:         k_vec = np.array(self.fit.block_sizes, int)
289:         n_noisy = np.maximum( 1, k_vec + rng.normal(0, self.sigma_n_scalar, size=len(k_vec)))
290:         conn = self.fit.block_conn.copy().astype(float).tocsr()
291:         mask_nz = conn.data != 0          # we only stored non-zeros
292:         conn.data[mask_nz] += rng.normal(
293:             0, self.sigma_e_scalar, size=mask_nz.sum()
294:         )
295:         conn = sp.triu(conn, k=0, format="csr")
296:         conn = conn + conn.T - sp.diags(conn.diagonal())
297:         conn = conn.astype(int).tocsr()
298:         return n_noisy, conn
299:     # ---- public ----------------------------------------------------
300:     def sample_sbm_fit(self,
301:                        rng: np.random.Generator,
302:                        post: Optional[Callable[[sp.csr_array], sp.csr_array]] = None
303:                        ) -> SBMFit:
304:         n_noisy, conn = self._draw_noisy_counts(rng)
305:         if post is not None:
306:             conn = post(conn)
307:         else:
308:             ### perform simple post-processing:
309:             #   round conn and block_sizes to int and ensure
310:             #   no conn-count is larger than the max possible
311:             rr, cc = conn.nonzero()
312:             for r, c in zip(rr, cc):
313:                 n_noisy[r] = np.round(n_noisy[r])
314:                 n_noisy[c] = np.round(n_noisy[c])
315:                 N = n_possible(n_noisy[r], n_noisy[c], same_block=(r == c)) # type: ignore
316:                 conn[r, c] = np.round(conn[r, c]) # type: ignore
317:                 if conn[r, c] > N: # type: ignore
318:                     conn[r, c] = N # type: ignore
319:         return SBMFit(
320:             block_sizes=n_noisy.tolist(),
321:             block_conn=conn,
322:             directed_graph=self.fit.directed_graph,
323:             neg_loglike=float("nan"),
324:             metadata={**self.fit.metadata, **self.metadata},
325:         )
326: @dataclass
327: class NaiveDegreeGaussNoise(_HomogGaussNoiseBase):
328:     """Homogeneous σ using global Δ_deg (α-quantile max-degree)."""
329:     pass
330: @dataclass
331: class NaiveEdgeCountGaussNoise(_HomogGaussNoiseBase):
332:     """Homogeneous σ using global Δ_nlk (α-quantile single block-change)."""
333:     pass
334: # --------------------------------------------------------------------
335: # 1.  p-matrix and Δ_{nlk}
336: # --------------------------------------------------------------------
337: def _prob_matrix_and_sens(
338:     conn: sp.csr_array,
339:     k_vec: np.ndarray,
340:     alpha: float,
341:     clip_p: float
342: ) -> Tuple[sp.csr_array, int]:
343:     """
344:     Convert edge counts → probabilities **p_{rs}** and compute
345:     Δ_{nlk} = α–quantile of max neighbours in any single block.
346:     """
347:     B = len(k_vec)
348:     p = conn.copy().astype(float).tocoo()
349:     for i, (r, s) in enumerate(zip(p.row, p.col)):
350:         N = n_possible(k_vec[r], k_vec[s], r == s) # type: ignore
351:         p.data[i] = conn[r, s] / N
352:     p = p.tocsr()
353:     delta_nlk = 0
354:     for r in range(B):
355:         ps_row = np.zeros(B)
356:         start, end = p.indptr[r], p.indptr[r + 1]
357:         ps_row[p.indices[start:end]] = p.data[start:end]
358:         delta_nlk = max(delta_nlk,
359:                         max_binom_quantile(k_vec[r], ps_row, alpha))
360:     # Avoid p=0 or 1 in later calculations
361:     p.data[p.data == 0.0] = clip_p
362:     p.data[p.data == 1.0] = 1.0 - clip_p
363:     return p, delta_nlk
364: # --------------------------------------------------------------------
365: # 2.  Weight computation
366: # --------------------------------------------------------------------
367: def _weights_and_S(
368:     p_mat: sp.csr_array,
369:     k_vec: np.ndarray,
370:     delta_nlk: int,
371:     weight_clip: float,
372:     clip_p: float,
373:     c_n_val: float,
374: ) -> Tuple[np.ndarray, np.ndarray, List[int], List[int], float]:
375:     """
376:     Compute weights w_q for n_r and m_rs, and the sum S = Σ √(c_q w_q).
377:     Weights are used to compute the noise levels σ_q so as to minimize
378:     expected likelihood loss
379:     Compute:
380:       * w_n   : vector length B
381:       * w_e   : list for every stored upper-tri cell (row parity)
382:       * idx_e : corresponding *column* indices (for CSR builder)
383:       * S_sum = Σ sqrt(c_q w_q) used in σ formula (12)
384:     """
385:     B = len(k_vec)
386:     c_e_val = delta_nlk ** 2
387:     w_n = np.zeros(B)
388:     w_e = []
389:     col_e= []
390:     row_e = []
391:     S_sum = 0.0
392:     for r in range(B):
393:         # ---- diagonal r,r (zero and non-zero alike) ---------------
394:         N_rr = n_possible(k_vec[r], k_vec[r], True)
395:         p_rr = p_mat[r, r]
396:         if p_rr < clip_p:
397:             w_rr = weight_clip
398:         else:
399:             # MSE weights
400:             #w_rr = 1.0 / N_rr
401:             # KL-based weight  w_rr = N_rr / [2 p_rr (1-p_rr)]
402:             w_rr = N_rr / (2.0 * p_rr * (1.0 - p_rr))   ### ← NEW (KL)
403:         w_rr = min(w_rr, weight_clip)
404:         # store sparse diagonal weight
405:         w_e.append(w_rr)
406:         row_e.append(r)
407:         col_e.append(r)
408:         S_sum += math.sqrt(c_e_val * w_rr)
409:         # ---- off-diagonal non-zero pairs r,s (s>r) -------------------------------
410:         for s_ptr in range(p_mat.indptr[r], p_mat.indptr[r + 1]):
411:             s = p_mat.indices[s_ptr]
412:             if s <= r:
413:                 continue
414:             p_rs = p_mat[r, s]
415:             if p_rs <= clip_p or p_rs >= 1.0 - clip_p:
416:                 w_rs = weight_clip
417:             else:
418:                 N_rs = n_possible(k_vec[r], k_vec[s], False) # type: ignore
419:                 # MSE weights
420:                 #w_rs = 1.0 / N_rs# (2 * N_rs * p_rs * (1 - p_rs))
421:                 # KL-based weight
422:                 w_rs = N_rs / (2.0 * p_rs * (1.0 - p_rs))  ### ← NEW (KL)
423:             w_rs = min(w_rs, weight_clip)
424:             # store sparse upper-tri weights
425:             w_e.append(w_rs)
426:             row_e.append(r)
427:             col_e.append(s)
428:             # add to normalization S
429:             S_sum += math.sqrt(c_e_val * w_rs)
430:         # ---- off-diagonal zero-pairs r>s ----------------------------
431:         # off diag
432:         present = set(p_mat.indices[p_mat.indptr[r] : p_mat.indptr[r+1]])
433:         for s in range(r+1, B):
434:             # only add terms from zero pairs upper diagonal pairs
435:             if (s in present) or s<=r:
436:                 continue
437:             N_rs = n_possible(k_vec[r], k_vec[s], False)
438:             S_sum += math.sqrt(c_e_val * (1/N_rs))
439:         # ---- MSE block-size weight w_n[r] -----------------------------
440:         #inter = p_mat[[r]].toarray().ravel()
441:         #inter[r] = 0.0
442:         ## ---- block-size weight w_n[r]  (MSE version)
443:         #p_row = p_mat[[r]].toarray().ravel()
444:         #p_off = np.delete(p_row, r)
445:         #w_n[r]  = k_vec[r] * (p_off ** 2 @ np.delete(k_vec, r))
446:         #p_rr    = p_row[r]
447:         #if k_vec[r] > 1:
448:         #    w_n[r] += ((2 * k_vec[r] - 1) ** 2) / (2 * k_vec[r] * (k_vec[r] - 1)) \
449:         #      * (p_rr ** 2)
450:         #if w_n[r] > weight_clip:
451:         #    w_n[r] = weight_clip
452:         # ---- block-size weight w_n[r]  (KL version) ---------------
453:         p_row = p_mat[[r]].toarray().ravel()
454:         # First sum:  2 * Σ w_rs * p_rs^2 / k^2
455:         w_nr = 0.0
456:         for s in range(B):
457:             if s == r:
458:                 # diagonal term already added
459:                 continue
460:             p_rs = p_row[s]
461:             if p_rs <= clip_p or p_rs >= 1.0 - clip_p:
462:                 continue
463:             N_rs = n_possible(k_vec[r], k_vec[s], False)
464:             w_rs = N_rs / (2.0 * p_rs * (1.0 - p_rs))
465:             w_nr += 2.0 * w_rs * (p_rs ** 2) / (k_vec[r] ** 2)
466:         # Second (diagonal) term: w_rr * c_k^2 * p_rr^2
467:         c_k = (2 * k_vec[r] - 4) / (k_vec[r] * (k_vec[r] - 1))
468:         w_nr += w_rr * (c_k ** 2) * (p_rr ** 2)
469:         if w_nr > weight_clip:
470:             w_nr = weight_clip
471:         w_n[r] = w_nr
472:         S_sum += math.sqrt(c_n_val * w_n[r])
473:     # backup in case all probs were clipped to zero 
474:     if S_sum <= 0:
475:         print("Warning: S_sum is zero, using small value to avoid division by zero.")
476:         S_sum = 1e-12
477:     return w_n, np.asarray(w_e), row_e, col_e, S_sum
478: # --------------------------------------------------------------------
479: # 3.  σ computation
480: # --------------------------------------------------------------------
481: def _compute_sigmas(
482:     w_n: np.ndarray,
483:     w_e: np.ndarray,
484:     S_sum: float,
485:     eps: float,
486:     delta: float,
487:     delta_tail: float,
488:     B: int,
489:     c_e_val: float,
490:     col_e: List[int],
491:     row_e: List[int],
492: ) -> Tuple[np.ndarray, sp.csr_array, float]:
493:     """
494:     Return vector σ_n and sparse CSR σ_e (upper-tri inc. diag).
495:     Computes the noise levels for the heterogeneous Gaussian mechanism
496:     """
497:     ### old gaussian mechanism:
498:     #R = eps**2 / (2*math.log(1.25/(delta+delta_tail)))
499:     #sigma_n = np.sqrt(1/np.sqrt(w_n*R) * S_sum)
500:     #sigma_e_vals = np.sqrt(c_e_val * w_e) * S_sum / R
501:     #sigma_e_vals = np.sqrt(np.sqrt(c_e_val / (w_e*R)) * S_sum)
502:     ### New gaussian mechanism: Balle and Wang 2018
503:     R = analytic_gauss_K(eps, delta)
504:     factor = (2 * R) ** 2 / S_sum
505:     sigma_n       = np.sqrt( np.sqrt(1.0 * w_n) * factor )
506:     sigma_e_vals  = np.sqrt( np.sqrt(c_e_val * w_e) * factor )
507:     print(f'max σ_n: {sigma_n.max():.3f}, max σ_e: {sigma_e_vals.max():.3f}')
508:     sigma_e = _upper_tri_csr(row_e, col_e, sigma_e_vals, B)
509:     return sigma_n, sigma_e, factor
510: # --------------------------------------------------------------------
511: # 4.  Factory
512: # --------------------------------------------------------------------
513: def create_sbm_noise(
514:     sbm: SBMFit,
515:     eps: float,
516:     delta: float,
517:     alpha: float,
518:     *,
519:     clip_p: float = 1e-12,
520:     weight_clip: float = 1e12,
521:     noise_type: NoiseType = "heterogeneous_gaussian",
522: ) -> "Noise":
523:     """
524:     Construct one of the three Noise objects.
525:     Steps:
526:       (1) convert counts→probabilities and compute Δ_{nlk}
527:       (2) weights  w_q  and  S = Σ√(c_q w_q)
528:       (3) σ_q  via eq. (12)
529:       (4) package into chosen Noise subclass
530:     """
531:     if sbm.directed_graph:
532:         raise NotImplementedError("undirected only")
533:     k_vec = np.asarray(sbm.block_sizes, int)
534:     B = len(k_vec)
535:     # 1) probabilities & sensitivity Δ_nlk --------------------------
536:     p_mat, delta_nlk = _prob_matrix_and_sens(
537:         sbm.block_conn, k_vec, alpha, clip_p
538:     )
539:     delta_tail = 1.0 - alpha
540:     c_e_val = delta_nlk ** 2
541:     # 2) weights & S -------------------------------------------------
542:     w_n, w_e, row_e, col_e, S_sum = _weights_and_S(
543:         p_mat, k_vec, delta_nlk, weight_clip, clip_p, c_n_val=1.0
544:     )
545:     # 3) σ’s  --------------------------------------------------------
546:     sigma_n, sigma_e, factor = _compute_sigmas(
547:         w_n=w_n, w_e=w_e, S_sum=S_sum,
548:         eps=eps, delta=delta, delta_tail=delta_tail,
549:         B=B, c_e_val=c_e_val, col_e=col_e, row_e=row_e
550:     )
551:     # -- select variant ---------------------------------------------
552:     if noise_type == "heterogeneous_gaussian":
553:         return HeterogeneousGaussNoise(
554:             fit=sbm,
555:             sigma_n=sigma_n,
556:             sigma_e=sigma_e,
557:             ### OLD gaussian mechanism:
558:             #sigma_zero_fun=lambda N_rs: np.sqrt(np.sqrt(c_e_val / (N_rs*R)) * S_sum),
559:             ### NEW gaussian mechanism:
560:             sigma_zero_fun=lambda N_rs: np.sqrt(
561:                 np.sqrt(c_e_val / N_rs) * factor      # ← updated line
562:             ),
563:             eps=eps,
564:             delta=delta,
565:             delta_tail=delta_tail,
566:             delta_nlk=delta_nlk,
567:             S_sum=S_sum,
568:             #R=R,
569:             metadata={"noise": "heterogeneous_gaussian",
570:                       "alpha": alpha,
571:                       "Delta_nlk": delta_nlk,
572:                       "delta_tail": delta_tail,
573:                       "eps": eps,
574:                       **sbm.metadata,
575:                       },
576:         )
577:     # ----- homogeneous variants share one σ ------------------------
578:     total_c = B*1.0 + (B*(B+1)//2) * c_e_val   # all cells!
579:     sigma_common = math.sqrt(total_c /
580:                              (eps**2 / (2*math.log(1.25/(delta+delta_tail)))))
581:     if noise_type == "naive_edge_count_gaussian":
582:         return NaiveEdgeCountGaussNoise(
583:             fit=sbm,
584:             sigma_n_scalar=sigma_common,
585:             sigma_e_scalar=sigma_common,
586:             sigma_n=np.full(B, sigma_common),
587:             sigma_e=sp.csr_array((B, B), dtype=float),
588:             eps=eps,
589:             delta=delta,
590:             delta_tail=delta_tail,
591:             delta_nlk=delta_nlk,
592:             metadata={"noise": "naive_edge_count_gaussian",
593:                       "sigma_common": sigma_common, **sbm.metadata},
594:         )
595:     # compute 
596:     if noise_type == "naive_degree_gaussian":
597:         return NaiveDegreeGaussNoise(
598:             fit=sbm,
599:             sigma_n_scalar=sigma_common,
600:             sigma_e_scalar=sigma_common,
601:             sigma_n=np.full(B, sigma_common),
602:             sigma_e=sp.csr_array((B, B), dtype=float),
603:             eps=eps,
604:             delta=delta,
605:             delta_tail=0.,
606:             delta_nlk=0,
607:             metadata={"noise": "naive_degree_gaussian",
608:                       "sigma_common": sigma_common,
609:                       **sbm.metadata},
610:         )
611:     raise ValueError(f"unknown noise_type {noise_type!r}")

================
File: src/sbm/post_process.py
================
  1: """
  2: Functions and classes for post-processing SBM fits to create noisy SBM fits
  3: """
  4: # --------------------------------------------------------------
  5: from typing import Callable, Tuple, Literal, Optional
  6: import numpy as np
  7: import scipy.sparse as sp
  8: from scipy.stats import norm
  9: from scipy.sparse import csr_array
 10: from typing import Callable
 11: # ------------------------------------------------------------------
 12: # Aliases
 13: PostProcessFnName = Literal['naive', 'lasso']
 14: # ------------------------------------------------------------------
 15: def naive_clamping(
 16:     n_noisy: np.ndarray,
 17:     noisy_conn: sp.csr_array,
 18:     sigma_e: sp.csr_array,
 19:     k_val: int,
 20:     sigma_zero_fun: Callable[[int], float],
 21:     rng: np.random.Generator,
 22:     *,
 23:     round_thresh: float = 0.5,
 24:     n_possible_fn: Callable[[int, int, bool], int],
 25: )-> Tuple[csr_array, np.ndarray]: 
 26:     rr, cc = noisy_conn.nonzero()
 27:     noise = rng.normal(loc=0, scale=sigma_e[rr, cc]) # type: ignore
 28:     noisy_conn.data = np.maximum(0., noisy_conn.data + noise).astype(int)
 29:     ### perform simple post-processing:
 30:     #   We have to release k anyway, so we set all block sizes to k_val.
 31:     #   This allows us to put strict bounds on the connectivity matrix.
 32:     for r, c in zip(rr, cc):
 33:         n_noisy[r] = k_val # type: ignore
 34:         n_noisy[c] = k_val # type: ignore
 35:         # ensure no negative counts
 36:         if noisy_conn[r, c] < 0: # type: ignore
 37:             noisy_conn[r, c] = 0 # type: ignore
 38:             continue
 39:         # ensure no noisy_conn-count is larger than the max possible
 40:         N = n_possible_fn(n_noisy[r], n_noisy[c], same_block=(r == c)) # type: ignore
 41:         if noisy_conn[r, c] > N: # type: ignore
 42:             noisy_conn[r, c] = N # type: ignore
 43:             continue
 44:         # round conn to int
 45:         noisy_conn[r, c] = np.round(noisy_conn[r, c]) # type: ignore
 46:     ### add noise to zero pairs
 47:     noisy_conn_lil = noisy_conn.tolil()
 48:     B = len(n_noisy)
 49:     total_zero_pair_edges = 0
 50:     for r in range(B):
 51:         present = set(noisy_conn_lil.rows[r])
 52:         for s in range(r, B):
 53:             # only add noise to zero pairs
 54:             if s in present:
 55:                 continue
 56:             N_rs = n_possible_fn(k_val, k_val, r == s)  # type: ignore
 57:             z = rng.normal(0, sigma_zero_fun(N_rs))  # noise for zero pair (r,s)
 58:             if z < round_thresh:  # round_thresh
 59:                 continue  # remain zero
 60:             m_rs = int(round(z))  # symmetric, non-negative
 61:             m_rs = min(m_rs, N_rs)
 62:             if m_rs > 0:
 63:                 total_zero_pair_edges += m_rs
 64:                 noisy_conn_lil[r, s] = m_rs # type: ignore
 65:                 if r != s:
 66:                     noisy_conn_lil[s, r] = m_rs # type: ignore
 67:     print(f"[NAIVE]    Added {total_zero_pair_edges} edges to zero pairs.") 
 68:     # ---------- finish   ------------------------------------------
 69:     conn_csr = csr_array(noisy_conn_lil, dtype=int)
 70:     conn_sym = sp.triu(conn_csr, k=0, format='csr')
 71:     conn_sym = conn_sym + conn_sym.T - sp.diags(conn_sym.diagonal())
 72:     conn_sym.data = conn_sym.data.astype(int)
 73:     noisy_conn = csr_array(conn_sym, dtype=int)
 74:     return noisy_conn, n_noisy
 75: # ------------------------------------------------------------------
 76: # utility functions for Lasso post-processing
 77: def lambda_for_activation(rho: float) -> float:
 78:     """λ so that exactly rho of zero cells survive the threshold."""
 79:     lam = norm.isf(rho / 2.0) # two-sided tail
 80:     return float(lam)
 81: # ------------------------------------------------------------------
 82: def constrained_lasso(
 83:     n_noisy: np.ndarray,
 84:     noisy_conn: sp.csr_array,
 85:     sigma_rs: sp.csr_array,
 86:     k_val: int,
 87:     sigma_zero_fun: Callable[[int], float],
 88:     rng: np.random.Generator,
 89:     *,
 90:     round_thresh: float = 0.5,
 91:     lam: Optional[float] = None,
 92:     n_possible_fn: Callable[[int, int, bool], int],
 93: ) -> Tuple[sp.csr_array, np.ndarray]:
 94:     """
 95:     L1-constrained projection row-by-row.
 96:     Parameters
 97:     ----------
 98:     conn_ut        : noisy counts, CSR, **upper triangle only**.
 99:     sigma_rs       : matching σ_rs for the same nnz pattern.
100:     k_val          : released block size k (all blocks are k or k+1).
101:     sigma_zero_fun : N_rs ↦ σ for a zero entry (uses new weight scheme).
102:     rng            : np.random.Generator.
103:     round_thresh   : magnitude that rounds to 1 (default .5).
104:     lam            : λ in soft-threshold  x ← sign(x)·max(|x|−λσ²,0).
105:     n_possible_fn  : callable (k_r,k_s,r==s) → N_rs.
106:     """
107:     B = noisy_conn.shape[0]
108:     noisy_conn_lil = noisy_conn.tolil(copy=True)          # efficient insertion
109:     sigma = sigma_rs.tolil(copy=False)
110:     if lam is None:
111:         # compute lambda based on desired proportion of active block pairs
112:         # assume that the average block connects to 5 others
113:         rho = .1 #5 * B / (B * (B - 1)/2)  
114:         lam = lambda_for_activation(rho)  # default λ for 5% of zero pairs
115:     total_added = 0
116:     for r in range(B):
117:         ### set block sizes to k_val
118:         #   We have to release k anyway, so we set all block sizes to k_val.
119:         #   This allows us to put strict bounds on the connectivity matrix.
120:         n_noisy[r] = k_val
121:         # check where non-zero counts
122:         present = {c: i for i, c in enumerate(noisy_conn_lil.rows[r])}
123:         # ---------- a) process existing nnz ------------------------
124:         for idx, c in enumerate(noisy_conn_lil.rows[r]):
125:             # account for upper-triangle only
126:             if c < r:
127:                 continue
128:             val   = noisy_conn_lil.data[r][idx]
129:             sig   = float(sigma[r, c]) # type: ignore
130:             # lasso regression with soft thresholding and clamping
131:             N_rs  = n_possible_fn(k_val, k_val, r == c)
132:             lasso_shrink = np.sign(val) * max(abs(val) - lam * sig, 0)
133:             new   = min(max(round(lasso_shrink), 0), N_rs)
134:             noisy_conn_lil.data[r][idx] = int(new)
135:         # ---------- b) add noise to zero cells (upper-tri only) ----
136:         for s in range(r, B):
137:             if s in present or s < r:                 # already processed nnz
138:                 continue
139:             N_rs = n_possible_fn(k_val, k_val, r == s)
140:             sig0 = sigma_zero_fun(N_rs)
141:             z = rng.normal(0.0, sig0)
142:             if abs(z) < round_thresh:
143:                 continue
144:             # lasso regression with soft thresholding
145:             lasso_shrink = np.sign(z) * max(abs(z) - lam * sig0, 0)
146:             m = min(round(lasso_shrink), N_rs)
147:             if m <=0:
148:                 continue
149:             noisy_conn_lil[r, s] = m
150:             if r != s:
151:                 noisy_conn_lil[s, r] = m
152:             total_added += m
153:     # ---------- finish   ------------------------------------------
154:     conn_csr = csr_array(noisy_conn_lil, dtype=int)
155:     conn_sym = sp.triu(conn_csr, k=0, format='csr')
156:     conn_sym = conn_sym + conn_sym.T - sp.diags(conn_sym.diagonal())
157:     conn_sym.data = conn_sym.data.astype(int)
158:     print(f"[LASSO]    Added {total_added} edges to previously-zero pairs")
159:     return conn_sym, n_noisy

================
File: src/sbm/stopping_criteria.py
================
 1: """ 
 2: Stopping criteria for the MCMC algorithm in the Stochastic Block Model (SBM).
 3: """
 4: class StoppingCriteria:
 5:     """
 6:     Base class for stopping criteria in the MCMC algorithm.
 7:     """
 8:     def __init__(self, stopping_configs: dict):
 9:         pass
10:     def should_stop(self, iteration: int, current_ll: float) -> bool:
11:         """
12:         Check if the stopping criteria are met.
13:         :param iteration: Current iteration number.
14:         :param current_ll: Current log-likelihood value.
15:         :return: True if the algorithm should stop, False otherwise.
16:         """
17:         raise NotImplementedError("Subclasses should implement this method.")

================
File: src/tests/dp/test_noise.py
================
  1: # ---------------------------------------------------------------------
  2: # tests/test_dp_noise.py
  3: # ---------------------------------------------------------------------
  4: import numpy as np
  5: import scipy.sparse as sp
  6: import pytest
  7: from sbm.io import SBMFit
  8: from sbm.noisy_fit import (
  9:     create_sbm_noise,
 10:     HeterogeneousGaussNoise,
 11:     NaiveDegreeGaussNoise,
 12:     NaiveEdgeCountGaussNoise,
 13: )
 14: from sbm.sampling import sample_sbm_graph_from_fit
 15: # ---------------------------------------------------------------------
 16: # helpers
 17: # ---------------------------------------------------------------------
 18: def _make_sbm(block_sizes, P):
 19:     """
 20:     Create an SBMFit with integer edge counts according to prob-matrix P.
 21:     P must be square len(block_sizes) × len(block_sizes), symmetric.
 22:     """
 23:     k_vec = np.array(block_sizes, int)
 24:     B = len(k_vec)
 25:     data, rows, cols = [], [], []
 26:     for r in range(B):
 27:         for s in range(r, B):
 28:             N = k_vec[r] * k_vec[s] if r != s else k_vec[r] * (k_vec[r] - 1) // 2
 29:             m = int(round(P[r, s] * N))
 30:             if m > 0:
 31:                 rows.append(r); cols.append(s); data.append(m)
 32:     M = sp.csr_array((data, (rows, cols)), shape=(B, B))
 33:     M = M + M.T - sp.diags(M.diagonal())
 34:     return SBMFit(
 35:         block_sizes=list(block_sizes),
 36:         block_conn=M,
 37:         directed_graph=False,
 38:         neg_loglike=-1.0,
 39:         metadata={},
 40:     )
 41: def _extract_sigma_e(noise_obj):
 42:     """Return 1-D array of σ_e values stored (heterogeneous variant)."""
 43:     if isinstance(noise_obj, HeterogeneousGaussNoise):
 44:         return noise_obj.sigma_e.data
 45:     raise ValueError
 46: # ---------------------------------------------------------------------
 47: # parametrisation -----------------------------------------------------
 48: EPS, DELTA, ALPHA = 1.0, 1e-6, 0.999
 49: RNG = np.random.default_rng(0)
 50: # ---------------------------------------------------------------------
 51: # 1. factory returns correct subclass ---------------------------------
 52: @pytest.mark.parametrize("ntype,cls", [
 53:     ("heterogeneous_gaussian",       HeterogeneousGaussNoise),
 54:     ("naive_degree_gaussian",  NaiveDegreeGaussNoise),
 55:     ("naive_edge_count_gaussian", NaiveEdgeCountGaussNoise),
 56: ])
 57: def test_factory_returns(ntype, cls):
 58:     sbm = _make_sbm([3, 3], np.zeros((2, 2)))
 59:     nz = create_sbm_noise(sbm, EPS, DELTA, ALPHA, noise_type=ntype)
 60:     assert isinstance(nz, cls)
 61: # ---------------------------------------------------------------------
 62: # 2. hetero σ_e differ when p differs ---------------------------------
 63: def test_heterogeneous_noise_varies():
 64:     P = np.array([[0.2, 0.9, 0.05],
 65:                   [0.9, 0.2, 0.05],
 66:                   [0.05,0.05, 0.01]])
 67:     sbm = _make_sbm([3, 3, 3], P)
 68:     oz  = create_sbm_noise(sbm, EPS, DELTA, ALPHA, noise_type="heterogeneous_gaussian")
 69:     sig = _extract_sigma_e(oz)
 70:     assert len(np.unique(sig)) > 1, "σ_e should vary for different p_rs"
 71: # ---------------------------------------------------------------------
 72: # 3. hetero σ_e identical when all p equal ----------------------------
 73: def test_heterogeneous_noise_equal():
 74:     P = np.full((3, 3), 0.3)
 75:     sbm = _make_sbm([3, 3, 3], P)
 76:     oz  = create_sbm_noise(sbm, EPS, DELTA, ALPHA,
 77:                            noise_type="heterogeneous_gaussian")
 78:     sig = _extract_sigma_e(oz)
 79:     print(f'sigma_e: {sig}')
 80:     diag = sig[[0, 4, 8]]  # diagonal σ’s
 81:     # diagonal σ’s should all be identical.
 82:     # Account for the fact that only upper-tri is stored.
 83:     assert np.allclose(diag, diag[0])
 84:     # … off-diagonals identical to each other …
 85:     off  = sig[[1, 2, 5]]
 86:     assert np.allclose(off, off[0])
 87:     # … but OFF ≠ DIAG because N_rr ≠ N_rs
 88:     assert not np.allclose(diag[0], off[0])
 89: # ---------------------------------------------------------------------
 90: # 4. naive σ scalars are equal for every coord ------------------------
 91: @pytest.mark.parametrize("ntype", ["naive_degree_gaussian",
 92:                                    "naive_edge_count_gaussian"])
 93: def test_naive_sigma_equal(ntype):
 94:     P = np.array([[0.4, 0.4],
 95:                   [0.4, 0.4]])
 96:     sbm = _make_sbm([4, 4], P)
 97:     nz  = create_sbm_noise(sbm, EPS, DELTA, ALPHA, noise_type=ntype)
 98:     assert np.all(nz.sigma_n == nz.sigma_n[0])
 99:     assert nz.sigma_n_scalar == nz.sigma_e_scalar # type: ignore
100: # ---------------------------------------------------------------------
101: # 5. zero & one probabilities handled (no inf / NaN) ------------------
102: @pytest.mark.parametrize("pdiag,poff", [(0.0, 0.0), (1.0, 0.0),
103:                                         (0.0, 1.0), (1.0, 1.0)])
104: def test_zero_one_probabilities(pdiag, poff):
105:     P = np.array([[pdiag, poff],
106:                   [poff,  pdiag]])
107:     sbm = _make_sbm([3, 3], P)
108:     nz  = create_sbm_noise(sbm, EPS, DELTA, ALPHA,
109:                            noise_type="heterogeneous_gaussian")
110:     assert not np.isnan(nz.sigma_n).any(), \
111:         f'sigma_n should not contain NaN, got {nz.sigma_n}'
112:     sig = _extract_sigma_e(nz)
113:     assert not np.isnan(sig).any() and not np.isinf(sig).any(),\
114:         f'sigma_e should not contain NaN or inf, got {sig}'
115: # ---------------------------------------------------------------------
116: # 6. big blocks memory usage (no excessive RAM) -----------------------
117: def test_big_blocks_memory():
118:     B = 300
119:     k = 3
120:     sizes = [k] * B
121:     P = np.full((B, B), 0.1)
122:     np.fill_diagonal(P, 0.2)
123:     sbm = _make_sbm(sizes, P)          # builds sparse counts
124:     nz = create_sbm_noise(sbm, 1.0, 1e-6, 0.999,
125:                           noise_type="heterogeneous_gaussian"
126:                           )
127:     # should finish < 1 s and < 200 MB RAM
128: # ---------------------------------------------------------------------
129: # 7. sampling integrity (no counts exceed max possible) ---------------
130: def test_sample_integrity():
131:     P = np.array([[0.8, 0.3],
132:                   [0.3, 0.05]])
133:     sbm   = _make_sbm([10, 20], P)
134:     noise = create_sbm_noise(sbm, EPS, DELTA, ALPHA,
135:                              noise_type="heterogeneous_gaussian")
136:     sbm_noisy = noise.sample_sbm_fit(RNG)
137:     # check sizes positive
138:     assert min(sbm_noisy.block_sizes) >= 1
139:     # check counts ≤ possible
140:     k = sbm_noisy.block_sizes
141:     conn = sbm_noisy.block_conn
142:     rr, cc = conn.nonzero()
143:     for r, c in zip(rr, cc):
144:         N = k[r] * k[c] if r != c else k[r] * (k[r]-1) // 2
145:         assert conn[r, c] <= N
146:     # can we sample a surrogate graph?
147:     g = sample_sbm_graph_from_fit(sbm_noisy, RNG)
148:     assert g.adjacency.shape[0] == sum(k)
149:     # undirected check
150:     assert (g.adjacency != g.adjacency.T).nnz == 0

================
File: src/tests/dp/test_post_processing.py
================
  1: """
  2: Unit‑tests for sbm.post_process.constrained_lasso
  3: ------------------------------------------------
  4: The tests focus exclusively on the *post‑processing* step and therefore
  5: construct tiny synthetic inputs instead of going through the full
  6: `HeterogeneousGaussNoise.sample_sbm_fit` pipeline.
  7: The invariants we check are:
  8:   1. No negative edge counts are returned.
  9:   2. All counts are *integers* and *symmetric* (upper‑triangle mirrored).
 10:   3. Every count is <= the maximum possible edges
 11:      N_rs = k_r*k_s for r≠s,  k_r*(k_r−1)/2 for r=s,  where every k_r == k_val.
 12:   4. The routine overwrites all released block sizes with `k_val`.
 13: Two deterministic corner‑case tests are followed by a stochastic
 14: property test that runs 50 random scenarios; this should still complete
 15: in well under 100 ms.
 16: """
 17: import numpy as np
 18: import scipy.sparse as sp
 19: import pytest
 20: # ---------------------------------------------------------------------
 21: # system under test
 22: # ---------------------------------------------------------------------
 23: from sbm.post_process import constrained_lasso
 24: from sbm.noisy_fit import n_possible  # helper already used by the library
 25: # ---------------------------------------------------------------------
 26: # helpers
 27: # ---------------------------------------------------------------------
 28: def _csr_symmetric_from_dense(mat: np.ndarray) -> sp.csr_array:
 29:     """Return *exactly* the upper‑triangle incl. diagonal as CSR."""
 30:     r, c = np.triu_indices(mat.shape[0])
 31:     data = mat[r, c]
 32:     nz_mask = data != 0
 33:     return sp.csr_array((data[nz_mask], (r[nz_mask], c[nz_mask])), shape=mat.shape)
 34: def _make_sigma_rs(pattern: sp.csr_array, *, sigma: float = 1.0) -> sp.csr_array:
 35:     """Return a symmetric σ matrix that shares *pattern*'s sparsity."""
 36:     return sp.csr_array((np.full_like(pattern.data, sigma, dtype=float), pattern.indices, pattern.indptr), shape=pattern.shape)
 37: RNG = np.random.default_rng(0)
 38: SIGMA_ZERO = lambda N: 1.0  # simple constant σ for zero pairs
 39: # ---------------------------------------------------------------------
 40: # 1. deterministic corner‑cases
 41: # ---------------------------------------------------------------------
 42: def test_negative_and_too_large_values_are_clamped():
 43:     """Negative counts become zero; overly large counts are capped at N_rs."""
 44:     k_val = 3
 45:     B = 2
 46:     # construct noisy_conn with impossible values
 47:     dense = np.array([
 48:         [ -2, 10],   # −2 on diagonal 0, 10 off‑diag
 49:         [  0,  5]    # 5 on diag 1 (will be ignored, only upper‑tri processed)
 50:     ], dtype=float)
 51:     noisy_conn = _csr_symmetric_from_dense(dense)
 52:     sigma_rs   = _make_sigma_rs(noisy_conn, sigma=0.5)  # arbitrary σ
 53:     n_noisy    = np.array([k_val, k_val]) + 1  # wrong on purpose
 54:     conn_out, n_out = constrained_lasso(
 55:         n_noisy=n_noisy,
 56:         noisy_conn=noisy_conn,
 57:         sigma_rs=sigma_rs,
 58:         k_val=k_val,
 59:         sigma_zero_fun=SIGMA_ZERO,
 60:         rng=RNG,
 61:         lam=1.0,
 62:         n_possible_fn=n_possible,
 63:     )
 64:     conn_dense = conn_out.toarray()
 65:     # invariants ------------------------------------------------------
 66:     assert (conn_dense >= 0).all()
 67:     assert np.issubdtype(conn_dense.dtype, np.integer)
 68:     # diag 0: max possible = 3*2/2 = 3 ; off‑diag: 3*3 = 9
 69:     assert conn_dense[0, 0] <= 3
 70:     assert conn_dense[0, 1] <= 9
 71:     # symmetry
 72:     assert conn_dense[0, 1] == conn_dense[1, 0]
 73:     # block sizes all set to k_val
 74:     assert (n_out == k_val).all()
 75: def test_zero_matrix_remains_valid():
 76:     """All‑zero input should stay zero (aside from possible added edges)."""
 77:     k_val = 4
 78:     B = 3
 79:     noisy_conn = sp.csr_array((B, B), dtype=float)
 80:     sigma_rs   = sp.csr_array((B, B), dtype=float)
 81:     n_noisy    = np.ones(B, dtype=int) * k_val
 82:     conn_out, _ = constrained_lasso(
 83:         n_noisy=n_noisy,
 84:         noisy_conn=noisy_conn,
 85:         sigma_rs=sigma_rs,
 86:         k_val=k_val,
 87:         sigma_zero_fun=SIGMA_ZERO,
 88:         rng=RNG,
 89:         lam=0.0,          # turn off shrinkage so only zero‑pair addition matters
 90:         round_thresh=10**10,  # large threshold ⇒ keep zeros
 91:         n_possible_fn=n_possible,
 92:     )
 93:     print(noisy_conn.toarray())
 94:     print(conn_out.toarray())
 95:     assert conn_out.nnz == 0, "No edges should be added when threshold is huge"
 96:     assert conn_out.shape == (B, B)
 97: # ---------------------------------------------------------------------
 98: # 2. stochastic property test
 99: # ---------------------------------------------------------------------
100: @pytest.mark.parametrize("seed", range(50))
101: def test_randomised_invariants(seed: int):
102:     """For many random inputs the core invariants must always hold."""
103:     rng = np.random.default_rng(seed)
104:     B      = rng.integers(2, 6)            # 2 ≤ B ≤ 5
105:     k_val  = int(rng.integers(2, 6))       # 2 ≤ k ≤ 5
106:     # generate random noisy counts in [‑5, 2*N_rs]
107:     dense  = np.zeros((B, B), dtype=float)
108:     for r in range(B):
109:         for s in range(r, B):
110:             N_rs = n_possible(k_val, k_val, r == s)
111:             dense[r, s] = rng.integers(-5, 2*N_rs + 1)
112:     noisy_conn = _csr_symmetric_from_dense(dense)
113:     sigma_rs   = _make_sigma_rs(noisy_conn, sigma=1.0)
114:     n_noisy    = rng.integers(1, k_val + 3, size=B)  # arbitrary wrong values
115:     conn_out, n_out = constrained_lasso(
116:         n_noisy=n_noisy,
117:         noisy_conn=noisy_conn,
118:         sigma_rs=sigma_rs,
119:         k_val=k_val,
120:         sigma_zero_fun=SIGMA_ZERO,
121:         rng=rng,
122:         lam=1.0,
123:         n_possible_fn=n_possible,
124:     )
125:     # ----- checks ----------------------------------------------------
126:     conn_dense = conn_out.toarray()
127:     assert (conn_dense >= 0).all(), "negative counts returned"
128:     assert np.issubdtype(conn_dense.dtype, np.integer), "counts not integer"
129:     assert np.allclose(conn_dense, conn_dense.T), "matrix not symmetric"
130:     for r in range(B):
131:         for s in range(r, B):
132:             N_rs = n_possible(k_val, k_val, r == s)
133:             assert conn_dense[r, s] <= N_rs, "count exceeds N_rs"
134:     # every block size released as k
135:     assert (n_out == k_val).all()

================
File: src/tests/mcmc/likelihood_test.py
================
  1: # tests/test_likelihood.py
  2: """
  3: End-to-end tests for the Bernoulli likelihood calculators.
  4:  * We create a tiny 4-node undirected graph with two blocks.
  5:  * We compare every Δℓ returned by the incremental code against the
  6:    ground-truth global likelihood difference.
  7: """
  8: from __future__ import annotations
  9: from collections import Counter
 10: from typing import Tuple, Dict
 11: import numpy as np
 12: #np.float_ = np.float64  # ensure float64 is used
 13: import pytest
 14: from scipy.sparse import csr_array
 15: from sbm.likelihood import (
 16:     compute_global_bernoulli_ll,
 17:     LikelihoodCalculator
 18: )
 19: from sbm.block_data import BlockData
 20: from sbm.graph_data import GraphData
 21: from sbm.block_change_proposers import NodeSwapProposer 
 22: ##############################################################################
 23: # Fixtures
 24: ##############################################################################
 25: @pytest.fixture(scope="module")
 26: def four_node_example() -> Tuple[BlockData, GraphData, Dict[int, int]]:
 27:     """
 28:     Graph:
 29:         0──1   Block 0: {0,1}      Edges: (0,1)
 30:         │  │   Block 1: {2,3}              (2,3)
 31:         2──3                              (0,2) (1,3)
 32:     The matrix is symmetrical (undirected, no loops).
 33:     """
 34:     adj = np.zeros((4, 4), dtype=int)
 35:     edges = [(0, 1), (2, 3), (0, 2), (1, 3)]
 36:     for u, v in edges:
 37:         adj[u, v] = 1
 38:         adj[v, u] = 1  # symmetric
 39:     adjacency = csr_array(adj)
 40:     blocks = {0: 0, 1: 0, 2: 1, 3: 1}  # Node to block mapping
 41:     graph_data: GraphData = GraphData(adjacency_matrix=adjacency, directed=False)
 42:     return BlockData(graph_data=graph_data, initial_blocks=blocks), graph_data, blocks
 43: ##############################################################################
 44: # Tests
 45: ##############################################################################
 46: def test_edge_counter(four_node_example):
 47:     """`_compute_edge_counts_between_node_and_blocks` returns correct counts."""
 48:     block_data, *_ = four_node_example
 49:     change_proposer = NodeSwapProposer(block_data)
 50:     counts = change_proposer._compute_edge_counts_between_node_and_blocks(node=0)
 51:     # Node 0 is linked to node-1 (block-0) and node-2 (block-1) → {0:1, 1:1}
 52:     assert counts == Counter({0: 1, 1: 1})
 53: def test_swap_same_block_zero_delta(four_node_example):
 54:     """
 55:     Swapping two nodes that are *already* in the same block must leave the
 56:     likelihood unchanged.
 57:     """
 58:     block_data, *_ = four_node_example
 59:     swap_proposer = NodeSwapProposer(block_data)
 60:     calc = LikelihoodCalculator(block_data)
 61:     # attempt to swap nodes 0 and 2
 62:     swap = [(0, block_data.blocks[1]), (1, block_data.blocks[0])]
 63:     swap, delta_e, delta_n = swap_proposer.propose_change(swap)
 64:     delta = calc.compute_delta_nll(delta_e=delta_e, delta_n=delta_n)
 65:     assert delta == pytest.approx(0.0, abs=1e-6)
 66: def test_delta_ll_matches_global_recompute(four_node_example):
 67:     """
 68:     delta ll from the incremental calculator must equal the brute-force recomputed
 69:     likelihood difference after the swap (0 ↔ 2).
 70:     """
 71:     block_data_old, graph_data, blocks_old = four_node_example
 72:     adjacency = graph_data.adjacency
 73:     swap_proposer = NodeSwapProposer(block_data_old)
 74:     calc = LikelihoodCalculator(block_data_old)
 75:     # ---------- perform swap 0 ↔ 2 -----------------------------------------
 76:     blocks_new = blocks_old.copy()
 77:     blocks_new[0], blocks_new[2] = blocks_new[2], blocks_new[0]
 78:     block_data_new = BlockData(
 79:         graph_data=GraphData(adjacency_matrix=adjacency, directed=False),
 80:         initial_blocks=blocks_new
 81:     )
 82:     ll_old = compute_global_bernoulli_ll(block_data_old)
 83:     ll_new = compute_global_bernoulli_ll(block_data_new)
 84:     expected_delta = ll_new - ll_old
 85:     swap = [(0, block_data_old.blocks[2]), (2, block_data_old.blocks[0])]
 86:     swap, delta_e, delta_n = swap_proposer.propose_change(swap)
 87:     delta_calc = calc.compute_delta_nll(delta_e=delta_e, delta_n=delta_n)
 88:     msg = (
 89:         f"Failed on swap (0 ↔ 2) with blocks {blocks_old} → {blocks_new}\n"
 90:         f"delta_e: {delta_e}\n"
 91:     )
 92:     assert delta_calc == pytest.approx(expected_delta, rel=1e-6, abs=1e-6), msg
 93: def test_delta_edge_counts_consistency(four_node_example):
 94:     """
 95:     The raw `delta_e` returned by `_compute_delta_edge_counts_swap` should turn
 96:     the old connectivity into the new one *exactly* on every affected (r,s).
 97:     """
 98:     block_data_old, graph_data, blocks_old = four_node_example
 99:     adjacency = graph_data.adjacency
100:     swap_proposer = NodeSwapProposer(block_data_old)
101:     calc = LikelihoodCalculator(block_data_old)
102:     i, j = 0, 2  # the same swap as above
103:     proposed_changes = [(i, block_data_old.blocks[j]), (j, block_data_old.blocks[i])]
104:     delta_e = swap_proposer._compute_delta_edge_counts(
105:         proposed_changes= proposed_changes
106:     )
107:     conn_expected = block_data_old.block_connectivity.copy()
108:     for (r, s), de in delta_e.items():
109:         conn_expected[r, s] += de
110:     # Ground-truth connectivity after the swap
111:     blocks_new = blocks_old.copy()
112:     blocks_new[i], blocks_new[j] = blocks_new[j], blocks_new[i]
113:     block_data_new = BlockData(
114:         graph_data=GraphData(adjacency_matrix=adjacency, directed=False),
115:         initial_blocks=blocks_new
116:     )
117:     for (r, s), de in delta_e.items():
118:         assert (
119:             conn_expected[r, s] == block_data_new.block_connectivity[r, s]
120:         ), f"Mismatch on block pair ({r},{s})"
121: ###################################################
122: ### Randomized tests
123: ###################################################
124: def _er_graph_csr(n: int, p: float, *, seed: int) -> csr_array:
125:     """Undirected G(n,p) without self-loops, returned as CSR matrix."""
126:     rng = np.random.default_rng(seed)
127:     upper = rng.random((n, n)) < p                           # boolean mask
128:     upper = np.triu(upper, k=1)                              # keep strict upper
129:     adj = upper | upper.T                                    # symmetrise
130:     return csr_array(adj.astype(np.int8))
131: def _random_equal_blocks(n: int, block_size: int, *, seed: int) -> dict[int, int]:
132:     """Random permutation of vertices into equal-size blocks."""
133:     rng = np.random.default_rng(seed)
134:     perm = rng.permutation(n)
135:     blocks: dict[int, int] = {}
136:     for b in range(n // block_size):
137:         for v in perm[b * block_size : (b + 1) * block_size]:
138:             blocks[v] = b
139:     return blocks
140: def _pick_two_different_blocks(rng: np.random.Generator, blocks: dict[int, int]):
141:     n = len(blocks)
142:     i = rng.choice(n, size=1)[0]
143:     j = rng.choice(n-1, size=1)[0]
144:     if j >= i:
145:         j += 1
146:     return i, j
147: def _single_swap_calc_vs_bruteforce(
148:     graph_data: GraphData,
149:     blocks: dict[int, int],
150:     rng: np.random.Generator,
151:     tol: float = 1e-6,
152:     experiment_index: int = 0
153: ):
154:     """One random swap and check incremental delta ll against brute force."""
155:     # choose vertices in different blocks
156:     i, j = _pick_two_different_blocks(rng, blocks)
157:     # incremental path -------------------------------------------------
158:     block_data = BlockData(graph_data=graph_data, initial_blocks=blocks)
159:     print(block_data.blocks)
160:     swap_proposer = NodeSwapProposer(block_data)
161:     calc = LikelihoodCalculator(block_data)
162:     swap_instr = [(i, blocks[j]), (j, blocks[i])]
163:     _, delta_e, delta_n = swap_proposer.propose_change(swap_instr)
164:     delta_ll = calc.compute_delta_nll(delta_e=delta_e, delta_n=delta_n)
165:     # brute-force path -------------------------------------------------
166:     nll_before = -compute_global_bernoulli_ll(block_data)
167:     new_blocks = blocks.copy()
168:     new_blocks[i], new_blocks[j] = new_blocks[j], new_blocks[i]
169:     block_data_after = BlockData(graph_data=graph_data, initial_blocks=new_blocks)
170:     nll_after = -compute_global_bernoulli_ll(block_data_after)
171:     delta_brute = nll_after - nll_before
172:     # compute the delta_e in the brute-force way
173:     # only storing non-zero deltas in upper triangular matrix
174:     delta_e_brute = block_data_after.block_connectivity - block_data.block_connectivity
175:     delta_e_brute = {
176:         (r, s): de for (r, s), de in zip(
177:             np.argwhere(delta_e_brute != 0),
178:             delta_e_brute[delta_e_brute != 0]
179:         )
180:         if r <= s
181:     }
182:     # comparison and print informatino in case of failure
183:     msg = (
184:         f"Failed on experiment {experiment_index}"
185:         f"\nGraph: {graph_data.adjacency.toarray()}"
186:         f"\nBlocks: {blocks}"
187:         f"\nswap:         {i} <-> {j} (blocks {blocks[i]} <-> {blocks[j]})"
188:         f"\ndelta_e:   {delta_e}"
189:         f"\ndelta_e_brute:   {delta_e_brute}"
190:         f"\ndelta_inc:    {delta_ll:.12g}"
191:         f"\ndelta_brute:  {delta_brute:.12g}"
192:     )
193:     assert delta_ll == pytest.approx(delta_brute, rel=tol, abs=tol), msg
194: def test_delta_ll_random_swaps_er():
195:     """100 random swaps on independent ER-20 graph must all match brute force delta ll."""
196:     for index in range(100):
197:         n, p, b = 20, 0.1, 2
198:         rng = np.random.default_rng(1)
199:         adj = _er_graph_csr(n, p, seed=42)
200:         graph = GraphData(adjacency_matrix=adj, directed=False)
201:         blocks = _random_equal_blocks(n, block_size=b, seed=2)
202:         _single_swap_calc_vs_bruteforce(graph_data=graph,
203:                                         blocks=blocks,
204:                                         rng=rng,
205:                                         experiment_index=index,
206:                                         tol=1e-6
207:                                         )

================
File: src/tests/mcmc/planted_partition_tests.py
================
 1: # src/tests/test_regressions.py
 2: """
 3: Targeted regression tests for issues uncovered in the planted‐partition script.
 4: * size-1 blocks must not crash likelihood computation
 5: * Δ-dicts must use *matrix indices*, not block-IDs
 6: """
 7: import numpy as np
 8: import pytest
 9: from scipy.sparse import csr_array
10: from sbm.block_data import BlockData
11: from sbm.likelihood import compute_global_bernoulli_ll
12: from sbm.block_change_proposers import NodeSwapProposer
13: from sbm.block_data import BlockData
14: from sbm.graph_data import GraphData
15: # -------------------------------------------------------------------
16: # 1. size-1 diagonal must be ignored (or handled gracefully)
17: # -------------------------------------------------------------------
18: @pytest.mark.parametrize("singletons", [1, 3])
19: def test_singleton_blocks_allowed(singletons):
20:     """
21:     A partition containing blocks of size 1 must not raise or return NaN.
22:     """
23:     n = 6
24:     # make a path graph (any sparse graph works)
25:     rows = np.arange(n-1)
26:     cols = rows + 1
27:     data = np.ones(n-1, dtype=int)
28:     A = csr_array((data, (rows, cols)), shape=(n, n))
29:     A = A + A.T
30:     # put the first `singletons` nodes into their own blocks
31:     blocks = {v: v if v < singletons else singletons for v in range(n)}
32:     bd = BlockData(
33:         initial_blocks=blocks,
34:         graph_data=GraphData(adjacency_matrix=A, directed=False)
35:     )
36:     ll = compute_global_bernoulli_ll(bd)
37:     assert np.isfinite(ll), "likelihood should be finite even with size-1 blocks"
38: # -------------------------------------------------------------------
39: # 2. Δ-dicts must reference matrix indices, not block-IDs
40: # -------------------------------------------------------------------
41: def test_delta_keys_are_matrix_indices():
42:     """
43:     When block IDs are non-contiguous (e.g. {0,10}), the delta_e keys
44:     must still be *matrix indices* (0 or 1), otherwise the likelihood
45:     updater crashes with an IndexError.
46:     """
47:     # two blocks with ids 0 and 10, one edge across
48:     adj = csr_array([[0,1],[1,0]])
49:     blocks = {0: 0, 1: 10}
50:     bd = BlockData(
51:         initial_blocks=blocks,
52:         graph_data=GraphData(adjacency_matrix=adj, directed=False)
53:     )
54:     proposer = NodeSwapProposer(bd)
55:     swap = [(0, 10)]  # move node 0 to block 10 -> will create a singleton & trigger Δ
56:     _, delta_e, _ = proposer.propose_change(swap)
57:     # the only valid matrix indices are 0 and 1
58:     valid = {0,1}
59:     for (r, s) in delta_e:
60:         assert r in valid and s in valid, (
61:             "delta_e must use matrix indices (0..B-1), "
62:             "not raw block IDs"
63:         )

================
File: src/tests/mcmc/test_block_assigner.py
================
  1: """PyTest suites for structural block‑model code.
  2: These unit tests focus on two invariants that *must* hold for the current
  3: pipeline:
  4: 1. **MetisBlockAssigner should only emit blocks whose sizes are either
  5:    `min_block_size` or `min_block_size + 1`.**  (Because the assigner first
  6:    builds blocks of exactly `min_block_size` vertices and then distributes any
  7:    leftovers one‑by‑one.)
  8: 2. **A SWAP move in the MCMC sampler must leave every block size unchanged.**
  9: The tests rely only on public APIs plus `_attempt_move`, which is part of the
 10: MCMC sampler’s stable interface (it is used by `fit` internally).  If the
 11: names or module paths differ in your codebase, tweak the imports at the top of
 12: each file – the assertions themselves should stay valid.
 13: Run with::
 14:     pytest -q tests/
 15: """
 16: # ──────────────────────────────────────────────────────────────────────────────
 17: # tests/test_block_assigner.py
 18: # ──────────────────────────────────────────────────────────────────────────────
 19: import networkx as nx
 20: import numpy as np
 21: import pytest
 22: # Adjust the import path to wherever MetisBlockAssigner lives in your project
 23: from sbm.block_assigner import MetisBlockAssigner
 24: from sbm.block_assigner import ProNEAndConstrKMeansAssigner
 25: from sbm.graph_data import gd_from_networkx
 26: @pytest.mark.parametrize(
 27:     "num_nodes,num_blocks,min_block_size,edge_p",
 28:     [
 29:         (97, 10, 8, 0.05),
 30:         (50, 5, 6, 0.10),
 31:         (23, 4, 5, 0.30),
 32:         (128, 16, 7, 0.02),
 33:     ],
 34: )
 35: def test_metis_block_sizes_are_balanced(num_nodes, num_blocks, min_block_size, edge_p):
 36:     """The initial partition must use only *min* and *min+1* sized blocks."""
 37:     G = nx.erdos_renyi_graph(
 38:             n=num_nodes,
 39:             p=edge_p,
 40:             seed=1,
 41:             directed=False
 42:         )
 43:     graph_data = gd_from_networkx(G)
 44:     assigner = MetisBlockAssigner(
 45:         graph_data=graph_data,
 46:         num_blocks=num_blocks,
 47:         min_block_size=min_block_size,
 48:         rng=np.random.default_rng(42),
 49:     )
 50:     block_data = assigner.compute_assignment()
 51:     # ensure that block_sizes correspond to 
 52:     # Ensure every vertex received exactly one label
 53:     assert len(block_data.blocks) == num_nodes
 54:     # Compute block‑size histogram
 55:     _, counts = np.unique(
 56:         list(block_data.blocks.values()),
 57:         return_counts=True
 58:         )
 59:     # All block sizes must be either min_block_size or min_block_size+1
 60:     assert (counts >= min_block_size).all(), \
 61:         (
 62:             "MetisBlockAssigner produced illegal block sizes: "
 63:             f"{sorted(set(counts))}. Expected larger than {min_block_size}."
 64:         )
 65:     # The partition must contain exactly *num_blocks* non‑empty blocks.
 66:     assert len(counts) == num_blocks
 67: def test_ProNEKMeans_block_sizes_are_balanced():
 68:     """The ProNEKMeans assigner must also use only *min* and *min+1* sized blocks."""
 69:     num_nodes = 100
 70:     min_block_size = 8
 71:     num_blocks = num_nodes // min_block_size
 72:     edge_p = 0.05
 73:     G = nx.erdos_renyi_graph(
 74:             n=num_nodes,
 75:             p=edge_p,
 76:             seed=1,
 77:             directed=False
 78:         )
 79:     graph_data = gd_from_networkx(G)
 80:     assigner = ProNEAndConstrKMeansAssigner(
 81:         graph_data=graph_data,
 82:         min_block_size=min_block_size,
 83:         rng=np.random.default_rng(42),
 84:     )
 85:     block_data = assigner.compute_assignment()
 86:     # ensure that block_sizes correspond to 
 87:     # Ensure every vertex received exactly one label
 88:     assert len(block_data.blocks) == num_nodes, \
 89:         "ProNEKMeansBlockAssigner did not assign a label to every vertex."
 90:     # ensure that block sizes correspond to the number of blocks
 91:     assert len(block_data.block_sizes) == num_blocks  \
 92:         and len(set(block_data.blocks.values())) == num_blocks, \
 93:         "ProNEKMeansBlockAssigner did not produce the expected number of blocks."
 94:     # Compute block‑size histogram
 95:     _, counts = np.unique(
 96:         list(block_data.blocks.values()),
 97:         return_counts=True
 98:         )
 99:     # All block sizes must be either min_block_size or min_block_size+1
100:     assert (counts >= min_block_size).all(), \
101:         (
102:             "ProNEKMeansBlockAssigner produced illegal block sizes: "
103:             f"{sorted(set(counts))}. Expected larger than {min_block_size}."
104:         )
105:     count_set = set(counts)
106:     # Ensure that the block sizes are either min_block_size or min_block_size + 1
107:     assert count_set.issubset({min_block_size, min_block_size + 1})
108:     # The partition must contain exactly *num_blocks* non‑empty blocks.
109:     assert len(counts) == num_blocks

================
File: src/tests/mcmc/test_change_proposer_and_mover.py
================
  1: # src/tests/test_change_proposers_and_mover.py
  2: """
  3: Unit-tests for
  4:   • sbm.block_change_proposers           (helper + NodeSwapProposer)
  5:   • sbm.node_mover                      (NodeMover)
  6: All graphs are 4 undirected vertices:
  7:     0──1   block 0 = {0,1}
  8:     │  │
  9:     2──3   block 1 = {2,3}
 10: Edges: (0,1) (2,3)  plus two cross edges (0,2) (1,3).
 11: """
 12: from __future__ import annotations
 13: from collections import defaultdict
 14: from typing import Dict, Tuple
 15: import numpy as np
 16: from numpy.typing import ArrayLike
 17: import pytest
 18: from scipy.sparse import csr_array
 19: from sbm.graph_data import GraphData
 20: from sbm.block_data import BlockData
 21: from sbm.block_change_proposers import (
 22:     NodeSwapProposer,
 23:     ProposedValidChanges,
 24:     EdgeBasedSwapProposer,
 25:     TriadicSwapProposer,
 26: )
 27: from sbm.edge_delta import EdgeDelta
 28: from sbm.node_mover import NodeMover
 29: ###############################################################################
 30: # helpers
 31: ###############################################################################
 32: def _toy_graph() -> Tuple[csr_array, Dict[int, int]]:
 33:     """Return 4×4 adjacency and initial {node: block} mapping."""
 34:     adj = np.zeros((4, 4), dtype=int)
 35:     edges = [(0, 1), (2, 3), (0, 2), (1, 3)]
 36:     for u, v in edges:
 37:         adj[u, v] = adj[v, u] = 1
 38:     blocks = {0: 0, 1: 0, 2: 1, 3: 1}
 39:     return csr_array(adj), blocks
 40: def _brute_block_connectivity(adj: csr_array, blocks: Dict[int, int]) -> Dict[Tuple[int, int], int]:
 41:     """Return upper-triangle edge counts between blocks."""
 42:     rows, cols = adj.nonzero() # type: ignore
 43:     bc = defaultdict(int)
 44:     for u, v in zip(rows, cols, strict=False):
 45:         if u >= v:  # count each undirected edge once
 46:             continue
 47:         a, b = blocks[u], blocks[v]
 48:         r, s = (a, b) if a <= b else (b, a)
 49:         bc[(r, s)] += 1
 50:     return bc
 51: ###############################################################################
 52: # tests for _increment_delta_e
 53: ###############################################################################
 54: def test_increment_delta_e_uses_sorted_key() -> None:
 55:     e_delta = EdgeDelta(n_blocks=4)
 56:     e_delta.increment(
 57:         counts=[1],
 58:         blocks_i=[3],
 59:         blocks_j=[1],
 60:     )          # block_i > block_j → key (1,3)
 61:     assert ((1, 3), 1) in e_delta.items() and ((3, 1), 1) not in e_delta.items(), \
 62:         f"Key mismatch: delta keys = {list(e_delta.items())}"
 63: def test_increment_delta_e_overwrites_existing() -> None:
 64:     e_delta = EdgeDelta(n_blocks=4)
 65:     e_delta.increment(
 66:         counts = [1],
 67:         blocks_i = [0],
 68:         blocks_j = [2],
 69:     )          # set to 1
 70:     e_delta.increment(
 71:         counts = [3],
 72:         blocks_i = [2],
 73:         blocks_j = [0]
 74:     )          # overwrite same pair
 75:     assert e_delta[(0, 2)] == 3, \
 76:         f"Value not overwritten, got {e_delta[(0, 2)]}, expected 3"
 77: ###############################################################################
 78: # tests for NodeSwapProposer
 79: ###############################################################################
 80: @pytest.fixture(scope="module")
 81: def proposer() -> NodeSwapProposer:
 82:     adj, blocks = _toy_graph()
 83:     bd = BlockData(initial_blocks=blocks, graph_data=GraphData(adj, directed=False))
 84:     return NodeSwapProposer(block_data=bd, rng=np.random.default_rng(0))
 85: def test_compute_delta_edge_counts_matches_brute(proposer: NodeSwapProposer) -> None:
 86:     # swap vertices 0 (block 0) and 2 (block 1)
 87:     changes: ProposedValidChanges = [(0, 1), (2, 0)]
 88:     delta = proposer._compute_delta_edge_counts(changes)          # type: ignore
 89:     before = _brute_block_connectivity(
 90:         proposer.block_data.graph_data.adjacency,
 91:         proposer.block_data.blocks
 92:     )
 93:     # build new blocks mapping
 94:     new_blocks = proposer.block_data.blocks.copy()
 95:     new_blocks[0], new_blocks[2] = new_blocks[2], new_blocks[0]
 96:     after = _brute_block_connectivity(proposer.block_data.graph_data.adjacency,
 97:                                       new_blocks)
 98:     brute_delta = {k: after.get(k, 0) - before.get(k, 0) for k in set(after) | set(before)}
 99:     delta_dict = dict(delta.items())
100:     assert delta_dict == brute_delta, \
101:         f"\nexpected {brute_delta}\ngot      {delta_dict}"
102: def test_propose_change_returns_expected_structure(proposer: NodeSwapProposer) -> None:
103:     changes = [(0, 1), (2, 0)]
104:     new_changes, delta_e, delta_n = proposer.propose_change(changes=changes)
105:     assert new_changes == changes, "proposer changed explicit instruction"
106:     assert all(isinstance(k, tuple) and len(k) == 2 for k in delta_e.items()), "delta_e keys malformed"
107:     # check that all kays of delta_e are accesible in delta_n (not necessarily non-zero)
108:     for (i, j), _ in delta_e.items():
109:         try:
110:             _ = delta_n[(i, j)]
111:         except KeyError:
112:             pytest.fail(f"delta_n missing key ({i}, {j}) from delta_e: {delta_e.items()}")
113: ###############################################################################
114: # tests for NodeMover
115: ###############################################################################
116: def test_node_mover_updates_blocks_and_sizes() -> None:
117:     adj, blocks = _toy_graph()
118:     bd = BlockData(initial_blocks=blocks, graph_data=GraphData(adj, directed=False))
119:     mover = NodeMover(bd)
120:     changes = [(0, 1), (2, 0)]
121:     # reuse proposer to get correct delta_e
122:     prop = NodeSwapProposer(block_data=bd, rng=np.random.default_rng(0))
123:     delta_e = prop._compute_delta_edge_counts(changes)            # type: ignore
124:     mover.perform_change(changes, delta_e)
125:     assert bd.blocks[0] == 1 and bd.blocks[2] == 0, \
126:         f"blocks not swapped: {bd.blocks}"
127:     assert bd.block_sizes[0] == 2 and bd.block_sizes[1] == 2, \
128:         f"block_sizes wrong: {bd.block_sizes}"
129: def test_node_mover_updates_connectivity() -> None:
130:     adj, blocks = _toy_graph()
131:     bd = BlockData(initial_blocks=blocks, graph_data=GraphData(adj, directed=False))
132:     mover = NodeMover(bd)
133:     before = bd.block_connectivity.copy()
134:     changes = [(0, 1), (2, 0)]
135:     prop = NodeSwapProposer(block_data=bd, rng=np.random.default_rng(0))
136:     delta_e = prop._compute_delta_edge_counts(changes)            # type: ignore
137:     mover.perform_change(changes, delta_e)
138:     # brute recompute
139:     after_brute = _brute_block_connectivity(bd.graph_data.adjacency, bd.blocks)
140:     # connectivity matrix stores both triangles → pick upper
141:     after_matrix = {(r, s): int(bd.block_connectivity[r, s]) #type: ignore
142:                     for r, s in after_brute}
143:     msg = (f"\nexpected connectivity {after_brute}"
144:            f"\nobserved  connectivity {after_matrix}"
145:            f"\ndelta_e applied        {delta_e}")
146:     assert after_matrix == after_brute, msg
147: # ---------------------------------------------------------------------------
148: # helpers – minimal block‑edge accounting for validation
149: # ---------------------------------------------------------------------------
150: def _block_edge_matrix(adj: csr_array, blocks: np.ndarray, n_blocks: int) -> np.ndarray:
151:     """Return an n_blocks×n_blocks symmetric matrix with edge counts."""
152:     mat = np.zeros((n_blocks, n_blocks), dtype=int)
153:     rows, cols = adj.nonzero()
154:     for u, v in zip(rows, cols):
155:         if u >= v:  # undirected ⇒ count each unordered pair once
156:             continue
157:         bu, bv = blocks[u], blocks[v]
158:         mat[bu, bv] += 1
159:         if bu != bv:
160:             mat[bv, bu] += 1
161:     return mat
162: def _apply_changes(blocks: np.ndarray, changes):
163:     new_blocks = blocks.copy()
164:     for node, tgt in changes:
165:         new_blocks[node] = tgt
166:     return new_blocks
167: def _assert_delta_matches(delta_e, before, after):
168:     """Check that EdgeDelta equals after–before for every block pair."""
169:     n_blocks = before.shape[0]
170:     for r in range(n_blocks):
171:         for s in range(n_blocks):
172:             assert delta_e[r, s] == after[r, s] - before[r, s]
173: # ---------------------------------------------------------------------------
174: # fixtures
175: # ---------------------------------------------------------------------------
176: @pytest.fixture(scope="module")
177: def toy_block_data():
178:     """Simple 6‑node, 2‑block undirected graph with both intra‑ and cross‑edges."""
179:     edges = [
180:         (0, 1), (1, 2), (0, 2),  # block 0 internal triangle
181:         (3, 4), (4, 5), (3, 5),  # block 1 internal triangle
182:         (0, 3), (1, 4), (2, 5),  # three cross edges
183:     ]
184:     n = 6
185:     rows, cols = [], []
186:     for u, v in edges:
187:         rows += [u, v]
188:         cols += [v, u]
189:     data = np.ones(len(rows), dtype=int)
190:     adj = csr_array((data, (rows, cols)), shape=(n, n))
191:     blocks = {0: 0, 1: 0, 2: 0, 3: 1, 4: 1, 5: 1}  # type: ignore[assignment]
192:     bd = BlockData(initial_blocks=blocks, graph_data=GraphData(adj, directed=False))
193:     return bd
194: # ---------------------------------------------------------------------------
195: # tests – EdgeBasedSwapProposer
196: # ---------------------------------------------------------------------------
197: def test_edge_based_swap_valid_move(toy_block_data):
198:     rng = np.random.default_rng(42)
199:     prop = EdgeBasedSwapProposer(toy_block_data, rng=rng)
200:     changes, delta_e, _ = prop.propose_change()
201:     # exactly two tuples returned
202:     assert len(changes) == 2
203:     (i, tgt_i), (j, tgt_j) = changes
204:     blocks = toy_block_data.blocks
205:     # originally different blocks and connected by an edge
206:     assert blocks[i] != blocks[j]
207:     assert toy_block_data.graph_data.adjacency[i, j] == 1  # type: ignore[index]
208:     # swap  semantics: targets are the partner's old blocks
209:     assert tgt_i == blocks[j]
210:     assert tgt_j == blocks[i]
211:     # edge‑delta correctness --------------------------------------------------
212:     before = _block_edge_matrix(toy_block_data.graph_data.adjacency, blocks,  # type: ignore[attr-defined]
213:                                 n_blocks=2)
214:     after_blocks = _apply_changes(blocks, changes)
215:     after = _block_edge_matrix(toy_block_data.graph_data.adjacency, after_blocks, 2)
216:     _assert_delta_matches(delta_e, before, after)
217: # ---------------------------------------------------------------------------
218: # tests – TriadicSwapProposer
219: # ---------------------------------------------------------------------------
220: def test_triadic_swap_valid_move(toy_block_data):
221:     rng = np.random.default_rng(7)
222:     prop = TriadicSwapProposer(toy_block_data, rng=rng, candidate_trials=20)
223:     changes, delta_e, _ = prop.propose_change()
224:     # two tuples returned
225:     assert len(changes) == 2
226:     (i, tgt_i), (l, tgt_l) = changes
227:     blocks = toy_block_data.blocks
228:     # i moves to l's block and vice‑versa
229:     assert tgt_i == blocks[l]
230:     assert tgt_l == blocks[i]
231:     # block sizes preserved ---------------------------------------------------
232:     block_sizes = toy_block_data.block_sizes
233:     after_blocks = _apply_changes(blocks, changes)
234:     new_block_sizes = {
235:         b: sum(1 for v in after_blocks.values() if v == b)
236:         for b in set(after_blocks.values())
237:     }
238:     for block, size in new_block_sizes.items():
239:         assert size == block_sizes[block], \
240:             f"Block {block} size changed: expected {block_sizes[block]}, got {size}"
241:     # delta‑edge correctness --------------------------------------------------
242:     before = _block_edge_matrix(toy_block_data.graph_data.adjacency, blocks, 2)  # type: ignore[attr-defined]
243:     after = _block_edge_matrix(toy_block_data.graph_data.adjacency, after_blocks, 2)
244:     _assert_delta_matches(delta_e, before, after)

================
File: src/tests/mcmc/test_edge_delta.py
================
  1: # tests/test_edge_delta_equivalence.py
  2: """
  3: Unit tests that compare behaviour of sbm.edge_delta.EdgeDelta
  4: and its NumPy-accelerated subclass NumpyEdgeDelta.
  5: The tests are written against the public API actually used by
  6: block-change proposers and the likelihood calculator:
  7:     • increment(counts, blocks_i, blocks_j)              :contentReference[oaicite:0]{index=0}
  8:     • __getitem__, __len__, items                       :contentReference[oaicite:1]{index=1}
  9: """
 10: from __future__ import annotations
 11: import random
 12: from collections import defaultdict
 13: from itertools import combinations
 14: import numpy as np
 15: import pytest
 16: from sbm.edge_delta import EdgeDelta, NumpyEdgeDelta
 17: # --------------------------------------------------------------------------- #
 18: # helpers                                                                     #
 19: # --------------------------------------------------------------------------- #
 20: def _random_updates(
 21:     n_blocks: int,
 22:     n_updates: int,
 23:     *, rng: random.Random
 24: ) -> tuple[list[int], list[int], list[int]]:
 25:     """
 26:     Create a *single* batch of updates without duplicate (i, j) pairs
 27:     – this mirrors how `_compute_delta_edge_counts` builds its argument
 28:     lists before calling ``increment`` once per batch.                   :contentReference[oaicite:2]{index=2}
 29:     """
 30:     pairs = random.sample(list(combinations(range(n_blocks), 2)), k=n_updates)
 31:     counts = [rng.randint(-5, 5) for _ in range(n_updates)]
 32:     blocks_i, blocks_j = zip(*pairs)   # already i < j
 33:     return counts, list(blocks_i), list(blocks_j)
 34: def _build_two_deltas(
 35:     n_blocks: int,
 36:     counts: list[int],
 37:     blocks_i: list[int],
 38:     blocks_j: list[int],
 39: ) -> tuple[EdgeDelta, NumpyEdgeDelta]:
 40:     """
 41:     Convenience wrapper: build and *increment once* – just like the
 42:     real code does.                                                      :contentReference[oaicite:3]{index=3}
 43:     """
 44:     d_py  = EdgeDelta(n_blocks)
 45:     d_np  = NumpyEdgeDelta(n_blocks)
 46:     d_py.increment(counts, blocks_i, blocks_j)
 47:     d_np.increment(counts, blocks_i, blocks_j)
 48:     return d_py, d_np
 49: # --------------------------------------------------------------------------- #
 50: # public API parity tests                                                     #
 51: # --------------------------------------------------------------------------- #
 52: @pytest.mark.parametrize("n_blocks, n_updates, seed", [
 53:     (5,  6,  1),
 54:     (7, 10, 42),
 55:     (3,  2, 99),
 56: ])
 57: def test_increment_equivalence(n_blocks: int, n_updates: int, seed: int) -> None:
 58:     """After an identical batch update, both classes hold exactly the same deltas."""
 59:     rng = random.Random(seed)
 60:     counts, bi, bj = _random_updates(n_blocks, n_updates, rng=rng)
 61:     d_py, d_np = _build_two_deltas(n_blocks, counts, bi, bj)
 62:     # compare through the *public* interface ─ not private storage
 63:     pairs = set(d_py.items()) | set(d_np.items())
 64:     for (i, j), _ in pairs:
 65:         assert d_py[i, j] == d_np[i, j], \
 66:             f"Mismatch on pair {(i, j)}: python={d_py[i, j]}, numpy={d_np[i, j]}"
 67:     assert len(d_py) == len(d_np), \
 68:         f"__len__ diverged: python={len(d_py)}, numpy={len(d_np)}"
 69:     # full dict comparison (order-independent)
 70:     assert dict(d_py.items()) == dict(d_np.items())
 71: def test_getitem_default_zero() -> None:
 72:     """Both classes must return 0 for unseen (i,j) pairs."""
 73:     d_py  = EdgeDelta(4)
 74:     d_np  = NumpyEdgeDelta(4)
 75:     for pair in ((0, 0), (0, 1), (2, 3)):
 76:         assert d_py[pair] == d_np[pair] == 0
 77: def test_negative_and_positive_counts() -> None:
 78:     """Signed counts stay intact and are *not* silently truncated."""
 79:     counts  = [  5, -3,  2]
 80:     blocks_i = [0, 0, 1]
 81:     blocks_j = [1, 2, 2]
 82:     d_py, d_np = _build_two_deltas(3, counts, blocks_i, blocks_j)
 83:     assert dict(d_py.items()) == { (0, 1): 5, (0, 2): -3, (1, 2): 2 }
 84:     assert dict(d_py.items()) == dict(d_np.items())
 85: # --------------------------------------------------------------------------- #
 86: # integration smoke test – reproduces the exact public call-sequence used
 87: # by `_compute_delta_edge_counts`                                            #
 88: # --------------------------------------------------------------------------- #
 89: def test_two_step_update_matches() -> None:
 90:     """
 91:     `_compute_delta_edge_counts` issues *two* successive ``increment`` calls
 92:     on the *same* EdgeDelta instance.  Here we reproduce that pattern and make
 93:     sure the NumPy implementation yields identical final deltas after both
 94:     steps.                                                                   :contentReference[oaicite:4]{index=4}
 95:     """
 96:     n_blocks = 4
 97:     # step-1: neighbour blocks
 98:     counts1  = [ 2, -1]
 99:     blocks1a = [0, 1]
100:     blocks1b = [2, 2]
101:     # step-2: intra / inter old blocks
102:     counts2  = [ 7, -4, -3]
103:     blocks2a = [0, 0, 1]
104:     blocks2b = [1, 0, 1]
105:     py = EdgeDelta(n_blocks)
106:     npd = NumpyEdgeDelta(n_blocks)
107:     py.increment(counts1, blocks1a, blocks1b)
108:     py.increment(counts2, blocks2a, blocks2b)
109:     npd.increment(counts1, blocks1a, blocks1b)
110:     npd.increment(counts2, blocks2a, blocks2b)
111:     assert dict(py.items()) == dict(npd.items())

================
File: src/tests/mcmc/test_global_ll.py
================
  1: """Tests that the *slow* and *fast* global Bernoulli log‑likelihood
  2: implementations are numerically identical on a variety of synthetic block
  3: partitions.
  4: We build *real* ``BlockData`` instances by constructing a synthetic graph
  5: (adjacency matrix) whose edge counts per block pair match a prescribed
  6: connectivity matrix.  This avoids touching the rest of the SBM pipeline
  7: while exercising exactly the code paths used by the likelihood routines.
  8: """
  9: from __future__ import annotations
 10: import random
 11: from typing import List, Sequence, Tuple
 12: import numpy as np
 13: import pytest
 14: import scipy.sparse as sp
 15: # ---------------------------------------------------------------------------
 16: # Functions under test
 17: # ---------------------------------------------------------------------------
 18: from sbm.likelihood import (
 19:     compute_global_bernoulli_ll,
 20:     compute_global_bernoulli_ll_fast,
 21: )
 22: from sbm.graph_data import GraphData
 23: # ---------------------------------------------------------------------------
 24: # Utility to create a BlockData instance whose *block_connectivity* matches a
 25: # given integer matrix ``conn`` (undirected only, because BlockData does not
 26: # implement the directed path).
 27: # ---------------------------------------------------------------------------
 28: try:
 29:     from sbm.block_data import BlockData  # type: ignore
 30: except ModuleNotFoundError:  # local fallback
 31:     from block_data import BlockData  # type: ignore
 32: def _node_ranges(sizes: Sequence[int]) -> List[Tuple[int, int]]:
 33:     """Return (start, stop) index for each block (Python half‑open)."""
 34:     ranges = []
 35:     start = 0
 36:     for sz in sizes:
 37:         ranges.append((start, start + sz))
 38:         start += sz
 39:     return ranges
 40: def build_block_data(
 41:     block_sizes: Sequence[int],
 42:     conn: np.ndarray,
 43:     rng: random.Random,
 44: ) -> BlockData:
 45:     """Construct a *consistent* BlockData (undirected) for testing."""
 46:     B = len(block_sizes)
 47:     assert conn.shape == (B, B)
 48:     assert (conn == conn.T).all(), "Connectivity must be symmetric for undirected graphs."  # noqa: E501
 49:     # Total number of nodes & adjacency matrix
 50:     N = int(sum(block_sizes))
 51:     adj = sp.dok_array((N, N), dtype=np.int64)
 52:     ranges = _node_ranges(block_sizes)
 53:     for r in range(B):
 54:         nodes_r = list(range(*ranges[r]))
 55:         # Diagonal block r==r
 56:         e_rr = int(conn[r, r])
 57:         if e_rr:
 58:             # all unordered pairs inside block
 59:             possible = [(u, v) for i, u in enumerate(nodes_r) for v in nodes_r[i + 1 :]]
 60:             assert e_rr <= len(possible)
 61:             chosen = rng.sample(possible, e_rr)
 62:             for u, v in chosen:
 63:                 adj[u, v] = 1
 64:                 adj[v, u] = 1
 65:         for s in range(r + 1, B):
 66:             e_rs = int(conn[r, s])
 67:             if not e_rs:
 68:                 continue
 69:             nodes_s = list(range(*ranges[s]))
 70:             possible = [(u, v) for u in nodes_r for v in nodes_s]
 71:             assert e_rs <= len(possible)
 72:             chosen = rng.sample(possible, e_rs)
 73:             for u, v in chosen:
 74:                 adj[u, v] = 1
 75:                 adj[v, u] = 1
 76:     adj = adj.tocsr()
 77:     # Blocks mapping: node -> block_id (block IDs are 0..B-1)
 78:     blocks = {node: b for b, (start, stop) in enumerate(ranges) for node in range(start, stop)}
 79:     dummy_graph = GraphData(adj, directed=False)
 80:     return BlockData(initial_blocks=blocks, graph_data=dummy_graph)
 81: # ---------------------------------------------------------------------------
 82: # Sanity helper
 83: # ---------------------------------------------------------------------------
 84: def assert_ll_equal(bd: BlockData):
 85:     ll_slow = compute_global_bernoulli_ll(bd)
 86:     ll_fast = compute_global_bernoulli_ll_fast(bd)
 87:     assert np.isclose(ll_slow, ll_fast, rtol=1e-4, atol=1e-6), f"{ll_slow} != {ll_fast}"
 88: # ==========================================================================
 89: # TEST CASES
 90: # ==========================================================================
 91: # 1) Tiny hand-crafted graph -------------------------------------------------
 92: def test_tiny_example():
 93:     sizes = [3, 4]
 94:     conn = np.array([[2, 5],
 95:                      [5, 1]], dtype=np.int64)
 96:     bd = build_block_data(sizes, conn, rng=random.Random(0))
 97:     assert_ll_equal(bd)
 98: # 2) Singleton block present -------------------------------------------------
 99: def test_singleton_block():
100:     sizes = [1, 5, 2]
101:     conn = np.array([[0, 0, 0],
102:                      [0, 4, 3],
103:                      [0, 3, 1]], dtype=np.int64)
104:     # ensure symmetry
105:     conn = conn + conn.T - np.diag(conn.diagonal())
106:     bd = build_block_data(sizes, conn, rng=random.Random(1))
107:     assert_ll_equal(bd)
108: # 3) Random dense undirected graphs -----------------------------------------
109: @pytest.mark.parametrize("seed,B", [(2, 4), (3, 6)])
110: def test_random_dense(seed: int, B: int):
111:     rng = random.Random(seed)
112:     sizes = [rng.randint(2, 6) for _ in range(B)]
113:     conn = np.zeros((B, B), dtype=np.int64)
114:     for r in range(B):
115:         n_rr = sizes[r] * (sizes[r] - 1) // 2
116:         conn[r, r] = rng.randrange(n_rr + 1)
117:         for s in range(r + 1, B):
118:             n_rs = sizes[r] * sizes[s]
119:             val = rng.randrange(n_rs + 1)
120:             conn[r, s] = conn[s, r] = val
121:     bd = build_block_data(sizes, conn, rng)
122:     assert_ll_equal(bd)

================
File: src/tests/mcmc/test_greedy_assign_helpers.py
================
  1: import numpy as np
  2: import scipy.sparse as sp
  3: from scipy.sparse import csr_array
  4: import pytest
  5: from collections import Counter, defaultdict
  6: from sbm.block_assigner import (
  7:     _boundary_vertices,
  8:     _movable_vertex,
  9:     _move,
 10:     categorize,
 11:     move_node_to_under,
 12:     move_node_from_over,
 13:     balance_k_plus_1_blocks,
 14:     _rebalance_to_min_size,
 15: )
 16: # ---------------------------------------------------------------------------
 17: # Minimal helper to build a fully connected small graph ---------------------
 18: # ---------------------------------------------------------------------------
 19: def full_graph_csr(n: int) -> csr_array:
 20:     rows, cols = np.triu_indices(n, 1)
 21:     data = np.ones_like(rows)
 22:     A = csr_array((data, (rows, cols)), shape=(n, n))
 23:     A = A + A.T  # undirected
 24:     return A
 25: # ---------------------------------------------------------------------------
 26: # Tests for categorize ------------------------------------------------------
 27: # ---------------------------------------------------------------------------
 28: def test_categorize_basic():
 29:     k = 3
 30:     sizes = {0: 2, 1: 3, 2: 4, 3: 5}
 31:     over2, over1, under = categorize(sizes, k)
 32:     assert over2 == {3}
 33:     assert over1 == {2}
 34:     assert under == {0}
 35: # ---------------------------------------------------------------------------
 36: # Tests for move_node_to_under -------------------------------------------
 37: # ---------------------------------------------------------------------------
 38: def test_move_node_to_under_correct():
 39:     k = 2
 40:     A = full_graph_csr(4)
 41:     # block 0 undersize (1), block 1 oversize (3)
 42:     blocks = {0: 0, 1: 1, 2: 1, 3: 1}
 43:     sizes = Counter(blocks.values())
 44:     members = defaultdict(set)
 45:     for v, b in blocks.items():
 46:         members[b].add(v)
 47:     rng = np.random.default_rng(0)
 48:     over2, over1, under = categorize(sizes, k)
 49:     move_node_to_under(
 50:         under=under,
 51:         over1=over1,
 52:         over2=over2,
 53:         rng=rng,
 54:         sizes=sizes,
 55:         k=k,
 56:         members=members,
 57:         blocks=blocks,
 58:         indptr=A.indptr,
 59:         indices=A.indices,
 60:     )
 61:     # After move, block 0 should have size 2, block 1 size 2
 62:     assert sizes[0] == k
 63:     assert sizes[1] == k
 64:     # No undersized blocks remain
 65:     _, _, under_new = categorize(sizes, k)
 66:     assert not under_new
 67: # ---------------------------------------------------------------------------
 68: # Tests for move_node_from_over --------------------------------------------
 69: # ---------------------------------------------------------------------------
 70: def test_move_node_from_over_shrink():
 71:     k = 3
 72:     A = full_graph_csr(8)
 73:     # block 0 size 2 (<k), block 1 size 6 (>k+1), others size 0
 74:     blocks = {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1}
 75:     sizes = Counter(blocks.values())
 76:     members = defaultdict(set)
 77:     for v, b in blocks.items():
 78:         members[b].add(v)
 79:     rng = np.random.default_rng(1)
 80:     over2, over1, under = categorize(sizes, k)
 81:     move_node_from_over(
 82:         under=under,
 83:         over1=over1,
 84:         over2=over2,
 85:         rng=rng,
 86:         sizes=sizes,
 87:         k=k,
 88:         members=members,
 89:         blocks=blocks,
 90:         indptr=A.indptr,
 91:         indices=A.indices,
 92:         r_target=0,
 93:     )
 94:     # block 0 size should have increased by 1, block1 decreased by1
 95:     assert sizes[0] == 2  # reached k
 96:     assert sizes[1] == 6
 97: # ---------------------------------------------------------------------------
 98: # Tests for balance_k_plus_1_blocks ----------------------------------------
 99: # ---------------------------------------------------------------------------
100: def test_balance_k_plus_1_blocks_shrink_and_enlarge():
101:     k = 2
102:     A = full_graph_csr(6)
103:     # create three blocks: 0 size 3 (k+1), 1 size 3 (k+1), 2 size 0 (empty)
104:     blocks = {0: 0, 1: 0, 2: 0, 3: 1, 4: 1, 5: 1}
105:     sizes = Counter(blocks.values())
106:     members = defaultdict(set)
107:     for v, b in blocks.items():
108:         members[b].add(v)
109:     rng = np.random.default_rng(3)
110:     r_target = 1  # we want exactly one k+1
111:     over2, over1, under = categorize(sizes, k)
112:     assert len(over1) == 2  # pre‑condition
113:     # no possible balance to achieve
114:     balance_k_plus_1_blocks(
115:         over1=over1,
116:         over2=over2,
117:         rng=rng,
118:         sizes=sizes,
119:         k=k,
120:         members=members,
121:         blocks=blocks,
122:         indptr=A.indptr,
123:         indices=A.indices,
124:         r_target=r_target,
125:     )
126:     # After balancing, over1 should be 1
127:     over2_after, over1_after, under_after = categorize(sizes, k)
128:     assert len(over1_after) == len(over1) # no change made
129:     assert len(over2_after) == len(over2) # no change made
130:     assert not under_after and not under # no undersized introduced
131: # ---------------------------------------------------------------------------
132: # Test safety with empty sets ----------------------------------------------
133: # ---------------------------------------------------------------------------
134: def test_empty_sets_no_crash():
135:     k = 2
136:     A = full_graph_csr(3)
137:     blocks = {0: 0, 1: 0, 2: 0}
138:     sizes = Counter(blocks.values())
139:     members = defaultdict(set)
140:     for v, b in blocks.items():
141:         members[b].add(v)
142:     rng = np.random.default_rng(4)
143:     # empty over/under sets
144:     over2, over1, under = categorize(sizes, k)
145:     # should do nothing and not raise
146:     move_node_to_under(under, over1, over2, rng, sizes, k, members, blocks, A.indptr, A.indices)
147:     move_node_from_over(under, over1, over2, rng, sizes, k, members, blocks, A.indptr, A.indices, r_target=0)
148:     balance_k_plus_1_blocks(over1, over2, rng, sizes, k, members, blocks, A.indptr, A.indices, r_target=0)
149: # ---------------------------------------------------------------------------
150: # Integration test for _rebalance_to_min_size ------------------------------
151: # ---------------------------------------------------------------------------
152: def test_rebalance_removes_all_undersize():
153:     n = 25
154:     k = 3
155:     A = full_graph_csr(n)
156:     rng = np.random.default_rng(10)
157:     # start with random over/under assignment
158:     blocks = {i: rng.integers(0, 8) for i in range(n)}
159:     print(set(Counter(blocks.values()).values()))
160:     balanced = _rebalance_to_min_size(blocks.copy(), A, k, rng)
161:     sizes = Counter(balanced.values())
162:     print(set(sizes.values()))
163:     # No block smaller than k
164:     assert min(sizes.values()) >= k

================
File: src/tests/mcmc/test_swaps.py
================
 1: # ──────────────────────────────────────────────────────────────────────────────
 2: # tests/test_swap_move.py
 3: # ──────────────────────────────────────────────────────────────────────────────
 4: import networkx as nx
 5: import numpy as np
 6: import pytest
 7: from sbm.block_assigner import MetisBlockAssigner
 8: from sbm.block_change_proposers import NodeSwapProposer
 9: from sbm.likelihood import LikelihoodCalculator
10: from sbm.mcmc import MCMC
11: from sbm.graph_data import gd_from_networkx
12: from sbm.block_data import BlockData
13: def _sizes_from_block_data(block_data: BlockData, num_blocks):
14:     """Helper used in both reference and post‑move checks."""
15:     sizes = np.zeros(num_blocks, dtype=int)
16:     for bid, nodes in block_data.block_members.items():
17:         if bid < num_blocks:
18:             sizes[bid] = len(nodes)
19:     return sizes
20: @pytest.mark.parametrize(
21:     "num_nodes,num_blocks,min_block_size,iterations,edge_p",
22:     [
23:         (80, 8, 8, 250, 0.05),
24:         (30, 6, 4, 100, 0.25),
25:         (10, 5, 2, 100, 0.25),
26:     ],
27: )
28: def test_swap_move_preserves_block_sizes(num_nodes, num_blocks, min_block_size, iterations, edge_p):
29:     """After *every* accepted SWAP move, block‑size vector must be unchanged."""
30:     rng = np.random.default_rng(42)
31:     # old version of networkx can't take rng so use seed instead
32:     G = nx.erdos_renyi_graph(num_nodes, edge_p, seed=42, directed=False)
33:     graph_data = gd_from_networkx(G)
34:     # ── Build initial state ────────────────────────────────────────────────
35:     block_data = MetisBlockAssigner(
36:         graph_data=graph_data,
37:         num_blocks=num_blocks,
38:         min_block_size=min_block_size,
39:         rng=rng,
40:     ).compute_assignment()
41:     likelihood_calculator = LikelihoodCalculator(block_data=block_data)
42:     swap_proposer = NodeSwapProposer(block_data=block_data, rng=rng)
43:     mcmc = MCMC(
44:         block_data=block_data,
45:         likelihood_calculator=likelihood_calculator,
46:         change_proposer={"uniform_swap": swap_proposer},
47:         rng=rng,
48:     )
49:     reference_sizes = _sizes_from_block_data(block_data, num_blocks)
50:     # ── Run many candidate swap moves ──────────────────────────────────────
51:     for iter in range(iterations):
52:         _delta_ll, accepted = mcmc._attempt_move(move_type="uniform_swap", temperature=1.0)
53:         if accepted:
54:             current_sizes = _sizes_from_block_data(mcmc.block_data, num_blocks)
55:             assert np.array_equal(reference_sizes, current_sizes), (
56:                 f"SWAP move {iter} changed block sizes:", reference_sizes, "→", current_sizes
57:             )
58:     # Final safeguard: after *all* moves sizes are still identical.
59:     final_sizes = _sizes_from_block_data(mcmc.block_data, num_blocks)
60:     assert np.array_equal(reference_sizes, final_sizes)

================
File: src/tests/metrics/clustering
================
 1: import numpy as np
 2: from scipy.sparse import csr_array
 3: from metrics.clustering import avg_clustering_difference
 4: from tests.metrics.conftest import _line_graph, _complete_graph
 5: 
 6: def test_identical_zero() -> None:
 7:     A: csr_array = _line_graph()
 8:     assert avg_clustering_difference(A, A) == 0.0
 9: 
10: def test_line_vs_complete() -> None:
11:     d = avg_clustering_difference(_line_graph(10), _complete_graph(10))
12:     assert d > 0 and np.isfinite(d)

================
File: src/tests/metrics/conftest.py
================
 1: import numpy as np, scipy.sparse as sp
 2: import pytest
 3: from scipy.sparse import csr_array
 4: # ------------------------------------------------------------------ helpers
 5: def _line_graph(n: int = 6) -> csr_array:
 6:     rows = np.arange(n - 1)
 7:     cols = rows + 1
 8:     A = sp.coo_matrix((np.ones_like(rows), (rows, cols)), shape=(n, n))
 9:     A = A + A.T
10:     return csr_array(A, dtype=np.int8)
11: def _complete_graph(n: int = 6) -> csr_array:
12:     A = np.ones((n, n), dtype=np.int8)
13:     np.fill_diagonal(A, 0)
14:     return csr_array(A)
15: def _er_graph(n: int = 10, p: float = .2, *, seed: int = 1) -> csr_array:
16:     rng = np.random.default_rng(seed)
17:     upper = rng.random((n, n)) < p
18:     upper = np.triu(upper, k=1)
19:     A = upper | upper.T
20:     return csr_array(A.astype(np.int8))
21: def _two_triangles() -> csr_array:
22:     edges = [(0, 1), (1, 2), (0, 2), (3, 4), (4, 5), (3, 5)]
23:     rows, cols = zip(*edges)
24:     A = sp.coo_matrix((np.ones(len(edges)), (rows, cols)), shape=(6, 6))
25:     A = A + A.T
26:     return csr_array(A, dtype=np.int8)
27: # ------------------------------------------------------------------ fixtures
28: @pytest.fixture(scope="module")
29: def rng() -> np.random.Generator:
30:     return np.random.default_rng(0)

================
File: src/tests/metrics/shortest_path.py
================
 1: import numpy as np, pytest
 2: from scipy.sparse import csr_array
 3: from metrics.shortest_path import avg_path_length_difference
 4: from tests.metrics.conftest import _line_graph, _complete_graph
 5: def test_identical_zero() -> None:
 6:     A: csr_array = _line_graph()
 7:     assert avg_path_length_difference(A, A, n_samples=None) == 0.0
 8: @pytest.mark.parametrize(
 9:     "emp,sur",
10:     [
11:         (_line_graph(8), _complete_graph(8)),
12:         (_line_graph(20), _line_graph(30)),
13:     ],
14: )
15: def test_difference_positive(emp: csr_array, sur: csr_array) -> None:
16:     d = avg_path_length_difference(emp, sur, n_samples=100)
17:     assert d > 0.0 and np.isfinite(d)

================
File: src/tests/metrics/test_assortativity.py
================
1: from scipy.sparse import csr_array
2: from metrics.assortativity import assortativity_difference
3: from tests.metrics.conftest import _line_graph, _complete_graph, _er_graph
4: def test_identical_zero() -> None:
5:     A: csr_array = _line_graph()
6:     assert assortativity_difference(A, A) == 0.0
7: def test_line_vs_complete_positive() -> None:
8:     d = assortativity_difference(_line_graph(12), _er_graph(n=12))
9:     assert d > 0

================
File: src/tests/metrics/test_community_metrics.py
================
 1: import numpy as np
 2: from scipy.sparse import csr_array
 3: from metrics.community import (
 4:     infomap_codelength_difference,
 5:     leiden_modularity_difference,
 6: )
 7: from tests.metrics.conftest import _two_triangles, _complete_graph
 8: def test_infomap_identical_zero():
 9:     A: csr_array = _two_triangles()
10:     assert infomap_codelength_difference(A, A) == 0.0
11: def test_leiden_identical_zero():
12:     A: csr_array = _two_triangles()
13:     assert leiden_modularity_difference(A, A) == 0.0
14: def test_infomap_vs_complete_positive():
15:     d = infomap_codelength_difference(_two_triangles(), _complete_graph(6))
16:     assert d > 0
17: def test_leiden_vs_complete_positive():
18:     d = leiden_modularity_difference(_two_triangles(), _complete_graph(6))
19:     assert d > 0

================
File: src/tests/metrics/test_eigen_subspace.py
================
 1: import numpy as np, pytest
 2: from scipy.sparse import csr_array
 3: from metrics.spectral import (
 4:     eigen_val_distance,
 5:     eigen_vec_distance,
 6:     centrality_distance
 7: )
 8: from tests.metrics.conftest import _line_graph, _complete_graph, _er_graph
 9: # ------------------------------------------------------------------------- #
10: # Eigenval tests
11: # ------------------------------------------------------------------------- #
12: def test_val_identical_zero_int_input() -> None:
13:     # adjacency is *int* on purpose – function must up-cast internally
14:     A: csr_array = _line_graph(12)
15:     assert eigen_val_distance(A, A, k=3) == 0.0
16: def test_val_different_size_graphs() -> None:
17:     # adjacency is *int* on purpose – function must up-cast internally
18:     A: csr_array = _line_graph(12)
19:     B: csr_array = _line_graph(13)
20:     eigen_val_distance(A, B, k=3)
21: @pytest.mark.parametrize("k", [1, 3])
22: def test_val_line_vs_complete_positive(k: int) -> None:
23:     d = eigen_val_distance(_line_graph(12), _complete_graph(12), k=k)
24:     assert d > 0.0 and np.isfinite(d)
25: # ------------------------------------------------------------------------- #
26: # Eigenvec tests
27: # ------------------------------------------------------------------------- #
28: def test_vec_identical_zero_int_input() -> None:
29:     # adjacency is *int* on purpose – function must up-cast internally
30:     A: csr_array = _line_graph(12)
31:     assert eigen_vec_distance(A, A, k=3) == 0.0
32: def test_vec_line_vs_er_positive() -> None:
33:     # adjacency is *int* on purpose – function must up-cast internally
34:     A: csr_array = _line_graph(50)
35:     B: csr_array = _er_graph(50)
36:     assert eigen_vec_distance(A, B, k=3) > 0.0
37: def test_vec_different_size_graphs() -> None:
38:     # adjacency is *int* on purpose – function must up-cast internally
39:     A: csr_array = _line_graph(12)
40:     B: csr_array = _line_graph(13)
41:     # check that the function raises a ValueError
42:     # because the graphs have different sizes
43:     with pytest.raises(ValueError):
44:         eigen_vec_distance(A, B, k=3)
45: # ------------------------------------------------------------------------- #
46: # Eigen centrality tests
47: # ------------------------------------------------------------------------- #
48: @pytest.mark.parametrize("k", [1, 3])
49: def test_vec_line_vs_complete_positive(k: int) -> None:
50:     d = centrality_distance(_line_graph(12), _complete_graph(12))
51:     assert d > 0.0 and np.isfinite(d)
52: def test_cent_identical_zero_int_input() -> None:
53:     # adjacency is *int* on purpose – function must up-cast internally
54:     A: csr_array = _line_graph(12)
55:     assert centrality_distance(A, A) == 0.0
56: def test_cent_different_size_graphs() -> None:
57:     # adjacency is *int* on purpose – function must up-cast internally
58:     A: csr_array = _line_graph(12)
59:     B: csr_array = _line_graph(20)
60:     assert centrality_distance(A, B) > 0.0
61: @pytest.mark.parametrize("k", [1, 3])
62: def test_cent_line_vs_complete_positive(k: int) -> None:
63:     d = centrality_distance(_line_graph(12), _complete_graph(12))
64:     assert d > 0.0 and np.isfinite(d)

================
File: src/tests/metrics/test_embedding_metrics.py
================
 1: import numpy as np, pytest
 2: from scipy.sparse import csr_array
 3: from metrics.embedding import (
 4:     embedding_node2vec_ip_emd,
 5:     embedding_prone_ip_emd,
 6: )
 7: from tests.metrics.conftest import _line_graph, _er_graph
 8: @pytest.mark.parametrize("fn", [embedding_node2vec_ip_emd, embedding_prone_ip_emd])
 9: def test_dissimilar_for_different_graphs(fn):
10:     A: csr_array = _line_graph(100)
11:     B: csr_array = _er_graph(100)
12:     d_AA = fn(A, A, dim=32, n_pairs=500)
13:     d_AB = fn(A, B, dim=32, n_pairs=500)
14:     d_BB = fn(B, B, dim=32, n_pairs=500)
15:     # for identical graphs we expect *almost* zero – allow tiny noise
16:     assert d_AA < d_AB
17:     assert d_BB < d_AB
18: @pytest.mark.parametrize("fn", [embedding_node2vec_ip_emd, embedding_prone_ip_emd])
19: def test_line_vs_er_positive(fn):
20:     d = fn(_line_graph(20), _er_graph(20, p=.3), dim=32, n_pairs=500)
21:     assert d > 0 and np.isfinite(d)

================
File: src/tests/metrics/test_metrics.py
================
 1: import numpy as np, scipy.sparse as sp
 2: from scipy.sparse import csr_array
 3: from metrics import (
 4:     shortest_path_distance,
 5:     degree_distance,
 6:     clustering_distance
 7: )
 8: ### Helper functions to create graphs
 9: def _line_graph(n=6) -> csr_array:
10:     rows = np.arange(n-1); cols = rows + 1
11:     A = sp.coo_matrix((np.ones(n-1), (rows, cols)), shape=(n, n))
12:     A = A + A.T
13:     A = csr_array(A, dtype=np.int8)
14:     return A
15: def _er_graph(n: int=10, p: float=0.1, *, seed: int=1) -> csr_array:
16:     """Undirected G(n,p) without self-loops, returned as CSR matrix."""
17:     rng = np.random.default_rng(seed)
18:     upper = rng.random((n, n)) < p                           # boolean mask
19:     upper = np.triu(upper, k=1)                              # keep strict upper
20:     adj = upper | upper.T                                    # symmetrise
21:     return csr_array(adj.astype(np.int8))
22: #### test functions
23: def test_shortest_path_identical_line():
24:     A = _line_graph()
25:     print(A.toarray())
26:     assert shortest_path_distance(A, A, n_samples=None) == 0.0
27: def test_degree_identical_line():
28:     A = _line_graph()
29:     assert degree_distance(A, A) == 0.0
30: def test_clustering_identical_line():
31:     A = _line_graph()
32:     assert clustering_distance(A, A) == 0.0
33: def test_shortest_path_different_line():
34:     A = _line_graph(n=20)
35:     B = _line_graph(n=200)
36:     assert shortest_path_distance(A, B, n_samples=100) != 0.0
37: def test_degree_different_line():
38:     A = _line_graph(n=20)
39:     A = _line_graph(n=200)
40:     assert degree_distance(A, A) == 0.0
41: def test_clustering_identical_er():
42:     A = _er_graph(n=100)
43:     assert clustering_distance(A, A) == 0.0
44: def test_shortest_path_identical_er():
45:     A = _er_graph(p=0.9)
46:     assert shortest_path_distance(A, A, n_samples=None) == 0.0
47: def test_shortest_path_different_er():
48:     A = _er_graph(n=20, p=0.9)
49:     B = _er_graph(n=200, p=0.1)
50:     assert shortest_path_distance(A, B, n_samples=100) != 0.0
51: def test_degree_different_er():
52:     A = _er_graph()
53:     assert degree_distance(A, A) == 0.0
54: def test_clustering_different_er():
55:     A = _er_graph()
56:     assert clustering_distance(A, A) == 0.0

================
File: src/tests/sbm/test_io.py
================
  1: # tests/test_io.py
  2: import json
  3: from pathlib import Path
  4: import numpy as np
  5: import scipy.sparse as sp
  6: from scipy.io import mmwrite
  7: import networkx as nx
  8: import pytest
  9: from sbm.io import SBMFit, SBMWriter, GraphLoader
 10: # ---------------------------------------------------------------------
 11: # helpers
 12: # ---------------------------------------------------------------------
 13: def _simple_adj(undirected: bool = True) -> sp.csr_array:
 14:     """
 15:     3-node graph:
 16:         0 — 1   and  (optionally) 1 → 2
 17:     """
 18:     rows, cols = [0, 1], [1, 0]            # 0–1 edge
 19:     if not undirected:
 20:         rows.append(1); cols.append(2)     # add 1→2 (makes it directed)
 21:     data = np.ones(len(rows), dtype=np.int8)
 22:     return sp.csr_array(sp.coo_matrix((data, (rows, cols)), shape=(3, 3)))
 23: def _assert_same_csr(a: sp.csr_array, b: sp.csr_array):
 24:     a.sort_indices()
 25:     b.sort_indices()
 26:     assert np.array_equal(a.data, b.data), f'Data arrays differ: {a.data} != {b.data}'
 27:     assert np.array_equal(a.indices, b.indices), f'Indices differ: {a.indices} != {b.indices}'
 28:     assert a.shape == b.shape, f'Shape differs: {a.shape} != {b.shape}'
 29: # ---------------------------------------------------------------------
 30: # 1. SBMWriter round-trip
 31: # ---------------------------------------------------------------------
 32: def test_sbmwriter_roundtrip(tmp_path: Path):
 33:     # --- build a tiny SBMFit ----------------------------------------
 34:     #adj = _simple_adj()
 35:     #blocks = {0: 0, 1: 0, 2: 1}
 36:     fit = SBMFit(
 37:         block_sizes   = [2, 1],
 38:         block_conn    = sp.csr_array([[1, .2],[.2, .1]]),
 39:         directed_graph= False,
 40:         neg_loglike   = -12.34,
 41:         metadata      = {"foo": "bar"},
 42:     )
 43:     # --- save & load ------------------------------------------------
 44:     SBMWriter.save(tmp_path, fit)
 45:     fit2 = SBMWriter.load(tmp_path)
 46:     # basic checks
 47:     assert fit2.block_sizes == [2, 1], f"Block sizes do not match: {fit2.block_sizes} != [2, 1]"
 48:     _assert_same_csr(fit.block_conn, fit2.block_conn)
 49:     assert fit2.neg_loglike == pytest.approx(fit.neg_loglike), "Negative log-likelihood does not match"
 50:     assert fit2.metadata["foo"] == "bar", "Metadata does not match"
 51: # ---------------------------------------------------------------------
 52: # 2. GraphLoader built-in formats
 53: # ---------------------------------------------------------------------
 54: @pytest.mark.parametrize("undirected", [True, False])
 55: def test_graphloader_npz(tmp_path: Path, undirected: bool):
 56:     adj = _simple_adj(undirected)
 57:     f = tmp_path / "g.npz"
 58:     sp.save_npz(f, adj)
 59:     g = GraphLoader.load(f)
 60:     _assert_same_csr(adj, g.adjacency)
 61:     assert g.directed == (not undirected)
 62: def test_graphloader_edges(tmp_path: Path):
 63:     # plain edge list (space-sep)
 64:     f = tmp_path / "toy.edges"
 65:     f.write_text("0 1\n1 2\n")  # unsymmetrised → directed
 66:     g = GraphLoader.load(f)
 67:     assert g.directed
 68:     assert g.num_nodes == 3
 69:     assert g.adjacency[1, 2] == 1
 70: def test_graphloader_mtx(tmp_path: Path):
 71:     adj = _simple_adj()
 72:     f = tmp_path / "toy.mtx"
 73:     mmwrite(str(f), adj)
 74:     g = GraphLoader.load(f)
 75:     _assert_same_csr(adj, g.adjacency)
 76:     assert not g.directed
 77: def test_graphloader_gml(tmp_path: Path):
 78:     # build with networkx
 79:     G = nx.Graph()
 80:     G.add_edge(0, 1); G.add_edge(1, 2)
 81:     f = tmp_path / "toy.gml"
 82:     nx.write_gml(G, f)
 83:     g = GraphLoader.load(f)
 84:     assert not g.directed
 85:     assert g.adjacency.nnz == 4      # undirected ⇒ 2 edges ×2
 86: # ---------------------------------------------------------------------
 87: # 3. Registry decorator sanity check
 88: # ---------------------------------------------------------------------
 89: def test_register_new_loader(tmp_path: Path):
 90:     # create a fake extension ".foo"
 91:     ext = ".foo"
 92:     @GraphLoader.register(ext)
 93:     def _load_foo(path: Path):
 94:         # loader that ignores content, returns 2-node edge
 95:         rows, cols = [0], [1]
 96:         adj = sp.coo_matrix((np.ones(1, int), (rows, cols)), shape=(2, 2)).tocsr()
 97:         return adj, True
 98:     # create dummy file and load
 99:     f = tmp_path / f"dummy{ext}"
100:     f.write_text("ignored")
101:     g = GraphLoader.load(f)
102:     assert g.directed
103:     assert g.adjacency[0, 1] == 1
104:     assert f.suffix.lower() in GraphLoader.registry

================
File: src/tests/sbm/test_sampling.py
================
  1: import numpy as np
  2: import scipy.sparse as sp
  3: import pytest
  4: from sbm.sampling import (
  5:     sample_adjacency_matrix,
  6:     sample_sbm_graph_from_fit,
  7: )
  8: from sbm.io import SBMFit
  9: from sbm.graph_data import GraphData
 10: @pytest.fixture(scope="module")
 11: def rng():
 12:     return np.random.default_rng(12345)
 13: # --------------------------------------------------------------------
 14: # helpers
 15: # --------------------------------------------------------------------
 16: def csr_edges_between(adj: sp.csr_array, idx_a, idx_b, directed:bool = False):
 17:     """number of non-zero entries with row in A and col in B"""
 18:     sub = adj[idx_a][:, idx_b] # type: ignore
 19:     if (idx_a == idx_b) and not directed:
 20:         # self-edges, count only upper triangle
 21:         return sub.count_nonzero() // 2 # type: ignore
 22:     if directed:
 23:         # directed, count all edges
 24:         print('')
 25:         print(sub.toarray().tolist())
 26:         print(adj.toarray().tolist())
 27:         print('')
 28:     return sub.sum() # type: ignore
 29: def complete_block_edges(n, directed):
 30:     return n * (n - 1) if directed else n * (n - 1) // 2
 31: # --------------------------------------------------------------------
 32: # 1. full connectivity should yield a complete bipartite/clique
 33: # --------------------------------------------------------------------
 34: @pytest.mark.parametrize("directed", [False, True])
 35: def test_full_connectivity(rng, directed):
 36:     n1, n2 = 3, 4
 37:     sizes = [n1, n2]
 38:     # maximum possible edges
 39:     B = 2
 40:     conn = sp.csr_array((B, B), dtype=int)
 41:     conn[0, 0] = complete_block_edges(n1, directed)
 42:     conn[1, 1] = complete_block_edges(n2, directed)
 43:     conn[0, 1] = conn[1, 0] = n1 * n2
 44:     adj = sample_adjacency_matrix(sizes, conn, directed=directed, rng=rng)
 45:     idx0 = slice(0, n1)
 46:     idx1 = slice(n1, n1 + n2)
 47:     # --- within-block ------------------------------------------------
 48:     assert csr_edges_between(adj, idx0, idx0, directed) == conn[0, 0], \
 49:         (
 50:             f"expected {conn[0, 0]} edges within block 0. Got {csr_edges_between(adj, idx0, idx0)}. "
 51:             f"sizes: {sizes}, conn: {conn.toarray().flatten()}, directed: {directed}"
 52:         )
 53:     assert csr_edges_between(adj, idx1, idx1, directed) == conn[1, 1], \
 54:         (
 55:             f"expected {conn[1, 1]} edges within block 1"
 56:             f"sizes: {sizes}, conn: {conn}, directed: {directed}"
 57:         )
 58:     # --- between blocks ---------------------------------------------
 59:     expect = conn[0, 1]
 60:     assert csr_edges_between(adj, idx0, idx1, directed) == expect ,\
 61:         (
 62:             f"expected {expect} edges between blocks 0 and 1. Got {csr_edges_between(adj, idx0, idx1)}. "
 63:             f"sizes: {sizes}, conn: {conn.toarray().flatten()}, directed: {directed}"
 64:         )
 65:     assert csr_edges_between(adj, idx1, idx0, directed) == expect, \
 66:         (
 67:             f"expected {expect} edges between blocks 1 and 0. Got {csr_edges_between(adj, idx1, idx0)}. "
 68:             f"sizes: {sizes}, conn: {conn.toarray().flatten()}, directed: {directed}"
 69:         )
 70:     if directed:
 71:         # both directions filled
 72:         assert csr_edges_between(adj, idx1, idx0, directed) == expect, \
 73:                 f"expected {expect} edges between blocks 1 and 0. Got {csr_edges_between(adj, idx1, idx0)}. "
 74:     # --- no self-loops ----------------------------------------------
 75:     assert adj.diagonal().sum() == 0, \
 76:                 "expected no self-loops in the adjacency matrix"
 77: # --------------------------------------------------------------------
 78: # 2. zero connectivity must yield zero edges between blocks
 79: # --------------------------------------------------------------------
 80: def test_zero_connectivity(rng):
 81:     n1, n2 = 5, 6
 82:     sizes = [n1, n2]
 83:     conn = sp.csr_array([[10, 0],
 84:                          [0, 15]], dtype=int)
 85:     adj = sample_adjacency_matrix(sizes, conn, directed=False, rng=rng)
 86:     idx0 = slice(0, n1)
 87:     idx1 = slice(n1, n1 + n2)
 88:     assert csr_edges_between(adj, idx0, idx1) == 0
 89:     assert csr_edges_between(adj, idx1, idx0) == 0
 90: # --------------------------------------------------------------------
 91: # 3. large probabilistic block matches expected count ±3σ
 92: # --------------------------------------------------------------------
 93: def test_statistical_match(rng):
 94:     n1, n2 = 100, 200
 95:     sizes = [n1, n2]
 96:     p = 0.15
 97:     m = int(p * n1 * n2)
 98:     conn = sp.csr_array((2, 2), dtype=int)
 99:     conn[0, 1] = conn[1, 0] = m
100:     trials = 10
101:     errs = []
102:     for _ in range(trials):
103:         adj = sample_adjacency_matrix(sizes, conn, directed=False, rng=rng)
104:         idx0 = slice(0, n1)
105:         idx1 = slice(n1, n1 + n2)
106:         observed = csr_edges_between(adj, idx0, idx1)
107:         errs.append(observed - m)
108:     std = np.sqrt(n1 * n2 * p * (1 - p))
109:     assert max(map(abs, errs)) < 3 * std, \
110:         (
111:             f"expected observed edge counts to match {m} ± 3σ. Got {errs}. "
112:         )
113: # --------------------------------------------------------------------
114: # 4. directed vs undirected symmetry
115: # --------------------------------------------------------------------
116: def test_directed_flag(rng):
117:     sizes = [10, 10]
118:     B = 2
119:     conn = sp.csr_array((B, B), dtype=int)
120:     conn[0, 1] = conn[1, 0] = 10 * 10 / 2   # p = 0.5
121:     adj_d = sample_adjacency_matrix(sizes, conn, directed=True, rng=rng)
122:     assert (adj_d != adj_d.T).nnz > 0, \
123:         "expected directed graph to be asymmetric"
124:     adj_u = sample_adjacency_matrix(sizes, conn, directed=False, rng=rng)
125:     assert (adj_u != adj_u.T).nnz == 0
126: # --------------------------------------------------------------------
127: # 5. sampling via SBMFit wrapper
128: # --------------------------------------------------------------------
129: def test_sample_from_fit(rng):
130:     sizes = [2, 2]
131:     conn = sp.csr_array([[1, 2],
132:                          [2, 1]], dtype=int)
133:     fit = SBMFit(
134:         block_sizes    = sizes,
135:         block_conn     = conn,
136:         directed_graph = False,
137:         neg_loglike    = -1.0,
138:         metadata       = {},
139:     )
140:     g = sample_sbm_graph_from_fit(fit, rng)
141:     assert isinstance(g, GraphData)
142:     assert g.adjacency.shape == (4, 4)

================
File: env_backup.yml
================
  1: name: anon_sbm
  2: channels:
  3:   - conda-forge
  4:   - defaults
  5: dependencies:
  6:   - bzip2=1.0.8
  7:   - ca-certificates=2024.9.24
  8:   - libexpat=2.6.4
  9:   - libffi=3.4.4
 10:   - libmpdec=4.0.0
 11:   - libsqlite=3.47.0
 12:   - libzlib=1.3.1
 13:   - ncurses=6.5
 14:   - openssl=3.4.0
 15:   - pip=24.3.1
 16:   - python=3.13.0
 17:   - python_abi=3.13
 18:   - readline=8.2
 19:   - tk=8.6.13
 20:   - xz=5.4.6
 21:   - pip:
 22:     - absl-py==2.3.0
 23:     - anon-sbm==0.1.0
 24:     - anyio==4.6.2.post1
 25:     - appnope==0.1.4
 26:     - argon2-cffi==23.1.0
 27:     - argon2-cffi-bindings==21.2.0
 28:     - arrow==1.3.0
 29:     - asttokens==2.4.1
 30:     - async-lru==2.0.4
 31:     - attrs==24.2.0
 32:     - babel==2.16.0
 33:     - beautifulsoup4==4.12.3
 34:     - bleach==6.2.0
 35:     - certifi==2024.8.30
 36:     - cffi==1.17.1
 37:     - charset-normalizer==3.4.0
 38:     - comm==0.2.2
 39:     - contourpy==1.3.1
 40:     - cycler==0.12.1
 41:     - debugpy==1.8.9
 42:     - decorator==5.1.1
 43:     - defusedxml==0.7.1
 44:     - executing==2.1.0
 45:     - fastjsonschema==2.20.0
 46:     - fonttools==4.55.0
 47:     - fqdn==1.5.1
 48:     - h11==0.14.0
 49:     - httpcore==1.0.7
 50:     - httpx==0.27.2
 51:     - idna==3.10
 52:     - immutabledict==4.2.1
 53:     - iniconfig==2.0.0
 54:     - ipykernel==6.29.5
 55:     - ipython==8.29.0
 56:     - ipywidgets==8.1.5
 57:     - isoduration==20.11.0
 58:     - jedi==0.19.2
 59:     - jinja2==3.1.4
 60:     - joblib==1.5.1
 61:     - json5==0.9.28
 62:     - jsonpointer==3.0.0
 63:     - jsonschema==4.23.0
 64:     - jsonschema-specifications==2024.10.1
 65:     - jupyter==1.1.1
 66:     - jupyter-client==8.6.3
 67:     - jupyter-console==6.6.3
 68:     - jupyter-core==5.7.2
 69:     - jupyter-events==0.10.0
 70:     - jupyter-lsp==2.2.5
 71:     - jupyter-server==2.14.2
 72:     - jupyter-server-terminals==0.5.3
 73:     - jupyterlab==4.2.6
 74:     - jupyterlab-pygments==0.3.0
 75:     - jupyterlab-server==2.27.3
 76:     - jupyterlab-widgets==3.0.13
 77:     - k-means-constrained==0.7.3
 78:     - kiwisolver==1.4.7
 79:     - markupsafe==3.0.2
 80:     - matplotlib==3.9.2
 81:     - matplotlib-inline==0.1.7
 82:     - mistune==3.0.2
 83:     - nbclient==0.10.0
 84:     - nbconvert==7.16.4
 85:     - nbformat==5.10.4
 86:     - nest-asyncio==1.6.0
 87:     - networkx==3.4.2
 88:     - notebook==7.2.2
 89:     - notebook-shim==0.2.4
 90:     - numpy==1.26.4
 91:     - ortools==9.14.6206
 92:     - overrides==7.7.0
 93:     - packaging==24.2
 94:     - pandas==2.3.0
 95:     - pandocfilters==1.5.1
 96:     - parso==0.8.4
 97:     - pathlib==1.0.1
 98:     - pexpect==4.9.0
 99:     - pillow==11.0.0
100:     - platformdirs==4.3.6
101:     - pluggy==1.5.0
102:     - prometheus-client==0.21.0
103:     - prompt-toolkit==3.0.48
104:     - protobuf==6.31.1
105:     - psutil==6.1.0
106:     - ptyprocess==0.7.0
107:     - pure-eval==0.2.3
108:     - pycparser==2.22
109:     - pygments==2.18.0
110:     - pymetis==2025.1.1
111:     - pyparsing==3.2.0
112:     - pytest==8.3.4
113:     - python-dateutil==2.9.0.post0
114:     - python-json-logger==2.0.7
115:     - pytz==2025.2
116:     - pyyaml==6.0.2
117:     - pyzmq==26.2.0
118:     - referencing==0.35.1
119:     - requests==2.32.3
120:     - rfc3339-validator==0.1.4
121:     - rfc3986-validator==0.1.1
122:     - rpds-py==0.21.0
123:     - scikit-learn==1.7.0
124:     - scipy==1.14.1
125:     - send2trash==1.8.3
126:     - setuptools==75.6.0
127:     - six==1.16.0
128:     - sniffio==1.3.1
129:     - soupsieve==2.6
130:     - stack-data==0.6.3
131:     - terminado==0.18.1
132:     - threadpoolctl==3.6.0
133:     - tinycss2==1.4.0
134:     - tornado==6.4.2
135:     - tqdm==4.67.1
136:     - traitlets==5.14.3
137:     - types-python-dateutil==2.9.0.20241003
138:     - typing-extensions==4.14.0
139:     - tzdata==2025.2
140:     - uri-template==1.3.0
141:     - urllib3==2.2.3
142:     - wcwidth==0.2.13
143:     - webcolors==24.11.1
144:     - webencodings==0.5.1
145:     - websocket-client==1.8.0
146:     - widgetsnbextension==4.0.13
147: prefix: /opt/anaconda3/envs/anon_sbm

================
File: pyproject.toml
================
1: [build-system]
2: requires = ["setuptools", "wheel"]
3: build-backend = "setuptools.build_meta"

================
File: README.md
================
1: # anon_sbm

================
File: notebooks/block_assigner_comparison_01-07-2025.ipynb
================
  1: {
  2:  "cells": [
  3:   {
  4:    "cell_type": "markdown",
  5:    "id": "03332c1a",
  6:    "metadata": {},
  7:    "source": [
  8:     "# Notebook for comparing the quality of block-assignment strategies"
  9:    ]
 10:   },
 11:   {
 12:    "cell_type": "code",
 13:    "execution_count": 1,
 14:    "id": "ca236c42",
 15:    "metadata": {},
 16:    "outputs": [],
 17:    "source": [
 18:     "from pathlib import Path\n",
 19:     "\n",
 20:     "import numpy as np\n",
 21:     "import pandas as pd\n",
 22:     "import scipy.sparse as sp\n",
 23:     "\n",
 24:     "from sbm.io import GraphLoader\n",
 25:     "from sbm.block_assigner import AssignerConstructor"
 26:    ]
 27:   },
 28:   {
 29:    "cell_type": "code",
 30:    "execution_count": 2,
 31:    "id": "75c16b11",
 32:    "metadata": {},
 33:    "outputs": [],
 34:    "source": [
 35:     "g = GraphLoader.load(\n",
 36:     "    Path(\"/Users/lmmi/anon_sbm/data/processed/congress_twitter.edgelist\"),\n",
 37:     "    force_undirected=True, # type: ignore\n",
 38:     "    )\n",
 39:     "#g = GraphLoader.load(\n",
 40:     "#    Path(\"/Users/lmmi/anon_sbm/data/processed/lastfm_asia.edgelist\"),\n",
 41:     "#    force_undirected=True, # type: ignore\n",
 42:     "#    )"
 43:    ]
 44:   },
 45:   {
 46:    "cell_type": "code",
 47:    "execution_count": 3,
 48:    "id": "e54ed4ac",
 49:    "metadata": {},
 50:    "outputs": [],
 51:    "source": [
 52:     "rng = np.random.default_rng(1) # type: ignore\n",
 53:     "k = 3"
 54:    ]
 55:   },
 56:   {
 57:    "cell_type": "code",
 58:    "execution_count": 4,
 59:    "id": "e8d0bf40",
 60:    "metadata": {},
 61:    "outputs": [],
 62:    "source": [
 63:     "assigner_const = AssignerConstructor(rng=rng)\n",
 64:     "uniform_assigner = assigner_const.create_assigner(\n",
 65:     "    graph_data=g,\n",
 66:     "    min_block_size=k, # type: ignore\n",
 67:     "    init_method=\"uniform\", # type: ignore\n",
 68:     "    )\n",
 69:     "prone_assigner = assigner_const.create_assigner(\n",
 70:     "    graph_data=g,\n",
 71:     "    min_block_size=k, # type: ignore\n",
 72:     "    init_method=\"prone_and_kmeans\", # type: ignore\n",
 73:     "    )\n",
 74:     "metis_assigner = assigner_const.create_assigner(\n",
 75:     "    graph_data=g,\n",
 76:     "    min_block_size=k, # type: ignore\n",
 77:     "    init_method=\"metis\", # type: ignore\n",
 78:     "    )\n",
 79:     "metis_ref_assigner = assigner_const.create_assigner(\n",
 80:     "    graph_data=g,\n",
 81:     "    min_block_size=k, # type: ignore\n",
 82:     "    init_method=\"metis_refine\", # type: ignore\n",
 83:     "    )"
 84:    ]
 85:   },
 86:   {
 87:    "cell_type": "code",
 88:    "execution_count": 10,
 89:    "id": "6030cfba",
 90:    "metadata": {},
 91:    "outputs": [
 92:     {
 93:      "name": "stdout",
 94:      "output_type": "stream",
 95:      "text": [
 96:       "[158, 83]\n",
 97:       "[158]\n"
 98:      ]
 99:     }
100:    ],
101:    "source": [
102:     "uniform_blocks = uniform_assigner.compute_assignment()\n",
103:     "#prone_blocks = prone_assigner.compute_assignment()\n",
104:     "metis_blocks = metis_assigner.compute_assignment()\n",
105:     "metis_ref_blocks = metis_ref_assigner.compute_assignment()"
106:    ]
107:   },
108:   {
109:    "cell_type": "code",
110:    "execution_count": 11,
111:    "id": "8b91f480",
112:    "metadata": {},
113:    "outputs": [
114:     {
115:      "name": "stdout",
116:      "output_type": "stream",
117:      "text": [
118:       "{3, 4}\n",
119:       "{2, 3, 4, 5}\n",
120:       "{3, 4}\n"
121:      ]
122:     }
123:    ],
124:    "source": [
125:     "print(set(uniform_blocks.block_sizes.values()))\n",
126:     "#print(set(prone_blocks.block_sizes.values()))\n",
127:     "print(set(metis_blocks.block_sizes.values()))\n",
128:     "print(set(metis_ref_blocks.block_sizes.values()))"
129:    ]
130:   },
131:   {
132:    "cell_type": "code",
133:    "execution_count": 12,
134:    "id": "399008f8",
135:    "metadata": {},
136:    "outputs": [
137:     {
138:      "name": "stdout",
139:      "output_type": "stream",
140:      "text": [
141:       "\n",
142:       "Small graph likelihood comparison:\n",
143:       "    Uniform assignment likelihood: 8261.40\n",
144:       "    Metis assignment likelihood: 4820.68\n",
145:       "    Metis-refine assignment likelihood: 4862.17\n",
146:       "\n"
147:      ]
148:     }
149:    ],
150:    "source": [
151:     "# compute likelihood of the assignments\n",
152:     "from sbm.likelihood import compute_global_bernoulli_ll_fast\n",
153:     "\n",
154:     "uniform_nll = -compute_global_bernoulli_ll_fast(uniform_blocks)\n",
155:     "#prone_ll = compute_global_bernoulli_ll_fast(prone_blocks)\n",
156:     "metis_nll = -compute_global_bernoulli_ll_fast(metis_blocks)\n",
157:     "metis_ref_nll = -compute_global_bernoulli_ll_fast(metis_ref_blocks)\n",
158:     "\n",
159:     "print(f\"\"\"\n",
160:     "Small graph likelihood comparison:\n",
161:     "    Uniform assignment likelihood: {uniform_nll:.2f}\n",
162:     "    Metis assignment likelihood: {metis_nll:.2f}\n",
163:     "    Metis-refine assignment likelihood: {metis_ref_nll:.2f}\n",
164:     "\"\"\")"
165:    ]
166:   },
167:   {
168:    "cell_type": "code",
169:    "execution_count": null,
170:    "id": "f3633444",
171:    "metadata": {},
172:    "outputs": [],
173:    "source": []
174:   },
175:   {
176:    "cell_type": "code",
177:    "execution_count": null,
178:    "id": "f2c3d8e0",
179:    "metadata": {},
180:    "outputs": [],
181:    "source": []
182:   }
183:  ],
184:  "metadata": {
185:   "kernelspec": {
186:    "display_name": "Python 3",
187:    "language": "python",
188:    "name": "python3"
189:   },
190:   "language_info": {
191:    "codemirror_mode": {
192:     "name": "ipython",
193:     "version": 3
194:    },
195:    "file_extension": ".py",
196:    "mimetype": "text/x-python",
197:    "name": "python",
198:    "nbconvert_exporter": "python",
199:    "pygments_lexer": "ipython3",
200:    "version": "3.12.11"
201:   }
202:  },
203:  "nbformat": 4,
204:  "nbformat_minor": 5
205: }

================
File: slurm_scripts/fit_sbm.sh
================
 1: #!/bin/sh
 2: ### General options
 3: #BSUB -q hpc
 4: #BSUB -J anon_sbm_fit
 5: #BSUB -n 1
 6: #BSUB -R "span[hosts=1]"
 7: #BSUB -R "rusage[mem=10GB]"
 8: #BSUB -M 20GB
 9: #BSUB -W 1:00
10: #BSUB -o slurm_outputs/anon_sbm_fit_%J.out
11: #BSUB -e slurm_outputs/anon_sbm_fit_%J.err
12: module purge
13: module load python3/3.12
14: source /zhome/c1/2/109045/anon_sbm_env/bin/activate
15: python3 src/pipelines/fit_sbm.py --fit_config /zhome/c1/2/109045/anon_sbm/configs/sbm_fit_block_size_experiments.yml

================
File: src/data_processing/process_all.py
================
 1: # src/data_processing/process_all.py
 2: """ 
 3: Script to run all processing steps of all datasets.
 4: """
 5: import subprocess
 6: import sys
 7: def run(cmd):
 8:     print(">>", " ".join(cmd))
 9:     subprocess.check_call(cmd)
10: datasets = [
11:     "data_processing.process_congress_twitter",
12:     "data_processing.process_email_eu",
13:     "data_processing.process_caltech",
14:     "data_processing.process_wiki_vote",
15:     "data_processing.process_enron_email",
16:     "data_processing.process_lastfm_asia",
17: ]
18: if __name__ == "__main__":
19:     python = sys.executable
20:     for dataset in datasets:
21:         run([python, "-m", dataset])

================
File: src/metrics/__init__.py
================
 1: from .shortest_path import shortest_path_distance, avg_path_length_difference
 2: from .degree import degree_distance
 3: from .clustering import clustering_distance, avg_clustering_difference
 4: from .spectral import eigen_val_distance, centrality_distance
 5: from .embedding import embedding_node2vec_ip_emd, embedding_prone_ip_emd
 6: from .community import infomap_codelength_difference, leiden_modularity_difference
 7: from .assortativity import assortativity_difference
 8: # registry maps a short name -> call-able
 9: REGISTRY = {
10:     "shortest_path": shortest_path_distance,
11:     "avg_path_length": avg_path_length_difference,
12:     "degree": degree_distance,
13:     "clustering": clustering_distance,
14:     "avg_clustering": avg_clustering_difference,
15:     "eigen_val": eigen_val_distance,
16:     "eigen_centrality": centrality_distance,
17:     "infomap": infomap_codelength_difference,
18:     "leiden": leiden_modularity_difference,
19:     "assortativity": assortativity_difference,
20:     "embedding_node2vec": embedding_node2vec_ip_emd,
21:     "embedding_prone": embedding_prone_ip_emd,
22: }

================
File: src/metrics/degree.py
================
 1: """ 
 2: Implementation of the degree distribution distance metric.
 3: This module computes the Earth-mover distance (1-D Wasserstein distance)
 4: between the degree distributions in two graphs represented by
 5: their adjacency matrices.
 6: """
 7: # metrics/degree.py
 8: from typing import Optional
 9: import numpy as np
10: from scipy.stats import wasserstein_distance #  1-D EMD
11: from scipy.sparse import csr_array
12: def degree_distance(
13:         emp_adj: csr_array,
14:         sur_adj: csr_array,
15:         directed: Optional[bool] = False,
16:         in_degree: Optional[bool] = False,
17:         out_degree: Optional[bool] = False,
18:         rng: np.random.Generator = np.random.default_rng(1)
19:     ) -> float:
20:     """ 
21:     Earth-mover (1-D Wasserstein) distance between the degree distributions
22:     of two graphs.
23:     Parameters
24:     ----------
25:     emp_adj, sur_adj : scipy.sparse.csr_matrix
26:         Adjacency of empirical and surrogate graphs (directed or undirected).
27:     directed : bool, optional
28:         If True, compute directed degree distribution.
29:         If False, compute undirected degree distribution.
30:     in_degree : bool, optional
31:         If True, compute in-degree distribution (for directed graphs).
32:         Ignored if `directed` is False.
33:     out_degree : bool, optional
34:         If True, compute out-degree distribution (for directed graphs).
35:         Ignored if `directed` is False.
36:     rng : np.random.Generator, optional
37:         Random number generator for sampling (default: np.random.default_rng(1)).
38:     Returns
39:     -------
40:     float
41:         Distance (lower = more similar).
42:     """
43:     if directed:
44:         raise NotImplementedError(
45:             "Directed degree distribution is not implemented yet."
46:         )
47:     else:
48:         if in_degree or out_degree:
49:             raise Warning(
50:                 "in_degree and out_degree are ignored for undirected graphs."
51:             )
52:         # Undirected degree distribution
53:         emp_degrees = np.asarray(emp_adj.sum(axis=0)).flatten()
54:         sur_degrees = np.asarray(sur_adj.sum(axis=0)).flatten()
55:         emp_dist = np.bincount(emp_degrees)
56:         sur_dist = np.bincount(sur_degrees)
57:         # Normalize distributions
58:         emp_dist = emp_dist / emp_dist.sum()
59:         sur_dist = sur_dist / sur_dist.sum()
60:         # Compute Earth-mover distance
61:         distance = wasserstein_distance(emp_dist, sur_dist)
62:         return distance

================
File: src/sbm/utils/pipeline_utils.py
================
  1: from typing import Dict, Union, TypedDict, List, Literal
  2: from pathlib import Path
  3: import numpy as np
  4: import scipy.sparse as sp
  5: def load_csr_npz(fn: Path):
  6:     with np.load(fn) as z:
  7:         return sp.csr_matrix(
  8:             (z["data"], z["indices"], z["indptr"]),
  9:             shape=z["shape"]
 10:         )
 11: InitMethodName = Literal["metis", "random", "ProneKMeans"]
 12: class DatasetSpec(TypedDict):
 13:     name: str
 14:     path: str
 15: class SBMConfig(TypedDict):
 16:     force_undirected: bool
 17:     min_block_size: int
 18:     n_iter: int
 19:     temperature: float
 20:     cooling_rate: float
 21:     init_method: InitMethodName
 22: class LoggingConfig(TypedDict):
 23:     logging_folder: str
 24:     log_every: int
 25: class FitConfig(TypedDict):
 26:     seed: int
 27:     sbm: SBMConfig
 28:     logging: LoggingConfig
 29:     datasets: List[DatasetSpec]
 30: class EvalConfig(TypedDict):
 31:     n_surrogates: int
 32:     overwrite: bool
 33:     metrics: List[str]
 34: def clean_filename(name: str) -> str:
 35:     """
 36:     Clean the name of all special characters and spaces, replacing them with underscores.
 37:     """
 38:     name = name.replace(":", "_")
 39:     name = name.replace(".", "_")
 40:     name = name.replace(",", "_")
 41:     return name
 42: def sbmfit_folderpath(
 43:     base_dir: Path,
 44:     sbm_config: SBMConfig,
 45:     data_spec: DatasetSpec,
 46: ) -> Path:
 47:     """
 48:     Generate the folderpath for storing a fitted SBM model based on the fit configuration.
 49:     Filename is created by unrolling the fit_config dictionary, using all fields and their values. 
 50:     :param name: Name of the dataset. 
 51:     """
 52:     folder_name = data_spec["name"] + "_" + "_".join(
 53:         f"{k}_{v}" for k, v in sorted(sbm_config.items())
 54:     )
 55:     folder_name = clean_filename(folder_name)
 56:     return base_dir / f"sbm_fit_{folder_name}"
 57: def surrogate_statistics_filename(
 58:     base_dir: Path,
 59:     eval_configs: EvalConfig,
 60:     sbm_config: SBMConfig,
 61:     data_spec: DatasetSpec,
 62: ) -> Path:
 63:     """
 64:     Generate the folfor surrogate statistics based on evaluation and fit configurations.
 65:     :param eval_configs: Evaluation configuration dictionary.
 66:     :param fit_config: Fit configuration dictionary.
 67:     :return: Path object representing the filename.
 68:     """
 69:     file_name = (
 70:         f"{data_spec['name']}_"
 71:         f"surrogates_{eval_configs['n_surrogates']}_"
 72:             #f"{'_'.join(eval_configs['metrics'])}_"
 73:         #f"{'_'.join(f'{k}_{v}' for k, v in sorted(sbm_config.items()))}"
 74:     )
 75:     file_name = clean_filename(file_name)
 76:     return base_dir / f"{file_name}.csv"
 77: def dataset_filepath(
 78:     base_dir: Path,
 79:     dataset_name: str,
 80: )-> Path:
 81:     """
 82:     Generate the filepath for a dataset based on its name.
 83:     :param base_dir: Base directory where datasets are stored.
 84:     :param dataset_name: Name of the dataset.
 85:     :return: Path object representing the dataset file path.
 86:     """
 87:     dataset_name = clean_filename(dataset_name)
 88:     return base_dir / f"{dataset_name}.npz"
 89: ##### Helper functions #####
 90: def fit_config_to_dicts(fit_config: FitConfig) -> List[dict[str, str]]:
 91:     """ 
 92:     Convert FitConfig to a list of DatasetSpec dictionaries.
 93:     One dictionary per dataset.
 94:     """
 95:     configs = [
 96:         {
 97:             "name": ds["name"],
 98:             "path": ds["path"],
 99:             **fit_config["sbm"],
100:         }
101:         for ds in fit_config["datasets"]
102:     ]
103:     for config in configs:
104:         if "seed" in config:
105:             config["seed"] = str(fit_config["seed"])
106:     return configs
107: def eval_config_to_dict(eval_config: EvalConfig) -> dict[str, str]:
108:     """
109:     Convert EvalConfig to a dictionary.
110:     """
111:     return {
112:         "n_surrogates": str(eval_config["n_surrogates"]),
113:         "metrics": "_".join(
114:                 eval_config["metrics"]    
115:             )
116:     }

================
File: src/sbm/edge_delta.py
================
  1: """
  2: Classes to build and hold changes in edge counts between blocks in a Stochastic Block Model (SBM).
  3: """
  4: from typing import DefaultDict, Tuple, List, Literal, Tuple, Iterator, Iterable, Literal
  5: from collections import defaultdict, Counter
  6: import numpy as np
  7: from numba import jit
  8: EdgeDeltas = Literal["PythonEdgeDelta", "NumpyEdgeDelta"]
  9: #### Pure python class for edge deltas #######
 10: class EdgeDelta: # edge-count changes between blocks
 11:     def __init__(self, n_blocks: int):
 12:         self._deltas: DefaultDict[Tuple[int, int], int] = defaultdict(int)
 13:     def _increment(self, count: int, block_i: int, block_j: int,
 14:      ) -> None:
 15:         """
 16:         Increment the edge count delta for a pair of blocks.
 17:         :param count: The change in edge count.
 18:         :param block_i: The first block index.
 19:         :param block_j: The second block index.
 20:         :return: Updated edge count delta.
 21:         """
 22:         if block_i < block_j:
 23:             self._deltas[(block_i, block_j)] = count
 24:         else:
 25:             self._deltas[(block_j, block_i)] = count
 26:     def __getitem__(self, pair: Tuple[int, int]) -> int:
 27:         """
 28:         Get the edge count delta for a pair of blocks.
 29:         :param pair: A tuple containing the block indices (i, j).
 30:         :return: The edge count delta for the pair.
 31:         """
 32:         if pair[0] < pair[1]:
 33:             return self._deltas.get(pair, 0)
 34:         else:
 35:             return self._deltas.get((pair[1], pair[0]), 0)
 36:     def __len__(self) -> int:
 37:         """
 38:         Return the number of non-zero edge count deltas.
 39:         :return: The number of non-zero edge count deltas.
 40:         """
 41:         return len([v for v in self._deltas.values() if v != 0])
 42:     def items(self) -> Iterator[Tuple[Tuple[int, int], int]]:
 43:         """
 44:         Yield tuple ((i, j), delta_e) for all stored pairs.
 45:         :return: An iterator over tuples of (block_i, block_j, delta_e).
 46:         """
 47:         for (i, j), delta_e in self._deltas.items():
 48:             yield (i, j), delta_e
 49:     def increment(self,
 50:                   counts: Iterable[int],
 51:                   blocks_i: Iterable[int],
 52:                   blocks_j: Iterable[int],
 53:      ) -> None:
 54:         """
 55:         Increment the edge counts deltas for a list of block pairs.
 56:         :param counts: List of changes in edge counts.
 57:         :param blocks_i: List of first block indices.
 58:         :param blocks_j: List of second block indices.
 59:         """
 60:         for count, block_i, block_j in zip(counts, blocks_i, blocks_j):
 61:             self._increment(count, block_i, block_j)
 62: ##### NumPy class for edge deltas ######
 63: class NumpyEdgeDelta(EdgeDelta):
 64:     """Sparse, symmetric (i <= j) container for edge‑count deltas.
 65:     Overwrites the pure‑Python :py:class:`EdgeDelta` class
 66:     Internally stores three *contiguous* one‑dimensional NumPy arrays
 67:     (`rows`, `cols`, `data`) in **COO** fashion as well as a Python
 68:     ``dict`` that maps the linearised pair key ``i * n_blocks + j`` to the
 69:     corresponding position in the arrays.  Only the *active* prefix
 70:     (``self.size``) of the arrays is considered valid – this makes the
 71:     structure friendly to Numba‐JIT’d consumers that expect fixed‑size
 72:     buffers.
 73:     The class focuses on *fast incremental updates* (``O(1)`` expected)
 74:     and cheap vector export; memory usage is proportional to the number
 75:     of *non‑zero* block pairs actually visited by the MCMC chain.
 76:     """
 77:     __slots__ = ("n_blocks", "rows", "cols", "data", "size", "_key2idx")
 78:     def __init__(self,
 79:                  n_blocks: int,
 80:                  initial_capacity: int = 64
 81:     ):
 82:         self.n_blocks: int = int(n_blocks)
 83:         cap = max(1, initial_capacity)
 84:         self.rows: np.ndarray = np.empty(cap, dtype=np.int32)
 85:         self.cols: np.ndarray = np.empty(cap, dtype=np.int32)
 86:         self.data: np.ndarray = np.zeros(cap, dtype=np.int32)
 87:         self.size: int = 0
 88:         # auxiliary map for *O(1)* lookup – not accessed inside JIT code
 89:         self._key2idx: dict[int, int] = {}
 90:     ### function for printing the object
 91:     def __repr__(self) -> str:
 92:         """Return a string representation of the NumpyEdgeDelta object."""
 93:         return (f"NumpyEdgeDelta(n_blocks={self.n_blocks}, "
 94:                 f"size={self.size}, "
 95:                 f"rows={self.rows[:self.size]}, "
 96:                 f"cols={self.cols[:self.size]}, "
 97:                 f"data={self.data[:self.size]})")
 98:     # ------------------------------------------------------------------
 99:     # Private helpers
100:     # ------------------------------------------------------------------
101:     def _encode(self, i: int, j: int) -> int:
102:         """Encode an ordered pair (i ≤ j) into a unique scalar."""
103:         return i * self.n_blocks + j
104:     def _ensure_capacity(self):
105:         if self.size == len(self.rows):
106:             # double in‑place (amortised O(1))
107:             new_cap = len(self.rows) * 2
108:             self.rows = np.resize(self.rows, new_cap)
109:             self.cols = np.resize(self.cols, new_cap)
110:             self.data = np.resize(self.data, new_cap)
111:     def _increment(self, count: int, block_i: int, block_j: int):
112:         """Add *value* to entry (i, j) (symmetric pair)."""
113:         if block_i > block_j:
114:             block_i, block_j = block_j, block_i
115:         key = self._encode(block_i, block_j)
116:         idx = self._key2idx.get(key)
117:         if idx is None:
118:             self._ensure_capacity()
119:             idx = self.size
120:             self.size += 1
121:             self.rows[idx] = block_i
122:             self.cols[idx] = block_j
123:             self.data[idx] = count
124:             self._key2idx[key] = idx
125:         else:
126:             self.data[idx] += count
127:     # ------------------------------------------------------------------
128:     # Public API
129:     # ------------------------------------------------------------------
130:     def __getitem__(self, pair: Tuple[int, int]) -> int:
131:         i, j = pair
132:         if i > j:
133:             i, j = j, i
134:         idx = self._key2idx.get(self._encode(i, j))
135:         return 0 if idx is None else int(self.data[idx])
136:     def __len__(self) -> int:
137:         """Return the number of non-zero and *active* pairs."""
138:         #return self.size
139:         active_pairs = self.data[:self.size]
140:         print(f"Active pairs: {active_pairs}")
141:         return active_pairs[active_pairs != 0].shape[0]
142:     def __setitem__(self, pair: Tuple[int, int], value: int):
143:         i, j = pair
144:         current = self[pair]
145:         self._increment(i, j, value - current)
146:     def items(self) -> Iterator[Tuple[Tuple[int, int], int]]:
147:         """Yield triples ``(i, j, delta_e)`` for all stored pairs."""
148:         for k in range(self.size):
149:             yield (int(self.rows[k]), int(self.cols[k])), int(self.data[k])
150:     def to_coo(self) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
151:         """Return the *active* COO view (no copying)."""
152:         return (self.rows[:self.size], self.cols[:self.size], self.data[:self.size])
153:     def increment(self,
154:             counts: Iterable[int],
155:             blocks_i: Iterable[int],
156:             blocks_j: Iterable[int],
157:      ) -> None:
158:         """Vectorised equivalent of ``increment`` for ``NumpyEdgeDelta``.
159:         Parameters
160:         ----------
161:         counts : 1‑D ``int`` array
162:             Changes in edge counts (positive or negative).
163:         blocks_i, blocks_j : 1‑D ``int`` arrays
164:             Block indices *parallel* to ``counts``.
165:         Notes
166:         -----
167:         The function works fully in **NumPy** space – no Python loops – by
168:         linearising the symmetric pair ``(i, j)`` into a *key* and then
169:         accumulating duplicate keys with :pyfunc:`numpy.add.at`.
170:         """
171:         # ------------------------------------------------------------------
172:         # Ensure ndarray inputs (copy=False promotes views)
173:         # ------------------------------------------------------------------
174:         assert isinstance(counts, (list, np.ndarray)) and \
175:                 isinstance(blocks_i, (list, np.ndarray)) and \
176:                 isinstance(blocks_j, (list, np.ndarray)), \
177:             "Counts and block indices must be list or ndarray."
178:         counts = np.asarray(counts, dtype=np.int32)
179:         blocks_i = np.asarray(blocks_i, dtype=np.int32)
180:         blocks_j = np.asarray(blocks_j, dtype=np.int32)
181:         # ------------------------------------------------------------------
182:         # Normalise the pair ordering so that i ≤ j
183:         # ------------------------------------------------------------------
184:         swap_mask = blocks_i > blocks_j
185:         if swap_mask.any():
186:             blocks_i, blocks_j = blocks_i.copy(), blocks_j.copy()  # avoid aliasing
187:             blocks_i[swap_mask], blocks_j[swap_mask] = blocks_j[swap_mask], blocks_i[swap_mask]
188:         # ------------------------------------------------------------------
189:         # Encode pairs → scalar keys and reduce duplicates in *one* pass
190:         # ------------------------------------------------------------------
191:         n_blocks = self.n_blocks
192:         keys = blocks_i.astype(np.int64) * n_blocks + blocks_j
193:         # ``np.unique`` already sorts – good for cache locality
194:         uniq_keys, inverse = np.unique(keys, return_inverse=True)
195:         reduced = np.zeros_like(uniq_keys, dtype=np.int32)
196:         np.add.at(reduced, inverse, counts)
197:         # ------------------------------------------------------------------
198:         # Decode unique keys and perform bulk update via the fast method
199:         # ------------------------------------------------------------------
200:         rows = (uniq_keys // n_blocks).astype(np.int32)
201:         cols = (uniq_keys %  n_blocks).astype(np.int32)
202:         for r, c, dv in zip(rows, cols, reduced):
203:             if dv != 0:
204:                 self._increment(block_i=int(r), block_j=int(c), count=int(dv))

================
File: src/sbm/sampling.py
================
  1: """ 
  2: Functions for sampling graph from SBM model
  3: """
  4: # sbm/sampling.py
  5: from typing import List, Optional
  6: import numpy as np
  7: from scipy.sparse import csr_array, coo_matrix
  8: from sbm.graph_data import GraphData
  9: from sbm.io import SBMFit
 10: def sample_adjacency_matrix(
 11:     block_sizes: List[int],
 12:     block_connectivity: csr_array,
 13:     rng: np.random.Generator,
 14:     directed: bool = False,
 15: ) -> csr_array:
 16:     """
 17:     Draw a random graph from the *profile* Bernoulli SBM specified by
 18:     `block_edge_counts` (edge counts m_rs) and `block_sizes`.
 19:     :param block_sizes: Sizes of the blocks.
 20:     :param block_connectivity: Sparse matrix of edge counts m_rs between blocks.
 21:     :param directed: Whether the graph is directed or undirected.
 22:     :param rng: Random number generator for reproducibility.
 23:     :return: Sparse adjacency matrix of the sampled graph.
 24:     """
 25:     block_sizes = list(map(int, block_sizes))
 26:     B = len(block_sizes)
 27:     N = sum(block_sizes)
 28:     # cumulative offsets → map local idx → global idx
 29:     offsets = np.cumsum([0] + block_sizes)
 30:     rows: list[int] = []
 31:     cols: list[int] = []
 32:     # ------------------------------------------------------------------
 33:     for r in range(B):
 34:         n_r = block_sizes[r]
 35:         off_r = offsets[r]
 36:         # -- diagonal block -------------------------------------------
 37:         m_rr = int(block_connectivity[r, r]) # type: ignore
 38:         if m_rr:
 39:             if directed:
 40:                 n_poss = n_r * (n_r - 1)
 41:                 p = m_rr / n_poss
 42:                 mask = (rng.random((n_r, n_r)) < p).astype(int)
 43:                 mask[np.diag_indices(n_r)] = 0
 44:                 rr, cc = np.nonzero(mask)
 45:                 rows.extend(off_r + rr)
 46:                 cols.extend(off_r + cc)
 47:             else:
 48:                 n_poss = n_r * (n_r - 1) // 2
 49:                 p = m_rr / n_poss
 50:                 triu_mask = rng.random((n_r, n_r)) < p
 51:                 tri_r, tri_c = np.triu_indices(n_r, k=1)
 52:                 sel = triu_mask[tri_r, tri_c]
 53:                 rr = tri_r[sel]; cc = tri_c[sel]
 54:                 rows.extend(off_r + rr)
 55:                 cols.extend(off_r + cc)
 56:                 rows.extend(off_r + cc)
 57:                 cols.extend(off_r + rr)
 58:         # -- off-diagonal blocks --------------------------------------
 59:         s_iter = range(B) if directed else range(r + 1, B)
 60:         for s in s_iter:
 61:             if s == r:
 62:                 continue
 63:             m_rs = int(block_connectivity[r, s]) # type: ignore
 64:             if m_rs == 0:
 65:                 continue
 66:             n_s = block_sizes[s]
 67:             off_s = offsets[s]
 68:             n_poss = n_r * n_s
 69:             p = m_rs / n_poss
 70:             mask = rng.random((n_r, n_s)) < p
 71:             rr, cc = np.nonzero(mask)
 72:             rows.extend(off_r + rr)
 73:             cols.extend(off_s + cc)
 74:             if not directed:
 75:                 # mirror block
 76:                 rows.extend(off_s + cc)
 77:                 cols.extend(off_r + rr)
 78:     data = np.ones(len(rows), dtype=np.int8)
 79:     adj = coo_matrix((data, (rows, cols)), shape=(N, N))
 80:     # ensure no duplicate edge
 81:     adj.sum_duplicates() 
 82:     adj.data.fill(1)
 83:     # convert to csr format
 84:     adj = csr_array(adj)
 85:     adj.sort_indices()
 86:     return adj
 87: def sample_sbm_graph(
 88:             block_sizes: List[int],
 89:             block_connectivity: csr_array,
 90:             directed:bool,
 91:             rng: np.random.Generator,
 92:             metadata: Optional[dict] = None
 93:     )->GraphData:
 94:     """
 95:     Sample a graph from a Stochastic Block Model (SBM) given block sizes and connectivity.
 96:     :param block_sizes: List of sizes for each block.
 97:     :param block_connectivity: Sparse matrix representing connectivity between blocks.
 98:     :param directed: Whether the graph is directed or undirected.
 99:     :param rng: Random number generator for reproducibility.
100:     :param metadata: Optional metadata to include in the graph data.
101:     :return: GraphData object containing the sampled graph.
102:     """
103:     if metadata is None:
104:         metadata = {}
105:     # Validate inputs
106:     if not isinstance(block_sizes, list) or not all(isinstance(size, int) for size in block_sizes):
107:         raise ValueError("block_sizes must be a list of integers.")
108:     if not isinstance(block_connectivity, csr_array):
109:         raise ValueError("block_connectivity must be a scipy.sparse.csr_array.")
110:     if len(block_sizes) != block_connectivity.shape[0] or len(block_sizes) != block_connectivity.shape[1]: #type: ignore
111:         raise ValueError("block_sizes length must match the dimensions of block_connectivity.")
112:     if not isinstance(directed, bool):
113:         raise ValueError("directed must be a boolean value.")
114:     if not isinstance(rng, np.random.Generator):
115:         raise ValueError("rng must be a numpy random Generator instance.")    
116:     adj = sample_adjacency_matrix(
117:         block_sizes=block_sizes,
118:         block_connectivity=block_connectivity,
119:         directed=directed,
120:         rng=rng
121:     )
122:     return GraphData(adjacency_matrix=adj, directed=directed)
123: def sample_sbm_graph_from_fit(sbm_fit: SBMFit, rng: np.random.Generator) -> GraphData:
124:     """
125:     Sample a graph from a Stochastic Block Model (SBM) fit.
126:     :param sbm_fit: SBMFit object containing block sizes and connectivity.
127:     :param rng: Random number generator for reproducibility.
128:     :return: GraphData object containing the sampled graph.
129:     """
130:     return sample_sbm_graph(
131:         block_sizes=sbm_fit.block_sizes,
132:         block_connectivity=sbm_fit.block_conn,
133:         directed=sbm_fit.directed_graph,
134:         rng=rng,
135:         metadata=sbm_fit.metadata
136:     )

================
File: .gitignore
================
 1: # --------------------------------------------------------------------
 2: #  Python byte-code / build artefacts
 3: # --------------------------------------------------------------------
 4: __pycache__/
 5: *.py[cod]
 6: *.pyo
 7: *.so
 8: *.dylib
 9: *.egg-info/
10: build/
11: dist/
12: 
13: # --------------------------------------------------------------------
14: #  Virtual-envs
15: # --------------------------------------------------------------------
16: .venv/
17: .env/
18: .mamba/
19: *.conda_env/
20: 
21: # --------------------------------------------------------------------
22: #  Data & model artefacts  (generated by pipeline)
23: # --------------------------------------------------------------------
24: data/
25: models/
26: logs/
27: reports/
28: figures/
29: results/
30: 
31: # --------------------------------------------------------------------
32: #  Large numpy / scipy files anywhere but src/tests
33: # --------------------------------------------------------------------
34: *.npz
35: *.npy
36: *.pkl
37: *.h5
38: *.parquet
39: 
40: # --------------------------------------------------------------------
41: #  Jupyter checkpoints
42: # --------------------------------------------------------------------
43: .ipynb_checkpoints/
44: 
45: # --------------------------------------------------------------------
46: #  IDE / OS metadata
47: # --------------------------------------------------------------------
48: .idea/
49: .vscode/
50: *.swp
51: .DS_Store
52: Thumbs.db
53: 
54: # --------------------------------------------------------------------
55: #  Misc
56: # --------------------------------------------------------------------
57: *.bak
58: *.tmp
59: repomix-output.txt
60: *.lprof

================
File: tmp_test.py
================
 1: import numpy as np
 2: import scipy.sparse as sp
 3: import line_profiler
 4: from sbm.io import SBMFit
 5: from sbm.noisy_fit import create_sbm_noise
 6: EPS, DELTA, ALPHA = 1.0, 1e-6, 0.999
 7: RNG = np.random.default_rng(0)
 8: @line_profiler.profile
 9: def _make_sbm(block_sizes, P):
10:     """
11:     Create an SBMFit with integer edge counts according to prob-matrix P.
12:     P must be square len(block_sizes) × len(block_sizes), symmetric.
13:     """
14:     k_vec = np.array(block_sizes, int)
15:     B = len(k_vec)
16:     data, rows, cols = [], [], []
17:     for r in range(B):
18:         for s in range(r, B):
19:             N = k_vec[r] * k_vec[s] if r != s else k_vec[r] * (k_vec[r] - 1) // 2
20:             m = int(round(P[r, s] * N))
21:             if m > 0:
22:                 rows.append(r); cols.append(s); data.append(m)
23:     M = sp.csr_array((data, (rows, cols)), shape=(B, B))
24:     M = M + M.T - sp.diags(M.diagonal())
25:     return SBMFit(
26:         block_sizes=list(block_sizes),
27:         block_conn=M,
28:         directed_graph=False,
29:         neg_loglike=-1.0,
30:         metadata={},
31:     )
32: def test_sample_integrity():
33:     P = np.array([[0.8, 0.3],
34:                   [0.3, 0.05]])
35:     sbm   = _make_sbm([3, 4], P)
36:     print('check')
37:     noise = create_sbm_noise(sbm, EPS, DELTA, ALPHA,
38:                              noise_type="heterogeneous_gaussian")
39:     print('check 2')
40:     sbm_noisy = noise.sample_sbm_fit(RNG)
41:     print('check 3')
42: def test_big_blocks_memory():
43:     B = 100
44:     k = 3
45:     sizes = [k] * B
46:     P = np.full((B, B), 0.1)
47:     np.fill_diagonal(P, 0.2)
48:     sbm = _make_sbm(sizes, P)          # builds sparse counts
49:     nz = create_sbm_noise(sbm, 1.0, 1e-6, 0.999,
50:                           noise_type="heterogeneous_gaussian")
51: if __name__ == "__main__":
52:     test_sample_integrity()

================
File: notebooks/move_type_comparisons_30-06-2025.ipynb
================
  1: {
  2:  "cells": [
  3:   {
  4:    "cell_type": "code",
  5:    "execution_count": 1,
  6:    "id": "0c56f619",
  7:    "metadata": {},
  8:    "outputs": [],
  9:    "source": [
 10:     "# Notebook for comparing move-types and their resulting likelihood trajectories"
 11:    ]
 12:   },
 13:   {
 14:    "cell_type": "code",
 15:    "execution_count": 2,
 16:    "id": "ca236c42",
 17:    "metadata": {},
 18:    "outputs": [],
 19:    "source": [
 20:     "from pathlib import Path\n",
 21:     "\n",
 22:     "import numpy as np\n",
 23:     "import pandas as pd\n",
 24:     "import scipy.sparse as sp\n",
 25:     "\n",
 26:     "from sbm.io import GraphLoader\n",
 27:     "from sbm.model import SBMModel\n",
 28:     "\n",
 29:     "from sbm.utils.pipeline_utils import (\n",
 30:     "    sbmfit_folderpath,\n",
 31:     "    FitConfig,\n",
 32:     ")"
 33:    ]
 34:   },
 35:   {
 36:    "cell_type": "code",
 37:    "execution_count": 3,
 38:    "id": "75c16b11",
 39:    "metadata": {},
 40:    "outputs": [],
 41:    "source": [
 42:     "g = GraphLoader.load(\n",
 43:     "    Path(\"/Users/lmmi/anon_sbm/data/processed/congress_twitter.edgelist\"),\n",
 44:     "    force_undirected=True, # type: ignore\n",
 45:     "    )"
 46:    ]
 47:   },
 48:   {
 49:    "cell_type": "code",
 50:    "execution_count": 4,
 51:    "id": "e54ed4ac",
 52:    "metadata": {},
 53:    "outputs": [],
 54:    "source": [
 55:     "rng = np.random.default_rng(1) # type: ignore"
 56:    ]
 57:   },
 58:   {
 59:    "cell_type": "code",
 60:    "execution_count": 5,
 61:    "id": "e8d0bf40",
 62:    "metadata": {},
 63:    "outputs": [],
 64:    "source": [
 65:     "from sbm.block_assigner import AssignerConstructor\n",
 66:     "\n",
 67:     "assigner_const = AssignerConstructor(rng=rng)\n",
 68:     "assigner = assigner_const.create_assigner(\n",
 69:     "    graph_data=g,\n",
 70:     "    min_block_size=5, # type: ignore\n",
 71:     "    init_method=\"metis_refine\", # type: ignore\n",
 72:     "    )"
 73:    ]
 74:   },
 75:   {
 76:    "cell_type": "code",
 77:    "execution_count": 6,
 78:    "id": "ecbbb1c7",
 79:    "metadata": {},
 80:    "outputs": [],
 81:    "source": [
 82:     "min_block_size = 5\n",
 83:     "cooling_rate = 0.9999\n",
 84:     "max_blocks = None\n",
 85:     "patience  = int(1e3)\n",
 86:     "return_nll = True"
 87:    ]
 88:   },
 89:   {
 90:    "cell_type": "code",
 91:    "execution_count": 7,
 92:    "id": "51e49a44",
 93:    "metadata": {},
 94:    "outputs": [
 95:     {
 96:      "name": "stdout",
 97:      "output_type": "stream",
 98:      "text": [
 99:       "\n",
100:       "\n",
101:       "Failed to import TensorFlow. Please note that TensorFlow is not installed by default when you install TensorFlow Probability. This is so that users can decide whether to install the GPU-enabled TensorFlow package. To use TensorFlow Probability, please install the most recent version of TensorFlow, by following instructions at https://tensorflow.org/install.\n",
102:       "\n",
103:       "\n"
104:      ]
105:     },
106:     {
107:      "ename": "ModuleNotFoundError",
108:      "evalue": "No module named 'tensorflow'",
109:      "output_type": "error",
110:      "traceback": [
111:       "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
112:       "\u001b[31mModuleNotFoundError\u001b[39m                       Traceback (most recent call last)",
113:       "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[7]\u001b[39m\u001b[32m, line 2\u001b[39m\n\u001b[32m      1\u001b[39m initial_blocks = assigner.compute_assignment()\n\u001b[32m----> \u001b[39m\u001b[32m2\u001b[39m uniform_swap_model = \u001b[43mSBMModel\u001b[49m\u001b[43m(\u001b[49m\n\u001b[32m      3\u001b[39m \u001b[43m    \u001b[49m\u001b[43minitial_blocks\u001b[49m\u001b[43m=\u001b[49m\u001b[43minitial_blocks\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m      4\u001b[39m \u001b[43m    \u001b[49m\u001b[43mrng\u001b[49m\u001b[43m=\u001b[49m\u001b[43mrng\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m      5\u001b[39m \u001b[43m    \u001b[49m\u001b[43mchange_freq\u001b[49m\u001b[43m \u001b[49m\u001b[43m=\u001b[49m\u001b[43m \u001b[49m\u001b[43m{\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;66;43;03m# probabilities of trying each move type\u001b[39;49;00m\n\u001b[32m      6\u001b[39m \u001b[43m        \u001b[49m\u001b[33;43m\"\u001b[39;49m\u001b[33;43muniform_swap\u001b[39;49m\u001b[33;43m\"\u001b[39;49m\u001b[43m:\u001b[49m\u001b[43m \u001b[49m\u001b[32;43m1\u001b[39;49m\u001b[43m,\u001b[49m\n\u001b[32m      7\u001b[39m \u001b[43m    \u001b[49m\u001b[43m}\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m      8\u001b[39m \u001b[43m)\u001b[49m\n\u001b[32m     10\u001b[39m uniform_nll = uniform_swap_model.fit(\n\u001b[32m     11\u001b[39m     min_block_size=min_block_size,\n\u001b[32m     12\u001b[39m     cooling_rate=cooling_rate,\n\u001b[32m   (...)\u001b[39m\u001b[32m     15\u001b[39m     return_nll=\u001b[38;5;28;01mTrue\u001b[39;00m,\n\u001b[32m     16\u001b[39m )\n\u001b[32m     17\u001b[39m block_data = uniform_swap_model.block_data\n",
114:       "\u001b[36mFile \u001b[39m\u001b[32m~/anon_sbm/src/sbm/model.py:77\u001b[39m, in \u001b[36mSBMModel.__init__\u001b[39m\u001b[34m(self, initial_blocks, rng, likelihood_type, logger, change_freq)\u001b[39m\n\u001b[32m     46\u001b[39m \u001b[38;5;28mself\u001b[39m.move_executor = NodeMover(\n\u001b[32m     47\u001b[39m     block_data=\u001b[38;5;28mself\u001b[39m.block_data,\n\u001b[32m     48\u001b[39m     )\n\u001b[32m     50\u001b[39m change_proposer = {\n\u001b[32m     51\u001b[39m     \u001b[33m\"\u001b[39m\u001b[33muniform_swap\u001b[39m\u001b[33m\"\u001b[39m: NodeSwapProposer(\n\u001b[32m     52\u001b[39m                 block_data=\u001b[38;5;28mself\u001b[39m.block_data,\n\u001b[32m   (...)\u001b[39m\u001b[32m     75\u001b[39m             ),\n\u001b[32m     76\u001b[39m }\n\u001b[32m---> \u001b[39m\u001b[32m77\u001b[39m \u001b[38;5;28mself\u001b[39m.mcmc_algorithm = \u001b[43mMCMCAlgorithm\u001b[49m\u001b[43m(\u001b[49m\n\u001b[32m     78\u001b[39m \u001b[43m    \u001b[49m\u001b[43mblock_data\u001b[49m\u001b[43m \u001b[49m\u001b[43m=\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43mblock_data\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m     79\u001b[39m \u001b[43m    \u001b[49m\u001b[43mlikelihood_calculator\u001b[49m\u001b[43m \u001b[49m\u001b[43m=\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43mlikelihood_calculator\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m     80\u001b[39m \u001b[43m    \u001b[49m\u001b[43mchange_proposer\u001b[49m\u001b[43m \u001b[49m\u001b[43m=\u001b[49m\u001b[43m \u001b[49m\u001b[43mchange_proposer\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;66;43;03m# type: ignore\u001b[39;49;00m\n\u001b[32m     81\u001b[39m \u001b[43m    \u001b[49m\u001b[43mchange_freq\u001b[49m\u001b[43m \u001b[49m\u001b[43m=\u001b[49m\u001b[43m \u001b[49m\u001b[43mchange_freq\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;66;43;03m# type: ignore\u001b[39;49;00m\n\u001b[32m     82\u001b[39m \u001b[43m    \u001b[49m\u001b[43mrng\u001b[49m\u001b[43m \u001b[49m\u001b[43m=\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43mrng\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m     83\u001b[39m \u001b[43m    \u001b[49m\u001b[43mlogger\u001b[49m\u001b[43m=\u001b[49m\u001b[43mlogger\u001b[49m\n\u001b[32m     84\u001b[39m \u001b[43m\u001b[49m\u001b[43m)\u001b[49m\n",
115:       "\u001b[36mFile \u001b[39m\u001b[32m~/anon_sbm/src/sbm/mcmc.py:54\u001b[39m, in \u001b[36mMCMCAlgorithm.__init__\u001b[39m\u001b[34m(self, block_data, likelihood_calculator, change_proposer, rng, logger, monitor, diag_lag, diag_checkpoints, change_freq)\u001b[39m\n\u001b[32m     52\u001b[39m \u001b[38;5;28mself\u001b[39m._monitor = monitor\n\u001b[32m     53\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m monitor:\n\u001b[32m---> \u001b[39m\u001b[32m54\u001b[39m     \u001b[38;5;28mself\u001b[39m._diag= \u001b[43mOnlineDiagnostics\u001b[49m\u001b[43m(\u001b[49m\u001b[43mmax_lag\u001b[49m\u001b[43m=\u001b[49m\u001b[43mdiag_lag\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m     55\u001b[39m     \u001b[38;5;28mself\u001b[39m._diag_checkpoints = diag_checkpoints\n\u001b[32m     56\u001b[39m     \u001b[38;5;28mself\u001b[39m._off_diag = \u001b[38;5;28mself\u001b[39m._select_off_pairs(max_panel=diag_checkpoints)\n",
116:       "\u001b[36mFile \u001b[39m\u001b[32m~/anon_sbm/src/sbm/mcmc_diagnostics.py:38\u001b[39m, in \u001b[36mOnlineDiagnostics.__init__\u001b[39m\u001b[34m(self, max_lag)\u001b[39m\n\u001b[32m     36\u001b[39m \u001b[38;5;28;01mdef\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34m__init__\u001b[39m(\u001b[38;5;28mself\u001b[39m, max_lag: \u001b[38;5;28mint\u001b[39m = \u001b[32m100\u001b[39m) -> \u001b[38;5;28;01mNone\u001b[39;00m:\n\u001b[32m     37\u001b[39m     \u001b[38;5;66;03m# --- R̂ and ESS reducers ----------------------------------------------\u001b[39;00m\n\u001b[32m---> \u001b[39m\u001b[32m38\u001b[39m     \u001b[38;5;28mself\u001b[39m._rhat_red = \u001b[43mtfp\u001b[49m\u001b[43m.\u001b[49m\u001b[43mexperimental\u001b[49m\u001b[43m.\u001b[49m\u001b[43mmcmc\u001b[49m.PotentialScaleReductionReducer(\n\u001b[32m     39\u001b[39m         independent_chain_ndims=\u001b[32m1\u001b[39m          \u001b[38;5;66;03m# <- 1 statistic axis\u001b[39;00m\n\u001b[32m     40\u001b[39m     )\n\u001b[32m     41\u001b[39m     \u001b[38;5;28mself\u001b[39m._ess_red  = tfp.experimental.mcmc.CovarianceReducer(\n\u001b[32m     42\u001b[39m         max_lags=max_lag,                  \u001b[38;5;66;03m# Geyer truncation window\u001b[39;00m\n\u001b[32m     43\u001b[39m         independent_chain_ndims=\u001b[32m1\u001b[39m\n\u001b[32m     44\u001b[39m     )\n",
117:       "\u001b[36mFile \u001b[39m\u001b[32m/opt/homebrew/Caskroom/miniforge/base/envs/anon_sbm_notebook_arm/lib/python3.12/site-packages/tensorflow_probability/python/internal/lazy_loader.py:56\u001b[39m, in \u001b[36mLazyLoader.__getattr__\u001b[39m\u001b[34m(self, item)\u001b[39m\n\u001b[32m     55\u001b[39m \u001b[38;5;28;01mdef\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34m__getattr__\u001b[39m(\u001b[38;5;28mself\u001b[39m, item):\n\u001b[32m---> \u001b[39m\u001b[32m56\u001b[39m   module = \u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43m_load\u001b[49m\u001b[43m(\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m     57\u001b[39m   \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28mgetattr\u001b[39m(module, item)\n",
118:       "\u001b[36mFile \u001b[39m\u001b[32m/opt/homebrew/Caskroom/miniforge/base/envs/anon_sbm_notebook_arm/lib/python3.12/site-packages/tensorflow_probability/python/internal/lazy_loader.py:40\u001b[39m, in \u001b[36mLazyLoader._load\u001b[39m\u001b[34m(self)\u001b[39m\n\u001b[32m     38\u001b[39m \u001b[38;5;250m\u001b[39m\u001b[33;03m\"\"\"Load the module and insert it into the parent's globals.\"\"\"\u001b[39;00m\n\u001b[32m     39\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28mcallable\u001b[39m(\u001b[38;5;28mself\u001b[39m._on_first_access):\n\u001b[32m---> \u001b[39m\u001b[32m40\u001b[39m   \u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43m_on_first_access\u001b[49m\u001b[43m(\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m     41\u001b[39m   \u001b[38;5;28mself\u001b[39m._on_first_access = \u001b[38;5;28;01mNone\u001b[39;00m\n\u001b[32m     42\u001b[39m \u001b[38;5;66;03m# Import the target module and insert it into the parent's namespace\u001b[39;00m\n",
119:       "\u001b[36mFile \u001b[39m\u001b[32m/opt/homebrew/Caskroom/miniforge/base/envs/anon_sbm_notebook_arm/lib/python3.12/site-packages/tensorflow_probability/python/__init__.py:38\u001b[39m, in \u001b[36m_validate_tf_environment\u001b[39m\u001b[34m(package)\u001b[39m\n\u001b[32m     27\u001b[39m \u001b[38;5;250m\u001b[39m\u001b[33;03m\"\"\"Check TF version and (depending on package) warn about TensorFloat32.\u001b[39;00m\n\u001b[32m     28\u001b[39m \n\u001b[32m     29\u001b[39m \u001b[33;03mArgs:\u001b[39;00m\n\u001b[32m   (...)\u001b[39m\u001b[32m     35\u001b[39m \u001b[33;03m    inadequate.\u001b[39;00m\n\u001b[32m     36\u001b[39m \u001b[33;03m\"\"\"\u001b[39;00m\n\u001b[32m     37\u001b[39m \u001b[38;5;28;01mtry\u001b[39;00m:\n\u001b[32m---> \u001b[39m\u001b[32m38\u001b[39m   \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01mtensorflow\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mas\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01mtf\u001b[39;00m\n\u001b[32m     39\u001b[39m \u001b[38;5;28;01mexcept\u001b[39;00m (\u001b[38;5;167;01mImportError\u001b[39;00m, \u001b[38;5;167;01mModuleNotFoundError\u001b[39;00m):\n\u001b[32m     40\u001b[39m   \u001b[38;5;66;03m# Print more informative error message, then reraise.\u001b[39;00m\n\u001b[32m     41\u001b[39m   \u001b[38;5;28mprint\u001b[39m(\u001b[33m'\u001b[39m\u001b[38;5;130;01m\\n\u001b[39;00m\u001b[38;5;130;01m\\n\u001b[39;00m\u001b[33mFailed to import TensorFlow. Please note that TensorFlow is not \u001b[39m\u001b[33m'\u001b[39m\n\u001b[32m     42\u001b[39m         \u001b[33m'\u001b[39m\u001b[33minstalled by default when you install TensorFlow Probability. This \u001b[39m\u001b[33m'\u001b[39m\n\u001b[32m     43\u001b[39m         \u001b[33m'\u001b[39m\u001b[33mis so that users can decide whether to install the GPU-enabled \u001b[39m\u001b[33m'\u001b[39m\n\u001b[32m     44\u001b[39m         \u001b[33m'\u001b[39m\u001b[33mTensorFlow package. To use TensorFlow Probability, please install \u001b[39m\u001b[33m'\u001b[39m\n\u001b[32m     45\u001b[39m         \u001b[33m'\u001b[39m\u001b[33mthe most recent version of TensorFlow, by following instructions at \u001b[39m\u001b[33m'\u001b[39m\n\u001b[32m     46\u001b[39m         \u001b[33m'\u001b[39m\u001b[33mhttps://tensorflow.org/install.\u001b[39m\u001b[38;5;130;01m\\n\u001b[39;00m\u001b[38;5;130;01m\\n\u001b[39;00m\u001b[33m'\u001b[39m)\n",
120:       "\u001b[31mModuleNotFoundError\u001b[39m: No module named 'tensorflow'"
121:      ]
122:     }
123:    ],
124:    "source": [
125:     "initial_blocks = assigner.compute_assignment()\n",
126:     "uniform_swap_model = SBMModel(\n",
127:     "    initial_blocks=initial_blocks,\n",
128:     "    rng=rng,\n",
129:     "    change_freq = { # probabilities of trying each move type\n",
130:     "        \"uniform_swap\": 1,\n",
131:     "    },\n",
132:     ")\n",
133:     "\n",
134:     "uniform_nll = uniform_swap_model.fit(\n",
135:     "    min_block_size=min_block_size,\n",
136:     "    cooling_rate=cooling_rate,\n",
137:     "    max_blocks=max_blocks,\n",
138:     "    patience=10**3,\n",
139:     "    return_nll=True,\n",
140:     ")\n",
141:     "block_data = uniform_swap_model.block_data"
142:    ]
143:   },
144:   {
145:    "cell_type": "code",
146:    "execution_count": null,
147:    "id": "b50abed4",
148:    "metadata": {},
149:    "outputs": [
150:     {
151:      "name": "stdout",
152:      "output_type": "stream",
153:      "text": [
154:       "Stopping early after 28371 iterations due to patience limit.\n"
155:      ]
156:     }
157:    ],
158:    "source": [
159:     "initial_blocks = assigner.compute_assignment()\n",
160:     "mix_swap_model = SBMModel(\n",
161:     "    initial_blocks=initial_blocks,\n",
162:     "    rng=rng,\n",
163:     "    change_freq = { # probabilities of trying each move type\n",
164:     "        #\"uniform_swap\": 0.5,\n",
165:     "        \"edge_based_swap\": 1,\n",
166:     "    },\n",
167:     ")\n",
168:     "\n",
169:     "mix_nll = mix_swap_model.fit(\n",
170:     "    min_block_size=min_block_size,\n",
171:     "    cooling_rate=cooling_rate,\n",
172:     "    max_blocks=max_blocks,\n",
173:     "    patience=10**3,\n",
174:     "    return_nll=True,\n",
175:     ")"
176:    ]
177:   },
178:   {
179:    "cell_type": "code",
180:    "execution_count": null,
181:    "id": "10298ee8",
182:    "metadata": {},
183:    "outputs": [
184:     {
185:      "data": {
186:       "image/png": "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441qvXv37njkkUdK7bUnT56MqKioAvtXr16NESNGlFo7iIhKg6lUXoWIiDwiOzsbwcHBl/z8SpUqubU9RETegD3ARERe2BO8aNEiTJgwAZqmqeXAgQPq2JYtW9CvXz9EREQgNjYWgwcPxsmTJx3PlZ7jhx56SPUeV6xYEX369FH733vvPTRr1gxlypRB9erV8eCDDyI9PV0dW7hwIYYNG4bU1FTH67388suFpkAcOnQIN9xwg3r9yMhI3HbbbUhMTHQcl+e1bNkS33//vXpuuXLlMHDgQJw5c6bU7h8R0cUwACYi8jIS+Hbs2BH33XcfEhIS1CJBa0pKCq666iq0atUKa9aswT///KOCTwlCnX377beq13fp0qWYOHGi2mcwGPDhhx9i69at6vj8+fPx1FNPqWOdOnVSQa4EtPbXe+KJJwq0y2q1quA3OTlZBehz587Fvn37cPvtt7uct3fvXkybNg0zZsxQi5z75ptvlug9IyIqDqZAEBF5Gek1lQA2PDwclStXduz/+OOPVfA7duxYx75vvvlGBce7du1C/fr11b569eph/PjxLtd0zieWntnXX38dDzzwAD799FP1WvKa0vPr/Hr5zZs3D5s3b8b+/fvVa4rvvvsOTZo0UbnC7dq1cwTKklNctmxZtS291PLcN954w233iIjocrAHmIjIR2zcuBELFixQ6Qf2pWHDho5eV7s2bdoUeO6///6Lnj17omrVqiowlaD01KlTOHfuXJFff/v27SrwtQe/onHjxmrwnBxzDrDtwa+Ii4tDUlLSJb1nIqKSwB5gIiIfITm71113Hd56660CxyTItJM8X2eSP3zttddi5MiRqhe2fPnyWLJkCYYPH64GyUlPszsFBQW5bEvPsvQKExF5CwbAREReSNISLBaLy77WrVtj6tSpqofVZCr6r++1a9eqAPTdd99VucDi119/vejr5deoUSMcPnxYLfZe4G3btqncZOkJJiLyFUyBICLyQhLkrly5UvXeSpUHCWBHjRqlBqDdcccdKudW0h5mz56tKjhcKHitW7cucnJy8NFHH6lBa1KhwT44zvn1pIdZcnXl9QpLjejVq5eqJDFo0CCsW7cOq1atwpAhQ9CtWze0bdu2RO4DEVFJYABMROSFpAqD0WhUPatSi1fKj1WpUkVVdpBgt3fv3ioYlcFtkoNr79ktTIsWLVQZNEmdaNq0KX744QeMGzfO5RypBCGD4qSig7xe/kF09lSGP//8E9HR0ejatasKiGvXro1ffvmlRO4BEVFJ0XRd10vs6kREREREXoY9wEREREQUUBgAExEREVFAYQBMRERERAGFATARERERBRQGwEREREQUUBgAExEREVFAYQBMRERERAGFATARERERBRQGwEREREQUUBgAExEREVFAYQBMRERERAGFATARERERIZD8PygTIG0v/GOiAAAAAElFTkSuQmCC",
187:       "text/plain": [
188:        "<Figure size 800x600 with 1 Axes>"
189:       ]
190:      },
191:      "metadata": {},
192:      "output_type": "display_data"
193:     }
194:    ],
195:    "source": [
196:     "# comparing initial methods\n",
197:     "import matplotlib.pyplot as plt\n",
198:     "fig, ax = plt.subplots(figsize=(8,6))\n",
199:     "\n",
200:     "ax.plot(np.arange(len(uniform_nll)),uniform_nll, label=\"Uniform Swap\", color=\"salmon\")# type: ignore\n",
201:     "\n",
202:     "ax.plot(np.arange(len(mix_nll)), mix_nll, label=\"Edge-biased swap\", color=\"slategrey\") # type: ignore\n",
203:     "\n",
204:     "ax.set_xlabel(\"Iteration\")\n",
205:     "ax.set_ylabel(\"Log Likelihood\")\n",
206:     "\n",
207:     "ax.legend()\n",
208:     "plt.show(fig)"
209:    ]
210:   },
211:   {
212:    "cell_type": "code",
213:    "execution_count": null,
214:    "id": "73af6cbf",
215:    "metadata": {},
216:    "outputs": [],
217:    "source": [
218:     "uniform_swap_model = SBMModel(\n",
219:     "    initial_blocks=block_data,\n",
220:     "    rng=rng,\n",
221:     "    change_freq = { # probabilities of trying each move type\n",
222:     "        \"uniform_swap\": 1.0,\n",
223:     "    },\n",
224:     ")\n",
225:     "\n",
226:     "edge_swap_model = SBMModel(\n",
227:     "    initial_blocks=block_data,\n",
228:     "    rng=rng,\n",
229:     "    change_freq = { # probabilities of trying each move type\n",
230:     "    \"edge_based_swap\": 1.0,\n",
231:     "    },\n",
232:     ")\n",
233:     "triad_swap_model = SBMModel(\n",
234:     "    initial_blocks=block_data,\n",
235:     "    rng=rng,\n",
236:     "    change_freq = { # probabilities of trying each move type\n",
237:     "    \"triadic_swap\": 1.0,\n",
238:     "    },\n",
239:     ")\n",
240:     "cross_swap_model = SBMModel(\n",
241:     "    initial_blocks=block_data,\n",
242:     "    rng=rng,\n",
243:     "    change_freq = { # probabilities of trying each move type\n",
244:     "    \"cross_triangle\": 1.0,\n",
245:     "    },\n",
246:     ")\n",
247:     "mix_swap_model = SBMModel(\n",
248:     "    initial_blocks=block_data,\n",
249:     "    rng=rng,\n",
250:     "    change_freq = {\n",
251:     "    \"edge_based_swap\": 0.6,\n",
252:     "    \"triadic_swap\": 0.2,\n",
253:     "    \"twin_leaf\": 0.15,\n",
254:     "    \"uniform_swap\": 0.05\n",
255:     "    },\n",
256:     ")"
257:    ]
258:   },
259:   {
260:    "cell_type": "code",
261:    "execution_count": null,
262:    "id": "574ec66f",
263:    "metadata": {},
264:    "outputs": [
265:     {
266:      "name": "stdout",
267:      "output_type": "stream",
268:      "text": [
269:       "Stopping early after 6552 iterations due to patience limit.\n"
270:      ]
271:     }
272:    ],
273:    "source": [
274:     "uniform_nll = uniform_swap_model.fit(\n",
275:     "    min_block_size=min_block_size,\n",
276:     "    cooling_rate=cooling_rate,\n",
277:     "    max_blocks=max_blocks,\n",
278:     "    patience=patience,\n",
279:     "    return_nll=return_nll,\n",
280:     ")"
281:    ]
282:   },
283:   {
284:    "cell_type": "code",
285:    "execution_count": null,
286:    "id": "76f33e97",
287:    "metadata": {},
288:    "outputs": [
289:     {
290:      "name": "stdout",
291:      "output_type": "stream",
292:      "text": [
293:       "Stopping early after 11427 iterations due to patience limit.\n"
294:      ]
295:     }
296:    ],
297:    "source": [
298:     "edge_nll = edge_swap_model.fit(\n",
299:     "    min_block_size=min_block_size,\n",
300:     "    cooling_rate=cooling_rate,\n",
301:     "    max_blocks=max_blocks,\n",
302:     "    patience=patience,\n",
303:     "    return_nll=return_nll,\n",
304:     ")"
305:    ]
306:   },
307:   {
308:    "cell_type": "code",
309:    "execution_count": null,
310:    "id": "96b956a2",
311:    "metadata": {},
312:    "outputs": [
313:     {
314:      "name": "stdout",
315:      "output_type": "stream",
316:      "text": [
317:       "Stopping early after 5153 iterations due to patience limit.\n"
318:      ]
319:     }
320:    ],
321:    "source": [
322:     "triad_nll = triad_swap_model.fit(\n",
323:     "    min_block_size=min_block_size,\n",
324:     "    cooling_rate=cooling_rate,\n",
325:     "    max_blocks=max_blocks,\n",
326:     "    patience=patience,\n",
327:     "    return_nll=return_nll,\n",
328:     ")"
329:    ]
330:   },
331:   {
332:    "cell_type": "code",
333:    "execution_count": null,
334:    "id": "d5a89795",
335:    "metadata": {},
336:    "outputs": [
337:     {
338:      "name": "stdout",
339:      "output_type": "stream",
340:      "text": [
341:       "Stopping early after 1000 iterations due to patience limit.\n"
342:      ]
343:     }
344:    ],
345:    "source": [
346:     "mix_nll = mix_swap_model.fit(\n",
347:     "    min_block_size=min_block_size,\n",
348:     "    cooling_rate=cooling_rate,\n",
349:     "    max_blocks=max_blocks,\n",
350:     "    patience=patience,\n",
351:     "    return_nll=return_nll,\n",
352:     ")"
353:    ]
354:   },
355:   {
356:    "cell_type": "code",
357:    "execution_count": null,
358:    "id": "c9ffcc17",
359:    "metadata": {},
360:    "outputs": [],
361:    "source": [
362:     "rng.normal(0, 1, size=1000).A1 # to make sure rng is not empty\n",
363:     "oo\n",
364:     "o"
365:    ]
366:   },
367:   {
368:    "cell_type": "code",
369:    "execution_count": null,
370:    "id": "6dc70577",
371:    "metadata": {},
372:    "outputs": [
373:     {
374:      "data": {
375:       "image/png": "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",
376:       "text/plain": [
377:        "<Figure size 800x600 with 1 Axes>"
378:       ]
379:      },
380:      "metadata": {},
381:      "output_type": "display_data"
382:     }
383:    ],
384:    "source": [
385:     "import matplotlib.pyplot as plt\n",
386:     "fig, ax = plt.subplots(figsize=(8,6))\n",
387:     "\n",
388:     "ax.plot(np.arange(len(uniform_nll)),uniform_nll, label=\"Uniform Swap\", color=\"salmon\")# type: ignore\n",
389:     "\n",
390:     "ax.plot(np.arange(len(edge_nll)), edge_nll, label=\"Edge Swap\", color=\"teal\")# type: ignore\n",
391:     "\n",
392:     "ax.plot(np.arange(len(triad_nll)), triad_nll, label=\"Triadic Swap\", color=\"black\") # type: ignore\n",
393:     "\n",
394:     "ax.plot(np.arange(len(cross_nll)), cross_nll, label=\"Cross Triangle\", color=\"slategrey\") # type: ignore\n",
395:     "\n",
396:     "ax.set_xlabel(\"Iteration\")\n",
397:     "ax.set_ylabel(\"Log Likelihood\")\n",
398:     "\n",
399:     "ax.legend()\n",
400:     "plt.show(fig)"
401:    ]
402:   },
403:   {
404:    "cell_type": "code",
405:    "execution_count": null,
406:    "id": "fc1d104a",
407:    "metadata": {},
408:    "outputs": [],
409:    "source": []
410:   }
411:  ],
412:  "metadata": {
413:   "kernelspec": {
414:    "display_name": "anon_sbm_notebook_arm",
415:    "language": "python",
416:    "name": "python3"
417:   },
418:   "language_info": {
419:    "codemirror_mode": {
420:     "name": "ipython",
421:     "version": 3
422:    },
423:    "file_extension": ".py",
424:    "mimetype": "text/x-python",
425:    "name": "python",
426:    "nbconvert_exporter": "python",
427:    "pygments_lexer": "ipython3",
428:    "version": "3.12.11"
429:   }
430:  },
431:  "nbformat": 4,
432:  "nbformat_minor": 5
433: }

================
File: notebooks/sbm_block_sizes_26-06-2025.ipynb
================
  1: {
  2:  "cells": [
  3:   {
  4:    "cell_type": "markdown",
  5:    "id": "09dbb184",
  6:    "metadata": {},
  7:    "source": [
  8:     "# Investigate SBM block sizes\n",
  9:     "We are attempting to learn SBM representations with a min-block size constraint.\n",
 10:     "\n",
 11:     "Optimally, we would like all blocks to have minimum size (gives smallest expected reconstruction error).\n",
 12:     "\n",
 13:     "The current implementation (Metis asigner) creates initial blocks, and their sizes never change. However, these initial blocks are not all minimum block size.\n",
 14:     "\n",
 15:     "Here we plot the actual block-size distributions and compare with pre-specified min-block-size."
 16:    ]
 17:   },
 18:   {
 19:    "cell_type": "code",
 20:    "execution_count": 1,
 21:    "id": "7097892b",
 22:    "metadata": {},
 23:    "outputs": [],
 24:    "source": [
 25:     "from pathlib import Path\n",
 26:     "import numpy as np\n",
 27:     "import pandas as pd\n",
 28:     "import matplotlib.pyplot as plt"
 29:    ]
 30:   },
 31:   {
 32:    "cell_type": "code",
 33:    "execution_count": 2,
 34:    "id": "8cb75b7b",
 35:    "metadata": {},
 36:    "outputs": [],
 37:    "source": [
 38:     "def get_min_block_size(string):\n",
 39:     "    # find index of substring 'min_block_size'\n",
 40:     "    index = string.find('min_block_size')\n",
 41:     "\n",
 42:     "    tail_string = string[index + len('min_block_size_'):]\n",
 43:     "    block_size = tail_string.split(\"_\")[0]\n",
 44:     "\n",
 45:     "    return int(block_size)"
 46:    ]
 47:   },
 48:   {
 49:    "cell_type": "code",
 50:    "execution_count": 4,
 51:    "id": "968e6b67",
 52:    "metadata": {},
 53:    "outputs": [
 54:     {
 55:      "name": "stdout",
 56:      "output_type": "stream",
 57:      "text": [
 58:       "Loading fit from /Users/lmmi/anon_sbm/data/sbm_fits/sbm_fit_congress_twitter_cooling_rate_0_999_force_undirected_True_init_method_ProneKMeans_max_n_iter_10000_min_block_size_3_patience_1000_temperature_1_0\n"
 59:      ]
 60:     },
 61:     {
 62:      "ename": "FileNotFoundError",
 63:      "evalue": "[Errno 2] No such file or directory: '/Users/lmmi/anon_sbm/data/sbm_fits/sbm_fit_congress_twitter_cooling_rate_0_999_force_undirected_True_init_method_ProneKMeans_max_n_iter_10000_min_block_size_3_patience_1000_temperature_1_0/block_sizes.json'",
 64:      "output_type": "error",
 65:      "traceback": [
 66:       "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
 67:       "\u001b[31mFileNotFoundError\u001b[39m                         Traceback (most recent call last)",
 68:       "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[4]\u001b[39m\u001b[32m, line 21\u001b[39m\n\u001b[32m     19\u001b[39m \u001b[38;5;28mprint\u001b[39m(\u001b[33mf\u001b[39m\u001b[33m\"\u001b[39m\u001b[33mLoading fit from \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mfit_folder_path\u001b[38;5;132;01m}\u001b[39;00m\u001b[33m\"\u001b[39m)\n\u001b[32m     20\u001b[39m min_block_size = get_min_block_size(\u001b[38;5;28mstr\u001b[39m(fit_folder_path))\n\u001b[32m---> \u001b[39m\u001b[32m21\u001b[39m sbm_fit = \u001b[43mSBMWriter\u001b[49m\u001b[43m.\u001b[49m\u001b[43mload\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfit_folder_path\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43msilence\u001b[49m\u001b[43m=\u001b[49m\u001b[38;5;28;43;01mTrue\u001b[39;49;00m\u001b[43m)\u001b[49m\n\u001b[32m     23\u001b[39m min_block_sizes.append([min_block_size] * \u001b[38;5;28mlen\u001b[39m(sbm_fit.block_sizes))\n\u001b[32m     24\u001b[39m block_sizes.append(sbm_fit.block_sizes)\n",
 69:       "\u001b[36mFile \u001b[39m\u001b[32m~/anon_sbm/src/sbm/io.py:51\u001b[39m, in \u001b[36mSBMWriter.load\u001b[39m\u001b[34m(path, silence)\u001b[39m\n\u001b[32m     48\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m silence:\n\u001b[32m     49\u001b[39m     \u001b[38;5;28mprint\u001b[39m(\u001b[33mf\u001b[39m\u001b[33m\"\u001b[39m\u001b[33mLoading SBM fit from \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mpath\u001b[38;5;132;01m}\u001b[39;00m\u001b[33m\"\u001b[39m)\n\u001b[32m---> \u001b[39m\u001b[32m51\u001b[39m \u001b[38;5;28;01mwith\u001b[39;00m \u001b[38;5;28;43mopen\u001b[39;49m\u001b[43m(\u001b[49m\u001b[43mpath\u001b[49m\u001b[43m \u001b[49m\u001b[43m/\u001b[49m\u001b[43m \u001b[49m\u001b[33;43m\"\u001b[39;49m\u001b[33;43mblock_sizes.json\u001b[39;49m\u001b[33;43m\"\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[33;43m'\u001b[39;49m\u001b[33;43mr\u001b[39;49m\u001b[33;43m'\u001b[39;49m\u001b[43m)\u001b[49m \u001b[38;5;28;01mas\u001b[39;00m sizes_file:\n\u001b[32m     52\u001b[39m     block_sizes = json.load(sizes_file)\n\u001b[32m     53\u001b[39m block_sizes = [\u001b[38;5;28mint\u001b[39m(size) \u001b[38;5;28;01mfor\u001b[39;00m size \u001b[38;5;129;01min\u001b[39;00m block_sizes]\n",
 70:       "\u001b[31mFileNotFoundError\u001b[39m: [Errno 2] No such file or directory: '/Users/lmmi/anon_sbm/data/sbm_fits/sbm_fit_congress_twitter_cooling_rate_0_999_force_undirected_True_init_method_ProneKMeans_max_n_iter_10000_min_block_size_3_patience_1000_temperature_1_0/block_sizes.json'"
 71:      ]
 72:     }
 73:    ],
 74:    "source": [
 75:     "import yaml\n",
 76:     "from sbm.utils.pipeline_utils import sbmfit_folderpath\n",
 77:     "from sbm.io import SBMWriter\n",
 78:     "\n",
 79:     "fit_config = yaml.safe_load(Path(\"/Users/lmmi/anon_sbm/configs/sbm_fit_block_size_experiments.yml\").read_text())\n",
 80:     "data_config = fit_config[\"datasets\"] # type: ignore\n",
 81:     "\n",
 82:     "min_block_sizes = []\n",
 83:     "block_sizes = []\n",
 84:     "for sbm_config in fit_config[\"sbm\"]:\n",
 85:     "    for ds in data_config:\n",
 86:     "\n",
 87:     "        # load fitted model\n",
 88:     "        fit_folder_path = sbmfit_folderpath(\n",
 89:     "            base_dir=Path(\"/Users/lmmi/anon_sbm/data/sbm_fits\"),\n",
 90:     "            sbm_config=sbm_config,# type: ignore\n",
 91:     "            data_spec=ds,\n",
 92:     "        )\n",
 93:     "        print(f\"Loading fit from {fit_folder_path}\")\n",
 94:     "        min_block_size = get_min_block_size(str(fit_folder_path))\n",
 95:     "        sbm_fit = SBMWriter.load(fit_folder_path, silence=True)\n",
 96:     "\n",
 97:     "        min_block_sizes.append([min_block_size] * len(sbm_fit.block_sizes))\n",
 98:     "        block_sizes.append(sbm_fit.block_sizes)\n"
 99:    ]
100:   },
101:   {
102:    "cell_type": "code",
103:    "execution_count": 35,
104:    "id": "7d83487f",
105:    "metadata": {},
106:    "outputs": [],
107:    "source": [
108:     "# flatten the lists\n",
109:     "min_block_sizes = np.array([ item for sublist in min_block_sizes for item in sublist ])\n",
110:     "block_sizes = np.array([ item for sublist in block_sizes for item in sublist ])"
111:    ]
112:   },
113:   {
114:    "cell_type": "code",
115:    "execution_count": 36,
116:    "id": "545352fa",
117:    "metadata": {},
118:    "outputs": [
119:     {
120:      "name": "stderr",
121:      "output_type": "stream",
122:      "text": [
123:       "/var/folders/y6/j9fbqcvx6lb5l99614n30y4c0000gn/T/ipykernel_92149/2968653449.py:7: UserWarning: FigureCanvasAgg is non-interactive, and thus cannot be shown\n",
124:       "  fig.show()\n"
125:      ]
126:     },
127:     {
128:      "data": {
129:       "image/png": "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bzmdawUhhyNvbkf9/fdmWd3GjWZcoIDUt680apRUpoy9vQEAACBvc/vEkS9fPgUHB9vdxnXJ6kxRXgpKP/xgwtGl3Js/v/TEEyYchYba2xsAAAAguflyO0k6cOCAQkJCVLFiRT388MM6cuTIVa9PTExUbGxsugfst3271KaN1LixCUj58kn9+kkHDkivvkpAAgAAgPtw65DUsGFDLV++XBs2bNDChQsVERGhJk2a6OzZs5m+Jjw8XIGBgamPUH77ttVPP0nt2km33y59/rkJR088YcLR4sVS+fJ2dwgAAACk59YhqW3bturatatq166t1q1b67PPPlN0dLTee++9TF8zatQoxcTEpD4iIyNzsGNcsmOH1L69dNtt0vr1kre39Nhj0v790uuvSxUq2N0hAAAAkDG3vycprSJFiqhq1ao6ePBgptf4+PjIx8cnB7tCWr/8Yu45+vhjM/bykh59VBo7VqpUyd7eAAAAgKxw65mkf4uLi9OhQ4dUOpfsC53VzRg8YdOGXbukTp2kW24xAcnLS3rkEWnfPmnZMgISAAAAcg+3DknPPfecvv32Wx0+fFg//PCDOnXqJG9vb3Xv3t3u1rLsWgEotwek3bulLl2kunWltWvNTn0PPyz9/rv05ptSlSp2dwgAAABkj1svtzt69Ki6d++u06dPq0SJErrzzju1bds2lShRwu7WssWyMt4OPDcHpF9/lSZNkj74wIwdDqlbN2n8eCkXnvcLAAAApHLrkLR69Wq7W3CatEFpzBhp6lR7+7lev/9uwtH771/+O3Xtau5DqlHD7u4AAACAG+fWIQnuY98+afJkafXqyzNgDzxgwtHNN9vbGwAAAOBMhCRc1R9/mHC0apWUkmJqnTubcFS7tr29AQAAAK5ASEKGDhyQpkyR3nnncjjq2NGEo7p17ewMAAAAcC1CEtI5dMiEo7fflpKTTe3++6WJE6V69WxtDQAAAMgRbr0FuCd58snLX0+bln7sDiIipMcfl6pVk1asMAHp3nuln36S1q0jIAEAACDvYCYpB2S0/fdrr5mH3duAHz5sQtvy5dLFi6bWtq2ZObrtNhsbAwAAAGxCSHKxjALSv5+3IygdOWLC0dKll8NR69YmHN1+e873AwAAALgLltu5UFaX1OXk0rvISKl/f6lyZTOTdfGidM890pYt0oYNBCQAAACAkORCr73m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xxQQEHDN1xQrVkxdu3ZV165d9cILL6hevXqaPXu2VqxYkeH1v//+u7p166bp06erVatWqfW4uDiVLl1amzZtuuI1RYoUuWYfAJAXMZMEAHlAmzZtdOHCBSUlJal169Z2t5NOiRIldOLEidRxbGysIiIicuzP9/b2lqR0OwBeEhAQoJCQEG3ZsiVdfcuWLapRo4YkM8O1c+fOq97f4+fnp08++US+vr5q3bq1zp49m60eCxQooEqVKqXubvdvf//9t+677z516dJFQ4YMSffcLbfcoqioKOXLl0+VK1dO98jqjCIA5DWEJADIA7y9vbV37179/vvvqaHAXdx9991666239N1332nPnj3q1auXS3uMjo5WVFSUjh8/rm+//VaTJ09W1apVddNNN2V4/fDhwzVjxgy9++672r9/v55//nnt3LlTgwYNkiR1795dwcHB6tixo7Zs2aI///xTH374obZu3ZrufQoWLKhPP/1U+fLlU9u2bRUXF5fhn/fJJ5+oZ8+eqUsB9+/fr9mzZ+uzzz5Thw4dMnxNly5d5O/vr4kTJyoqKir1kZycrJYtW6pRo0bq2LGjvvjiCx0+fFg//PCDxowZo59//vkGvpMA4LlYbgcAeURWlnjZYdSoUYqIiFD79u0VGBioKVOmuHQm6dLOfpfusWratKleeOGFTM97evbZZxUTE6Nhw4bp1KlTqlGjhv7zn/+oSpUqkswszxdffKFhw4apXbt2unjxomrUqJHhssZChQpp/fr1at26te6991599tlnKliwYLpratSoIX9/fw0bNkyRkZHy8fFRlSpVtGTJkkzvndq8ebMkqXz58unqERERqlChgj777DONGTNGffr00V9//ZX69750bxcAID2H9e+F4AAAAACQh7HcDgAAAADSICQBAAAAQBqEJAAAAABIg5AEAAAAAGkQkgAAAAAgDUISAAAAAKRBSAIAAACANAhJAAAAAJAGIQkAAAAA0iAkAQAAAEAahCQAAAAASIOQBAAAAABp/D9dke2IkjFNNAAAAABJRU5ErkJggg==",
130:       "text/plain": [
131:        "<Figure size 1000x600 with 1 Axes>"
132:       ]
133:      },
134:      "metadata": {},
135:      "output_type": "display_data"
136:     }
137:    ],
138:    "source": [
139:     "fig, ax = plt.subplots(figsize=(10, 6))\n",
140:     "\n",
141:     "ax.plot(min_block_sizes, block_sizes, marker='o', linestyle='-', color='b')\n",
142:     "ax.set_xlabel(\"Minimum Block Size\")\n",
143:     "ax.set_ylabel(\"Block Sizes\")\n",
144:     "\n",
145:     "fig.show()\n"
146:    ]
147:   },
148:   {
149:    "cell_type": "code",
150:    "execution_count": 49,
151:    "id": "879ee57b",
152:    "metadata": {},
153:    "outputs": [
154:     {
155:      "data": {
156:       "text/plain": [
157:        "<matplotlib.legend.Legend at 0x11ffcd6d0>"
158:       ]
159:      },
160:      "execution_count": 49,
161:      "metadata": {},
162:      "output_type": "execute_result"
163:     },
164:     {
165:      "data": {
166:       "image/png": "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XFxsDhw44NituLjYFBYWmurq6pC/tz/96U9GUoNbZGSkWbRoUYPxkkxubq7/68mTJ5uIiAizfft2/7J9+/aZ6Oho86Uvfcm/bO7cuUaS+fvf/95gm7ZtG2OMefXVV40k89xzz5kjR46Yiy66yPTs2dN88MEHp/0+rrjiCjNkyJCgvtedO3c2en9xcbHp27evOffcc015ebkxxpg33njDSDJ//etf641dsWJFo8sDqa6uNi+88IKZPHmyCQ8PN16v11x++eXm73//u6mqqgpqG3X1T5gwwf+YGWPMmDFjjGVZ5pZbbvEvq6mpMX369DEXXXRRvW2c+vzl5uYaSebGG2+sN+7KK680PXr0OG1NF110kZFkfv7zn/uXVVZWmhEjRpjExET/97Zz504jyfzpT3/yj6sbc+DAAf+y//3vf8bj8ZipU6f6l02dOtV4PB7z3nvvNdh/3eNQ99i89957Zv/+/WbIkCEmMzPT5Ofnn/Z7GD58uPnKV77S5Ji6xymQrVu3mtjYWHPppZeampoaY4wxf/7zn43H4zFvvPFGvbELFy40ksx///vfgNsL9J5zMtpaAADowBYsWKBVq1Zp1apV+stf/qKLL75YN910k/7+978HXMfn82nlypWaPHmyMjMz/ct79+6tb33rW3rzzTdVVlYmSfrb3/6m4cOH68orr2ywnVPbckpLSzV+/Hht2rRJa9as0YgRI05bf1xcnPbs2aP33nsvyO+44fdy7bXX6siRI1q2bJm6desmSXruuecUGxurSy+9VCUlJf7byJEj1b17d7366qtBbT8sLExf+9rXtGzZMu3Zs0ePPvqoPvvsM1111VXq06ePfvCDHzR5qfaTzZgxo95jlpWVJWOMZsyY4V/m9Xo1atQo7dixI6ht3nLLLfW+HjdunA4cOOB//k73vc2cOdP/dUREhGbOnKmioiKtW7eu0XX279+vDRs26IYbblBCQoJ/+bBhw3TppZfq5ZdfllR79Hn58uWaNGlSvXMi6pz6s7Nnzx5ddNFFqq6u1uuvv65+/fqdtv64uDh98skn2rp162nHNqaiokJXXnml4uPj9fTTT/vPa3juuec0ePBgDRo0qN7Pzv/93/9JUtA/O4EQzgEA6MBGjx6t7OxsZWdn67rrrtNLL72kc845R7fddlvAvt7i4mIdPXpUZ599doP7Bg8eLNu2tXv3bknS9u3bg5oPW5LuvPNOvffee3rllVc0ZMiQoNb54Q9/qO7du2v06NE666yzNGvWLP33v/8Nal2pdjaO//znP1qyZEm9FoitW7eqtLRUiYmJ6tWrV71beXm5ioqKgt5HncTERH3ve9/TW2+9pZtuuklFRUX62c9+poqKiqDW79u3b72vY2NjJUlpaWkNlgfTF9/YNutOYA1m/ZSUFP+HmToDBw6UpIBzyn/22WeSFPBnp6SkRBUVFSouLlZZWVnQPzvXX3+9ioqK9NprrwXdNvTggw/q8OHDGjhwoM4991z94Ac/0IcffhjUupJ08803a/v27Vq2bJl69OjhX75161Z98sknDX5u6h6b5vzsnIxwDgBAJ+LxeHTxxRdr//79zT6i2FxXXHGFjDF65JFHgp6/ffDgwdq8ebOeeeYZXXjhhfrb3/6mCy+8ULm5uaddd/ny5Xr00Uf14IMP6rLLLqt3n23bSkxM9P9V4dTbgw8+GNL3ZozRq6++quuvv17Jycn6wx/+oEsuuURPP/20YmJigtpGoBlnGltugjwBNdA2g13fLa666iodPnxYv/zlL4Ne50tf+pK2b9+uP/7xjxo6dKh+//vf6/zzz9fvf//70677y1/+Uk8//bSeeuqpBn/hsW1b5557bsCfne9+97uhfnv1cEIoAACdTE1NjaTakzkb06tXL3Xt2rXRmTA2bdokj8fjP5rbv39/ffzxx0Htd/LkyRo/frxuuOEGRUdH67e//W1Q63Xr1k1TpkzRlClTVFVVpauuuko/+clPNGfOnIBTCG7ZskXTpk3T5MmTde+99za4v3///nrllVc0duxYdenSJag6GpOfn6/Fixdr0aJFys/PV58+ffS9731PM2bM8J/42F7t27dPFRUV9Y6eb9myRZICfm917SaBfnZ69uypbt26qUuXLoqJiQn6Z2f27NkaMGCA5s6dq9jY2KDnJk9ISND06dM1ffp0lZeX60tf+pIeeOAB3XTTTQHXeeONN/T9739fd955p6677roG9/fv31//+9//dMkll7TKjEocOQcAoBOprq7WypUrFRERocGDBzc6xuv1avz48XrhhRfqtS8UFhZqyZIluvDCC/1Hg6+++mr973//07Jlyxpsp7Gjs1OnTtWvfvUrLVy4UD/84Q9PW++BAwfqfR0REaFzzjlHxpiAvdzl5eW68sorlZqaqsWLFzcaoK655hr5fD79+Mc/bnBfTU2NDh8+3GRdH330kbKzs5WZmamf/OQnOu+88/TSSy8pPz9fP/7xj9t9MJdqH4cnn3zS/3VVVZWefPJJ9erVSyNHjmx0nd69e2vEiBFavHhxvcfw448/1sqVK3X55ZdLqv0LzuTJk/WPf/xD77//foPtNPazc//99+v73/++5syZE9QHu1N/drp3764BAwY0Od3h/v37dc011+jCCy/UY4891uiYa665Rnv37tVTTz3V4L5jx44F3cYUCEfOAQDowP71r39p06ZNkmp7YZcsWaKtW7fqnnvuabLd4qGHHtKqVat04YUX6rvf/a7CwsL05JNPqrKyUj/96U/9437wgx/o+eef1ze+8Q3deOONGjlypA4ePKgXX3xRCxcu1PDhwxts+7bbblNZWZl+9KMfKTY2ttEj23XGjx+v5ORkjR07VklJSdq4caOeeOIJfeUrX1F0dHSj68ybN0+ffvqp7rvvPr3wwgv17uvfv7/GjBmjiy66SDNnzlReXp42bNig8ePHKzw8XFu3btVzzz2nX/7yl/r6178esK5169b5TwCdNm1avSkaO4qUlBQ9+uijys/P18CBA7V06VJt2LBBv/vd75qcZvKxxx7TxIkTNWbMGM2YMcM/lWJsbGy9ucIffvhhrVy5UhdddJF/SsL9+/frueee05tvvqm4uLhGt11aWqpZs2YpOjq6ySlBzznnHH35y1/WyJEjlZCQoPfff1/PP/+8brvttoDr3H777SouLtbdd9+tZ555pt59w4YN07Bhw3T99dfr2Wef1S233KJXX31VY8eOlc/n06ZNm/Tss8/q3//+d6MnuQaLcA4AQADGmKB7o1tr/2dq7ty5/v9HRUVp0KBB+u1vf1tvFo7GDBkyRG+88YbmzJmjvLw82batrKws/eUvf/HPcS7VHo184403lJubq2XLlmnx4sVKTEzUJZdcoj59+gTc/r333qvS0lJ/QJ81a1aj42bOnKm//vWvevzxx1VeXq4+ffro9ttv13333Rdw28XFxZJqP2Ccatq0aRozZowkaeHChRo5cqSefPJJ3XvvvQoLC1N6erq+/e1va+zYsU0+Pt/4xjfqXdCoI4qPj9fixYs1e/ZsPfXUU0pKStITTzyhm2++ucn1srOztWLFCuXm5mru3LkKDw/XRRddpEcf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++236/zzz1dCQoLeeustzZkzR/v379fjjz/udGmdTklJiXw+n5KSkuotT0pK0qZNmxyqCnWysrK0aNEinX322dq/f7/mzZuncePG6eOPP1Z0dLTT5eEUBQUFktTo66nuPjjrsssu01VXXaWMjAxt375d9957ryZOnKi1a9fK6/U6XV6nYtu27rzzTo0dO1ZDhw6VVPsaioiIUFxcXL2xvIbgRq4P5/fcc48effTRJsds3LhRgwYNUk5Ojn/ZsGHDFBERoZkzZyovL4/L9gInmThxov//w4YNU1ZWlvr166dnn31WM2bMcLAyoH365je/6f//ueeeq2HDhql///5as2aNLrnkEgcr63xmzZqljz/+mPNo0G65Ppx/73vf0w033NDkmMzMzEaXZ2VlqaamRvn5+Tr77LNboToE0rNnT3m93gZnwhcWFio5OdmhqhBIXFycBg4cqG3btjldChpR95opLCxU7969/csLCws1YsQIh6pCUzIzM9WzZ09t27aNcN6GbrvtNv3zn//U66+/rj59+viXJycnq6qqSocPH6539JzfSXAj1/ec9+rVS4MGDWryFhER0ei6GzZskMfjUWJiYhtXjYiICI0cOVKrV6/2L7NtW6tXr9aYMWMcrAyNKS8v1/bt2+sFP7hHRkaGkpOT672eysrK9M477/B6cqk9e/bowIEDvKbaiDFGt912m5YtW6b//Oc/ysjIqHf/yJEjFR4eXu81tHnzZu3atYvXEFzH9UfOg7V27Vq98847uvjiixUdHa21a9fqrrvu0re//W3Fx8c7XV6nlJOTo2nTpmnUqFEaPXq05s+fr4qKCk2fPt3p0jq973//+5o0aZL69eunffv2KTc3V16vV9dee63TpXVa5eXl9f5ysXPnTm3YsEEJCQnq27ev7rzzTj300EM666yzlJGRofvvv18pKSmaPHmyc0V3Ik09PwkJCZo3b56uvvpqJScna/v27br77rs1YMAATZgwwcGqO49Zs2ZpyZIleuGFFxQdHe3vI4+NjVWXLl0UGxurGTNmKCcnRwkJCYqJidHs2bM1ZswYfeELX3C4euAUTk8X01LWrVtnsrKyTGxsrImKijKDBw82Dz/8sDl+/LjTpXVqv/71r03fvn1NRESEGT16tHn77bedLgnGmClTppjevXubiIgIk5qaaqZMmWK2bdvmdFmd2quvvmokNbhNmzbNGFM7neL9999vkpKSTGRkpLnkkkvM5s2bnS26E2nq+Tl69KgZP3686dWrlwkPDzf9+vUzN998sykoKHC67E6jsedGkvnTn/7kH3Ps2DHz3e9+18THx5uuXbuaK6+80uzfv9+5ooEALGOMafuPBAAAAABO5fqecwAAAKCzIJwDAAAALkE4BwAAAFyCcA4AAAC4BOEcAAAAcAnCOQAAAOAShHMAAADAJQjnAAAAgEsQzgEAAACXIJwDAAAALkE4BwAAAFyCcA4AAAC4xP8H9LjNs4014Q4AAAAASUVORK5CYII=",
167:       "text/plain": [
168:        "<Figure size 800x500 with 1 Axes>"
169:       ]
170:      },
171:      "metadata": {},
172:      "output_type": "display_data"
173:     }
174:    ],
175:    "source": [
176:     "fig, ax = plt.subplots(figsize=(8, 5))\n",
177:     "\n",
178:     "values, counts  = np.unique(min_block_sizes - block_sizes, return_counts=True)\n",
179:     "\n",
180:     "ax.plot(values, counts/counts.sum(), marker='o', linestyle='-', color='salmon')\n",
181:     "\n",
182:     "ax.fill_betweenx(y=[0, 1], x1=min(values), x2=0, color='#dddddd', alpha=0.5, label='Block size > min block size')\n",
183:     "\n",
184:     "fig.legend(fontsize=12)\n",
185:     "\n",
186:     "\n"
187:    ]
188:   },
189:   {
190:    "cell_type": "code",
191:    "execution_count": null,
192:    "id": "b8a60bad",
193:    "metadata": {},
194:    "outputs": [],
195:    "source": []
196:   },
197:   {
198:    "cell_type": "code",
199:    "execution_count": null,
200:    "id": "ec731210",
201:    "metadata": {},
202:    "outputs": [],
203:    "source": []
204:   },
205:   {
206:    "cell_type": "code",
207:    "execution_count": null,
208:    "id": "8198ec2d",
209:    "metadata": {},
210:    "outputs": [],
211:    "source": []
212:   },
213:   {
214:    "cell_type": "code",
215:    "execution_count": 1,
216:    "id": "fbbae561",
217:    "metadata": {},
218:    "outputs": [],
219:    "source": [
220:     "import numpy as np"
221:    ]
222:   },
223:   {
224:    "cell_type": "code",
225:    "execution_count": 2,
226:    "id": "995a8d86",
227:    "metadata": {},
228:    "outputs": [],
229:    "source": [
230:     "def fun(B, delta=0.05, Delta=10**3):\n",
231:     "    return np.log((B+B**2)/delta)*Delta"
232:    ]
233:   },
234:   {
235:    "cell_type": "code",
236:    "execution_count": null,
237:    "id": "17749985",
238:    "metadata": {},
239:    "outputs": [
240:     {
241:      "data": {
242:       "text/plain": [
243:        "np.float64(14615.015756511137)"
244:       ]
245:      },
246:      "execution_count": 3,
247:      "metadata": {},
248:      "output_type": "execute_result"
249:     }
250:    ],
251:    "source": [
252:     "fun()"
253:    ]
254:   },
255:   {
256:    "cell_type": "code",
257:    "execution_count": 4,
258:    "id": "e6fc7922",
259:    "metadata": {},
260:    "outputs": [
261:     {
262:      "data": {
263:       "text/plain": [
264:        "333"
265:       ]
266:      },
267:      "execution_count": 4,
268:      "metadata": {},
269:      "output_type": "execute_result"
270:     }
271:    ],
272:    "source": [
273:     "1000//3"
274:    ]
275:   },
276:   {
277:    "cell_type": "code",
278:    "execution_count": null,
279:    "id": "509dda70",
280:    "metadata": {},
281:    "outputs": [],
282:    "source": []
283:   }
284:  ],
285:  "metadata": {
286:   "kernelspec": {
287:    "display_name": "anon_sbm_notebook",
288:    "language": "python",
289:    "name": "python3"
290:   },
291:   "language_info": {
292:    "codemirror_mode": {
293:     "name": "ipython",
294:     "version": 3
295:    },
296:    "file_extension": ".py",
297:    "mimetype": "text/x-python",
298:    "name": "python",
299:    "nbconvert_exporter": "python",
300:    "pygments_lexer": "ipython3",
301:    "version": "3.13.5"
302:   }
303:  },
304:  "nbformat": 4,
305:  "nbformat_minor": 5
306: }

================
File: src/metrics/clustering.py
================
 1: """ 
 2: Implementation of the clustering coefficient distance metric.
 3: This module computes the absolute difference in the clustering coefficients
 4: between two graphs represented by their adjacency matrices.
 5: """
 6: # metrics/clustering.py
 7: from typing import Optional
 8: import numpy as np
 9: import networkx as nx
10: from scipy.sparse import csr_array
11: ###############################################################################
12: ### Clustering coefficient distributional distance ----------------------------
13: ###############################################################################
14: def clustering_distance(
15:         emp_adj: csr_array,
16:         sur_adj: csr_array,
17:         directed: Optional[bool] = False,
18:         rng: np.random.Generator = np.random.default_rng(1)
19:     ) -> float:
20:     """ 
21:     Compute absolute 
22:     Parameters
23:     ----------
24:     emp_adj, sur_adj : scipy.sparse.csr_matrix
25:         Adjacency of empirical and surrogate graphs (directed or undirected).
26:     directed : bool, optional
27:         If True, compute directed degree distribution.
28:         If False, compute undirected degree distribution.
29:     rng : np.random.Generator, optional
30:         Random number generator for sampling (default: np.random.default_rng(1)).
31:     Returns
32:     -------
33:     float
34:         Distance (lower = more similar).
35:     """
36:     if directed:
37:         raise NotImplementedError(
38:             "Directed clustering coefficient is not implemented yet."
39:         )
40:     else:
41:         # Undirected clustering coefficient
42:         emp_graph = nx.from_scipy_sparse_matrix(emp_adj)
43:         sur_graph = nx.from_scipy_sparse_matrix(sur_adj)
44:         emp_clustering = nx.average_clustering(emp_graph)
45:         sur_clustering = nx.average_clustering(sur_graph)
46:         return abs(emp_clustering - sur_clustering)
47: ###############################################################################
48: # Average clustering coefficient difference -------------------------------
49: ###############################################################################
50: def avg_clustering_difference(
51:     emp_adj: csr_array,
52:     sur_adj: csr_array,
53:     *,
54:     rng: np.random.Generator = np.random.default_rng(1),
55: ) -> float:
56:     """Absolute difference in *average* clustering coefficient.
57:     (The existing *clustering_distance* compares the *distribution*; this
58:     variant is the scalar average.)
59:     """
60:     emp_C = nx.average_clustering(nx.from_scipy_sparse_matrix(emp_adj))
61:     sur_C = nx.average_clustering(nx.from_scipy_sparse_matrix(sur_adj))
62:     return abs(emp_C - sur_C)

================
File: src/pipelines/evaluate_surrogates.py
================
 1: """
 2:     Generate surrogate SBM graphs and evaluate them against empirical data.
 3: """
 4: import argparse
 5: import yaml
 6: import csv
 7: from pathlib import Path
 8: import numpy as np
 9: from itertools import product
10: from multiprocessing import Pool, cpu_count
11: from metrics import REGISTRY
12: from sbm.io import SBMWriter
13: from sbm.sampling import sample_sbm_graph_from_fit
14: from sbm.io import GraphLoader
15: from sbm.utils.pipeline_utils import (
16:     sbmfit_folderpath,
17:     surrogate_statistics_filename,
18:     FitConfig,
19:     EvalConfig,
20: )
21: #######################
22: ### Configuration Types 
23: #######################
24: def _generate_and_evaluate(sbm_config, ds, eval_config, rng):
25:     # Load empirical graph
26:     g = GraphLoader.load(
27:             Path(ds["path"]),
28:             force_undirected=sbm_config["force_undirected"], # type: ignore
29:         )
30:     emp = g.adjacency
31:     # load fitted model
32:     fit_folder_path = sbmfit_folderpath(
33:         base_dir=Path("results/sbm_fits"),
34:         sbm_config=sbm_config,# type: ignore
35:         data_spec=ds,
36:     )
37:     # load the sbm fit
38:     sbm_fit = SBMWriter.load(fit_folder_path)
39:     # check if metrics have been cached earlier
40:     out = surrogate_statistics_filename(
41:         base_dir=Path("results/surrogate_statistics"),
42:         eval_configs=eval_config,
43:         sbm_config=sbm_config,# type: ignore
44:         data_spec=ds,
45:     )
46:     out.parent.mkdir(exist_ok=True)
47:     if out.exists() and not eval_config["overwrite"]:
48:         return
49:     # Generate surrogates and campare metrics
50:     results = []
51:     for i in range(eval_config["n_surrogates"]):
52:         surr = sample_sbm_graph_from_fit(
53:             sbm_fit=sbm_fit,
54:             rng=rng,
55:         )
56:         surr = surr.adjacency
57:         row = {"dataset": ds["name"], "surrogate": f'surr_{i}'}
58:         for m in eval_config["metrics"]:
59:             row[m] = REGISTRY[m](emp, surr)
60:         results.append(row)
61:     with out.open("w", newline="") as f:
62:         w = csv.DictWriter(f, fieldnames=results[0].keys())
63:         w.writeheader(); w.writerows(results)
64: ############################################
65: ### main function
66: ############################################
67: def main(fit_config: str, eval_config: str, parallel:bool): # type: ignore
68:     fit_config: FitConfig = yaml.safe_load(Path(fit_config).read_text())
69:     rng = np.random.default_rng(fit_config["seed"])
70:     data_config = fit_config["datasets"] # type: ignore
71:     eval_config: EvalConfig = yaml.safe_load(Path(eval_config).read_text())
72:     # Prepare arguments for the worker function
73:     args = [
74:         (sbm_config, ds, eval_config, rng)
75:         for sbm_config, ds in product(fit_config["sbm"], data_config)
76:     ][::-1]
77:     if parallel:
78:         # Create a pool of workers
79:         n_workers = max(1, cpu_count() - 1)  # Leave one core free
80:         with Pool(n_workers) as pool:
81:             # Execute the worker function in parallel
82:             pool.starmap(_generate_and_evaluate, args)
83:     else:
84:         for sbm_config, ds in product(fit_config["sbm"], data_config):
85:             _generate_and_evaluate(sbm_config, ds, eval_config, rng)
86: if __name__ == "__main__":
87:     p = argparse.ArgumentParser()
88:     p.add_argument("--fit_config", type=str, help="Path to the configuration file.")
89:     p.add_argument("--eval_config", type=str, help="Path to the configuration file.")
90:     p.add_argument("--parallel", action="store_true", help="Run in parallel leaving one core free.")
91:     args = p.parse_args()
92:     main(
93:         fit_config=args.fit_config,
94:         eval_config=args.eval_config,
95:         parallel=args.parallel,
96:     )

================
File: src/pipelines/run_all.py
================
 1: """ 
 2: Script to run fitting, generation, and evaluation pipelines in sequence.
 3: """
 4: import subprocess
 5: import sys
 6: def run(cmd):
 7:     print(">>", " ".join(cmd))
 8:     subprocess.check_call(cmd)
 9: CFG_FIT = "configs/sbm_fit_block_size_experiments.yml"
10: CFG_EVAL = "configs/surrogate_eval.yml"
11: if __name__ == "__main__":
12:     python = sys.executable
13:     run([
14:         python, "-m",
15:         "pipelines.fit_sbm",
16:         "--fit_config", CFG_FIT
17:     ])
18:     run([
19:         python, "-m",
20:         "pipelines.evaluate_surrogates",
21:         "--fit_config", CFG_FIT,
22:         "--eval_config", CFG_EVAL,
23:     ])

================
File: src/sbm/utils/util.py
================
 1: import numpy as np
 2: from pathlib import Path
 3: import networkx as nx
 4: from scipy.sparse.csgraph import connected_components
 5: from scipy.sparse import csr_array
 6: def set_random_seed(seed: int):
 7:     return np.random.default_rng(seed)
 8: def restrict_to_lcc(adj: csr_array, directed:bool) -> csr_array:
 9:     """ 
10:     resricts adjacency matrix to the largest connected component (LCC).
11:     """
12:     if directed:
13:         n_components, labels = connected_components(adj, directed=True)
14:     else:
15:         n_components, labels = connected_components(adj, directed=False)
16:     if n_components == 1:
17:         return adj
18:     largest_component = np.argmax(np.bincount(labels))
19:     mask = labels == largest_component
20:     adj_lcc = csr_array(adj[mask][:, mask]) # type: ignore
21:     return adj_lcc
22: def _nx_graph(adj: csr_array, *, directed: bool = False) -> nx.Graph:
23:     """Convert *adj* to a NetworkX (di)graph, restricted to its LCC."""
24:     adj_lcc = restrict_to_lcc(adj, directed)
25:     return (
26:         nx.from_scipy_sparse_matrix(adj_lcc, create_using=nx.DiGraph() if directed else nx.Graph())
27:     )

================
File: src/sbm/graph_data.py
================
 1: from scipy.sparse import csr_array
 2: import networkx as nx
 3: class GraphData:
 4:     def __init__(self, adjacency_matrix: csr_array, directed=False):
 5:         if not isinstance(adjacency_matrix, csr_array):
 6:             raise ValueError("Adjacency matrix must be a scipy.sparse.csr_array")
 7:         self.adjacency = adjacency_matrix.astype(int)
 8:         self.directed: bool= directed
 9:         self.num_nodes = self.adjacency.shape[0] # type: ignore
10:         if directed:
11:             self.total_edges = int(self.adjacency.sum())
12:         else:
13:             self.total_edges = int(self.adjacency.sum() / 2)  # For undirected graphs
14:         def __len__(self):
15:             return self.num_nodes
16: def gd_from_networkx(G: nx.Graph) -> GraphData:
17:     """
18:     Create a GraphData instance from a NetworkX graph.
19:     """
20:     if not hasattr(G, 'adjacency'):
21:         raise ValueError("The provided graph must have an adjacency matrix.")
22:     # for new version of networkx
23:     #adj = nx.to_scipy_sparse_matrix(G)
24:     # for old version of networkx
25:     adj = nx.to_scipy_sparse_matrix(G)
26:     adj = csr_array(adj)
27:     return GraphData(adj, directed=G.is_directed())

================
File: src/sbm/node_mover.py
================
 1: from typing import List, Tuple
 2: import scipy.sparse as sp
 3: import numpy as np
 4: from sbm.block_data import BlockData, _BlockDataUpdater
 5: from line_profiler import profile
 6: from sbm.block_change_proposers import (
 7:     ProposedValidChanges,
 8:     EdgeDelta,
 9: )
10: class NodeMover:
11:     """
12:     Class to move nodes between block assignment in the Stochastic Block Model (SBM).
13:     When performing a change, it updates the block sizes, connectivity matrix,
14:     block indices, and inverse block indices accordingly.
15:     All changes are performed in-place on the BlockData object by the _BlockDataUpdater.
16:     """
17:     def __init__(self, block_data: BlockData):
18:         self.block_data_updater = _BlockDataUpdater(block_data)
19:     def perform_change(self,
20:             proposed_changes: ProposedValidChanges,
21:             delta_e: EdgeDelta,
22:             ):
23:         """ 
24:         Change the block assignments of nodes according to the proposed change.
25:         Update:
26:         - block sizes
27:         - block connectivity matrix (edge counts between blocks)
28:         - block indices (node to block assignment)
29:         - inverse block indices (nodes in each block)
30:         Rely on increment_edge_count from BlockData to update edge counts.
31:         :param change: A list of tuples where each tuple contains a node and their new block.
32:         """
33:         (node_i, new_block_i), (node_j, new_block_j) = proposed_changes
34:         # update the block assignments, sizes, and memberships
35:         self.block_data_updater._move_node_to_block(node_i, new_block_i)
36:         self.block_data_updater._move_node_to_block(node_j, new_block_j)
37:         # update the edge counts between the blocks
38:         for (r, s), e_delta in delta_e.items():
39:             self.block_data_updater._increment_edge_count(r, s, e_delta)

================
File: requirements.txt
================
 1: pytest
 2: numpy==1.26.4
 3: scipy==1.12.0
 4: networkx
 5: metis
 6: ortools
 7: tqdm
 8: pyyaml
 9: nodevectors
10: scikit-learn
11: k-means-constrained
12: line_profiler
13: infomap
14: leidenalg
15: python-igraph
16: protobuf==5.29.5
17: tensorflow=2.19
18: ortools==9.8.3296

================
File: setup.cfg
================
 1: [metadata]
 2: name = anon-sbm
 3: version = 0.1.0
 4: author = Lasse Mohr
 5: author_email = lmmi@dtu.dk
 6: description = Package for SBM with minimum group-size constraints
 7: long_description = file: README.md
 8: long_description_content_type = text/markdown
 9: classifiers =
10:     Programming Language :: Python :: 3
11:     License :: OSI Approved :: MIT License
12:     Operating System :: OS Independent
13: 
14: [options]
15: package_dir =
16:     =src
17: packages = find:
18: python_requires = >=3.12.0
19: install_requires =
20:     numpy
21:     scipy
22:     networkx
23:     metis
24:     k-means-constrained
25:     nodevectors
26:     tqdm
27:     scikit-learn
28:     pytest
29:     line_profiler
30: 
31: [options.packages.find]
32: where = src

================
File: configs/sbm_fit_block_size_experiments.yml
================
 1: # -------------------------------------------------------------------
 2: #  Global defaults
 3: # -------------------------------------------------------------------
 4: seed: 42
 5: # -------------------------------------------------------------------
 6: #  Configuration for the SBM models fitting as list of dicts
 7: # Each item needs:
 8: #    min_block_size: minimum size of the blocks
 9: #    n_iter: number of iterations for the fitting
10: #    temperature: initial temperature for the simulated annealing
11: #    cooling_rate: cooling rate for the simulated annealing
12: #    force_undirected: whether to treat the graph as undirected
13: # -------------------------------------------------------------------
14: sbm:
15:   - min_block_size: 3
16:     cooling_rate: 0.9999
17:     force_undirected: true
18:     init_method: "metis"
19:   - min_block_size: 6
20:     cooling_rate: 0.9999
21:     force_undirected: true
22:     init_method: "metis"
23:   - min_block_size: 12
24:     cooling_rate: 0.9999
25:     force_undirected: true
26:     init_method: "metis"
27:   - min_block_size: 25
28:     cooling_rate: 0.9999
29:     force_undirected: true
30:     init_method: "metis"
31: # -------------------------------------------------------------------
32: #  Configuration for the logging
33: #  - logging_folder: folder to save the logs
34: #  - overwirte: set true to ignore cached results
35: #  - log_every: how often to log the results (in number of iterations)
36: # -------------------------------------------------------------------
37: logging:
38:   - logging_folder: "./logs/"
39:     overwrite: true           # set true to ignore cached results
40:     log_every: 1_000
41: # -------------------------------------------------------------------
42: #  List of empirical graphs to process
43: #  Each item needs:
44: #    name : label used for output folder (models/sbm/<name>/)
45: #    path : relative or absolute path to the processed graph file
46: # -------------------------------------------------------------------
47: datasets:
48: # small datasets (< 1000 nodes)
49:   - name: congress_twitter
50:     path: data/processed/congress_twitter.edgelist # undirected GML
51:   - name: caltech_fb 
52:     path: data/processed/caltech_fb.edgelist # undirected GML
53:   - name: eu_email
54:     path: data/processed/eu_email.edgelist # undirected GML
55: # medium datasets (1000 - 10_000 nodes):
56:   - name: lastfm_asia
57:     path: data/processed/lastfm_asia.edgelist # undirected GML
58:   - name: wiki_vote
59:     path: data/processed/wiki_vote.edgelist # undirected GML
60: # large datasets (10_000-100_000 nodes):
61:   - name: enron_email 
62:     path: data/processed/enron_email.edgelist # undirected GML

================
File: configs/surrogate_eval.yml
================
 1: # ---------------------------------------------------------------
 2: n_surrogates: 20 # graphs to sample per dataset
 3: overwrite: false # set true to ignore cached results
 4: # which similarity metrics to compute
 5: metrics:
 6:   - shortest_path
 7:   - avg_path_length
 8:   - degree
 9:   - clustering
10:   - avg_clustering
11:   - eigen_val 
12:   - eigen_centrality
13:   - infomap
14:   - leiden
15:   - assortativity
16:   - embedding_node2vec
17:   - embedding_prone

================
File: notebooks/surrogate_accuracy_26-06-2025.ipynb
================
  1: {
  2:  "cells": [
  3:   {
  4:    "cell_type": "markdown",
  5:    "id": "2b29dd78",
  6:    "metadata": {},
  7:    "source": [
  8:     "# Notebook for investigating network accuracy of surrogates"
  9:    ]
 10:   },
 11:   {
 12:    "cell_type": "markdown",
 13:    "id": "57bdcafc",
 14:    "metadata": {},
 15:    "source": []
 16:   },
 17:   {
 18:    "cell_type": "code",
 19:    "execution_count": 1,
 20:    "id": "dfb246da",
 21:    "metadata": {},
 22:    "outputs": [],
 23:    "source": [
 24:     "import numpy as np\n",
 25:     "import pandas as pd\n",
 26:     "import matplotlib.pyplot as plt"
 27:    ]
 28:   },
 29:   {
 30:    "cell_type": "code",
 31:    "execution_count": 2,
 32:    "id": "fc84799c",
 33:    "metadata": {},
 34:    "outputs": [],
 35:    "source": [
 36:     "import sys\n",
 37:     "from pathlib import Path\n",
 38:     "\n",
 39:     "### Load all surrogate statistics\n",
 40:     "folder_path = Path('/Users/lmmi/anon_sbm/results/surrogate_statistics')\n",
 41:     "\n",
 42:     "# find all log files in the logs directory\n",
 43:     "stat_files = list(folder_path.glob(\"*.csv\"))"
 44:    ]
 45:   },
 46:   {
 47:    "cell_type": "code",
 48:    "execution_count": 6,
 49:    "id": "707ac12e",
 50:    "metadata": {},
 51:    "outputs": [
 52:     {
 53:      "data": {
 54:       "text/plain": [
 55:        "38"
 56:       ]
 57:      },
 58:      "execution_count": 6,
 59:      "metadata": {},
 60:      "output_type": "execute_result"
 61:     }
 62:    ],
 63:    "source": [
 64:     "len(stat_files)"
 65:    ]
 66:   },
 67:   {
 68:    "cell_type": "code",
 69:    "execution_count": 8,
 70:    "id": "b09387bc",
 71:    "metadata": {},
 72:    "outputs": [],
 73:    "source": [
 74:     "# drop all files with 'patience' in the name[\n",
 75:     "stat_files = [f for f in stat_files if 'patience' not in f.name]"
 76:    ]
 77:   },
 78:   {
 79:    "cell_type": "code",
 80:    "execution_count": 14,
 81:    "id": "8ee87d6c",
 82:    "metadata": {},
 83:    "outputs": [],
 84:    "source": [
 85:     "def determine_block_size(stat_file):\n",
 86:     "    \"\"\"\n",
 87:     "    Determine min_block_size from the filename.\n",
 88:     "\n",
 89:     "    min_block_size is encoded in filename as *min_block_size_{min_block_size}*.csv\n",
 90:     "    \"\"\"\n",
 91:     "\n",
 92:     "    # drop .csv extension\n",
 93:     "    if stat_file.name.endswith('.csv'):\n",
 94:     "        stat_file = stat_file.with_suffix('')\n",
 95:     "\n",
 96:     "    # find location of substring 'min_block_size_'\n",
 97:     "    index = stat_file.name.find('min_block_size_')\n",
 98:     "\n",
 99:     "    tail = stat_file.name[index + len('min_block_size_'):]\n",
100:     "    size = tail.split('_')[0]\n",
101:     "\n",
102:     "    # check if size is a digit\n",
103:     "    if not size.isdigit():\n",
104:     "        return None\n",
105:     "    return int(size)"
106:    ]
107:   },
108:   {
109:    "cell_type": "code",
110:    "execution_count": 15,
111:    "id": "f5f8ac7e",
112:    "metadata": {},
113:    "outputs": [],
114:    "source": [
115:     "df_list = []\n",
116:     "\n",
117:     "for stat_file in stat_files:\n",
118:     "    df = pd.read_csv(stat_file)\n",
119:     "    block_size = determine_block_size(stat_file)\n",
120:     "    if block_size is None:\n",
121:     "        continue\n",
122:     "    df[\"block_size\"] = block_size\n",
123:     "    df['surrogate'] = [int(surrogate_str.split(\"_\")[1]) for surrogate_str in df['surrogate']]\n",
124:     "\n",
125:     "    df_list.append(df)\n",
126:     "\n",
127:     "df = pd.concat(df_list, ignore_index=True)"
128:    ]
129:   },
130:   {
131:    "cell_type": "code",
132:    "execution_count": null,
133:    "id": "782cc864",
134:    "metadata": {},
135:    "outputs": [],
136:    "source": []
137:   },
138:   {
139:    "cell_type": "code",
140:    "execution_count": 16,
141:    "id": "0ddc127e",
142:    "metadata": {},
143:    "outputs": [],
144:    "source": [
145:     "marker_styles = {\n",
146:     "    \"congress_twitter\": \"o\",\n",
147:     "    \"caltech_fb\": \"s\",\n",
148:     "    \"eu_email\": \"D\",\n",
149:     "    \"lastfm_asia\": \"x\",\n",
150:     "    \"wiki_vote\": \"+\",\n",
151:     "    \"enron_email\": \"+\",\n",
152:     "}\n",
153:     "\n",
154:     "# load nice colormaps\n",
155:     "from matplotlib import colormaps as cm\n",
156:     "\n",
157:     "cmap = cm.get_cmap(\"tab10\")\n",
158:     "\n",
159:     "colors = {\n",
160:     "    \"congress_twitter\": \"teal\",\n",
161:     "    \"caltech_fb\": \"salmon\",\n",
162:     "    \"eu_email\": \"black\",\n",
163:     "    \"lastfm_asia\": cmap(0),\n",
164:     "    \"wiki_vote\": cmap(0.5),\n",
165:     "    \"enron_email\": cmap(1),\n",
166:     "}"
167:    ]
168:   },
169:   {
170:    "cell_type": "code",
171:    "execution_count": 17,
172:    "id": "0281f1f1",
173:    "metadata": {},
174:    "outputs": [
175:     {
176:      "data": {
177:       "text/html": [
178:        "<div>\n",
179:        "<style scoped>\n",
180:        "    .dataframe tbody tr th:only-of-type {\n",
181:        "        vertical-align: middle;\n",
182:        "    }\n",
183:        "\n",
184:        "    .dataframe tbody tr th {\n",
185:        "        vertical-align: top;\n",
186:        "    }\n",
187:        "\n",
188:        "    .dataframe thead th {\n",
189:        "        text-align: right;\n",
190:        "    }\n",
191:        "</style>\n",
192:        "<table border=\"1\" class=\"dataframe\">\n",
193:        "  <thead>\n",
194:        "    <tr style=\"text-align: right;\">\n",
195:        "      <th></th>\n",
196:        "      <th>dataset</th>\n",
197:        "      <th>surrogate</th>\n",
198:        "      <th>shortest_path</th>\n",
199:        "      <th>degree</th>\n",
200:        "      <th>clustering</th>\n",
201:        "      <th>block_size</th>\n",
202:        "      <th>avg_path_length</th>\n",
203:        "      <th>avg_clustering</th>\n",
204:        "      <th>spectral</th>\n",
205:        "      <th>infomap</th>\n",
206:        "      <th>leiden</th>\n",
207:        "      <th>assortativity</th>\n",
208:        "      <th>embedding_node2vec</th>\n",
209:        "      <th>embedding_prone</th>\n",
210:        "    </tr>\n",
211:        "  </thead>\n",
212:        "  <tbody>\n",
213:        "    <tr>\n",
214:        "      <th>0</th>\n",
215:        "      <td>lastfm_asia</td>\n",
216:        "      <td>0</td>\n",
217:        "      <td>0.2392</td>\n",
218:        "      <td>0.003980</td>\n",
219:        "      <td>0.068181</td>\n",
220:        "      <td>6</td>\n",
221:        "      <td>NaN</td>\n",
222:        "      <td>NaN</td>\n",
223:        "      <td>NaN</td>\n",
224:        "      <td>NaN</td>\n",
225:        "      <td>NaN</td>\n",
226:        "      <td>NaN</td>\n",
227:        "      <td>NaN</td>\n",
228:        "      <td>NaN</td>\n",
229:        "    </tr>\n",
230:        "    <tr>\n",
231:        "      <th>1</th>\n",
232:        "      <td>lastfm_asia</td>\n",
233:        "      <td>1</td>\n",
234:        "      <td>0.2306</td>\n",
235:        "      <td>0.004052</td>\n",
236:        "      <td>0.069189</td>\n",
237:        "      <td>6</td>\n",
238:        "      <td>NaN</td>\n",
239:        "      <td>NaN</td>\n",
240:        "      <td>NaN</td>\n",
241:        "      <td>NaN</td>\n",
242:        "      <td>NaN</td>\n",
243:        "      <td>NaN</td>\n",
244:        "      <td>NaN</td>\n",
245:        "      <td>NaN</td>\n",
246:        "    </tr>\n",
247:        "    <tr>\n",
248:        "      <th>2</th>\n",
249:        "      <td>lastfm_asia</td>\n",
250:        "      <td>2</td>\n",
251:        "      <td>0.1723</td>\n",
252:        "      <td>0.004388</td>\n",
253:        "      <td>0.068788</td>\n",
254:        "      <td>6</td>\n",
255:        "      <td>NaN</td>\n",
256:        "      <td>NaN</td>\n",
257:        "      <td>NaN</td>\n",
258:        "      <td>NaN</td>\n",
259:        "      <td>NaN</td>\n",
260:        "      <td>NaN</td>\n",
261:        "      <td>NaN</td>\n",
262:        "      <td>NaN</td>\n",
263:        "    </tr>\n",
264:        "    <tr>\n",
265:        "      <th>3</th>\n",
266:        "      <td>lastfm_asia</td>\n",
267:        "      <td>3</td>\n",
268:        "      <td>0.1872</td>\n",
269:        "      <td>0.004476</td>\n",
270:        "      <td>0.073102</td>\n",
271:        "      <td>6</td>\n",
272:        "      <td>NaN</td>\n",
273:        "      <td>NaN</td>\n",
274:        "      <td>NaN</td>\n",
275:        "      <td>NaN</td>\n",
276:        "      <td>NaN</td>\n",
277:        "      <td>NaN</td>\n",
278:        "      <td>NaN</td>\n",
279:        "      <td>NaN</td>\n",
280:        "    </tr>\n",
281:        "    <tr>\n",
282:        "      <th>4</th>\n",
283:        "      <td>lastfm_asia</td>\n",
284:        "      <td>4</td>\n",
285:        "      <td>0.2375</td>\n",
286:        "      <td>0.004593</td>\n",
287:        "      <td>0.069663</td>\n",
288:        "      <td>6</td>\n",
289:        "      <td>NaN</td>\n",
290:        "      <td>NaN</td>\n",
291:        "      <td>NaN</td>\n",
292:        "      <td>NaN</td>\n",
293:        "      <td>NaN</td>\n",
294:        "      <td>NaN</td>\n",
295:        "      <td>NaN</td>\n",
296:        "      <td>NaN</td>\n",
297:        "    </tr>\n",
298:        "    <tr>\n",
299:        "      <th>...</th>\n",
300:        "      <td>...</td>\n",
301:        "      <td>...</td>\n",
302:        "      <td>...</td>\n",
303:        "      <td>...</td>\n",
304:        "      <td>...</td>\n",
305:        "      <td>...</td>\n",
306:        "      <td>...</td>\n",
307:        "      <td>...</td>\n",
308:        "      <td>...</td>\n",
309:        "      <td>...</td>\n",
310:        "      <td>...</td>\n",
311:        "      <td>...</td>\n",
312:        "      <td>...</td>\n",
313:        "      <td>...</td>\n",
314:        "    </tr>\n",
315:        "    <tr>\n",
316:        "      <th>495</th>\n",
317:        "      <td>congress_twitter</td>\n",
318:        "      <td>15</td>\n",
319:        "      <td>0.0226</td>\n",
320:        "      <td>0.004695</td>\n",
321:        "      <td>0.073769</td>\n",
322:        "      <td>25</td>\n",
323:        "      <td>NaN</td>\n",
324:        "      <td>NaN</td>\n",
325:        "      <td>NaN</td>\n",
326:        "      <td>NaN</td>\n",
327:        "      <td>NaN</td>\n",
328:        "      <td>NaN</td>\n",
329:        "      <td>NaN</td>\n",
330:        "      <td>NaN</td>\n",
331:        "    </tr>\n",
332:        "    <tr>\n",
333:        "      <th>496</th>\n",
334:        "      <td>congress_twitter</td>\n",
335:        "      <td>16</td>\n",
336:        "      <td>0.0254</td>\n",
337:        "      <td>0.004873</td>\n",
338:        "      <td>0.079693</td>\n",
339:        "      <td>25</td>\n",
340:        "      <td>NaN</td>\n",
341:        "      <td>NaN</td>\n",
342:        "      <td>NaN</td>\n",
343:        "      <td>NaN</td>\n",
344:        "      <td>NaN</td>\n",
345:        "      <td>NaN</td>\n",
346:        "      <td>NaN</td>\n",
347:        "      <td>NaN</td>\n",
348:        "    </tr>\n",
349:        "    <tr>\n",
350:        "      <th>497</th>\n",
351:        "      <td>congress_twitter</td>\n",
352:        "      <td>17</td>\n",
353:        "      <td>0.0363</td>\n",
354:        "      <td>0.004783</td>\n",
355:        "      <td>0.071975</td>\n",
356:        "      <td>25</td>\n",
357:        "      <td>NaN</td>\n",
358:        "      <td>NaN</td>\n",
359:        "      <td>NaN</td>\n",
360:        "      <td>NaN</td>\n",
361:        "      <td>NaN</td>\n",
362:        "      <td>NaN</td>\n",
363:        "      <td>NaN</td>\n",
364:        "      <td>NaN</td>\n",
365:        "    </tr>\n",
366:        "    <tr>\n",
367:        "      <th>498</th>\n",
368:        "      <td>congress_twitter</td>\n",
369:        "      <td>18</td>\n",
370:        "      <td>0.0335</td>\n",
371:        "      <td>0.003752</td>\n",
372:        "      <td>0.073450</td>\n",
373:        "      <td>25</td>\n",
374:        "      <td>NaN</td>\n",
375:        "      <td>NaN</td>\n",
376:        "      <td>NaN</td>\n",
377:        "      <td>NaN</td>\n",
378:        "      <td>NaN</td>\n",
379:        "      <td>NaN</td>\n",
380:        "      <td>NaN</td>\n",
381:        "      <td>NaN</td>\n",
382:        "    </tr>\n",
383:        "    <tr>\n",
384:        "      <th>499</th>\n",
385:        "      <td>congress_twitter</td>\n",
386:        "      <td>19</td>\n",
387:        "      <td>0.0303</td>\n",
388:        "      <td>0.004358</td>\n",
389:        "      <td>0.074571</td>\n",
390:        "      <td>25</td>\n",
391:        "      <td>NaN</td>\n",
392:        "      <td>NaN</td>\n",
393:        "      <td>NaN</td>\n",
394:        "      <td>NaN</td>\n",
395:        "      <td>NaN</td>\n",
396:        "      <td>NaN</td>\n",
397:        "      <td>NaN</td>\n",
398:        "      <td>NaN</td>\n",
399:        "    </tr>\n",
400:        "  </tbody>\n",
401:        "</table>\n",
402:        "<p>500 rows × 14 columns</p>\n",
403:        "</div>"
404:       ],
405:       "text/plain": [
406:        "              dataset  surrogate  shortest_path    degree  clustering  \\\n",
407:        "0         lastfm_asia          0         0.2392  0.003980    0.068181   \n",
408:        "1         lastfm_asia          1         0.2306  0.004052    0.069189   \n",
409:        "2         lastfm_asia          2         0.1723  0.004388    0.068788   \n",
410:        "3         lastfm_asia          3         0.1872  0.004476    0.073102   \n",
411:        "4         lastfm_asia          4         0.2375  0.004593    0.069663   \n",
412:        "..                ...        ...            ...       ...         ...   \n",
413:        "495  congress_twitter         15         0.0226  0.004695    0.073769   \n",
414:        "496  congress_twitter         16         0.0254  0.004873    0.079693   \n",
415:        "497  congress_twitter         17         0.0363  0.004783    0.071975   \n",
416:        "498  congress_twitter         18         0.0335  0.003752    0.073450   \n",
417:        "499  congress_twitter         19         0.0303  0.004358    0.074571   \n",
418:        "\n",
419:        "     block_size  avg_path_length  avg_clustering  spectral  infomap  leiden  \\\n",
420:        "0             6              NaN             NaN       NaN      NaN     NaN   \n",
421:        "1             6              NaN             NaN       NaN      NaN     NaN   \n",
422:        "2             6              NaN             NaN       NaN      NaN     NaN   \n",
423:        "3             6              NaN             NaN       NaN      NaN     NaN   \n",
424:        "4             6              NaN             NaN       NaN      NaN     NaN   \n",
425:        "..          ...              ...             ...       ...      ...     ...   \n",
426:        "495          25              NaN             NaN       NaN      NaN     NaN   \n",
427:        "496          25              NaN             NaN       NaN      NaN     NaN   \n",
428:        "497          25              NaN             NaN       NaN      NaN     NaN   \n",
429:        "498          25              NaN             NaN       NaN      NaN     NaN   \n",
430:        "499          25              NaN             NaN       NaN      NaN     NaN   \n",
431:        "\n",
432:        "     assortativity  embedding_node2vec  embedding_prone  \n",
433:        "0              NaN                 NaN              NaN  \n",
434:        "1              NaN                 NaN              NaN  \n",
435:        "2              NaN                 NaN              NaN  \n",
436:        "3              NaN                 NaN              NaN  \n",
437:        "4              NaN                 NaN              NaN  \n",
438:        "..             ...                 ...              ...  \n",
439:        "495            NaN                 NaN              NaN  \n",
440:        "496            NaN                 NaN              NaN  \n",
441:        "497            NaN                 NaN              NaN  \n",
442:        "498            NaN                 NaN              NaN  \n",
443:        "499            NaN                 NaN              NaN  \n",
444:        "\n",
445:        "[500 rows x 14 columns]"
446:       ]
447:      },
448:      "execution_count": 17,
449:      "metadata": {},
450:      "output_type": "execute_result"
451:     }
452:    ],
453:    "source": [
454:     "df"
455:    ]
456:   },
457:   {
458:    "cell_type": "code",
459:    "execution_count": 12,
460:    "id": "57a9d87f",
461:    "metadata": {},
462:    "outputs": [
463:     {
464:      "data": {
465:       "image/png": "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ZiUi9+JYxbGKyF9wvOJ45TAH135RgJU1xcLMYsWKmaZPnx6uMo2tsqbw119/mWrXrq2LNFFxp1q1aqYtW7ZE+FrXrl0zdevWTRdgovJN5syZdeHl1atXI5Q1tTRgwADdPm3aNLvfx759+0z9+/c3lShRwpQyZUpdLIqFqs2bN9fzs2S92BMf21vEiX8fA0qtDh482JQ7d249f5RcLV++vOnjjz82PX782OF/cyJyHscqjlVE/oLjFccrZ8XCfxwP0YiIiIiIiMgZXNNFRERERETkQQy6iIiIiIiIPIhBFxERERERkQcx6CIiIiIiIvIgBl1EREREREQexKCLiIiIiIjIgxh0EREREREReRCDLiIiIiIiIg9i0EVERERERORBDLqIiIiIiIg8iEEXERERERGRBzHoIiIiIiIi8iAGXURERERERB7EoIuIiIiIiMiDGHQRERERERF5EIMuIiIiIiIiD2LQRURERERE5EEMuoiIiIiIiDyIQRcREREREZEHMegiIiIiIiLyIAZdREREREREHsSgi4iIiIiIyIMYdBEREREREXkQgy4iIiIiIiIPYtBFRERERETkQQy6iIiIiIiIPIhBFxERERERkQcx6CIiIiIiIvIgBl1EREREREQexKCLiIiIiIjIgxh0EREREREReRCDLiIiIiIiIg9i0EVERERERORBDLqIiIiIiIg8iEEXERERERGRBzHoIiIiIiIi8iAGXURERERERB7EoIuIiIiIiMiDGHQRERERERF5EIMuIiIiIiIiD2LQRURERERE5EEMuoiIiIiIiDyIQRcREREREZEHMegiIiIiIiLyoBBPvnmwefr0qTx58sTbp0FBLG7cuBInThxvnwYRERERWWDQ5QYmk0n+/fdfuXnzprdPhUiSJ08u6dOnl1ixYnn7VIiIiIiIQZd7GAFX2rRpJVGiRLzYJa8F//fv35fLly/r6wwZMnj7lIiIiIiIQZd7UgqNgCtVqlTePh0KcgkTJtRnBF74mWSqIREREZH3sZBGNBlruDDDReQLjJ9Fri8kIiIi8g0MutyEKYXkK/izSERERORbGHQRERERERF5EIMuIjfKnj27TJo0ydunQUREREQ+hEGXj3j67JlsOH1a5u3fr894TTGratWq0qtXr2i9x86dO6VLly7hUv1+/vnncMcMHz5cihUrFq2vQ0RERET+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xnbs9zTMYKGgxI8//qipd5jxwgyWJQRlgwcPliJFimiVQay7QqADISEhMmXKFG2CjAqCKLkeU1DgA7NXKHKB9WaY+UKgZMB5Yhbv9ddf15muFi1aaKokmjbbMmHCBEmRIoWUL19eAy+kXZYoUSLGvh8iIiIiCjysXhhNrBRHvoY/k0RERES+hTNdREREREREHsSgi3waqgiibLutB9IEiYiIiIh8HQtpkE9DYQ+sw7IFxTuIiIiIiHwdgy7yaSlTptQHEREREZG/YnohERERERGRBzHoIiIiIiIi8iAGXURERERERB7EoIuIiIiIiMiDGHQRERERERF5EIMucsnw4cOlWLFiHv86sWLFkp9//tnlz9+8ebMULlxY4saNK40aNZINGzboe968edOt50lEREREZA9LxnuZ6dYNkfv37B+QKLHESpZCfF379u01kIlOgOQJffr00eBwxYoV2lB5z5493j4lIiIiIgoyDLq8HHCFTRsnEhZm/6CQEAnpNsgvAi9fdOLECW2wnDlzZm+fChEREREFKaYXehNmuCILuAD7I5sJi4Znz57J+PHjJXfu3BI/fnzJmjWrjB49WvcNHDhQ8ubNK4kSJZKcOXPK0KFD5cmTJ3ZTDefMmSNLlizR1D08kMYHZ8+elRYtWkjy5Mm1yXHDhg3l9OnT4T7/66+/lkKFCuk5ZMiQQbp16xZu/9WrV6Vx48Z6Lnny5JFffvklyu8NXwPnce3aNXnjjTf049mzZ4dLOyxSpIgkSJBAypYtKwcOHHDp35CIiIiIKCoMuoLY4MGDZdy4cRpQHTp0SObOnSvp0qXTfaGhoRqkYPvkyZNl5syZMnHiRJvv069fPw2s6tSpIxcvXtRH+fLlNUirXbu2vtemTZs00EGKH457/Pixfu706dPlnXfekS5dusj+/fs1oEIQaGnEiBH6/vv27ZN69epJ27Zt5fr165F+b1myZNHzSJo0qUyaNEk/btmypXl///795ZNPPpGdO3dKmjRp5JVXXrEbVBIRERERRQfTC4PUnTt3NJiaNm2atGvXTrflypVLKlasqB+/99575mOzZ8+ugdX8+fNlwIABEd4LgVTChAnl0aNHkj59evP27777TmfTvvzyS51pglmzZumsF2bCXnrpJRk1apT07dtXevbsaf680qVLR1gv1rp1a/14zJgxMmXKFNmxY4cG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unwIUgmxhsuTKYXWEFghCDGCrpQpU0rBggU17S9fvnxRfj7WTK1YsUJnourXry/37t1z+hwwa4VUQKQ5GgU0DJkyZZLly5fLjh07pGjRovLmm29Kx44d5b333jMfgzVhKJ6B80baI9abIXDDjBi+t5deekkKFy6sa89Qyt4I1oiIiIiIYkIsk2XeFjnt4cOHcurUKcmRI4em2hF5G38miYiIiHwLb/kTERERERF5EIMu8qhChQppCqKth3VTZCIiIiKiQMSS8eRRWI/15MkTm/vSpUsX4+dDRERERBTTGHSRR2XLls3bp0BERERE5FVMLyQiIiIiIvIgBl1EREREREQexKCLiIiIiIjIgxh0EREREREReRCDLiIiIiIiIg9i0EVERERERORBDLqIHHT69GmJFSuW7NmzR19v2LBBX9+8edPbp0ZEREREPoxBly+586/I+rHPn8nnZMmSRS5evCgvvPCCt0+FiIiIiPwIgy5fgmBr4zi/DboeP34sgSxOnDiSPn16CQlhT3EiIiIichyDriD27NkzGTt2rOTIkUMSJkwoRYsWlYULF4ZLnVu7dq2UKlVKEiVKJOXLl5cjR46YP3/48OFSrFgx+fLLL/U9EiRIoNvPnDkjDRs2lCRJkkjSpEmlRYsWcunSpQif9+2330r27NklWbJk0qpVK7lz5060z9vy3FetWiXFixfXY6pXry6XL1+WFStWSIECBfS82rRpI/fv3zd/3sqVK6VixYqSPHlySZUqlbz88sty4sQJu+mFRERERESOYNDlbZjVurDn+ePi3ufb8Gxs8+CsFwKXb775Rj7//HM5ePCg9O7dW1599VXZuHGj+ZghQ4bIJ598Irt27dIZnjfeeCPcexw/flx++uknWbRokQYjCIgQcF2/fl3fZ/Xq1XLy5Elp2bJluM9DMPPzzz/L0qVL9YFjx40b57bzNoK7adOmyZYtW+Ts2bMa/E2aNEnmzp0ry5Ytk99++02mTp1qPv7evXvSp08f/V4RbMaOHVsaN26s3xMRERERkauYJ+Vtu2Y9Tym09GuP/z6uMkik2mC3f9lHjx7JmDFjZM2aNVKuXDndljNnTvnjjz/kiy++kC5duui20aNHS5UqVfTjQYMGSf369eXhw4fmWS2kFCIASpMmjb5GkLV//345deqUroEC7C9UqJDs3LlTSpcurdsQyMyePVtCQ0P19WuvvaaBDr5edM7bOFcYNWqUVKhQQT/u2LGjDB48WIM9HA/NmjWT9evXy8CBA/V106ZNw32tr7/+Wr+vQ4cOcR0XEREREbmMQZe3leogkq/ufzNcCLhemSKSoejzbaHpPfJlMUOF1LpatWqF244gCil5hiJFipg/zpAhgz4jTS9r1qz6cbZs2cwBFxw+fFiDLSPggoIFC2rKHvYZQRfSCo2Ay3hvvK+7ztv63NOlS6cpkkbAZWzbsWOH+fWxY8fk/fffl+3bt8vVq1fNM1xIl2TQRURERESuYtDlbQiqrAMrBFwZi3n0y969e1efkWaXKVOmcPvix49vXssUN25c83asZwLLdLvEiRO79PUt39d4b0fS+KI6b3tfA+8f1dd85ZVXNIicOXOmZMyYUfch2Ar0AiFERERE5FkMuoIUZp8QpGAWxzIlz2BZQMIZKFKB9VN4GLNdSM9DLyt8TU+ft6uuXbumRUIQcFWqVEm3IWWRiIiIiCi6GHT5Esx4YQ2Xh1IKw32p0FDp16+fFqHAjA6q9t26dUs2b96slf0w4+OKmjVrSuHChaVt27ZatCIsLEzefvttDZBQBdHT592uXTuX3jdFihRasXDGjBma6oigDmvYiIiIiIiii0GXL0Gw5YGiGfZ88MEHuh4L1QBRYRDrrkqUKCHvvvuuyxX7kLK3ZMkS6d69u1SuXFkrANapUydclUBPnrercJ7z58+XHj16aEphvnz5ZMqUKVK1alW3nTcRERERBadYJpPJ5O2T8Geo5IdKfZZ9qoi8iT+TRERERL6FfbqIiIiIiIg8iEEX+RSspUqSJIndB/YTEREREfkTrukin4JS7Xv27Il0PxERERGRP2HQRT4lJCREcufO7e3TICIiIiJyG6YXugnrkZCv4M8iERERkW9h0BVNcePG1ef79+97+1SIwv0sGj+bRERERORdTC+Mpjhx4mifqMuXL+vrRIkSaa8qIm/McCHgws8ifibxs0lERERE3sc+XW6Af8J///1Xbt686e1TIdKAK3369Az+iYiIiHwEgy43evr0qTx58sSdb0nkFKQUcoaLiIiIyLcw6CIiIiIiIvIgFtIgIiIiIiLyIAZdREREREREHsSgi4iIiIiIyIMYdBEREREREXkQgy4iIiIiIiIPYtBFRERERETkQQy6iIiIiIiIxHP+B4LShCo8u8BUAAAAAElFTkSuQmCC",
466:       "text/plain": [
467:        "<Figure size 1000x300 with 3 Axes>"
468:       ]
469:      },
470:      "metadata": {},
471:      "output_type": "display_data"
472:     }
473:    ],
474:    "source": [
475:     "### Visualize reconstruction error across block sizes and datasets\n",
476:     "fig, ax = plt.subplots(\n",
477:     "    figsize=(10, 3),\n",
478:     "    ncols = 3,\n",
479:     "    sharex=True,\n",
480:     "    sharey=False,\n",
481:     "    # set spacing between subplots\n",
482:     "    gridspec_kw={'wspace': 0.7}\n",
483:     "    )\n",
484:     "\n",
485:     "for group in df.groupby(['block_size', 'dataset']):\n",
486:     "    block_size, dataset = group[0]\n",
487:     "    group_data = group[1]\n",
488:     "\n",
489:     "    marker = marker_styles[dataset]\n",
490:     "    color = colors[dataset]\n",
491:     "\n",
492:     "    # plot the shortest-path reconstruction error for each surrogate\n",
493:     "    path_errors = group_data['shortest_path'].mean()\n",
494:     "    ax[0].plot(\n",
495:     "        [block_size],\n",
496:     "        [path_errors],\n",
497:     "        label=f\"{dataset}\",\n",
498:     "        marker=marker,\n",
499:     "        linewidth=0,\n",
500:     "        color=color\n",
501:     "    )\n",
502:     "\n",
503:     "    # plot the degree-dist reconstruction error for each surrogate\n",
504:     "    degree_errors = group_data['degree'].mean()\n",
505:     "    ax[1].plot(\n",
506:     "        [block_size],\n",
507:     "        [degree_errors],\n",
508:     "        marker=marker,\n",
509:     "        linewidth=0,\n",
510:     "        color=color\n",
511:     "    )\n",
512:     "\n",
513:     "    clustering_errors = group_data['clustering'].mean()\n",
514:     "    ax[2].plot(\n",
515:     "        [block_size],\n",
516:     "        [clustering_errors],\n",
517:     "        marker=marker,\n",
518:     "        linewidth=0,\n",
519:     "        color=color\n",
520:     "    )\n",
521:     "        \n",
522:     "ax[0].set_ylabel('Shortest-path distribution error', fontsize=12)\n",
523:     "ax[1].set_ylabel('Degree distribution error', fontsize=12)\n",
524:     "ax[2].set_ylabel('Clustering distribution error', fontsize=12)\n",
525:     "\n",
526:     "xticks = df['block_size'].unique()[::3]\n",
527:     "for axis in ax:\n",
528:     "    axis.set_xscale('log')\n",
529:     "    axis.set_xticks(xticks)\n",
530:     "    axis.set_xticklabels(xticks, fontsize=12)\n",
531:     "    axis.spines[['top', 'right']].set_visible(False)\n",
532:     "    axis.set_xlabel('Block size', fontsize=12)\n",
533:     "\n",
534:     "    axis.set_xlabel('Block Size')\n",
535:     "\n",
536:     "\n",
537:     "### Construct legend from single axis\n",
538:     "handles, labels = ax[0].get_legend_handles_labels()\n",
539:     "legend_set = set(zip(labels, handles))\n",
540:     "\n",
541:     "by_label = dict(legend_set)\n",
542:     "ax[0].legend(\n",
543:     "    by_label.values(),\n",
544:     "    by_label.keys(),\n",
545:     "    loc='lower left',\n",
546:     "    bbox_to_anchor=(0, -1),\n",
547:     "    fontsize=10,\n",
548:     "    )\n",
549:     "\n",
550:     "plt.show(fig)"
551:    ]
552:   },
553:   {
554:    "cell_type": "code",
555:    "execution_count": 13,
556:    "id": "1f49754b",
557:    "metadata": {},
558:    "outputs": [],
559:    "source": [
560:     "import numpy as np\n",
561:     "\n",
562:     "rng = np.random.default_rng(42)"
563:    ]
564:   },
565:   {
566:    "cell_type": "code",
567:    "execution_count": 14,
568:    "id": "c965ecb3",
569:    "metadata": {},
570:    "outputs": [],
571:    "source": [
572:     "import scipy.sparse as sp\n",
573:     "\n",
574:     "a = sp.random(100, 100, density=0.1, format='csr', random_state=rng)"
575:    ]
576:   },
577:   {
578:    "cell_type": "code",
579:    "execution_count": 15,
580:    "id": "dac2e459",
581:    "metadata": {},
582:    "outputs": [
583:     {
584:      "data": {
585:       "text/plain": [
586:        "array([[0.        , 0.        , 0.        , ..., 0.        , 0.        ,\n",
587:        "        0.        ],\n",
588:        "       [0.        , 0.        , 0.        , ..., 0.        , 0.        ,\n",
589:        "        0.        ],\n",
590:        "       [0.48176355, 0.75232891, 0.        , ..., 0.        , 0.        ,\n",
591:        "        0.86413683],\n",
592:        "       ...,\n",
593:        "       [0.        , 0.        , 0.        , ..., 0.        , 0.        ,\n",
594:        "        0.        ],\n",
595:        "       [0.        , 0.42176606, 0.        , ..., 0.        , 0.        ,\n",
596:        "        0.        ],\n",
597:        "       [0.        , 0.        , 0.        , ..., 0.        , 0.        ,\n",
598:        "        0.        ]])"
599:       ]
600:      },
601:      "execution_count": 15,
602:      "metadata": {},
603:      "output_type": "execute_result"
604:     }
605:    ],
606:    "source": [
607:     "a.toarray()"
608:    ]
609:   },
610:   {
611:    "cell_type": "code",
612:    "execution_count": 16,
613:    "id": "3aa9b937",
614:    "metadata": {},
615:    "outputs": [
616:     {
617:      "data": {
618:       "text/plain": [
619:        "<1x100 sparse matrix of type '<class 'numpy.float64'>'\n",
620:        "\twith 8 stored elements in Compressed Sparse Row format>"
621:       ]
622:      },
623:      "execution_count": 16,
624:      "metadata": {},
625:      "output_type": "execute_result"
626:     }
627:    ],
628:    "source": [
629:     "# flatten the \n",
630:     "a[0, :]"
631:    ]
632:   },
633:   {
634:    "cell_type": "code",
635:    "execution_count": 1,
636:    "id": "5eed144f",
637:    "metadata": {},
638:    "outputs": [],
639:    "source": [
640:     "from sbm.noisy_fit import HeterogeneousGaussNoise, NaiveDegreeGaussNoise, create_sbm_noise\n",
641:     "from sbm.io import SBMWriter\n",
642:     "from pathlib import Path\n",
643:     "import numpy as np"
644:    ]
645:   },
646:   {
647:    "cell_type": "code",
648:    "execution_count": 2,
649:    "id": "8354f69a",
650:    "metadata": {},
651:    "outputs": [
652:     {
653:      "name": "stdout",
654:      "output_type": "stream",
655:      "text": [
656:       "Loading SBM fit from /Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_caltech_fb_cooling_rate_0_999_force_undirected_True_init_method_ProneKMeans_min_block_size_12_n_iter_100000_temperature_1_0\n"
657:      ]
658:     }
659:    ],
660:    "source": [
661:     "sbm = SBMWriter.load(\n",
662:     "    Path(\"/Users/lmmi/anon_sbm/results/sbm_fits/sbm_fit_caltech_fb_cooling_rate_0_999_force_undirected_True_init_method_ProneKMeans_min_block_size_12_n_iter_100000_temperature_1_0\")\n",
663:     ")"
664:    ]
665:   },
666:   {
667:    "cell_type": "code",
668:    "execution_count": 4,
669:    "id": "2a0f1cea",
670:    "metadata": {},
671:    "outputs": [
672:     {
673:      "ename": "ValueError",
674:      "evalue": "index pointer size (2081) should be (65)",
675:      "output_type": "error",
676:      "traceback": [
677:       "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
678:       "\u001b[31mValueError\u001b[39m                                Traceback (most recent call last)",
679:       "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[4]\u001b[39m\u001b[32m, line 2\u001b[39m\n\u001b[32m      1\u001b[39m rng = np.random.default_rng(\u001b[32m0\u001b[39m)\n\u001b[32m----> \u001b[39m\u001b[32m2\u001b[39m noiser = \u001b[43mcreate_sbm_noise\u001b[49m\u001b[43m(\u001b[49m\n\u001b[32m      3\u001b[39m \u001b[43m    \u001b[49m\u001b[43msbm\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43meps\u001b[49m\u001b[43m=\u001b[49m\u001b[32;43m1.0\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mdelta\u001b[49m\u001b[43m=\u001b[49m\u001b[32;43m1e-6\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43malpha\u001b[49m\u001b[43m=\u001b[49m\u001b[32;43m0.999\u001b[39;49m\u001b[43m,\u001b[49m\n\u001b[32m      4\u001b[39m \u001b[43m    \u001b[49m\u001b[43mnoise_type\u001b[49m\u001b[43m=\u001b[49m\u001b[33;43m\"\u001b[39;49m\u001b[33;43mheterogeneous_gaussian\u001b[39;49m\u001b[33;43m\"\u001b[39;49m\n\u001b[32m      5\u001b[39m \u001b[43m    \u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m      7\u001b[39m \u001b[38;5;28;01massert\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(noiser, NaiveDegreeGaussNoise)\n\u001b[32m      8\u001b[39m \u001b[38;5;28mprint\u001b[39m(noiser.sigma_n_scalar, noiser.sigma_e_scalar)\n",
680:       "\u001b[36mFile \u001b[39m\u001b[32m~/anon_sbm/src/sbm/noisy_fit.py:346\u001b[39m, in \u001b[36mcreate_sbm_noise\u001b[39m\u001b[34m(sbm, eps, delta, alpha, clip_p, weight_clip, noise_type)\u001b[39m\n\u001b[32m    343\u001b[39m sigma_e_data = (np.sqrt(c_e_val * data_w_e) * S_sum) / R \u001b[38;5;66;03m# type: ignore\u001b[39;00m\n\u001b[32m    345\u001b[39m \u001b[38;5;66;03m# build sparse σ matrix upper tri\u001b[39;00m\n\u001b[32m--> \u001b[39m\u001b[32m346\u001b[39m sigma_e = \u001b[43msp\u001b[49m\u001b[43m.\u001b[49m\u001b[43mcsr_array\u001b[49m\u001b[43m(\u001b[49m\u001b[43m(\u001b[49m\u001b[43msigma_e_data\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m    347\u001b[39m \u001b[43m                        \u001b[49m\u001b[43mnp\u001b[49m\u001b[43m.\u001b[49m\u001b[43marray\u001b[49m\u001b[43m(\u001b[49m\u001b[43mdata_sigma_idx\u001b[49m\u001b[43m)\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m    348\u001b[39m \u001b[43m                        \u001b[49m\u001b[43mnp\u001b[49m\u001b[43m.\u001b[49m\u001b[43marange\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;28;43mlen\u001b[39;49m\u001b[43m(\u001b[49m\u001b[43mdata_sigma_idx\u001b[49m\u001b[43m)\u001b[49m\u001b[43m \u001b[49m\u001b[43m+\u001b[49m\u001b[43m \u001b[49m\u001b[32;43m1\u001b[39;49m\u001b[43m)\u001b[49m\u001b[43m)\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m    349\u001b[39m \u001b[43m                       \u001b[49m\u001b[43mshape\u001b[49m\u001b[43m=\u001b[49m\u001b[43m(\u001b[49m\u001b[43mB\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mB\u001b[49m\u001b[43m)\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    350\u001b[39m sigma_e = sigma_e + sigma_e.T - sp.diags(sigma_e.diagonal())\n\u001b[32m    352\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m noise_type == \u001b[33m\"\u001b[39m\u001b[33mheterogeneous_gaussian\u001b[39m\u001b[33m\"\u001b[39m:\n",
681:       "\u001b[36mFile \u001b[39m\u001b[32m/opt/homebrew/Caskroom/miniforge/base/envs/anon_sbm_notebook_arm/lib/python3.12/site-packages/scipy/sparse/_compressed.py:107\u001b[39m, in \u001b[36m_cs_matrix.__init__\u001b[39m\u001b[34m(self, arg1, shape, dtype, copy)\u001b[39m\n\u001b[32m    104\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m dtype \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n\u001b[32m    105\u001b[39m     \u001b[38;5;28mself\u001b[39m.data = \u001b[38;5;28mself\u001b[39m.data.astype(dtype, copy=\u001b[38;5;28;01mFalse\u001b[39;00m)\n\u001b[32m--> \u001b[39m\u001b[32m107\u001b[39m \u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43mcheck_format\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfull_check\u001b[49m\u001b[43m=\u001b[49m\u001b[38;5;28;43;01mFalse\u001b[39;49;00m\u001b[43m)\u001b[49m\n",
682:       "\u001b[36mFile \u001b[39m\u001b[32m/opt/homebrew/Caskroom/miniforge/base/envs/anon_sbm_notebook_arm/lib/python3.12/site-packages/scipy/sparse/_compressed.py:168\u001b[39m, in \u001b[36m_cs_matrix.check_format\u001b[39m\u001b[34m(self, full_check)\u001b[39m\n\u001b[32m    166\u001b[39m \u001b[38;5;66;03m# check index pointer\u001b[39;00m\n\u001b[32m    167\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m (\u001b[38;5;28mlen\u001b[39m(\u001b[38;5;28mself\u001b[39m.indptr) != major_dim + \u001b[32m1\u001b[39m):\n\u001b[32m--> \u001b[39m\u001b[32m168\u001b[39m     \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mValueError\u001b[39;00m(\u001b[33m\"\u001b[39m\u001b[33mindex pointer size (\u001b[39m\u001b[38;5;132;01m{}\u001b[39;00m\u001b[33m) should be (\u001b[39m\u001b[38;5;132;01m{}\u001b[39;00m\u001b[33m)\u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m    169\u001b[39m                      \u001b[33m\"\u001b[39m\u001b[33m\"\u001b[39m.format(\u001b[38;5;28mlen\u001b[39m(\u001b[38;5;28mself\u001b[39m.indptr), major_dim + \u001b[32m1\u001b[39m))\n\u001b[32m    170\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m (\u001b[38;5;28mself\u001b[39m.indptr[\u001b[32m0\u001b[39m] != \u001b[32m0\u001b[39m):\n\u001b[32m    171\u001b[39m     \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mValueError\u001b[39;00m(\u001b[33m\"\u001b[39m\u001b[33mindex pointer should start with 0\u001b[39m\u001b[33m\"\u001b[39m)\n",
683:       "\u001b[31mValueError\u001b[39m: index pointer size (2081) should be (65)"
684:      ]
685:     }
686:    ],
687:    "source": [
688:     "rng = np.random.default_rng(0)\n",
689:     "noiser = create_sbm_noise(\n",
690:     "    sbm, eps=1.0, delta=1e-6, alpha=0.999,\n",
691:     "    noise_type=\"heterogeneous_gaussian\"\n",
692:     "    )\n",
693:     "\n",
694:     "assert isinstance(noiser, NaiveDegreeGaussNoise)\n",
695:     "print(noiser.sigma_n_scalar, noiser.sigma_e_scalar)\n",
696:     "noisy_fit = noiser.sample_sbm_fit(rng)\n"
697:    ]
698:   },
699:   {
700:    "cell_type": "code",
701:    "execution_count": null,
702:    "id": "114a6e02",
703:    "metadata": {},
704:    "outputs": [],
705:    "source": []
706:   }
707:  ],
708:  "metadata": {
709:   "kernelspec": {
710:    "display_name": "anon_sbm_notebook_arm",
711:    "language": "python",
712:    "name": "python3"
713:   },
714:   "language_info": {
715:    "codemirror_mode": {
716:     "name": "ipython",
717:     "version": 3
718:    },
719:    "file_extension": ".py",
720:    "mimetype": "text/x-python",
721:    "name": "python",
722:    "nbconvert_exporter": "python",
723:    "pygments_lexer": "ipython3",
724:    "version": "3.12.11"
725:   }
726:  },
727:  "nbformat": 4,
728:  "nbformat_minor": 5
729: }

================
File: src/metrics/shortest_path.py
================
  1: """ 
  2: Metrics functions to compare the shortest-path properties of two graphs.
  3: """
  4: # metrics/shortest_path.py
  5: from typing import Optional
  6: import numpy as np
  7: import networkx as nx
  8: from scipy.stats import wasserstein_distance #  1-D EMD
  9: from scipy.sparse import csr_array
 10: from sbm.utils.util import restrict_to_lcc, _nx_graph
 11: import networkx as nx
 12: from typing import  Hashable, List, Union
 13: ### Aliases  --------------------------------------------------------
 14: Number = Union[int, float]
 15: ### Helpers ---------------------------------------------------------
 16: def _average_path_length(
 17:     G: nx.Graph,
 18:     *,
 19:     n_samples: Optional[int],
 20:     rng: np.random.Generator,
 21: ) -> float:
 22:     """Return ⟨d⟩ ≡ mean shortest‑path length in *G*.
 23:     If *n_samples* is None or the graph is small (≤ 2000 nodes), the exact
 24:     average is computed. Otherwise *n_samples* node pairs are sampled.
 25:     """
 26:     n = G.number_of_nodes()
 27:     if n <= 1:
 28:         return 0.0
 29:     if n_samples is None or n <= 2000:
 30:         return nx.average_shortest_path_length(G)
 31:     # --- sample pairs ---------------------------------------------------------
 32:     nodes = list(G)
 33:     path_lens: List[int] = []
 34:     for _ in range(int(n_samples)):
 35:         u, v = rng.choice(nodes, size=2, replace=False)
 36:         try:
 37:             path_lens.append(nx.shortest_path_length(G, u, v))
 38:         except nx.NetworkXNoPath:
 39:             # Ignore unreachable pairs → corresponds to infinite distance.
 40:             pass
 41:     return float(np.mean(path_lens)) if path_lens else np.inf
 42: def all_unique_shortest_distances(
 43:     G: nx.Graph,
 44:     weight: str | None = None,
 45:     cutoff: Number | None = None,
 46:     directed: bool = False,
 47: ) -> List[Number]:
 48:     """
 49:     Return a list containing the length of every unique shortest path in *G*.
 50:     Parameters
 51:     ----------
 52:     G : networkx.Graph
 53:         The input graph (directed or undirected, weighted or unweighted).
 54:     weight : str or None, default=None
 55:         Edge-attribute key to use as weight.  ``None`` ⇒ treat edges as unit-weight.
 56:     cutoff : int | float | None, default=None
 57:         Ignore paths longer than *cutoff* (same semantics as NetworkX).
 58:     Returns
 59:     -------
 60:     distances : list[Number]
 61:         One entry per unordered, connected node pair.  
 62:         Unreachable pairs are silently skipped.
 63:     """
 64:     # 1.  Choose the correct all-pairs iterator
 65:     if weight is None:
 66:         # Unweighted ⇢ multi-source breadth-first search
 67:         iterator = nx.all_pairs_shortest_path_length(G, cutoff=cutoff)  # :contentReference[oaicite:0]{index=0}
 68:     else:
 69:         # Weighted ⇢ repeated Dijkstra
 70:         iterator = nx.all_pairs_dijkstra_path_length(G, cutoff=cutoff, weight=weight)  # :contentReference[oaicite:1]{index=1}
 71:     # 2.  Collect unique unordered pairs
 72:     seen: set[frozenset[Hashable]] = set()
 73:     distances: List[Number] = []
 74:     for u, length_dict in iterator:
 75:         for v, d in length_dict.items():
 76:             if u == v:                       # skip self-loops (distance 0)
 77:                 continue
 78:             pair = frozenset((u, v))         # unordered representation
 79:             if pair in seen:                 # already counted via (v, u)
 80:                 continue
 81:             seen.add(pair)
 82:             distances.append(d)
 83:     return distances
 84: ###############################################################################
 85: ### --- Metrics --------------------------------------------------------
 86: ###############################################################################
 87: def shortest_path_distance(
 88:         emp_adj: csr_array,
 89:         sur_adj: csr_array,
 90:         n_samples: Optional[int]=10_000,
 91:         rng:np.random.Generator = np.random.default_rng(1)
 92:     ) -> float:
 93:     """
 94:     Earth-mover (1-D Wasserstein) distance between the distributions
 95:     of all-pairs shortest-path lengths.
 96:     Parameters
 97:     ----------
 98:     emp_adj, sur_adj : scipy.sparse.csr_matrix
 99:         Adjacency of empirical and surrogate graphs (undirected).
100:     n_samples : int, optional
101:         Number of samples to use for the distributions.
102:         If None, all pairs are used.
103:     Returns
104:     -------
105:     float
106:         Distance (lower = more similar).
107:     """
108:     emp_adj = restrict_to_lcc(emp_adj, directed=False)
109:     sur_adj = restrict_to_lcc(sur_adj, directed=False)
110:     emp_graph_size = emp_adj.shape[0] # type: ignore
111:     sur_graph_size = sur_adj.shape[0] # type: ignore
112:     if n_samples is None:
113:         # Use all pairs if n_samples is None, generated using networkx (returns iterator)
114:         x = all_unique_shortest_distances(
115:             nx.from_scipy_sparse_matrix(emp_adj),
116:             weight=None,
117:             cutoff=None
118:         )
119:         y = all_unique_shortest_distances(
120:             nx.from_scipy_sparse_matrix(sur_adj),
121:             weight=None,
122:             cutoff=None
123:         )
124:     else:
125:         n_samples_emp = int(min(
126:             n_samples,
127:             emp_graph_size * (emp_graph_size - 1) // 2,
128:         ))
129:         n_samples_sur = int(min(
130:             n_samples,
131:             sur_graph_size * (sur_graph_size - 1) // 2,
132:         ))
133:         emp_pair_part_1 = rng.choice(emp_graph_size, size=n_samples_emp, replace=True)
134:         emp_pair_part_2 = rng.choice(emp_graph_size-1, size=n_samples_emp, replace=True)
135:         emp_pair_part_2[emp_pair_part_2 >= emp_pair_part_1] += 1
136:         emp_pairs = np.column_stack((emp_pair_part_1, emp_pair_part_2))
137:         sur_pair_part_1 = rng.choice(sur_graph_size, size=n_samples_sur, replace=True)
138:         sur_pair_part_2 = rng.choice(sur_graph_size-1, size=n_samples_sur, replace=True)
139:         sur_pair_part_2[sur_pair_part_2 >= sur_pair_part_1] += 1
140:         sur_pairs = np.column_stack((sur_pair_part_1, sur_pair_part_2))
141:         def sample_shortest_paths(adj, pairs):
142:             G = nx.from_scipy_sparse_matrix(adj)
143:             path_lengths = []
144:             for pair in pairs:
145:                 try:
146:                     length = nx.shortest_path_length(G, source=pair[0], target=pair[1])
147:                     path_lengths.append(length)
148:                 except nx.exception.NodeNotFound:
149:                     raise Warning(
150:                         f"Node {pair[0]} or {pair[1]} not found in the graph."
151:                     )
152:             return path_lengths
153:         x = sample_shortest_paths(emp_adj, emp_pairs)
154:         y = sample_shortest_paths(sur_adj, sur_pairs)
155:     return wasserstein_distance(x, y)
156: ###############################################################################
157: # Average path‑length difference -------------------------------------------
158: ###############################################################################
159: def avg_path_length_difference(
160:     emp_adj: csr_array,
161:     sur_adj: csr_array,
162:     *,
163:     n_samples: Optional[int] = 10_000,
164:     rng: np.random.Generator = np.random.default_rng(1),
165:     restrict_to_lcc: bool = True,
166: ) -> float:
167:     """Absolute difference of average shortest‑path lengths.
168:     Parameters
169:     ----------
170:     n_samples : int | None
171:         If *None*, compute the exact average; otherwise sample this many
172:         (unordered) node pairs.
173:     """
174:     G_emp = _nx_graph(emp_adj, directed=False)
175:     G_sur = _nx_graph(sur_adj, directed=False)
176:     if restrict_to_lcc:
177:         G_emp = G_emp.subgraph(max(nx.connected_components(G_emp), key=len))
178:         G_sur = G_sur.subgraph(max(nx.connected_components(G_sur), key=len))
179:     d_emp = _average_path_length(G_emp, n_samples=n_samples, rng=rng)
180:     d_sur = _average_path_length(G_sur, n_samples=n_samples, rng=rng)
181:     return abs(d_emp - d_sur)

================
File: src/sbm/block_change_proposers.py
================
  1: from typing import List, Optional, Tuple, DefaultDict, Literal
  2: from collections import defaultdict, Counter
  3: import numpy as np
  4: from sbm.block_data import BlockData
  5: from sbm.edge_delta import EdgeDelta, NumpyEdgeDelta
  6: ### Aliases 
  7: CombinationDelta= DefaultDict[Tuple[int, int], int] # changes in possible pairs between blocks
  8: ProposedValidChanges = List[Tuple[int, int]]  # list of proposed node-block pairs
  9: ChangeProposerName = Literal["uniform_swap", "edge_based_swap", "triadic_swap"]
 10: ChangeProposers = Literal["NodeSwapProposer", "EdgeBasedSwapProposer", "TriadicSwapProposer"]
 11: ### ChangeProposer classes for proposing block changes in the SBM
 12: # These classes handle the logic of proposing valid changes to the block assignments
 13: # and computing the resulting edge deltas for the block connectivity matrix.
 14: class ChangeProposer:
 15:     """ 
 16:     Class to propose block-assignment changes for the MCMC algorithm.
 17:     Handles min block size constraints. All functions return None
 18:     if a  and ensures valid moves.
 19:     Proposers shoudl always change block-id to block-adjacency idx before
 20:     computing deltas.
 21:     """
 22:     def __init__(self,
 23:                  block_data: BlockData,
 24:                  rng: np.random.Generator=np.random.default_rng(1),
 25:                  use_numpy: bool = False,
 26:                  ):
 27:         self.block_data = block_data
 28:         self.rng = rng
 29:         self.min_block_size = 1
 30:         self.use_numpy = use_numpy
 31:         # Direct CSR pointers for O(1) edge sampling
 32:         self._indptr = self.block_data.graph_data.adjacency.indptr
 33:         self._indices = self.block_data.graph_data.adjacency.indices
 34:     def propose_change(self,
 35:         changes: Optional[ProposedValidChanges] = None,
 36:         )-> Tuple[ProposedValidChanges, EdgeDelta, CombinationDelta]:
 37:         raise NotImplementedError("This method should be overridden by subclasses.")
 38:     def _compute_delta_edge_counts(self, proposed_changes: ProposedValidChanges) -> EdgeDelta:
 39:         """
 40:         Compute the edge deltas for the proposed change.
 41:         :param change: Proposed change as a list of (node, target_block) tuples.
 42:         :return: EdgeDelta containing the changes in edge counts between blocks.
 43:         """
 44:         raise NotImplementedError("This method should be overridden by subclasses.")
 45:     # -----------------------------------------------------------------------------
 46:     def _compute_edge_counts_between_node_and_blocks(self,
 47:                                                node: int,
 48:                                                ) -> Counter[int]:
 49:         """
 50:         Compute the number of edges between a node and each affected block.
 51:         :param node: The node to move.
 52:         :param affected_blocks: The blocks affected by the move.
 53:         :return: A dictionary mapping block IDs to edge counts with the node.
 54:         k_i: Counter[int]: number of edges between node and each affected block.
 55:         returns a Counter object where keys are block IDs and values are edge counts.
 56:         """
 57:         if self.block_data.directed:
 58:             raise NotImplementedError("Directed graphs are not supported yet.")
 59:         else:
 60:             #neighbors = self.block_data.graph_data.adjacency[:, [node]].indices  # type: ignore
 61:             neighbors = self.block_data.graph_data.adjacency[[node], :].indices  # type: ignore
 62:             blocks_among_neighbors = [
 63:                 self.block_data.block_indices[
 64:                     self.block_data.blocks[neighbor]
 65:                 ] for neighbor in neighbors
 66:             ]
 67:             k_i = Counter(blocks_among_neighbors)
 68:             return k_i
 69: class NodeSwapProposer(ChangeProposer):
 70:     def propose_change(self,
 71:         changes: Optional[ProposedValidChanges] = None,
 72:     ) -> Tuple[ProposedValidChanges, EdgeDelta, CombinationDelta]:
 73:         """
 74:         Propose swapping two nodes between different blocks.
 75:         :return: Tuple of (node1, node2) or None if no valid swap.
 76:         """
 77:         if changes is not None:
 78:             if len(changes) != 2:
 79:                 raise ValueError("NodeSwapProposer requires exactly two nodes to swap.")
 80:             proposed_changes = changes
 81:         else:
 82:             # Select two different blocks
 83:             block1, block2 = self.rng.choice(
 84:                 self.block_data.block_connectivity.shape[0],
 85:                 #list(self.block_data.block_sizes.keys()),
 86:                 size=2,
 87:                 replace=False
 88:             )
 89:             # Select one node from each block
 90:             # Note: changing to list is inefficient for large blocks.
 91:             # However, having memberships being lists allow for fast 
 92:             # membership updates.
 93:             # Change if large blocks are common.
 94:             node1 = self.rng.choice(
 95:                 list(self.block_data.block_members[block1])
 96:             )
 97:             node2 = self.rng.choice(
 98:                 list(self.block_data.block_members[block2])
 99:             )
100:             proposed_changes :ProposedValidChanges = [(node1, block2), (node2, block1)]
101:         delta_e: EdgeDelta = self._compute_delta_edge_counts(
102:                 proposed_changes=proposed_changes,
103:                 use_numpy=self.use_numpy,
104:             )
105:         delta_n: CombinationDelta = defaultdict(int)
106:         return proposed_changes, delta_e, delta_n
107:     def _compute_delta_edge_counts(self,
108:             proposed_changes: ProposedValidChanges,
109:             use_numpy: bool = False,
110:         )-> EdgeDelta:
111:         """
112:         Compute the changes in edge counts between blocks due to swapping
113:         node i and node j.
114:         :param i: The index of the first node being swapped.
115:         :param j: The index of the second node being swapped.
116:         :param k_i: The edges between the moving node and its neighbor blocks.
117:         :param source_block: The block from which the node is moved.
118:         :param target_block: The block to which the node is moved.
119:         :return: A Counter mapping block pairs to changes in edge counts.
120:         """
121:         if self.block_data.directed:
122:             raise NotImplementedError("Directed graphs are not supported yet.")
123:         (i, old_block_j), (j, old_block_i) = proposed_changes
124:         if use_numpy:
125:             delta_e = NumpyEdgeDelta(
126:                 n_blocks=len(self.block_data.block_sizes)
127:             )
128:         else:
129:             delta_e = EdgeDelta(
130:                 n_blocks=len(self.block_data.block_sizes)
131:             )
132:         # compute the edge counts for the blocks of i and j
133:         # on block-adjacency idx level
134:         k_i = self._compute_edge_counts_between_node_and_blocks(i)
135:         k_j = self._compute_edge_counts_between_node_and_blocks(j)
136:         affected_blocks = set(k_i.keys()) | set(k_j.keys())
137:         # new implementation with combined increment function
138:         neighbor_blocks = affected_blocks - {old_block_i, old_block_j}
139:         # build increment lists for neighbor blocks
140:         counts = [
141:             -k_i[t] + k_j[t] for t in neighbor_blocks
142:         ] + [
143:             -k_j[t] + k_i[t] for t in neighbor_blocks
144:         ]
145:         blocks_i = [old_block_i] * len(neighbor_blocks) + [old_block_j] * len(neighbor_blocks)
146:         block_j = list(neighbor_blocks) + list(neighbor_blocks)
147:         delta_e.increment(
148:             counts = counts,
149:             blocks_i = blocks_i,
150:             blocks_j = block_j,
151:         ) 
152:         # Add the changes for the old blocks of i and j
153:         has_edge_ij = bool(self.block_data.graph_data.adjacency[i, j])
154:         delta_e.increment(
155:             counts=[
156:                 k_i[old_block_i] - k_i[old_block_j] + k_j[old_block_j] - k_j[old_block_i] + 2 * has_edge_ij,
157:                 k_j[old_block_i] - k_i[old_block_i] - has_edge_ij,
158:                 k_i[old_block_j] - k_j[old_block_j] - has_edge_ij
159:             ],
160:             blocks_i=[old_block_i, old_block_i, old_block_j],
161:             blocks_j=[old_block_j, old_block_i, old_block_j]
162:         )
163:         return delta_e
164: # -----------------------------------------------------------------------------
165: #  Edge‑based swap proposer
166: # -----------------------------------------------------------------------------
167: class EdgeBasedSwapProposer(NodeSwapProposer):
168:     """A Peixoto‑style *edge‑conditioned* two‑vertex swap.
169:     1. Pick a **cross‑block edge** ``(i,j)`` uniformly at random.
170:     2. Swap the block labels of its end‑points.
171:     The proposal is *symmetric* (uniform over edges), so the Metropolis–
172:     Hastings acceptance probability is simply ``min(1, exp(Δℓ/T))``.
173:     """
174:     def __init__(
175:         self,
176:         block_data,
177:         rng: np.random.Generator = np.random.default_rng(1),
178:         use_numpy: bool = True,
179:         max_trials: int = 128,
180:     ) -> None:
181:         super().__init__(block_data=block_data, rng=rng, use_numpy=use_numpy)
182:         self.max_trials = max_trials
183:         # Direct CSR pointers for O(1) edge sampling
184:         self._indptr = self.block_data.graph_data.adjacency.indptr
185:         self._indices = self.block_data.graph_data.adjacency.indices
186:     # ------------------------------------------------------------------
187:     def propose_change(
188:         self,
189:         changes: Optional[ProposedValidChanges] = None,
190:     ) -> Tuple[ProposedValidChanges, EdgeDelta, CombinationDelta]:
191:         if changes is not None:
192:             return super().propose_change(changes=changes)
193:         n = self.block_data.graph_data.num_nodes  # type: ignore[attr-defined]
194:         blocks = self.block_data.blocks
195:         for _ in range(self.max_trials):
196:             i = int(self.rng.integers(n))
197:             # get i's neighbor index-range (adj is csr format)
198:             istart, iend = self._indptr[i], self._indptr[i + 1]
199:             if iend == istart:
200:                 continue  # isolated vertex
201:             # pick a random neighbor j
202:             j = int(self.rng.choice(self._indices[istart:iend]))
203:             bi, bj = blocks[i], blocks[j]
204:             if bi == bj:
205:                 continue  # need a cross‑block edge
206:             proposed_changes: ProposedValidChanges = [(i, bj), (j, bi)]
207:             break
208:         else:  # all trials failed – fall back to uniform swap
209:             return super().propose_change(changes=None)
210:         delta_e = self._compute_delta_edge_counts(
211:             proposed_changes=proposed_changes,
212:             use_numpy=self.use_numpy,
213:         )
214:         delta_n: CombinationDelta = defaultdict(int)  # block sizes unchanged
215:         return proposed_changes, delta_e, delta_n
216: # -----------------------------------------------------------------------------
217: #  Triadic informed swap   (new implementation)
218: # -----------------------------------------------------------------------------
219: class TriadicSwapProposer(NodeSwapProposer):
220:     """A *three‑vertex* informed swap.
221:     Strategy
222:     --------
223:     1. Pick a random vertex ``i`` (block *A*).
224:     2. Choose a random neighbour ``j`` with ``block(j) = B \neq A``.
225:     3. Search in block *B* for a vertex ``l \ne j`` that has **at least one**
226:        neighbour in block *A*.
227:     4. Swap the block labels of ``i`` and ``l``.
228:     Swapping these two vertices reduces the expected number of *cross* edges by
229:     converting:
230:     * all edges from ``i`` into *B* to *internal*, and
231:     * all edges from `l``` into *A* to *internal*,
232:     while typically adding fewer new cross edges because ``i`` and ``j'`` were
233:     originally “boundary” vertices.
234:     The proposal distribution is still *symmetric* because every triad is
235:     selected with the same probability in either direction, so the usual MH
236:     acceptance rule applies.
237:     """
238:     def __init__(
239:         self,
240:         block_data,
241:         rng: np.random.Generator = np.random.default_rng(1),
242:         use_numpy: bool = False,
243:         max_trials: int = 128,
244:         candidate_trials: int = 64,
245:     ) -> None:
246:         super().__init__(block_data=block_data, rng=rng, use_numpy=use_numpy)
247:         self.max_trials = max_trials            # attempts to find (i,j)
248:         self.candidate_trials = candidate_trials  # attempts to find j′ per (i,j)
249:         self._indptr = self.block_data.graph_data.adjacency.indptr
250:         self._indices = self.block_data.graph_data.adjacency.indices
251:     # ------------------------------------------------------------------
252:     def propose_change(
253:         self,
254:         changes: Optional[ProposedValidChanges] = None,
255:     ) -> Tuple[ProposedValidChanges, EdgeDelta, CombinationDelta]:
256:         # Explicit‑changes path used in unit tests
257:         if changes is not None:
258:             return super().propose_change(changes=changes)
259:         n = self.block_data.graph_data.num_nodes  # type: ignore[attr-defined]
260:         blocks = self.block_data.blocks
261:         for _ in range(self.max_trials):
262:             # ---- step 1: pick i ------------------------------------------------
263:             i = int(self.rng.integers(n))
264:             # find i's neighbour index-range (adj is csr format)
265:             istart, iend = self._indptr[i], self._indptr[i + 1]
266:             if iend == istart:
267:                 continue  # isolated – try another
268:             # ---- step 2: pick neighbour j in a *different* block --------------
269:             neighs_i = self._indices[istart:iend]
270:             j = int(self.rng.choice(neighs_i))
271:             a, b = blocks[i], blocks[j]
272:             if a == b:
273:                 continue  # need a cross edge i‑j
274:             # ---- step 3: find j′ in block b that touches block a --------------
275:             block_b_members = self.block_data.block_members[b]
276:             # change to list and randomlize order
277:             block_b_members = list(block_b_members)
278:             self.rng.shuffle(block_b_members)
279:             for l in block_b_members[:self.candidate_trials]:
280:                 if l in (i, j):
281:                     continue
282:                 # find neighbors of l in block a
283:                 lstart, lend = self._indptr[l], self._indptr[l + 1]
284:                 l_neighbors = self._indices[lstart:lend]
285:                 l_neighbor_in_block_a = any(
286:                     blocks[neighbor] == a for neighbor in l_neighbors
287:                 )
288:                 if not l_neighbor_in_block_a:
289:                     continue  # l must touch block a
290:                 proposed_changes: ProposedValidChanges = [(i, b), (l, a)]
291:                 delta_e = self._compute_delta_edge_counts(
292:                     proposed_changes=proposed_changes,
293:                     use_numpy=self.use_numpy,
294:                 )
295:                 delta_n: CombinationDelta = defaultdict(int)
296:                 return proposed_changes, delta_e, delta_n
297:             # could not find j′ – back to outer loop
298:             continue
299:         # ---- fallback --------------------------------------------------------
300:         # If every attempt failed (e.g. almost perfect partition), fall back to
301:         # a plain uniform swap to keep the chain ergodic.
302:         return super().propose_change(changes=None)
303: # -----------------------------------------------------------------------------#
304: #  Cross-triangle (cross-wedge) swap proposer                                   #
305: # -----------------------------------------------------------------------------#
306: class CrossTriangleSwapProposer(NodeSwapProposer):
307:     """
308:     Swap the *odd* vertex of an open cross-wedge.
309:     1. Draw a **cross edge** (i,j) uniformly at random.
310:     2. Pick a random neighbour k of j such that block(k) == block(i) (i.e. an
311:        *open wedge* i-j-k with i,k in the same block, j outside that block).
312:     3. Swap the block labels of *i* and *j*.
313:     When i-k are **not directly connected**, the move converts two cross edges
314:     (i,j) and (j,k) into one cross edge (i,j) and one *internal* edge (j,k),
315:     giving a positive Δ log-likelihood in expectation.  Proposal is symmetric.
316:     """
317:     def __init__(
318:         self,
319:         block_data: BlockData,
320:         rng: np.random.Generator = np.random.default_rng(1),
321:         use_numpy: bool = True,
322:         max_trials: int = 256,
323:         neighbour_trials: int = 8,
324:     ) -> None:
325:         super().__init__(block_data=block_data, rng=rng, use_numpy=use_numpy)
326:         self.max_trials = max_trials
327:         self.neighbour_trials = neighbour_trials
328:         self._indptr = self.block_data.graph_data.adjacency.indptr
329:         self._indices = self.block_data.graph_data.adjacency.indices
330:     # ------------------------------------------------------------------
331:     def propose_change(
332:         self,
333:         changes: Optional[ProposedValidChanges] = None,
334:     ) -> Tuple[ProposedValidChanges, EdgeDelta, CombinationDelta]:
335:         if changes is not None:                     # path for unit tests
336:             return super().propose_change(changes)
337:         n = self.block_data.graph_data.num_nodes    # type: ignore[attr-defined]
338:         blocks = self.block_data.blocks
339:         for _ in range(self.max_trials):
340:             # ---- pick a random edge -----------------------------------------
341:             i = int(self.rng.integers(n))
342:             istart, iend = self._indptr[i], self._indptr[i + 1]
343:             if istart == iend:
344:                 continue                            # i is isolated
345:             j = int(self.rng.choice(self._indices[istart:iend]))
346:             bi, bj = blocks[i], blocks[j]
347:             if bi == bj:
348:                 continue                            # need a cross edge
349:             # ---- search a neighbour k of j inside block bi ------------------
350:             jstart, jend = self._indptr[j], self._indptr[j + 1]
351:             nbrs_j = self._indices[jstart:jend]
352:             if len(nbrs_j) == 0:
353:                 continue
354:             # sample up to neighbour_trials neighbours
355:             cand = self.rng.choice(
356:                 nbrs_j,
357:                 size=min(self.neighbour_trials, len(nbrs_j)),
358:                 replace=False,
359:             )
360:             k = next((int(v) for v in cand if blocks[v] == bi and v != i), None)
361:             if k is None:
362:                 continue                            # wedge not found
363:             # ---- valid cross-wedge: swap i and j ----------------------------
364:             proposed_changes: ProposedValidChanges = [(i, bj), (j, bi)]
365:             delta_e = self._compute_delta_edge_counts(
366:                 proposed_changes=proposed_changes,
367:                 use_numpy=self.use_numpy,
368:             )
369:             delta_n: CombinationDelta = defaultdict(int)
370:             return proposed_changes, delta_e, delta_n
371:         # fallback to uniform swap
372:         return super().propose_change(changes=None)
373: # -----------------------------------------------------------------------------#
374: #  Twin-leaf swap proposer                                                     #
375: # -----------------------------------------------------------------------------#
376: class TwinLeafSwapProposer(NodeSwapProposer):
377:     """
378:     Swap two *leaves* whose neighbours lie in each other’s blocks.
379:     1. Pick a random **leaf** i (deg=1) whose neighbour u is in block B != block(i).
380:     2. Inside block B, look for another leaf k (deg=1, k≠i) whose sole neighbour
381:        v lies in block A = block(i).
382:     3. Swap the labels of i and k.
383:     This move removes two cross edges and introduces *zero* new ones, because
384:     leaves have no other connections.  Works great on heavy-tailed networks.
385:     """
386:     def __init__(
387:         self,
388:         block_data: BlockData,
389:         rng: np.random.Generator = np.random.default_rng(1),
390:         use_numpy: bool = True,
391:         max_trials: int = 256,
392:         partner_trials: int = 32,
393:     ) -> None:
394:         super().__init__(block_data=block_data, rng=rng, use_numpy=use_numpy)
395:         self.max_trials = max_trials
396:         self.partner_trials = partner_trials
397:         self._indptr = self.block_data.graph_data.adjacency.indptr
398:         self._indices = self.block_data.graph_data.adjacency.indices
399:     # ------------------------------------------------------------------
400:     def _is_leaf(self, v: int) -> bool:
401:         return (self._indptr[v + 1] - self._indptr[v]) == 1
402:     # ------------------------------------------------------------------
403:     def propose_change(
404:         self,
405:         changes: Optional[ProposedValidChanges] = None,
406:     ) -> Tuple[ProposedValidChanges, EdgeDelta, CombinationDelta]:
407:         if changes is not None:
408:             return super().propose_change(changes)
409:         n = self.block_data.graph_data.num_nodes    # type: ignore[attr-defined]
410:         blocks = self.block_data.blocks
411:         for _ in range(self.max_trials):
412:             # ---- step 1: choose a random leaf i -----------------------------
413:             i = int(self.rng.integers(n))
414:             if not self._is_leaf(i):
415:                 continue
416:             # unique neighbour of i
417:             u = int(self._indices[self._indptr[i]])
418:             a, b = blocks[i], blocks[u]
419:             if a == b:
420:                 continue                            # internal leaf – ignore
421:             # ---- step 2: search leaf partner k in block b -------------------
422:             block_b_members = list(self.block_data.block_members[b])
423:             if len(block_b_members) <= 1:
424:                 continue
425:             self.rng.shuffle(block_b_members)
426:             trials = 0
427:             for k in block_b_members:
428:                 if trials >= self.partner_trials:
429:                     break
430:                 trials += 1
431:                 if k == i or (not self._is_leaf(k)):
432:                     continue
433:                 v = int(self._indices[self._indptr[k]])
434:                 if blocks[v] != a:                  # neighbour must lie in block a
435:                     continue
436:                 # ---- valid twin leaves found: swap i,k ----------------------
437:                 proposed_changes: ProposedValidChanges = [(i, b), (k, a)]
438:                 delta_e = self._compute_delta_edge_counts(
439:                     proposed_changes=proposed_changes,
440:                     use_numpy=self.use_numpy,
441:                 )
442:                 delta_n: CombinationDelta = defaultdict(int)
443:                 return proposed_changes, delta_e, delta_n
444:             # partner not found – try another i
445:             continue
446:         # fallback
447:         return super().propose_change(changes=None)

================
File: src/sbm/io.py
================
  1: from typing import Dict, Callable, Iterable, Tuple, Optional
  2: from pathlib import Path
  3: from dataclasses import dataclass
  4: import json
  5: import gzip
  6: import numpy as np
  7: from scipy.sparse import csr_array, csr_array, load_npz, coo_matrix
  8: from scipy.io import mmread
  9: import networkx as nx                                # light dep
 10: import numpy as np
 11: from scipy.sparse import load_npz, save_npz
 12: from scipy.sparse import csr_array
 13: from sbm.graph_data import GraphData
 14: # src/sbm/io.py
 15: @dataclass
 16: class SBMFit:
 17:     block_sizes: list[int]
 18:     block_conn: csr_array
 19:     directed_graph: bool # if undirected, only upper triangle is stored
 20:     neg_loglike: float
 21:     metadata: dict
 22: class SBMWriter:
 23:     @staticmethod
 24:     def save(path: Path, fit: SBMFit) -> None:
 25:         """ save SBM fit to file """
 26:         path.mkdir(parents=True, exist_ok=True)
 27:         clean_sizes  = [int(s) for s in fit.block_sizes]
 28:         (path / "block_sizes.json").write_text(json.dumps(clean_sizes))
 29:         # save sparce block connectivity matrix using scipy
 30:         with open(path / "block_connectivity.npz", 'wb') as file:
 31:             save_npz(file, fit.block_conn, compressed=True)
 32:         (path / "directed_graph.txt").write_text(str(fit.directed_graph))
 33:         (path / "neg_loglike.txt").write_text(str(fit.neg_loglike))
 34:         with open(path / "metadata.json", 'w') as f:
 35:             json.dump(fit.metadata, f)
 36:     @staticmethod
 37:     def load(path: Path, silence:bool=False) -> SBMFit:
 38:         if not silence:
 39:             print(f"Loading SBM fit from {path}")
 40:         with open(path / "block_sizes.json", 'r') as sizes_file:
 41:             block_sizes = json.load(sizes_file)
 42:         block_sizes = [int(size) for size in block_sizes]
 43:         with open(path / "block_connectivity.npz", 'rb') as conn_file:
 44:             block_conn = load_npz(conn_file)
 45:         directed_graph = path / "directed_graph.txt"
 46:         directed_graph = (path / "directed_graph.txt").read_text().strip().lower() == 'true'
 47:         neg_loglike = float((path / "neg_loglike.txt").read_text().strip())
 48:         with open(path / "metadata.json", 'r') as f:
 49:             metadata = json.load(f)
 50:         return SBMFit(
 51:             #blocks=blocks,
 52:             block_sizes=block_sizes,
 53:             block_conn=csr_array(block_conn),
 54:             directed_graph=directed_graph,
 55:             neg_loglike=neg_loglike,
 56:             metadata=metadata
 57:         )
 58: # ---------------------------------------------------------------------
 59: #  GraphLoader
 60: # ---------------------------------------------------------------------
 61: class GraphLoader:
 62:     """
 63:     Factory that maps a file *extension* to a loader function and returns
 64:     a `GraphData` object (CSR adjacency + directed flag).
 65:     Register new loaders with the `@GraphLoader.register('.ext')`
 66:     decorator.
 67:     """
 68:     # maps extension (lower-case, incl. leading dot) -> callable
 69:     registry: Dict[str, Callable[[Path], Tuple[csr_array, bool]]] = {}
 70:     # ----------------------- decorator -------------------------------
 71:     @classmethod
 72:     def register(cls, *exts: str):
 73:         """
 74:         Use as::
 75:             @GraphLoader.register('.gml', '.graphml')
 76:             def _load_graphml(path): ...
 77:         """
 78:         def decorator(fn: Callable[[Path], Tuple[csr_array, bool]]):
 79:             for ext in exts:
 80:                 cls.registry[ext.lower()] = fn
 81:             return fn
 82:         return decorator
 83:     # ----------------------- public API ------------------------------
 84:     @staticmethod
 85:     def load(
 86:         path: Path,
 87:         *,
 88:         directed: Optional[bool] = None,
 89:         force_undirected: Optional[bool] = None
 90:     ) -> GraphData:
 91:         """Load graph at *path* and return GraphData."""
 92:         ext = path.suffix.lower()
 93:         if ext not in GraphLoader.registry:
 94:             raise ValueError(
 95:                 f"GraphLoader: no loader registered for extension '{ext}'."
 96:             )
 97:         adj, is_directed = GraphLoader.registry[ext](path)
 98:         # allow caller to override detection
 99:         if directed is not None:
100:             is_directed = bool(directed)
101:         # if caller wants undirected, symmetrise the adjacency matrix
102:         if force_undirected:
103:             if is_directed:
104:                 adj = adj.maximum(adj.T)
105:             is_directed = False
106:         adj = csr_array(adj, dtype=np.int8)  # ensure type is int8
107:         return GraphData(adjacency_matrix=adj, directed=is_directed)
108:     # ---------------- default loaders -------------------------------
109: # 1. compressed / plain .npz containing a CSR adjacency ----------------
110: @GraphLoader.register(".npz")
111: def _load_npz(path: Path) -> Tuple[csr_array, bool]:
112:     adj = load_npz(path)
113:     directed = _is_directed(adj)
114:     return adj.tocsr(), directed
115: # 2. Matrix Market -----------------------------------------------------
116: @GraphLoader.register(".mtx")
117: def _load_mtx(path: Path) -> Tuple[csr_array, bool]:
118:     adj = mmread(str(path))
119:     adj = csr_array(adj, dtype=np.int8)
120:     directed = _is_directed(adj)
121:     return adj, directed
122: # 3. Plain edge list (.edges, .edgelist, .txt, optional .gz) -----------
123: @GraphLoader.register(".edges", ".edgelist", ".txt", ".gz")
124: def _load_edgelist(path: Path) -> Tuple[csr_array, bool]:
125:     opener = gzip.open if path.suffix == ".gz" else open
126:     rows, cols = [], []
127:     if not path.exists():
128:         raise FileNotFoundError(f"GraphLoader: file {path} does not exist.")
129:     with opener(path, "rt") as f:
130:         for line in f:
131:             if not line.strip() or line.startswith("#"):
132:                 continue
133:             u, v = map(int, line.split()[:2])
134:             rows.append(u)
135:             cols.append(v)
136:     n = max(rows + cols) + 1
137:     data = np.ones(len(rows), dtype=np.int8)
138:     adj = coo_matrix((data, (rows, cols)), shape=(n, n)).tocsr()
139:     directed = _is_directed(adj)
140:     if not directed:            # symmetrise if undirected
141:         adj = adj.maximum(adj.T)
142:     adj = csr_array(adj, dtype=np.int8)  # ensure type is int8
143:     return adj, directed
144: # 4. GML / GraphML via NetworkX ---------------------------------------
145: @GraphLoader.register(".gml", ".graphml")
146: def _load_graphml(path: Path) -> Tuple[csr_array, bool]:
147:     G = nx.read_gml(path) if path.suffix == ".gml" else nx.read_graphml(path)
148:     directed = G.is_directed()
149:     # new version of networkx
150:     #adj = nx.to_scipy_sparse_array(G, format="csr", dtype=np.int8)
151:     # old version of networkx
152:     adj = nx.to_scipy_sparse_matrix(G, format="csr", dtype=np.int8)
153:     if not directed:
154:         adj = adj.maximum(adj.T)
155:     return adj, directed
156: # ---------------- helper ----------------------------------------------
157: def _is_directed(adj:  csr_array, tol: int = 0) -> bool:
158:     """
159:     Quick symmetric test for an unweighted adjacency.
160:     `tol` is an integer threshold: if more than `tol` entries differ,
161:     we declare the graph directed.
162:     """
163:     diff = adj - adj.T
164:     return diff.count_nonzero() > tol

================
File: src/sbm/model.py
================
  1: from typing import Dict, Optional
  2: import numpy as np
  3: from scipy.sparse import csr_array
  4: from sbm.block_data import BlockData
  5: from sbm.likelihood import (
  6:     LikelihoodCalculator,
  7:     LikelihoodType,
  8: )
  9: from sbm.block_change_proposers import (
 10:     NodeSwapProposer,
 11:     EdgeBasedSwapProposer,
 12:     TriadicSwapProposer,
 13:     CrossTriangleSwapProposer,
 14:     TwinLeafSwapProposer
 15: )
 16: from sbm.node_mover import NodeMover
 17: from sbm.mcmc import MCMC, PrivatePartitionMCMC
 18: from sbm.io import SBMFit
 19: from sbm.utils.logger import CSVLogger
 20: class SBMModel:
 21:     def __init__(self,
 22:                 initial_blocks: BlockData,
 23:                 rng: np.random.Generator,
 24:                 likelihood_type: LikelihoodType = "bernoulli",
 25:                 logger: Optional[CSVLogger] = None,
 26:                 change_freq = { # probabilities of trying each move type
 27:                     "edge_based_swap": 1.0,
 28:                 },
 29:                 private_sbm: bool = False, # whether to use the private partitioning MCMC
 30:         ):
 31:         self._best_block_assignment = None
 32:         self._best_block_conn = None
 33:         self.block_data = initial_blocks
 34:         self.rng = rng
 35:         self.likelihood_calculator = LikelihoodCalculator(
 36:             block_data=self.block_data,
 37:             likelihood_type=likelihood_type
 38:             )
 39:         self.move_executor = NodeMover(
 40:             block_data=self.block_data,
 41:             )
 42:         change_proposer = {
 43:             "uniform_swap": NodeSwapProposer(
 44:                         block_data=self.block_data,
 45:                         rng=self.rng,
 46:                         use_numpy=True,
 47:                     ),
 48:             "edge_based_swap": EdgeBasedSwapProposer(
 49:                         block_data=self.block_data,
 50:                         rng=self.rng,
 51:                         use_numpy=False,
 52:                     ),
 53:             "triadic_swap": TriadicSwapProposer(
 54:                         block_data=self.block_data,
 55:                         rng=self.rng,
 56:                         use_numpy=True,
 57:                     ),
 58:             "twin_leaf": TwinLeafSwapProposer(
 59:                         block_data=self.block_data,
 60:                         rng=self.rng,
 61:                         use_numpy=True,
 62:                     ),
 63:             "cross_triangle": CrossTriangleSwapProposer(
 64:                         block_data=self.block_data,
 65:                         rng=self.rng,
 66:                         use_numpy=True,
 67:                     ),
 68:         }
 69:         if private_sbm:
 70:             self.mcmc_algorithm = PrivatePartitionMCMC(
 71:                 block_data=self.block_data,
 72:                 likelihood_calculator=self.likelihood_calculator,
 73:                 change_proposer=change_proposer, # type: ignore
 74:                 rng=self.rng,
 75:                 logger=logger,
 76:             )
 77:         else:
 78:             self.mcmc_algorithm = MCMC(
 79:                 block_data = self.block_data,
 80:                 likelihood_calculator = self.likelihood_calculator,
 81:                 change_proposer = change_proposer, # type: ignore
 82:                 change_freq = change_freq, # type: ignore
 83:                 rng = self.rng,
 84:                 logger=logger
 85:             )
 86:     def fit(self,
 87:         min_block_size: int,
 88:         cooling_rate: float=1-1e-4,
 89:         max_blocks: Optional[int] = None,
 90:         patience: Optional[int] = None,
 91:         return_nll: bool = False,
 92:         max_num_iterations: int=int(10**6),
 93:         initial_temperature: float=1.0,
 94:         ):
 95:         nll = self.mcmc_algorithm.fit(
 96:             max_num_iterations=max_num_iterations,
 97:             min_block_size=min_block_size,
 98:             initial_temperature=initial_temperature,
 99:             cooling_rate=cooling_rate,
100:             max_blocks=max_blocks,
101:             patience=patience,
102:         )
103:         if return_nll:
104:             return nll
105:     def get_block_assignments(self, best:bool=True) -> Dict[int, int]:
106:         if best:
107:             return self.mcmc_algorithm._best_block_assignment
108:         else:
109:             return self.block_data.blocks
110:     def to_sbmfit(self, metadata: Optional[Dict] = None, best:bool=True) -> SBMFit:
111:         """ 
112:         Convert the fitted SBM model to an SBMFit object for serialization. 
113:         """
114:         if metadata is None:
115:             metadata = {}
116:         if best:
117:             blocks = self.mcmc_algorithm._best_block_assignment
118:             block_sizes = np.unique(list(blocks.values()), return_counts=True)[1].tolist()
119:             block_conn = self.mcmc_algorithm._best_block_conn
120:             nll = self.mcmc_algorithm.best_nll
121:         else:
122:             blocks = self.block_data.blocks
123:             block_sizes = list(self.block_data.block_sizes.values())
124:             block_conn = self.block_data.block_connectivity
125:             nll = self.mcmc_algorithm.current_nll
126:         return SBMFit(
127:             block_sizes=block_sizes,
128:             block_conn=csr_array(block_conn),
129:             directed_graph=self.block_data.graph_data.directed,
130:             neg_loglike=nll,
131:             metadata=metadata
132:         )

================
File: src/pipelines/fit_sbm.py
================
 1: # src/pipelines/fit_sbm.py
 2: import yaml
 3: import argparse
 4: from pathlib import Path
 5: from itertools import product
 6: from line_profiler import profile
 7: from time import time
 8: import numpy as np
 9: from tqdm import tqdm
10: from sbm.io import GraphLoader, SBMWriter
11: from sbm.block_assigner import AssignerConstructor
12: from sbm.model import SBMModel
13: from sbm.utils.logger import CSVLogger
14: from sbm.utils.pipeline_utils import (
15:     sbmfit_folderpath,
16:     FitConfig,
17: )
18: @profile
19: def main(fit_config: str): # type: ignore
20:     fit_config: FitConfig = yaml.safe_load(Path(fit_config).read_text())
21:     logging_config = fit_config["logging"][0] # type: ignore
22:     data_config = fit_config["datasets"] # type: ignore
23:     seed = fit_config['seed']
24:     rng = np.random.default_rng(seed)
25:     config_pairs = product(
26:         fit_config['sbm'], # type: ignore
27:         fit_config['datasets'], # type: ignore
28:     )
29:     iterator = tqdm(
30:         config_pairs,
31:         desc="Fitting SBM models",
32:         total=len(fit_config['sbm']) * len(fit_config['datasets'])
33:     )
34:     for sbm_config, ds in iterator:
35:         # prepare SBM model
36:         g = GraphLoader.load(
37:             Path(ds["path"]),
38:             force_undirected=bool(sbm_config["force_undirected"]), # type: ignore
39:             )
40:         assigner_const = AssignerConstructor(rng=rng)
41:         assigner = assigner_const.create_assigner(
42:             graph_data=g,
43:             min_block_size=int(sbm_config["min_block_size"]), # type: ignore
44:             init_method=sbm_config["init_method"], # type: ignore
45:             )
46:         block_data = assigner.compute_assignment()
47:         # check block sizes
48:         model = SBMModel(
49:             initial_blocks=block_data,
50:             rng=rng)
51:         # fit SBM model
52:         name = ds["name"] + "_".join(
53:             f"{k}_{v}" for k, v in sbm_config.items() # type: ignore
54:         )
55:         log_path = Path(logging_config['logging_folder']) / f"{name}.csv"
56:         tic = time()
57:         with CSVLogger(log_path, log_every=logging_config['log_every']) as logger:
58:             model.fit(
59:                 min_block_size=sbm_config["min_block_size"], # type: ignore
60:                 cooling_rate=sbm_config["cooling_rate"], # type: ignore
61:                 logger=logger,
62:             )
63:         # save the fitted model
64:         fit = model.to_sbmfit()
65:         toc = time()
66:         print(f"Fitting {ds['name']} took {toc - tic:.2f} seconds")
67:         tic = time()
68:         fit_configs = sbm_config.copy() # type: ignore
69:         out_dir = sbmfit_folderpath(
70:             base_dir=Path("results/sbm_fits"),
71:             sbm_config=fit_configs,
72:             data_spec=ds, 
73:         )
74:         print(f'Out directory: {out_dir}')
75:         out_dir.mkdir(parents=True, exist_ok=True)
76:         SBMWriter.save(out_dir, fit)
77:         toc = time()
78:         print(f"Saving {ds['name']} took {toc - tic:.2f} seconds, nll = {fit.neg_loglike:.2f}")
79: if __name__ == "__main__":
80:     p = argparse.ArgumentParser()
81:     p.add_argument("--fit_config", type=str, help="Path to the configuration file.")
82:     args = p.parse_args()
83:     main(fit_config=args.fit_config)

================
File: src/sbm/block_assigner.py
================
  1: """ 
  2:     Functions and classes for computing initial block assignment 
  3:     used in the Stochastic Block Model (SBM). These are later updated
  4:     using the MCMC algorithm.
  5: """
  6: from __future__ import annotations
  7: from typing import List, Dict, Optional, Tuple, Iterable, TypeAlias, Set
  8: from collections import defaultdict, Counter
  9: from time import time
 10: import metis
 11: import scipy.sparse as sp
 12: from scipy.sparse import csr_array
 13: import numpy as np
 14: from k_means_constrained import KMeansConstrained
 15: from nodevectors import ProNE
 16: from sbm.block_data import BlockData
 17: from sbm.graph_data import GraphData
 18: from sbm.utils.pipeline_utils import InitMethodName
 19: from ortools.sat.python import cp_model  # type: ignore
 20: # ---------------------------------------------------------------------------
 21: #  helper ---------------------------------------------------------------
 22: # ---------------------------------------------------------------------------
 23: def _block_sizes(blocks: Dict[int, int]) -> Dict[int, int]:
 24:     sizes = defaultdict(int)
 25:     for b in blocks.values():
 26:         sizes[b] += 1
 27:     return sizes
 28: def _boundary_vertices(block: int, members: Set[int], blocks: Dict[int, int],
 29:                        indptr: np.ndarray, indices: np.ndarray) -> List[int]:
 30:     """Return vertices in *block* that touch at least one different block."""
 31:     out = []
 32:     for v in members:
 33:         row = slice(indptr[v], indptr[v + 1])
 34:         if any(blocks[u] != block for u in indices[row]):
 35:             out.append(v)
 36:     return out
 37: def _movable_vertex(src: int, dst_set: Set[int], *, rng: np.random.Generator,
 38:                     blocks: Dict[int, int], members: Dict[int, Set[int]],
 39:                     indptr: np.ndarray, indices: np.ndarray) -> Tuple[int, int] | None:
 40:     """Pick (vertex, dst) with vertex in *src* boundary and dst in dst_set."""
 41:     boundary = _boundary_vertices(src, members[src], blocks, indptr, indices)
 42:     rng.shuffle(boundary)
 43:     for v in boundary:
 44:         row = slice(indptr[v], indptr[v + 1])
 45:         neigh_blks = {blocks[u] for u in indices[row] if blocks[u] in dst_set}
 46:         if neigh_blks:
 47:             return v, rng.choice(list(neigh_blks))
 48:     return None
 49: def _move(v: int, src: int, dst: int, *, blocks: Dict[int, int],
 50:           members: Dict[int, Set[int]], sizes: Counter
 51:     ):
 52:     """Execute the move and update bookkeeping structures."""
 53:     blocks[v] = dst
 54:     members[src].remove(v)
 55:     members[dst].add(v)
 56:     sizes[src] -= 1
 57:     sizes[dst] += 1
 58:     if sizes[src] == 0:
 59:         # remove empty block
 60:         del members[src]
 61:         del sizes[src]
 62:         del blocks[v]
 63: def move_node_to_under(
 64:         under: Set[int], # blocks of size < k
 65:         over1: Set[int], # blocks of size k+1
 66:         over2: Set[int], # blocks of size > k+1
 67:         rng: np.random.Generator,
 68:         sizes: Counter[int],
 69:         k: int,
 70:         members: Dict[int, Set[int]],
 71:         blocks: Dict[int, int],
 72:         indptr: np.ndarray,
 73:         indices: np.ndarray
 74:     ) -> None:
 75:     """ 
 76:     Move a node from an oversize block to an undersize block.
 77:     """
 78:     if len(under) == 0:
 79:         # no undersize blocks available, skip
 80:         return
 81:     donors = list(over2 | over1) or list(b for b, s in sizes.items() if s > k)
 82:     rng.shuffle(donors)
 83:     moved = False
 84:     if len(under) > 0:
 85:         for b_src in donors:
 86:             mv = _movable_vertex(b_src, under, rng=rng, blocks=blocks,
 87:                                     members=members, indptr=indptr, indices=indices)
 88:             if mv is not None:
 89:                 v, b_dst = mv
 90:                 _move(v, b_src, b_dst, blocks=blocks, members=members, sizes=sizes)
 91:                 moved = True
 92:                 return
 93:     # If we reach here no boundary move could be found. Relax: pick random.
 94:     if len(donors) == 0:
 95:         # no oversize blocks available, pick random from all
 96:         donors = list(blocks.keys())
 97:     b_src = rng.choice(donors)
 98:     if len(members[b_src]) == 0:
 99:         # no members in the source block, skip
100:         return
101:     v = rng.choice(list(members[b_src]))
102:     b_dst = rng.choice(tuple(under))
103:     _move(v, b_src, b_dst, blocks=blocks, members=members, sizes=sizes)
104:     return
105: def move_node_from_over(
106:     under: Set[int], # blocks of size < k
107:     over1: Set[int], # blocks of size k+1
108:     over2: Set[int], # blocks of size > k+1
109:     rng: np.random.Generator,
110:     sizes: Counter[int],
111:     k: int,
112:     members: Dict[int, Set[int]],
113:     blocks: Dict[int, int],
114:     indptr: np.ndarray,
115:     indices: np.ndarray,
116:     r_target: int,
117: ) -> None:
118:     """ 
119:         Nodes are moved from block with size > k to block with size either
120:         < k or <=k if there are fewer than r_target blocks with size k+1.
121:     """
122:     if len(over2) == 0:
123:         # no oversize blocks available, skip
124:         return
125:     b_src = rng.choice(tuple(over2))
126:     dests = under.copy()
127:     if len(over1) > r_target:
128:         dests |= {b for b, s in sizes.items() if s == k}
129:     if not dests:
130:         # no eligible destination respecting k‑lower‑bound → skip
131:         return
132:     mv = _movable_vertex(b_src, dests, rng=rng, blocks=blocks,
133:                             members=members, indptr=indptr, indices=indices)
134:     if mv is None:
135:         v = rng.choice(_boundary_vertices(b_src, members[b_src], blocks, indptr, indices))
136:         b_dst = rng.choice(tuple(dests))
137:     else:
138:         v, b_dst = mv
139:     _move(v, b_src, b_dst, blocks=blocks, members=members, sizes=sizes)
140:     return
141: def balance_k_plus_1_blocks(
142:     over1: Set[int], # blocks of size k+1
143:     over2: Set[int], # blocks of size >k+1
144:     rng: np.random.Generator,
145:     sizes: Counter[int],
146:     k: int,
147:     members: Dict[int, Set[int]],
148:     blocks: Dict[int, int],
149:     indptr: np.ndarray,
150:     indices: np.ndarray,
151:     r_target: int,
152: ) -> None:
153:     """ 
154:     Balance the number of blocks with size k+1.
155:     If there are too many blocks with size k+1, shrink one of them
156:     by moving a vertex to a block with size k or smaller.
157:     If there are too few blocks with size k+1, enlarge one of the blocks
158:     with size k by moving a vertex from a block with size larger than k+1
159:     or smaller than k+1
160:     """
161:     if len(over1) == r_target:
162:         # already balanced, nothing to do
163:         return
164:     elif len(over1) > r_target: # need fewer k+1 blocks
165:         # shrink a k+1 block
166:         b_src = rng.choice(tuple(over1))
167:         dests = {b for b, s in sizes.items() if s <= k}
168:     else:  # need more k+1 blocks
169:         # enlarge a k block
170:         #dests = set()
171:         b_src = rng.choice(tuple(over2))
172:         dests = {b for b, s in sizes.items() if s == k}
173:     if len(dests) == 0:
174:         # no eligible destination respecting k‑upper‑bound → skip
175:         return
176:     # shrink case
177:     mv = _movable_vertex(b_src, dests, rng=rng, blocks=blocks,
178:                             members=members, indptr=indptr, indices=indices)
179:     if mv is not None:
180:         v, b_dst = mv
181:         _move(v, b_src, b_dst, blocks=blocks, members=members, sizes=sizes)
182:         return
183:     return
184: def categorize(
185:     sizes: Dict[int, int],
186:     k: int,
187: ) -> Tuple[Set[int], Set[int], Set[int]]:
188:     """Return (oversize>k+1, oversize==k+1, undersize<k)."""
189:     over2 = {b for b, s in sizes.items() if s > k + 1}
190:     over1 = {b for b, s in sizes.items() if s == k + 1}
191:     under = {b for b, s in sizes.items() if s < k}
192:     return over2, over1, under
193: # ---------------------------------------------------------------------------
194: # Improved greedy balancer (split into helpers)
195: # ---------------------------------------------------------------------------
196: def _rebalance_to_min_size(
197:     blocks: Dict[int, int],
198:     adjacency: csr_array,
199:     k: int,
200:     rng: np.random.Generator | None = None,
201:     max_iter: int | None = None,
202: ) -> Dict[int, int]:
203:     """Greedy boundary‑only balancing.
204:     Guarantees **no block ends smaller than *k***; tries to respect the stricter
205:     goal (sizes ∈ {k,k+1} & exactly *r* oversized) but will *sacrifice* that goal
206:     rather than leave an undersized block.
207:     """
208:     if rng is None:
209:         rng = np.random.default_rng(1)
210:     n = adjacency.shape[0]
211:     indptr, indices = adjacency.indptr, adjacency.indices
212:     sizes: Counter[int] = Counter(blocks.values())
213:     members: Dict[int, Set[int]] = defaultdict(set)
214:     for v, b in blocks.items():
215:         members[b].add(v)
216:     B = len(sizes)
217:     r_target = n - k * B  # blocks that *should* have k+1
218:     iter_limit = max_iter or 5 * n
219:     while iter_limit:
220:         iter_limit -= 1
221:         over2, over1, under = categorize(sizes=sizes, k=k)
222:         if len(under)==0 and len(over2)==0 and len(over1)==r_target:
223:             break  # fully balanced by strict rules
224:         # 1) fix undersized first ------------------------------------------------
225:         if len(under) > 0:
226:             move_node_to_under(
227:                 under=under,
228:                 over1=over1,
229:                 over2=over2,
230:                 rng=rng,
231:                 sizes=sizes,
232:                 k=k,
233:                 members=members,
234:                 blocks=blocks,
235:                 indptr=indptr,
236:                 indices=indices
237:             )
238:             continue
239:         # 2) shrink blocks > k+1 --------------------------------------------------
240:         if len(over2) > 0 :
241:             move_node_from_over(
242:                 under=under,
243:                 over1=over1,
244:                 over2=over2,
245:                 rng=rng,
246:                 sizes=sizes,
247:                 k=k,
248:                 members=members,
249:                 blocks=blocks,
250:                 indptr=indptr,
251:                 indices=indices,
252:                 r_target=r_target
253:             )
254:             continue
255:         # 3) adjust number of k+1 blocks -----------------------------------------
256:         if len(over1) != r_target:
257:             balance_k_plus_1_blocks(
258:                 over1=over1,
259:                 over2=over2,
260:                 rng=rng,
261:                 sizes=sizes,
262:                 k=k,
263:                 members=members,
264:                 blocks=blocks,
265:                 indptr=indptr,
266:                 indices=indices,
267:                 r_target=r_target
268:             )
269:             continue
270:     # ---------------- final safety pass: remove any undersized ---------------
271:     # we first attempt to move nodes from oversize blocks to undersize blocks
272:     # if that fails, we move nodes from remaining undersized blocks to any block
273:     under_blocks = [b for b, s in sizes.items() if s < k]
274:     if len(under_blocks) == 0:
275:         return blocks
276:     rng.shuffle(under_blocks)
277:     over_blocks = [b for b, s in sizes.items() if s > k]
278:     if len(over_blocks) > 0:
279:         # attempt to move nodes from oversize blocks to undersize blocks
280:         while len(over_blocks) > 0 and len(under_blocks) > 0:
281:             b_dst = under_blocks[-1]
282:             while sizes[b_dst] < k and len(over_blocks) > 0:
283:                 b_src = over_blocks[-1]  # take from the end for efficiency
284:                 if sizes[b_src] == k: # have we taken all we can?
285:                     over_blocks.pop() # discount this block from further consideration
286:                     continue
287:                 # can we find a vertex in b_src connected to b_dst?
288:                 mv = _movable_vertex(b_src, {b_dst}, rng=rng, blocks=blocks,
289:                                       members=members, indptr=indptr, indices=indices)
290:                 if mv is None:
291:                     # if not, pick a random vertex in b_src
292:                     v = rng.choice(tuple(members[b_src]))
293:                 else:
294:                     v, _ = mv
295:                 _move(v, b_src, b_dst, blocks=blocks, members=members, sizes=sizes)
296:                 over_blocks = {b for b, s in sizes.items() if s > k}
297:             if sizes[b_dst] >= k:
298:                 # we have filled the under block, remove it from consideration
299:                 under_blocks.pop()
300:     # assign all nodes in under_block to a random block
301:     while len(under_blocks) > 0:
302:         b_src = under_blocks[-1]  # take from the end for efficiency
303:         while len(members[b_src]) > 0:
304:             non_under_blocks = {b for b, s in sizes.items() if s >= k}
305:             # check if v touches a non_under block
306:             mv = _movable_vertex(b_src, non_under_blocks, rng=rng, blocks=blocks,
307:                                     members=members, indptr=indptr, indices=indices)
308:             if mv is not None:
309:                 v, b_dst = mv
310:             else:
311:                 v = rng.choice(tuple(members[b_src]))
312:                 b_dst= rng.choice(tuple(blocks.values()))
313:             _move(v, b_src, b_dst, blocks=blocks, members=members, sizes=sizes)
314:         under_blocks.pop()
315:     # final check
316:     _, _, under = categorize(sizes=sizes, k=k)
317:     assert len(under) == 0, \
318:         f"Rebalance failed: {len(under)} blocks are still undersized (<{k})."
319:     return blocks
320: ### Base class for BlockAssigner
321: class BlockAssigner:
322:     """
323:     Base class for assigning nodes to blocks in the Stochastic Block Model (SBM).
324:     This class is intended to be subclassed for specific block assignment strategies.
325:     """
326:     def __init__(self,
327:                  graph_data: GraphData,
328:                  rng: np.random.Generator,
329:                  num_blocks: Optional[int] = None,
330:                  min_block_size: Optional[int] = None,
331:                  max_block_size: Optional[int] = None,
332:                  ):
333:         self.graph_data = graph_data
334:         # check if there exist a valid assignment
335:         # given num_blocks, min_block_size, max_block_size
336:         if num_blocks is not None and min_block_size is not None:
337:             if num_blocks * min_block_size > graph_data.num_nodes:
338:                 raise ValueError("Invalid parameters: num_blocks * min_block_size exceeds total number of nodes.")
339:         if max_block_size is not None and min_block_size is not None:
340:             if max_block_size < min_block_size:
341:                 raise ValueError("Invalid parameters: max_block_size cannot be less than min_block_size.")
342:         self.num_blocks = num_blocks
343:         self.min_block_size = min_block_size
344:         self.max_block_size = max_block_size
345:         self.rng = rng
346:     def reindex_blocks(self, blocks: Dict[int, int]) -> Dict[int, int]:
347:         """ 
348:         Reindex block IDs to be consecutive integers starting from 0.
349:         """
350:         unique_blocks = sorted(set(blocks.values()))
351:         block_mapping = {old_id: new_id for new_id, old_id in enumerate(unique_blocks)}
352:         return {node: block_mapping[block_id] for node, block_id in blocks.items()}
353:     def _compute_assignment(self) -> Dict[int, int]:
354:         raise NotImplementedError(
355:             "compute_assignment must be implemented by subclasses of BlockAssigner."
356:         )
357:     def compute_assignment(self) -> BlockData:
358:         raise NotImplementedError(
359:             "compute_assignment must be implemented by subclasses of BlockAssigner."
360:         )
361: class UniformSmallBlockAssigner(BlockAssigner):
362:     """ 
363:     Assigns nodes to blocks of size min_block_size uniformly at random. 
364:     Ignore num_blocks and max_block_size.
365:     """
366:     def _compute_assignment(self) -> Dict[int, int]:
367:         """
368:         Assign nodes to blocks uniformly at random, ensuring each block has at least min_block_size nodes.
369:         """
370:         if self.min_block_size is None:
371:             raise ValueError("min_block_size must be specified for UniformSmallBlockAssigner.")
372:         if self.min_block_size <= 0:
373:             raise ValueError("min_block_size must be a positive integer.")
374:         if self.max_block_size is not None:
375:             Warning("max_block_size is ignored in UniformSmallBlockAssigner.")
376:         if self.num_blocks is not None:
377:             Warning("num_blocks is ignored in UniformSmallBlockAssigner.")
378:         num_nodes = self.graph_data.num_nodes
379:         # create list of nodes in random order
380:         node_list = self.rng.permutation(np.arange(num_nodes))
381:         # assign nodes to blocks
382:         block_assignments = {
383:             node: node // self.min_block_size for node in node_list
384:         }
385:         return block_assignments
386:     # -----------------------------------------------------------------
387:     def compute_assignment(self) -> BlockData:
388:         """
389:         Compute a block assignment based on the proposed assignment.
390:         Currently, this method only performs a min_size balancing step.
391:         """
392:         if self.min_block_size is None:
393:             raise ValueError("min_block_size must be specified for UniformSmallBlockAssigner.")
394:         assignment = self._compute_assignment()
395:         assignment= _rebalance_to_min_size(
396:             blocks=assignment,
397:             adjacency=self.graph_data.adjacency,
398:             k=self.min_block_size,
399:             rng=self.rng,
400:             max_iter=None,  # data-driven max_iter (10*num_nodes)
401:         )
402:         reindexed_assignment = self.reindex_blocks(assignment)
403:         return BlockData(
404:             initial_blocks=reindexed_assignment,
405:             graph_data=self.graph_data
406:         )
407: class MetisBlockAssigner(BlockAssigner):
408:     """
409:     Use Metis to obtain a *balanced* `num_blocks`-way partition of the
410:     (undirected) graph.
411:     Parameters
412:     ----------
413:     graph_data : GraphData
414:         Graph wrapper holding the (sparse) adjacency matrix.
415:     num_blocks : int
416:         Desired number of blocks (≈ N // k where k is target block size).
417:     seed : int, optional
418:         Random seed forwarded to METIS.  If None, METIS uses its own seed.
419:     """
420:     def __init__(
421:         self,
422:         graph_data: GraphData,
423:         rng: np.random.Generator,
424:         num_blocks: Optional[int] = None,
425:         min_block_size: Optional[int] = None,
426:         max_block_size: Optional[int] = None,
427:     ) -> None:
428:         super().__init__(
429:             graph_data=graph_data,
430:             rng=rng,
431:             num_blocks=num_blocks,
432:             min_block_size=min_block_size,
433:             max_block_size=max_block_size,
434:             )
435:         if graph_data.directed:
436:             raise NotImplementedError(
437:                 "MetisBlockAssigner currently supports undirected graphs only."
438:             )
439:         if num_blocks is None and min_block_size is None:
440:             raise ValueError("Either num_blocks or min_block_size must be specified for MetisBlockAssigner.")
441:         if num_blocks is None:
442:             num_blocks = max(
443:                 1, graph_data.num_nodes // min_block_size
444:             )
445:         self.num_blocks = int(num_blocks)
446:         self.seed = rng.integers(2**32)
447:     # -----------------------------------------------------------------
448:     # Utilities
449:     # -----------------------------------------------------------------
450:     @staticmethod
451:     def _to_adj_lists(adj: sp.csr_array) -> list[list[int]]:
452:         """
453:         Convert a CSR adjacency matrix to the adjacency-list format Metis
454:         expects (no self-loops, undirected symmetry).
455:         """
456:         n = adj.shape[0] # type: ignore
457:         rows, cols = adj.nonzero() # type: ignore
458:         neigh = [[] for _ in range(n)]
459:         for u, v in zip(rows, cols):
460:             if u == v:
461:                 continue  # ignore self-loops
462:             neigh[u].append(v)
463:         return neigh
464:     # -----------------------------------------------------------------
465:     # Public API
466:     # -----------------------------------------------------------------
467:     def _compute_metis_assignment(self) -> Dict[int, int]:
468:         """
469:         Run METIS and return a BlockData with the resulting assignment.
470:         May results in blocks of size < min_block_size or > max_block_size.
471:         """
472:         n = self.graph_data.num_nodes
473:         adj_lists = self._to_adj_lists(self.graph_data.adjacency)
474:         # PyMetis returns (edgecuts, membership-array)
475:         _, parts = metis.part_graph(
476:             graph=adj_lists,
477:             nparts = self.num_blocks,
478:             ufactor = 30, # aggresively balance block
479:             tpwgts = [1/self.num_blocks]*self.num_blocks, # equal weights for each block
480:             ubvec = [1+0.05], # 5% imbalance allowed
481:             recursive=True
482:         )
483:         # PyMetis guarantees |parts| == n
484:         blocks: Dict[int, int] = {node: part for node, part in enumerate(parts)}
485:         # Wrap in BlockData so downstream code can use it directly
486:         return blocks
487:     # -----------------------------------------------------------------
488:     def compute_assignment(self) -> BlockData:
489:         """
490:         Compute a balanced block assignment based on the proposed assignment.
491:         Currently, this method only performs a min_size balancing step.
492:         """
493:         if self.min_block_size is None:
494:             raise ValueError("min_block_size must be specified for MetisBlockAssigner.")
495:         assignment = self._compute_metis_assignment()
496:         #assignment = _rebalance_to_min_size(
497:         #    blocks=assignment,
498:         #    adjacency=self.graph_data.adjacency,
499:         #    k=self.min_block_size,
500:         #    rng=self.rng,
501:         #    max_iter=None,  # data-driven max_iter (10*num_nodes)
502:         #)
503:         assignment = self.reindex_blocks(assignment)
504:         return BlockData(
505:             initial_blocks=assignment,
506:             graph_data=self.graph_data
507:         )
508: class RefinedMetisBlockAssigner(MetisBlockAssigner):
509:     """PyMETIS seed ➜ improved greedy rebalance ➜ optional CP‑SAT polish."""
510:     def __init__(
511:         self,
512:         graph_data: GraphData,
513:         rng: np.random.Generator,
514:         num_blocks: int | None = None,
515:         min_block_size: int | None = None,
516:         max_block_size: int | None = None,
517:         cpsat_time_limit: int | None = 5,
518:     ) -> None:
519:         super().__init__(
520:             graph_data=graph_data,
521:             rng=rng,
522:             num_blocks=num_blocks,
523:             min_block_size=min_block_size,
524:             max_block_size=max_block_size,
525:         )
526:         self._rng = rng
527:         self._cpsat_limit = cpsat_time_limit
528:     # -----------------------------------------------------------------
529:     def compute_assignment(self) -> BlockData:  # noqa: D401 – keep signature
530:         # unbalanced
531:         if self.min_block_size is None:
532:             raise ValueError("min_block_size must be specified for RefinedMetisBlockAssigner.")
533:         blocks = super()._compute_metis_assignment()
534:         blocks = _rebalance_to_min_size(
535:             blocks,
536:             self.graph_data.adjacency,
537:             self.min_block_size,
538:             rng=self._rng,
539:         )
540:         # polish with CP‑SAT
541:         blocks = self._cpsat_polish(blocks)
542:         return BlockData(initial_blocks=self.reindex_blocks(blocks),
543:                          graph_data=self.graph_data)
544:     # -----------------------------------------------------------------
545:     def _compute_metis_assignment(self) -> Dict[int, int]:  # noqa: D401  – keep name
546:         return super()._compute_metis_assignment()
547:     # -----------------------------------------------------------------
548:     def _block_members(self, blk: int, blocks: Dict[int, int]) -> List[int]:
549:         return [v for v, b in blocks.items() if b == blk]
550:     # -----------------------------------------------------------------
551:     def _cpsat_polish(self, blocks: Dict[int, int]) -> Dict[int, int]:
552:         """ 
553:         Polish the block assignment to decrease the edge cut while ensuring
554:         block sizes are within min_block_size and min_block_size + 1.
555:         """
556:         if self.min_block_size is None:
557:             return blocks
558:         k = self.min_block_size
559:         sizes = _block_sizes(blocks)
560:         wrong = {b for b, s in sizes.items() if not (k <= s <= k + 1)}
561:         if not wrong:
562:             return blocks  # already good
563:         # collect *boundary* nodes of wrong blocks + their neighbours
564:         boundary: Set[int] = set()
565:         adj = self.graph_data.adjacency
566:         indptr, indices = adj.indptr, adj.indices
567:         for b in wrong:
568:             for v in self._block_members(b, blocks):
569:                 row = slice(indptr[v], indptr[v + 1])
570:                 if any(blocks[u] != b for u in indices[row]):
571:                     boundary.add(v)
572:                     boundary.update(indices[row])
573:         sub_nodes = sorted(boundary)
574:         sub_adj = adj[sub_nodes][:, sub_nodes]  # type: ignore[index]
575:         # blocks involved
576:         blks_sub = {blocks[v] for v in sub_nodes}
577:         # ------- build CP‑SAT model ----------------------------------
578:         model = cp_model.CpModel()
579:         x = {}
580:         for v in sub_nodes:
581:             for b in blks_sub:
582:                 x[v, b] = model.NewBoolVar(f"x_{v}_{b}")
583:             # each vertex exactly one block (in sub‑problem)
584:             model.Add(sum(x[v, b] for b in blks_sub) == 1)
585:         # block‑size constraints & t_b variables
586:         t = {}
587:         r_target = (len(sub_nodes) + sum(sizes[b] for b in blks_sub) - k * len(blks_sub))  # local oversize quota
588:         for b in blks_sub:
589:             t[b] = model.NewBoolVar(f"t_{b}")
590:             size_expr = sum(x[v, b] for v in sub_nodes) + (sizes[b] - sum(blocks[v] == b for v in sub_nodes))
591:             model.Add(size_expr == k + t[b])
592:         model.Add(sum(t[b] for b in blks_sub) == r_target)
593:         # edge‑cut objective (linearised y/z eliminated – constant perimeter suffices in subgraph)
594:         rows, cols = sub_adj.nonzero()
595:         z = {}
596:         for v, u in zip(rows, cols):
597:             if v >= u:
598:                 continue  # undirected upper triangle
599:             i, j = sub_nodes[v], sub_nodes[u]
600:             z[(i, j)] = model.NewBoolVar(f"z_{i}_{j}")
601:             # z = 1 if endpoints differ
602:             for b in blks_sub:
603:                 model.AddBoolAnd([x[i, b], x[j, b]]).OnlyEnforceIf(z[(i, j)].Not())
604:             # if all same‑block conjunctions false → z=1
605:         model.Minimize(sum(z.values()))
606:         # solve
607:         solver = cp_model.CpSolver()
608:         if self._cpsat_limit:
609:             solver.parameters.max_time_in_seconds = float(self._cpsat_limit)
610:         status = solver.Solve(model)
611:         if status in (cp_model.OPTIMAL, cp_model.FEASIBLE):
612:             for v in sub_nodes:
613:                 for b in blks_sub:
614:                     if solver.BooleanValue(x[v, b]):
615:                         blocks[v] = b
616:                         break
617:         return blocks
618: class EmbedAndConstrKMeansAssigner(BlockAssigner):
619:     """
620:     Assign nodes to blocks using a two-step process:
621:     1. use embed nodes into a low-dimensional space,
622:     2. use constrained KMeans to assign nodes to blocks of prespecified sizes.
623:     """ 
624:     def __init__(
625:         self,
626:         graph_data: GraphData,
627:         rng: np.random.Generator,
628:         num_blocks: Optional[int] = None,
629:         min_block_size: Optional[int] = None,
630:         max_block_size: Optional[int] = None,
631:     ) -> None:
632:         super().__init__(
633:             graph_data=graph_data,
634:             rng=rng,
635:             num_blocks=num_blocks,
636:             min_block_size=min_block_size,
637:             max_block_size=max_block_size,
638:         )
639:         if min_block_size is None:
640:             raise ValueError("num_blocks and min_block_size must be specified for ProneAndConstrKMeansAssigner.")
641:         if num_blocks is not None:
642:             Warning("num_blocks is ignored in ProneAndConstrKMeansAssigner. Only min_block_size is used.")
643:         if max_block_size is not None:
644:             Warning("max_block_size is ignored in ProneAndConstrKMeansAssigner. Only min_block_size is used.")
645:     def embed_nodes(self, adjacency:sp.csr_array, n_dimensions:int=128)->np.ndarray:
646:         """ 
647:         Method to perform node embedding. Subclasses should implement this method
648:         """
649:         raise NotImplementedError("This method should be overwritten by subclasses to provide specific embedding logic.")
650:     def _compute_assignment(self) -> Dict[int, int]:
651:         """
652:         Compute block assignments using constrained KMeans after embedding with Prone.
653:         """
654:         if self.graph_data.num_nodes < self.min_block_size:
655:             raise ValueError("Number of nodes in the graph is less than min_block_size.")
656:         if self.min_block_size is None:
657:             raise ValueError("min_block_size must be specified for ProneAndConstrKMeansAssigner.")
658:         # Step 1: Embed nodes using Prone
659:         embeddings = self.embed_nodes(
660:             adjacency=self.graph_data.adjacency,
661:             n_dimensions=128  # default embedding dimension
662:         )
663:         # compute how many blocks we need to only have blocks of
664:         #   size min_block_size and min_block_size+1
665:         number_of_clusters = self.graph_data.num_nodes // self.min_block_size
666:         # Step 2: Use constrained KMeans to assign nodes to blocks
667:         kmeans = KMeansConstrained(
668:                     n_clusters=number_of_clusters,
669:                     size_min=self.min_block_size,
670:                     size_max=self.min_block_size+1, # 
671:                     init='k-means++',
672:                     n_init=1,
673:                     max_iter=10,
674:                     tol=1e-3,
675:                     verbose=False,
676:                     random_state=self.rng.choice(2**32), 
677:                     copy_x=False, # perform centering
678:                     # use all available CPU cores
679:                     n_jobs=-1
680:                 )
681:         tic = time()
682:         labels = kmeans.fit_predict(embeddings)
683:         toc = time()
684:         print(f"KMeans with constraints took {toc - tic:.2f} seconds for {self.graph_data.num_nodes} nodes.")
685:         # Create a mapping from node index to block ID
686:         blocks = {node: label for node, label in enumerate(labels)} # type: ignore
687:         return blocks
688:     def compute_assignment(self) -> BlockData:
689:         """
690:         Compute a block assignment based on the proposed assignment.
691:         Currently, this method only performs a min_size balancing step.
692:         """
693:         balanced_assignment = self._compute_assignment() # balanced from k-means w. size constraints
694:         reindexed_assignment = self.reindex_blocks(balanced_assignment)
695:         return BlockData(
696:             initial_blocks=reindexed_assignment,
697:             graph_data=self.graph_data
698:         )
699: class ProNEAndConstrKMeansAssigner(EmbedAndConstrKMeansAssigner):
700:     """
701:     Assign nodes to blocks using ProNE embedding followed by constrained KMeans.
702:     """
703:     def embed_nodes(self, adjacency: sp.csr_array, n_dimensions: int = 128) -> np.ndarray:
704:         """
705:         Embed nodes using ProNE.
706:         """
707:         if n_dimensions <= 0:
708:             raise ValueError("n_dimensions must be a positive integer.")
709:         # Create a ProNE instance and fit it to the adjacency matrix
710:         model = ProNE(
711:                     n_components=n_dimensions,
712:                     step=10,
713:                     mu=0.2,
714:                     theta=0.5, 
715:                     exponent=0.75,
716:                     verbose=False
717:                 )
718:         tic = time()
719:         embeddings = model.fit_transform(
720:             sp.csr_matrix(adjacency) # nodevectors expect a CSR matrix, and not array
721:             )
722:         toc = time()
723:         print(f"ProNE embedding took {toc - tic:.2f} seconds for {adjacency.shape[0]} nodes.") # type: ignore
724:         return embeddings
725: class AssignerConstructor:
726:     """ 
727:     Factory class to construct block assigners based on configuration parameters. 
728:     """
729:     def __init__(self, rng: np.random.Generator):
730:         self.rng = rng
731:     def create_assigner(self,
732:                         graph_data: GraphData,
733:                         init_method: InitMethodName = "metis", 
734:                         min_block_size: Optional[int] = None,
735:                         max_block_size: Optional[int] = None,
736:                         num_blocks: Optional[int] = None,
737:                     ) -> BlockAssigner:
738:         if init_method == "uniform":
739:             return UniformSmallBlockAssigner(
740:                 graph_data=graph_data,
741:                 rng=self.rng,
742:                 min_block_size=min_block_size,
743:                 max_block_size=max_block_size,
744:                 num_blocks=num_blocks,
745:             )
746:         elif init_method == "prone_and_kmeans":
747:             return ProNEAndConstrKMeansAssigner(
748:                 graph_data=graph_data,
749:                 rng=self.rng,
750:                 min_block_size=min_block_size,
751:                 max_block_size=max_block_size,
752:                 num_blocks=num_blocks,
753:             )
754:         elif init_method == "metis":
755:             return MetisBlockAssigner(
756:                 graph_data=graph_data,
757:                 rng=self.rng,
758:                 num_blocks=num_blocks,
759:                 min_block_size=min_block_size,
760:                 max_block_size=max_block_size,
761:             )
762:         elif init_method == "metis_refine":
763:             return RefinedMetisBlockAssigner(
764:                 graph_data=graph_data,
765:                 rng=self.rng,
766:                 min_block_size=min_block_size,
767:                 max_block_size=max_block_size,
768:                 num_blocks=num_blocks,
769:                 cpsat_time_limit=10
770:             )
771:         else:
772:             raise ValueError(f"Unknown initialization method: {init_method}. "
773:                 "Available methods: 'metis', 'uniform', 'prone_and_kmeans', 'metis_refine'."
774:                 )

================
File: src/sbm/block_data.py
================
  1: """ 
  2: Block data for the Stochastic Block Model (SBM).
  3: This module defines the `BlockData` class, which manages the block structure of the SBM,
  4: including block memberships, edge counts, and possible pairs of edges between blocks.
  5: It also provides methods to update the block data when nodes are moved between blocks,
  6: and to compute edge counts and possible pairs.
  7: """
  8: from typing import Dict, Set, Sequence, Tuple
  9: import numpy as np
 10: import scipy.sparse as sp
 11: from sbm.graph_data import GraphData
 12: BlockConn = sp.dok_array
 13: BlockMembership = Dict[int, Set[int]]  # Block ID to set of node indices
 14: class _BlockDataUpdater:
 15:     """
 16:     Helper class to update edge counts and possible pairs in the block data.
 17:     This class is used to hide bookkeeping of handling directed vs undirected graphs.
 18:     Parameters
 19:     ----------
 20:     bd : BlockData
 21:     """
 22:     def __init__(self, block_data: "BlockData"):
 23:         self.block_data = block_data # B × B integer matrix
 24:     # block memberships
 25:     def _move_node_to_block(self, node: int, block_id: int, update_sizes=True) -> None:
 26:         # update block assignment
 27:         old_block = self.block_data.blocks[node] # type: ignore
 28:         if update_sizes: 
 29:             # update block sizes
 30:             self.block_data.block_sizes[block_id] += 1
 31:             self.block_data.block_sizes[old_block] -= 1
 32:         self.block_data.blocks[node] = block_id # type: ignore
 33:         # update block membersets
 34:         if block_id not in self.block_data.block_members:
 35:             self.block_data.block_members[block_id] = set()
 36:         self.block_data.block_members[block_id].add(node)
 37:         self.block_data.block_members[old_block].remove(node)
 38:     # ----- edge counts --------------------------------------------------
 39:     def _increment_edge_count(self, idx_a: int, idx_b: int, e_delta: int) -> None:
 40:         """ 
 41:         Increment the edge count between two blocks.
 42:         If the graph is undirected, increment both directions.
 43:         e_delta can be negative to decrement the edge count.
 44:         idx_a and idx_b are indices in the block_connectivity matrix.
 45:         """
 46:         self.block_data.block_connectivity[idx_a, idx_b] += e_delta
 47:         if not self.block_data.directed and idx_a != idx_b:
 48:             self.block_data.block_connectivity[idx_b, idx_a] += e_delta
 49: class BlockData:
 50:     """ 
 51:     Class to store block data for the SBM.
 52:     There are two ways to initialize this class:
 53:     Attributes:
 54:         graph_data: The graph data object.
 55:         blocks: A dictionary mapping node indices to block indices.
 56:         block_members: A dictionary mapping block indices to lists of node indices.
 57:         block_sizes: A dictionary mapping block indices to the number of nodes in each block.
 58:         directed: A boolean indicating whether the graph is directed or not.
 59:         block_indices: A dictionary mapping block IDs to indices used in matrices.
 60:         inverse_block_indices: A dictionary mapping indices used in matrices to block IDs.
 61:         block_connectivity: A sparse matrix representing the block connectivity matrix.
 62:     """
 63:     def __init__(self,
 64:                  initial_blocks: Dict[int, int],
 65:                  graph_data: GraphData,
 66:         ):
 67:         self.blocks: Dict[int, int] = initial_blocks # Node to block mapping
 68:         self.block_updater = _BlockDataUpdater(self)
 69:         self.graph_data = graph_data
 70:         self.directed = graph_data.directed
 71:         self.block_members = self._initialize_block_members()
 72:         self.block_sizes = {block: len(nodes) for block, nodes in self.block_members.items()}
 73:         self._update_block_indices()
 74:         self.block_connectivity: BlockConn = self._compute_block_connectivity()
 75:         # Recompute block connectivity based on the new graph data
 76:         self.block_connectivity = self._compute_block_connectivity()
 77:     # --------------------------------------------------------------------- # 
 78:     def increment_edge_count(self, block_a: int, block_b: int, e_delta: int) -> None:
 79:         """ 
 80:         Increment the edge count between two blocks.
 81:         If the graph is undirected, increment both directions.
 82:         e_delta can be negative to decrement the edge count.
 83:         """
 84:         idx_a = self.block_indices[block_a]
 85:         idx_b = self.block_indices[block_b]
 86:         self.block_updater._increment_edge_count(idx_a, idx_b, e_delta)
 87:     # --------------------------------------------------------------------- # 
 88:     def get_possible_pairs(self, block_a: int, block_b:int ) -> int:
 89:         """ 
 90:         Compute the possible number of edges between two blocks.
 91:         """
 92:         if block_a == block_b:
 93:             # If the same block, return the number of pairs within the block
 94:             return self.block_sizes[block_a] * (self.block_sizes[block_a] - 1) // 2
 95:         # If different blocks, return the product of their sizes
 96:         return self.block_sizes[block_a] * self.block_sizes[block_b]
 97:     # --------------------------------------------------------------------- # 
 98:     def _initialize_block_members(self) -> BlockMembership:
 99:         """
100:         Initialize block members from the blocks mapping.
101:         :return: A dictionary mapping block indices to lists of node indices.
102:         """
103:         if self.blocks is None:
104:             raise ValueError("Blocks mapping is not provided to initialize block members.")
105:         block_members: BlockMembership = {}
106:         for node, block in self.blocks.items():
107:             if block not in block_members:
108:                 block_members[block] = set()
109:             # Add node to the corresponding block
110:             block_members[block].add(node)
111:         return block_members
112:     # --------------------------------------------------------------------- # 
113:     def _update_block_indices(self):
114:         """
115:         Update mappings between block IDs and indices used in matrices.
116:         """
117:         # Sort block IDs to ensure consistent ordering
118:         sorted_block_ids = sorted(self.block_members.keys())
119:         self.block_indices = {
120:             block_id: idx for idx, block_id in enumerate(sorted_block_ids)
121:             }
122:         self.inverse_block_indices = {
123:             idx: block_id for block_id, idx in self.block_indices.items()
124:             }
125:     # --------------------------------------------------------------------- # 
126:     def _compute_block_connectivity(self) -> BlockConn:
127:         """
128:         Compute the block connectivity matrix.
129:         This matrix is a sparse matrix where the entry at (i, j) is number of edges 
130:         between block i and block j. If the graph is undirected, the matrix is symmetric.
131:         """
132:         if self.graph_data is None:
133:             raise ValueError("Graph data is not set. Cannot compute block connectivity.")
134:         if self.block_members is None:
135:             raise ValueError("Block members are not initialized. Cannot compute block connectivity.")
136:         num_blocks = len(self.block_members)
137:         self._update_block_indices()
138:         block_connectivity_dok = sp.dok_array((num_blocks, num_blocks), dtype=np.int64)
139:         if self.directed:
140:             raise ValueError("Block connectivity computation is not implemented for directed graphs.")
141:         else:
142:             for i_block_id, nodes_i in self.block_members.items():
143:                 idx_i = self.block_indices[i_block_id]
144:                 nodes_i = list(nodes_i)
145:                 sub_adj_i = self.graph_data.adjacency[nodes_i]  # type: ignore
146:                 for j_block_id, nodes_j in self.block_members.items():
147:                     idx_j = self.block_indices[j_block_id]
148:                     nodes_j = list(nodes_j)
149:                     # Sum of weights between block i and block j
150:                     weight = sub_adj_i[:, nodes_j].sum() # type: ignore
151:                     # If the blocks are the same, we only count pairs
152:                     if i_block_id == j_block_id:
153:                         weight = weight // 2
154:                     block_connectivity_dok[idx_i, idx_j] = weight
155:             return block_connectivity_dok
156:     # --------------------------------------------------------------------- # 
157:     def _remove_block_index(self, block_id: int):
158:         """
159:         Remove a block from block_indices and inverse_block_indices.
160:         Do not use directly, call remove_block instead.
161:         :param block_id: The block ID to remove.
162:         """
163:         idx = self.block_indices.pop(block_id)
164:         self.inverse_block_indices.pop(idx)
165:         # Adjust indices of remaining blocks
166:         for b_id, index in self.block_indices.items():
167:             if index > idx:
168:                 self.block_indices[b_id] -= 1
169:                 self.inverse_block_indices[self.block_indices[b_id]] = b_id
170:     # --------------------------------------------------------------------- # 
171:     def _remove_block_from_connectivity(self, block_id: int):
172:         """
173:         Remove the block's row and column from the block connectivity matrix.
174:         Do not use directly, call remove_block instead.
175:         :param block_id: The block ID to remove.
176:         """
177:         idx = self.block_indices[block_id]
178:         # Remove the row and column corresponding to idx
179:         slicable_array = self.block_connectivity.tocsr()
180:         non_slice_idx = np.arange(self.block_connectivity.shape[1]) != idx # type: ignore
181:         self.block_connectivity = slicable_array[:, non_slice_idx][non_slice_idx, :].todok()
182:     # --------------------------------------------------------------------- # 
183:     def remove_block(self, block_id: int):
184:         """
185:         Remove a block from the block data.
186:         Do not use directly, call remove_block instead.
187:         :param block_id: The block ID to remove.
188:         """
189:         del self.block_sizes[block_id]
190:         del self.block_members[block_id]
191:         self._remove_block_from_connectivity(block_id)
192:         self._remove_block_index(block_id)
193:     # --------------------------------------------------------------------- # 
194:     def _add_block_index(self, block_id: int):
195:         """
196:         Add a new block index for a new block.
197:         Do not use directly, call add_block instead.
198:         :param block_id: The block ID to add.
199:         """
200:         new_idx = len(self.block_indices)
201:         self.block_indices[block_id] = new_idx
202:         self.inverse_block_indices[new_idx] = block_id
203:     def _add_block_to_connectivity(self):
204:         """
205:         Add a new block to the block connectivity matrix.
206:         Do not use directly, call add_block instead.
207:         :param block_id: The block ID to add.
208:         """
209:         num_blocks = len(self.block_indices)
210:         connectivity_lil = sp.lil_matrix(self.block_connectivity)
211:         connectivity_lil.resize((num_blocks, num_blocks))
212:         self.block_connectivity = connectivity_lil.todok()
213:     # --------------------------------------------------------------------- # 
214:     def add_block(self, block_id: int, nodes=[]):
215:         """
216:         Add a new block to the block data.
217:         :param block_id: The block ID to add.
218:         """
219:         if self.blocks is None:
220:             raise ValueError("Blocks mapping is not initialized. Cannot add a block.")
221:         self.block_sizes[block_id] = len(nodes)
222:         self.block_members[block_id] = nodes
223:         for node in nodes:
224:             self.blocks[node] = block_id
225:         self._add_block_index(block_id)
226:         self._add_block_to_connectivity()
227:     # --------------------------------------------------------------
228:     def counts_for_pairs(self,
229:                          pairs: Sequence[Tuple[int, int]]
230:                          ) -> np.ndarray:
231:         """
232:         Parameters
233:         ----------
234:         pairs : list of (r, s) with r < s
235:         Returns
236:         -------
237:         np.ndarray, shape (len(pairs),)
238:             Edge counts m_rs for those pairs.
239:         """
240:         # Fast path when the block matrix lives in a dict‑of‑dicts:
241:         return np.fromiter(
242:             (self.block_connectivity[r, s] for r, s in pairs),
243:             dtype=np.int64, count=len(pairs)
244:         )
245:     # --------------------------------------------------------------
246:     def diagonal_counts(self) -> np.ndarray:
247:         """
248:         Returns
249:         -------
250:         np.ndarray, shape (B,)
251:             Internal edge counts m_rr for every block r.
252:         """
253:         # Extract diagonal elements directly from the sparse matrix
254:         return self.block_connectivity.diagonal()
255:     # --------------------------------------------------------------

================
File: src/sbm/likelihood.py
================
  1: from typing import (
  2:     Dict,
  3:     Tuple,
  4:     Literal,
  5: )
  6: from numba import jit
  7: from scipy.sparse import coo_array
  8: import numpy as np
  9: from sbm.block_data import BlockData
 10: from sbm.block_change_proposers import (
 11:     EdgeDelta,
 12:     CombinationDelta,
 13: )
 14: #### aliases ######
 15: LikelihoodType = Literal['bernoulli']
 16: # Bernoulli functions
 17: @jit(nopython=True, cache=True, fastmath=True)
 18: def _bernoulli_ll_block_pair(e: int, n: int, eps:float= 1e-6) -> float:
 19:     """
 20:     Profile log-likelihood for one block pair (constants dropped).
 21:     e: number of edges between block pair.
 22:     n: number of possible pairs between block pair.
 23:     """
 24:     if e == 0: # 0 · log 0 := 0   (limit)
 25:         return 0.0
 26:     elif n <= 0:
 27:         raise ValueError("Number of possible pairs (n) must be greater than 0.")
 28:     # clip to avoid overflow in lo
 29:     pos = max(e/n, eps)
 30:     neg = max(1 - e/n, eps)
 31:     return e * np.log(pos) - (n-e) * np.log(neg)
 32: @jit(fastmath=True, cache=True)
 33: def _delta_ll_bernoulli_block_pair(
 34:         e_old: int, e_new: int,
 35:         n_old: int, n_new: int,
 36:         eps: float = 1e-6
 37:         ) -> float:
 38:     """Δℓ for a single block pair.
 39:     e_new: new number of edges between block pair.
 40:     e_old: old number of edges between block pair.
 41:     n_new: new number of possible pairs between block pair.
 42:     n_old: old number of possible pairs between block pair.
 43:     """
 44:     new_ll = _bernoulli_ll_block_pair(e=e_new, n=n_new, eps=eps)
 45:     old_ll = _bernoulli_ll_block_pair(e=e_old, n=n_old, eps=eps)
 46:     return new_ll - old_ll
 47: def compute_delta_ll_from_change_bernoulli(
 48:         delta_e: EdgeDelta,
 49:         delta_n: CombinationDelta,
 50:         block_data: BlockData) -> float:
 51:     """
 52:     Incremental change in Bernoulli log-likelihood after a node-swap or move.
 53:     Only the pairs present in `delta_e` or `delta_n` need to be visited.
 54:     delta_e: changes in edge counts between affected blocks.
 55:     delta_n: changes in possible pairs between affected blocks.
 56:     block_data: BlockData object containing edge counts and possible pairs.
 57:     :return: Tuple of (change in log-likelihood, edge counts changes of move delta).
 58:     """
 59:     upper_triangle_only = not block_data.directed
 60:     delta_ll = 0.0
 61:     for (r, s), delta in delta_e.items():
 62:         if upper_triangle_only and s < r:
 63:             continue
 64:         e_old = int(block_data.block_connectivity[r, s]) # type: ignore
 65:         n_old = block_data.get_possible_pairs(r, s)
 66:         e_new = e_old + delta
 67:         n_new = n_old + delta_n[r, s]
 68:         delta_ll += _delta_ll_bernoulli_block_pair(
 69:             e_old=e_old,
 70:             e_new=e_new,
 71:             n_old=n_old,
 72:             n_new=n_new
 73:         )
 74:     return delta_ll
 75: # ────────────────────────────────────────────────────────────────────
 76: ### Helpter function to vectorise the LL global computation
 77: # ────────────────────────────────────────────────────────────────────
 78: @jit(nopython=True, cache=True, fastmath=True)   # remove decorator if you dislike Numba
 79: def _ll_vec(edges: np.ndarray, pairs: np.ndarray, eps: float = 1e-6) -> np.ndarray:
 80:     """
 81:     edges  : e_rs   (int ≥ 0)
 82:     pairs  : n_rs   (int ≥ 1)
 83:     returns: ℓ_rs   (float)
 84:     """
 85:     p = edges / pairs
 86:     p = np.where(p < eps, eps, p)
 87:     p = np.where(p > 1.0 - eps, 1.0 - eps, p)
 88:     return edges * np.log(p) - (pairs - edges) * np.log1p(-p)
 89: def compute_global_bernoulli_ll_fast(block_data:BlockData) -> float:
 90:     """
 91:     Computes the global log-likelihood of the SBM using Bernoulli likelihood.
 92:     Same semantics as the original `compute_global_bernoulli_ll`, but
 93:     **O(nnz)** instead of O(B²).
 94:     The trick: only block pairs with at least one edge (e_rs > 0) can
 95:     change the profiled Bernoulli LL once the constants are dropped.
 96:     """
 97:     conn: coo_array = coo_array(block_data.block_connectivity)
 98:     rows, cols, e = conn.row, conn.col, conn.data.astype(np.int64)
 99:     # Undirected graphs: keep only upper-triangle to avoid double count
100:     if not block_data.directed:
101:         keep = rows <= cols
102:         rows, cols, e = rows[keep], cols[keep], e[keep]
103:     # Block sizes in matrix-index order
104:     sizes = np.fromiter(
105:         (block_data.block_sizes[block_data.inverse_block_indices[i]]
106:          for i in range(len(block_data.block_sizes))),
107:         dtype=np.int64,
108:         count=len(block_data.block_sizes)
109:     )
110:     # Possible pair counts n_rs (vectorised)
111:     n = np.where(
112:         rows == cols,
113:         sizes[rows] * (sizes[rows] - 1) // 2,   # diagonal blocks
114:         sizes[rows] * sizes[cols]               # off-diagonal
115:     )
116:     # Safety: skip singleton blocks (n = 0) to avoid /0 in n==1 corner
117:     valid = n > 0
118:     if not valid.all():
119:         rows, cols, e, n = rows[valid], cols[valid], e[valid], n[valid]
120:     # Vectorised LL and reduction
121:     return float(_ll_vec(e, n).sum())
122: def compute_global_bernoulli_ll(
123:         block_data: BlockData,
124: ) -> float:
125:     """
126:     Compute the global log-likelihood of the SBM using Bernoulli likelihood.
127:     :param block_data: The BlockData object containing block connectivity and sizes.
128:     :param upper_triangle_only: If True, only compute for upper triangle of the connectivity matrix.
129:     :return: The global log-likelihood.
130:     """
131:     upper_triangle_only = not block_data.directed
132:     ll = 0.0
133:     for r in range(len(block_data.block_sizes)):
134:         # if block has less than 2 nodes, skip it: no possible pairs
135:         size_r = block_data.block_sizes[ block_data.inverse_block_indices[r] ]
136:         if size_r <= 1:
137:             continue 
138:         for s in range(r if upper_triangle_only else 0, len(block_data.block_sizes)):
139:             e = block_data.block_connectivity[r, s]
140:             #n = block_data.get_possible_pairs(r, s)
141:             if r == s:
142:                 # If the same block, return the number of pairs within the block
143:                 n = block_data.block_sizes[r] * (block_data.block_sizes[r] - 1) // 2
144:             # If different blocks, return the product of their sizes
145:             else:
146:                 n = block_data.block_sizes[r] * block_data.block_sizes[s]
147:             if e < 0 or n < 0:
148:                 raise ValueError(f"Invalid edge count {e} or possible pairs {n} for block pair ({r}, {s}).")
149:             if e > n:
150:                 raise ValueError(f"Edge count {e} cannot be greater than possible pairs {n} for block pair ({r}, {s}).")
151:             ll += _bernoulli_ll_block_pair(e, n) # type: ignore
152:     return ll
153: #### LikelihoodCalculator class ######
154: class LikelihoodCalculator:
155:     def __init__(self,
156:                  block_data: BlockData,
157:                  likelihood_type: LikelihoodType = 'bernoulli',
158:                  ):
159:         self.block_data = block_data
160:         self.likelihood_type: LikelihoodType = 'bernoulli'
161:         self.nll = self.compute_nll()
162:     def compute_nll(self) -> float:
163:         """
164:         Compute the negative likelihood of the network given the current partition.
165:         :return: The negative log-likelihood of the SBM.
166:         """
167:         if self.likelihood_type.lower() == 'bernoulli':
168:             return -compute_global_bernoulli_ll_fast(block_data=self.block_data)
169:         else:
170:             raise NotImplementedError("Only Bernoulli likelihood is implemented.")
171:     def _compute_delta_nll_from_changes(self,
172:                                        delta_e: EdgeDelta,
173:                                        delta_n: CombinationDelta,
174:     ) ->float:
175:         """
176:         efficeintly compute the change in log-likelihood from changes in edge counts and possible pairs.
177:         :param delta_e: Changes in edge counts between blocks.
178:         :param delta_n: Changes in possible pairs between blocks.
179:         :param total_edges: Total number of edges in the graph.
180:         :return: The change in log-likelihood.
181:         """
182:         if self.likelihood_type.lower() == 'bernoulli':
183:             return -compute_delta_ll_from_change_bernoulli(
184:                 delta_e=delta_e,
185:                 delta_n=delta_n,
186:                 block_data=self.block_data
187:             )
188:         else:
189:             raise NotImplementedError("Only Bernoulli likelihood is implemented.")
190:     def compute_delta_nll(self,
191:                         delta_e: EdgeDelta,
192:                         delta_n: CombinationDelta,
193:         ) -> float:
194:         """
195:         Compute the change in log-likelihood for a proposed swap of two nodes.
196:         :param proposed_moves: A list of tuples (node_i, node_j) representing the nodes to swap.
197:         :return: The change in log-likelihood.
198:         """
199:         return self._compute_delta_nll_from_changes(
200:             delta_e=delta_e,
201:             delta_n=delta_n
202:             )

================
File: src/sbm/mcmc.py
================
  1: """ 
  2: Code for the MCMC algorithm used in the Stochastic Block Model (SBM) fitting.
  3: This code implements the MCMC algorithm for both standard and private partitioning scenarios.
  4: It includes the main MCMC algorithm class and a specialized class for private partitioning with differential privacy
  5: """
  6: from typing import Optional, Tuple, Dict, Optional, List
  7: from collections import deque
  8: import numpy as np
  9: #from line_profiler import profile
 10: from numba import jit
 11: from math import exp
 12: #from src.sbm.graph_data import GraphData
 13: from sbm.block_data import BlockData
 14: from sbm.likelihood import LikelihoodCalculator
 15: from sbm.block_change_proposers import ChangeProposer
 16: from sbm.node_mover import NodeMover
 17: from sbm.utils.logger import CSVLogger
 18: from sbm.mcmc_diagnostics import OnlineDiagnostics
 19: from sbm.block_change_proposers import ChangeProposer, ChangeProposerName
 20: #### Aliases
 21: ChangeProposerDict = Dict[ChangeProposerName, ChangeProposer] 
 22: ChangeFreqDict = Dict[ChangeProposerName, float]
 23: class MCMC:
 24:     def __init__(self,
 25:                  block_data: BlockData,
 26:                  likelihood_calculator: LikelihoodCalculator,
 27:                  change_proposer: ChangeProposerDict,
 28:                  rng: np.random.Generator,
 29:                  logger: Optional[CSVLogger] = None,
 30:                  monitor: bool = True,
 31:                  diag_lag: int =1000,
 32:                  diag_checkpoints: int = 3000,
 33:                  change_freq: Optional[ChangeFreqDict] = None,
 34:                  ):
 35:         self.block_data = block_data
 36:         self.likelihood_calculator = likelihood_calculator
 37:         self.change_proposers = change_proposer
 38:         self.change_freq = change_freq
 39:         self.node_mover = NodeMover(block_data=block_data)
 40:         self.rng = rng
 41:         self.current_nll = self.likelihood_calculator.nll
 42:         self.logger = logger # True if logging is enabled, False otherwise.
 43:         ### set up mcmc diagnostics (R̂ and ESS)
 44:         # only for estimating convergence diagnostics for dp patitioning
 45:         self._monitor = monitor
 46:         if monitor:
 47:             self._diag= OnlineDiagnostics(window=diag_lag)
 48:             self._diag_checkpoints = diag_checkpoints
 49:             self._off_diag = self._select_off_pairs(max_panel=diag_checkpoints)
 50:         else:
 51:             self._diag = None
 52:             self._diag_checkpoints = 0
 53:             self._off_diag = []
 54:         # store the best block assignment and likelihood
 55:         self._best_block_assignment = block_data.blocks.copy()
 56:         self._best_block_conn = block_data.block_connectivity.copy()
 57:         self.best_nll = self.likelihood_calculator.nll
 58:     def fit(self,
 59:             max_num_iterations: int,
 60:             initial_temperature: float = 1,
 61:             cooling_rate: float = 0.99,
 62:             min_block_size: Optional[int] = None,
 63:             max_blocks: Optional[int] = None,
 64:             patience: Optional[int] = None,
 65:         ) -> List[float]:
 66:         """
 67:         Run the adaptive MCMC algorithm to fit the SBM to the network data.
 68:         :param max_num_iterations: max number of MCMC iterations to run.
 69:         :param min_block_size: Minimum allowed size for any block.
 70:         :param initial_temperature: Starting temperature for simulated annealing.
 71:         :param cooling_rate: Rate at which temperature decreases.
 72:         :param target_acceptance_rate: Desired acceptance rate for adaptive adjustments (default 25%).
 73:         :param max_blocks: Optional maximum number of blocks allowed.
 74:         """
 75:         acc_hist = deque(maxlen=1000)          # for accept‑rate window
 76:         temperature = initial_temperature
 77:         current_nll = self.likelihood_calculator.nll
 78:         acceptance_rate = 0 # acceptance rate of moves between logging
 79:         nll_list = [current_nll]
 80:         # if patience None, set based on the graph size
 81:         if patience is None:
 82:             n_nodes = self.block_data.graph_data.num_nodes
 83:             patience = min(int(0.1 * n_nodes*(n_nodes - 1) // 2), 10**5)
 84:         if self.logger:
 85:             self.logger.log(0, current_nll, acceptance_rate, temperature)
 86:         n_steps_declined = 0
 87:         for iteration in range(1, max_num_iterations + 1):
 88:             move_type = self._select_move_type()
 89:             delta_nll, move_accepted = self._attempt_move(
 90:                 move_type=move_type,
 91:                 min_block_size=min_block_size,
 92:                 temperature=temperature,
 93:                 max_blocks=max_blocks
 94:                 )
 95:             acc_hist.append(move_accepted)
 96:             # --- diagnostics update --------------------------------
 97:             if self._monitor and self._diag is not None:
 98:                 diag_vec = self.block_data.diagonal_counts()
 99:                 off_vec  = self.block_data.counts_for_pairs(self._off_diag)
100:                 self._diag.update(self.current_nll, diag_vec, off_vec)
101:             # update likelihood and best assignment so far
102:             if move_accepted :
103:                 self.current_nll += delta_nll
104:                 n_steps_declined = 0
105:                 if self.logger:
106:                     acceptance_rate += 1
107:                 if self.current_nll < self.best_nll:
108:                     self.best_nll = current_nll
109:                     self._best_block_assignment = self.block_data.blocks.copy()
110:                     self._best_block_conn = self.block_data.block_connectivity.copy()
111:             else:
112:                 n_steps_declined += 1
113:             nll_list.append(self.current_nll)
114:             temperature = self._update_temperature(temperature, cooling_rate)
115:             # --- logging --------------------------------
116:             if (self.logger is not None and
117:                 iteration % self.logger.log_every == 0
118:                 ):
119:                 if (self._monitor and
120:                     self._diag is not None and
121:                     iteration % self._diag_checkpoints == 0
122:                     ):
123:                     rhat, ess = self._diag.summary()
124:                 else:
125:                     rhat, ess = np.nan, np.nan
126:                 self.logger.log(
127:                     iteration          = iteration,
128:                     neg_loglike        = self.current_nll,
129:                     accept_rate_window = float(np.mean(acc_hist or [0])),
130:                     temperature        = 1.0,          # or self.T if annealing
131:                     rhat_max           = rhat,
132:                     ess_min            = ess,
133:                 )
134:             if patience is not None and n_steps_declined >= patience:
135:                 print(f"Stopping early after {iteration} iterations due to patience limit.")
136:                 break
137:         return nll_list 
138:     def _select_move_type(self) -> ChangeProposerName:
139:         """
140:         Select a move type based on the current proposal probabilities.
141:         :return: The selected move type.
142:         """
143:         if self.change_freq is None:
144:             return "uniform_swap"
145:         else:
146:             # Select a move type based on the defined probabilities
147:             move_type = self.rng.choice(
148:                 tuple(self.change_freq.keys()),
149:                 p=tuple(self.change_freq.values())
150:             )
151:         return move_type # type: ignore
152:     def _attempt_move(self,
153:                       move_type: ChangeProposerName,
154:                       temperature: float,
155:                       max_blocks: Optional[int] = None,
156:                       min_block_size: Optional[int] = None,
157:         ) -> Tuple[float, bool]:
158:         """
159:         Attempt a move of the specified type.
160:         :param move_type: The type of move to attempt ('swap').
161:         :param min_block_size: Minimum allowed size for any block.
162:         :param temperature: Current temperature for simulated annealing.
163:         :param max_blocks: Optional maximum number of blocks allowed.
164:         :return: Tuple of (delta_nll, move_accepted)
165:         """
166:         delta_nll, move_accepted = 0.0, False
167:         proposed_change, proposed_delta_e, proposed_delta_n = \
168:             self.change_proposers[move_type].propose_change()
169:         # Compute change in log-likelihood and accept/reject move
170:         delta_nll = self.likelihood_calculator.compute_delta_nll(
171:             delta_e=proposed_delta_e,
172:             delta_n=proposed_delta_n
173:             )
174:         move_accepted = self._accept_move(delta_nll, temperature)
175:         if move_accepted:
176:             self.node_mover.perform_change(proposed_change, proposed_delta_e)
177:         return delta_nll, move_accepted
178:     def _accept_move(self, delta_nll: float, temperature: float, eps:float=1e-6) -> bool:
179:         """
180:         Determine whether to accept a proposed move based on likelihood change and temperature.
181:         :param delta_nll: Change in negative log-likelihood resulting from the proposed move.
182:         :param temperature: Current temperature for simulated annealing.
183:         :return: True if move is accepted, False otherwise.
184:         """
185:         if delta_nll < 0:
186:             return True
187:         temperature = max(temperature, eps)  # Avoid division by zero
188:         z = min(delta_nll / temperature, 700) # clip to avoid overflow in exp
189:         return self.rng.uniform() > np.exp(z)
190:     def _update_temperature(self, current_temperature: float, cooling_rate: float) -> float:
191:         """
192:         Update the temperature according to the cooling schedule.
193:         :param current_temperature: The current temperature.
194:         :param cooling_rate: The cooling rate.
195:         :return: The updated temperature.
196:         """
197:         return current_temperature * cooling_rate
198:     # --------------------------------------------------------------
199:     def _select_off_pairs(self, max_panel: int):
200:         """ 
201:         Randomly sample off pairs to monitor for diagnostics. 
202:         First we select pairs that currently have at least one edge,
203:         then we add random pairs until we reach the desired size.
204:         """
205:         B = len(self.block_data.block_sizes)
206:         want = min(max_panel, 2 * B) # number of pairs to sample and track
207:         ### get all pairs that currently have >= 1 edge
208:         nz = [(r, s) for r in range(B) for s in range(r + 1, B)
209:               if self.block_data.block_connectivity[r, s] > 0]
210:         self.rng.shuffle(nz)
211:         panel = nz[:want]
212:         # 2. add random extras until size == want
213:         while len(panel) < want:
214:             r, s = self.rng.choice(range(B), 2)
215:             if r > s:
216:                 r, s = s, r
217:             if (r, s) not in panel:
218:                 panel.append((r, s))
219:         return panel
220: ### --------------------------------------------------------------------------- 
221: #### MCMC Algorithm for Private Partitioning
222: ### --------------------------------------------------------------------------- 
223: class PrivatePartitionMCMC(MCMC):
224:     """
225:     MCMC sampler that targets the node-level DP Boltzmann distribution
226:         P(z) ∝ exp(-ε · L(z) / (2Δ))
227:     where L is the negative log-likelihood and Δ is its global
228:     sensitivity (Δ = 1 for Bernoulli SBMs).
229:     """
230:     def __init__(self, *, epsilon: float, delta_ll_sensitivity=1.0, temperature=1, **kwargs):
231:         super().__init__(**kwargs)
232:         self.eps   = float(epsilon)
233:         self.delta = float(delta_ll_sensitivity)
234:         self.temperatur = temperature
235:     # --- single move ----------------------------------------------------
236:     def _accept_prob(self, delta_nll: float) -> float:
237:         """Metropolis ratio specialised to the exponential mechanism."""
238:         ratio = exp(- self.eps * delta_nll / (2.0 * self.delta))
239:         return min(1.0, ratio)
240:     def _attempt_move(self,
241:                       move_type: ChangeProposerName,
242:                       temperature: float,
243:                       max_blocks: Optional[int] = None,
244:                       min_block_size: Optional[int] = None,
245:                       ) -> Tuple[float, bool]:
246:         # invoke parent proposer / Δnll code
247:         delta_nll, accepted = super()._attempt_move(
248:             move_type=move_type,
249:             temperature=temperature,      # no annealing in a DP chain
250:             max_blocks=max_blocks,
251:             min_block_size=min_block_size
252:         )
253:         return delta_nll, accepted




================================================================
End of Codebase
================================================================
